<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speech Gradebook v3.0 - Supabase Edition</title>
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&family=Roboto:wght@400;500;700&family=Open+Sans:wght@400;600;700&family=Georgia&family=Crimson+Pro:wght@400;600;700&family=Work+Sans:wght@400;600;700&display=swap" rel="stylesheet">
    
    <!-- Supabase JS Library -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <style>
        /* CSS Variables for Theming */
        :root {
            --primary: #1e3a5f;
            --primary-dark: #142940;
            --secondary: #c8a882;
            --accent: #d4af37;
            --text: #2c3e50;
            --text-light: #6c757d;
            --bg: #fafbfc;
            --bg-alt: #f1f4f7;
            --card: #ffffff;
            --border: #e1e8ed;
            --success: #28a745;
            --warning: #ffc107;
            --error: #dc3545;
            --heading-font: 'Crimson Pro', serif;
            --body-font: 'Work Sans', sans-serif;
            --heading-weight: 700;
            --body-weight: 400;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: var(--body-font);
            font-weight: var(--body-weight);
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
        }
        
        h1, h2, h3, h4, h5, h6 {
            font-family: var(--heading-font);
            font-weight: var(--heading-weight);
            color: var(--primary);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 1rem;
        }
        
        /* Header */
        header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            padding: 1rem 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .logo {
            width: 50px;
            height: 50px;
            background: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.5rem;
            color: var(--primary);
        }
        
        .logo img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 50%;
        }
        
        .app-title h1 {
            color: white;
            font-size: 1.8rem;
            margin-bottom: 0.2rem;
        }
        
        .tagline {
            font-size: 0.9rem;
            opacity: 0.9;
        }
        
        /* Navigation */
        nav {
            display: flex;
            gap: 1.5rem;
        }
        
        .nav-link {
            color: white;
            text-decoration: none;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            transition: background 0.3s;
        }
        
        .nav-link:hover {
            background: rgba(255,255,255,0.1);
        }
        
        .nav-link.active {
            background: rgba(255,255,255,0.2);
        }
        
        /* Main Content */
        main {
            padding: 2rem 0;
            min-height: calc(100vh - 200px);
        }
        
        .section {
            display: none;
        }
        
        .section.active {
            display: block;
        }
        
        /* Cards */
        .card {
            background: var(--card);
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            margin-bottom: 2rem;
        }
        
        .card-header {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: var(--primary);
            border-bottom: 2px solid var(--border);
            padding-bottom: 1rem;
        }
        
        /* Upload Zone */
        .upload-zone {
            border: 3px dashed var(--border);
            border-radius: 1rem;
            padding: 3rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: var(--bg-alt);
        }
        
        .upload-zone:hover {
            border-color: var(--primary);
            background: white;
        }
        
        .upload-zone.drag-over {
            border-color: var(--primary);
            background: rgba(30, 58, 95, 0.05);
        }
        
        .upload-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
        
        .file-info {
            background: var(--success);
            color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        /* Forms */
        .form-group {
            margin-bottom: 1.5rem;
        }
        
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--text);
        }
        
        input[type="text"],
        input[type="email"],
        input[type="date"],
        input[type="number"],
        input[type="password"],
        select,
        textarea {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--border);
            border-radius: 0.5rem;
            font-size: 1rem;
            font-family: var(--body-font);
            transition: border-color 0.3s;
        }
        
        input:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        textarea {
            resize: vertical;
            min-height: 100px;
        }
        
        /* Buttons */
        button,
        .btn {
            background: var(--primary);
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-block;
            text-decoration: none;
            text-align: center;
        }
        
        button:hover,
        .btn:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .btn-secondary {
            background: var(--secondary);
        }
        
        .btn-success {
            background: var(--success);
        }
        
        .btn-danger {
            background: var(--error);
        }
        
        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
        }
        
        /* Progress Steps */
        .progress-steps {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2rem;
            position: relative;
        }
        
        .progress-steps::before {
            content: '';
            position: absolute;
            top: 25px;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--border);
            z-index: 1;
        }
        
        .step {
            flex: 1;
            text-align: center;
            position: relative;
            z-index: 2;
        }
        
        .step-circle {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--border);
            color: var(--text-light);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin: 0 auto 0.5rem;
            transition: all 0.3s;
        }
        
        .step.active .step-circle {
            background: var(--primary);
            color: white;
        }
        
        .step.completed .step-circle {
            background: var(--success);
            color: white;
        }
        
        .step-label {
            font-size: 0.9rem;
            color: var(--text-light);
        }
        
        .step.active .step-label {
            color: var(--primary);
            font-weight: 600;
        }
        
        /* Classes Grid */
        .classes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }
        
        .class-card {
            background: var(--card);
            border: 2px solid var(--border);
            border-radius: 1rem;
            padding: 1.5rem;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .class-card:hover {
            border-color: var(--primary);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }
        
        .class-header {
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 0.5rem;
        }
        
        .class-meta {
            color: var(--text-light);
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }
        
        .class-stats {
            display: flex;
            justify-content: space-between;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary);
        }
        
        .stat-label {
            font-size: 0.8rem;
            color: var(--text-light);
        }
        
        /* Rubrics */
        .rubrics-list {
            display: grid;
            gap: 1rem;
        }
        
        .rubric-item {
            background: var(--bg-alt);
            padding: 1rem;
            border-radius: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .rubric-info h4 {
            margin-bottom: 0.25rem;
        }
        
        .rubric-info p {
            font-size: 0.9rem;
            color: var(--text-light);
        }
        
        .rubric-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        /* Loading Spinner */
        .spinner {
            border: 4px solid var(--border);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 2rem auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Score Display */
        .score-banner {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            margin: 2rem 0;
        }
        
        .score-value {
            font-size: 3rem;
            font-weight: bold;
            margin: 1rem 0;
        }
        
        .score-percentage {
            font-size: 1.5rem;
            opacity: 0.9;
        }
        
        /* Footer */
        footer {
            background: var(--primary);
            color: white;
            padding: 2rem 0;
            margin-top: 3rem;
        }
        
        .footer-content {
            text-align: center;
        }
        
        .footer-links {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-bottom: 1rem;
        }
        
        .footer-links a {
            color: white;
            text-decoration: none;
            opacity: 0.8;
            transition: opacity 0.3s;
        }
        
        .footer-links a:hover {
            opacity: 1;
        }
        
        /* Utility Classes */
        .hidden {
            display: none !important;
        }
        
        .text-center {
            text-align: center;
        }
        
        .mt-2 {
            margin-top: 2rem;
        }
        
        .mb-2 {
            margin-bottom: 2rem;
        }
        
        .alert {
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }
        
        .alert-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            nav {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .header-content {
                flex-direction: column;
                gap: 1rem;
            }
            
            .classes-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <div class="header-content">
                <div class="logo-section">
                    <div class="logo" id="appLogo">SG</div>
                    <div class="app-title">
                        <h1 id="appName">Speech Gradebook</h1>
                        <div class="tagline" id="appTagline">AI-Powered Speech Assessment</div>
                    </div>
                </div>
                <nav>
                    <a href="#" class="nav-link active" id="navEvaluate" onclick="showEvaluate(); return false;">Evaluate Speech</a>
                    <a href="#" class="nav-link" id="navDashboard" onclick="showDashboard(); return false;">Dashboard</a>
                    <a href="#" class="nav-link" id="navSettings" onclick="showSettings(); return false;">Settings</a>
                    <a href="#" class="nav-link" id="navHelp" onclick="showHelp(); return false;">Help</a>
                </nav>
            </div>
        </div>
    </header>

    <main class="container">
        <!-- Evaluate Section -->
        <section id="evaluateSection" class="section active">
            <div class="card">
                <div class="card-header" id="evaluateCardHeader">üìä Evaluate a Speech</div>
                
                <div class="progress-steps">
                    <div class="step active" id="step1">
                        <div class="step-circle">1</div>
                        <div class="step-label">Upload</div>
                    </div>
                    <div class="step" id="step2">
                        <div class="step-circle">2</div>
                        <div class="step-label">Details</div>
                    </div>
                    <div class="step" id="step3">
                        <div class="step-circle">3</div>
                        <div class="step-label">Evaluate</div>
                    </div>
                    <div class="step" id="step4">
                        <div class="step-circle">4</div>
                        <div class="step-label">Results</div>
                    </div>
                </div>

                <!-- Step 1: Upload -->
                <div id="uploadStep">
                    <div class="upload-zone" id="uploadZone">
                        <div class="upload-icon">üìÅ</div>
                        <h3>Upload Speech Recording</h3>
                        <p>Click or drag & drop your audio/video file here</p>
                        <p style="color: var(--text-light); font-size: 0.9rem; margin-top: 0.5rem;">
                            Supported: MP3, MP4, WAV, M4A, WebM<br>
                            <strong>For GPT-4o:</strong> Can also upload image/screenshot (JPG, PNG)
                        </p>
                    </div>
                    <input type="file" id="fileInput" accept="audio/*,video/*,image/*" style="display: none;">
                    <div id="fileInfo" class="file-info hidden">
                        <span id="fileName"></span>
                        <button onclick="removeFile()" class="btn-small btn-danger">Remove</button>
                    </div>
                    <div id="continueButtonContainer" style="margin-top: 2rem; display: none;">
                        <button onclick="moveToStep(2)" id="continueToDetails">Continue to Details ‚Üí</button>
                    </div>
                </div>

                <!-- Step 2: Details -->
                <div id="detailsStep" class="hidden">
                    <form id="studentForm">
                        <div class="form-group">
                            <label for="studentName">Student Name *</label>
                            <input type="text" id="studentName" required>
                        </div>
                        <div class="form-group">
                            <label for="studentEmail">Student Email</label>
                            <input type="email" id="studentEmail">
                        </div>
                        <div class="form-group">
                            <label for="speechDate">Speech Date</label>
                            <input type="date" id="speechDate">
                        </div>
                        <div class="form-group">
                            <label for="assignmentType">Assignment Type</label>
                            <select id="assignmentType">
                                <option value="self-introduction">Self Introduction Speech</option>
                                <option value="informative">Informative Speech</option>
                                <option value="persuasive">Persuasive Speech</option>
                                <option value="demonstration">Demonstration Speech</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="rubricSelect">Evaluation Rubric *</label>
                            <select id="rubricSelect" required>
                                <option value="">-- Select a Rubric --</option>
                            </select>
                            <p style="font-size: 0.9rem; color: var(--text-light); margin-top: 0.5rem;">
                                Choose which rubric to use for evaluation. <a href="#" onclick="showDashboard(); return false;" style="color: var(--primary);">Manage rubrics</a>
                            </p>
                        </div>
                        <div class="form-group">
                            <label for="apiProvider">AI Provider *</label>
                            <select id="apiProvider" onchange="updateApiKeyPlaceholder()">
                                <option value="gpt4o">OpenAI GPT-4o-mini (FREE $5 Credits - Best Value!)</option>
                                <option value="gemini">Google Gemini (Full Video Analysis)</option>
                                <option value="claude">Anthropic Claude (Audio Only)</option>
                            </select>
                            <p style="font-size: 0.9rem; color: var(--text-light); margin-top: 0.5rem;">
                                <strong>GPT-4o-mini:</strong> FREE $5 credits! Video frames + audio analysis<br>
                                <strong>Gemini:</strong> Full video analysis (requires billing)<br>
                                <strong>Claude:</strong> Audio transcription only
                            </p>
                        </div>
                        <div class="form-group">
                            <label for="apiKey" id="apiKeyLabel">OpenAI API Key *</label>
                            <input type="password" id="apiKey" placeholder="sk-proj-...">
                            <p style="font-size: 0.9rem; color: var(--text-light); margin-top: 0.5rem;">
                                üí° <strong>Tip:</strong> Save your key in <a href="#" onclick="showSettings(); return false;" style="color: var(--primary);">Settings</a> to avoid entering it each time!
                            </p>
                        </div>
                        <div style="display: flex; gap: 1rem;">
                            <button type="button" onclick="moveToStep(1)" class="btn-secondary">‚Üê Back</button>
                            <button type="submit" id="submitEvaluationBtn">Continue to Evaluation ‚Üí</button>
                        </div>
                    </form>
                </div>

                <!-- Step 3: Processing -->
                <div id="processingStep" class="hidden text-center">
                    <div class="spinner"></div>
                    <h3>Evaluating Speech...</h3>
                    <p id="processingMessage">Analyzing speech content and delivery...</p>
                </div>

                <!-- Step 4: Results -->
                <div id="resultsStep" class="hidden">
                    <div id="resultsContent"></div>
                    <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                        <button onclick="openSaveModal()">üíæ Save Results</button>
                        <button onclick="downloadPDF()" class="btn-secondary">üìã Copy to Clipboard</button>
                        <button onclick="emailResults()" class="btn-secondary">üìß Email Results</button>
                        <button onclick="startOver()" class="btn-secondary">üîÑ Start Over</button>
                    </div>
                </div>
            </div>
        </section>

        <!-- Save Modal -->
        <div id="saveModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
            <div style="background:white;padding:2rem;border-radius:1rem;max-width:500px;width:90%;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                <h3 style="margin-top:0;color:var(--primary);">üíæ Save Evaluation</h3>
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">Class:</label>
                    <select id="saveClassSel" onchange="loadSaveStudents()" style="width:100%;padding:0.75rem;font-size:1rem;border:2px solid #ddd;border-radius:0.5rem;">
                        <option value="">-- Select Class --</option>
                    </select>
                </div>
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">Student:</label>
                    <select id="saveStudentSel" style="width:100%;padding:0.75rem;font-size:1rem;border:2px solid #ddd;border-radius:0.5rem;">
                        <option value="">-- Select Student --</option>
                    </select>
                </div>
                <div style="display:flex;gap:1rem;justify-content:flex-end;margin-top:2rem;">
                    <button onclick="closeSaveModal()" style="padding:0.75rem 1.5rem;background:#6c757d;color:white;border:none;border-radius:0.5rem;cursor:pointer;">Cancel</button>
                    <button onclick="doSaveEval()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;font-weight:600;">Save</button>
                </div>
            </div>
        </div>

        <!-- Dashboard Section -->
        <section id="dashboardSection" class="section">
            <div class="card">
                <div class="card-header">üìö My Classes</div>
                <div style="margin-bottom: 1.5rem;">
                    <button onclick="showCreateClass()">‚ûï Create New Class</button>
                </div>
                <div id="classesGrid" class="classes-grid"></div>
            </div>

            <!-- Create Class Form -->
            <div id="createClassCard" class="card hidden">
                <div class="card-header">Create New Class</div>
                <form id="createClassForm">
                    <div class="form-group">
                        <label for="className">Class Name *</label>
                        <input type="text" id="className" required placeholder="e.g., CMST 210">
                    </div>
                    <div class="form-group">
                        <label for="classSemester">Semester</label>
                        <select id="classSemester">
                            <option value="Spring">Spring</option>
                            <option value="Summer">Summer</option>
                            <option value="Fall" selected>Fall</option>
                            <option value="Winter">Winter</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="classSection">Section</label>
                        <input type="text" id="classSection" placeholder="e.g., 001">
                    </div>
                    <div class="form-group">
                        <label for="classYear">Year</label>
                        <input type="number" id="classYear" value="2026">
                    </div>
                    <div class="form-group">
                        <label for="classNotes">Notes</label>
                        <textarea id="classNotes" placeholder="Optional notes about this class"></textarea>
                    </div>
                    <div style="display: flex; gap: 1rem;">
                        <button type="button" onclick="cancelCreateClass()" class="btn-secondary">Cancel</button>
                        <button type="submit">Create Class</button>
                    </div>
                </form>
            </div>

            <!-- Rubric Management -->
            <div class="card">
                <div class="card-header">üìã My Rubrics</div>
                
                <!-- Course Filter -->
                <div style="margin-bottom: 1rem;">
                    <label for="courseFilter" style="font-weight: 500; margin-bottom: 0.5rem; display: block;">Filter by Course:</label>
                    <select id="courseFilter" onchange="filterRubricsByCourse()" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                        <option value="">All Courses</option>
                        <!-- Will be populated dynamically -->
                    </select>
                </div>
                
                <div style="margin-bottom: 1.5rem; display: flex; gap: 1rem;">
                    <button onclick="showCreateRubric()">‚ûï Create Custom Rubric</button>
                    <button onclick="showUploadRubric()" style="background: var(--secondary);">üìÑ Upload Rubric (PDF/Image)</button>
                </div>
                <div id="rubricsList" class="rubrics-list"></div>
            </div>

            <!-- Create/Edit Rubric Form -->
            <div id="createRubricCard" class="card hidden">
                <div class="card-header" id="rubricFormHeader">Create Custom Rubric</div>
                <form id="createRubricForm">
                    <input type="hidden" id="editingRubricId" value="">
                    
                    <!-- Basic Info -->
                    <h4 style="margin-bottom: 1rem; color: var(--primary);">Basic Information</h4>
                    <div class="form-group">
                        <label for="rubricName">Rubric Name *</label>
                        <input type="text" id="rubricName" placeholder="e.g., Persuasive Speech" required>
                    </div>
                    <div class="form-group">
                        <label for="rubricDescription">Description</label>
                        <textarea id="rubricDescription" placeholder="Brief description of this rubric..."></textarea>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                        <div class="form-group">
                            <label for="rubricTotalPoints">Total Points *</label>
                            <input type="number" id="rubricTotalPoints" value="50" min="1" required>
                        </div>
                        <div class="form-group">
                            <label for="rubricSpeechType">Speech Type</label>
                            <input type="text" id="rubricSpeechType" placeholder="e.g., Persuasive, Informative">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Associated Courses (Optional)</label>
                        <p style="font-size: 0.9rem; color: var(--text-light); margin-bottom: 0.5rem;">
                            Select one or more courses/sections. This helps organize your rubrics and makes them easier to find during evaluation.
                        </p>
                        <div id="rubricCoursesContainer" style="max-height: 200px; overflow-y: auto; border: 1px solid var(--border); border-radius: 0.25rem; padding: 0.75rem; background: white;">
                            <!-- Will be populated with checkboxes dynamically -->
                            <p style="color: var(--text-light); text-align: center;">No courses available. Create courses in "My Classes" first.</p>
                        </div>
                    </div>

                    <!-- Grade Scale -->
                    <h4 style="margin: 1.5rem 0 1rem; color: var(--primary);">Grade Scale</h4>
                    <p style="font-size: 0.9rem; color: var(--text-light); margin-bottom: 1rem;">
                        Define what percentage of maximum points each grade represents:
                    </p>
                    <div style="display: grid; gap: 0.5rem; margin-bottom: 1.5rem;">
                        <div style="display: grid; grid-template-columns: auto 1fr 1fr 1fr; gap: 0.5rem; align-items: center;">
                            <strong style="font-size: 0.9rem;">Grade</strong>
                            <strong style="font-size: 0.9rem;">Label</strong>
                            <strong style="font-size: 0.9rem;">Percentage</strong>
                            <strong style="font-size: 0.9rem;">Range</strong>
                        </div>
                        <div style="display: grid; grid-template-columns: auto 1fr 1fr 1fr; gap: 0.5rem; align-items: center;">
                            <span style="font-weight: 600;">A</span>
                            <input type="text" id="gradeA_label" value="Professional" style="padding: 0.4rem;">
                            <input type="number" id="gradeA_pct" value="100" min="0" max="100" style="padding: 0.4rem;">
                            <input type="text" id="gradeA_range" value="100-91" style="padding: 0.4rem;">
                        </div>
                        <div style="display: grid; grid-template-columns: auto 1fr 1fr 1fr; gap: 0.5rem; align-items: center;">
                            <span style="font-weight: 600;">B</span>
                            <input type="text" id="gradeB_label" value="Proficient" style="padding: 0.4rem;">
                            <input type="number" id="gradeB_pct" value="90" min="0" max="100" style="padding: 0.4rem;">
                            <input type="text" id="gradeB_range" value="90-81" style="padding: 0.4rem;">
                        </div>
                        <div style="display: grid; grid-template-columns: auto 1fr 1fr 1fr; gap: 0.5rem; align-items: center;">
                            <span style="font-weight: 600;">C</span>
                            <input type="text" id="gradeC_label" value="Developing" style="padding: 0.4rem;">
                            <input type="number" id="gradeC_pct" value="80" min="0" max="100" style="padding: 0.4rem;">
                            <input type="text" id="gradeC_range" value="80-71" style="padding: 0.4rem;">
                        </div>
                        <div style="display: grid; grid-template-columns: auto 1fr 1fr 1fr; gap: 0.5rem; align-items: center;">
                            <span style="font-weight: 600;">D</span>
                            <input type="text" id="gradeD_label" value="Unprofessional" style="padding: 0.4rem;">
                            <input type="number" id="gradeD_pct" value="70" min="0" max="100" style="padding: 0.4rem;">
                            <input type="text" id="gradeD_range" value="70-61" style="padding: 0.4rem;">
                        </div>
                        <div style="display: grid; grid-template-columns: auto 1fr 1fr 1fr; gap: 0.5rem; align-items: center;">
                            <span style="font-weight: 600;">F</span>
                            <input type="text" id="gradeF_label" value="Unacceptable" style="padding: 0.4rem;">
                            <input type="number" id="gradeF_pct" value="60" min="0" max="100" style="padding: 0.4rem;">
                            <input type="text" id="gradeF_range" value="60-0" style="padding: 0.4rem;">
                        </div>
                    </div>

                    <!-- Categories -->
                    <h4 style="margin: 1.5rem 0 1rem; color: var(--primary);">Categories & Subcategories</h4>
                    <div id="categoriesContainer"></div>
                    <button type="button" onclick="addCategory()" class="btn-secondary" style="margin-top: 1rem;">‚ûï Add Category</button>

                    <!-- Action Buttons -->
                    <div style="display: flex; gap: 1rem; margin-top: 2rem; padding-top: 1.5rem; border-top: 2px solid var(--border);">
                        <button type="button" onclick="cancelCreateRubric()" class="btn-secondary">Cancel</button>
                        <button type="submit" id="rubricSubmitBtn">Create Rubric</button>
                    </div>
                </form>
            </div>
        </section>

        <!-- Settings Section -->
        <section id="settingsSection" class="section">
            <div class="card">
                <div class="card-header">‚öôÔ∏è Settings</div>
                
                <div class="form-group">
                    <label for="tenantSelect">University / Theme</label>
                    <select id="tenantSelect" onchange="switchTenant(this.value)">
                        <option value="default">Generic / Default</option>
                        <option value="utk">University of Tennessee, Knoxville</option>
                    </select>
                </div>

                <div style="margin-top: 2rem;">
                    <h3 style="margin-bottom: 1rem;">üîë API Keys</h3>
                    <p style="font-size: 0.9rem; color: var(--text-light); margin-bottom: 1.5rem;">
                        Save your API keys here so you don't have to enter them every time. Keys are stored securely in your browser.
                    </p>

                    <div class="form-group">
                        <label for="savedGeminiKey">
                            <strong>Google Gemini API Key</strong>
                            <span style="color: var(--text-light); font-weight: normal; margin-left: 0.5rem;">(Recommended - Full video analysis)</span>
                        </label>
                        <input type="password" id="savedGeminiKey" placeholder="AIza...">
                        <p style="font-size: 0.9rem; color: var(--text-light); margin-top: 0.5rem;">
                            Get your key at: <a href="https://aistudio.google.com/app/apikey" target="_blank" style="color: var(--primary);">aistudio.google.com/app/apikey</a>
                        </p>
                    </div>

                    <div class="form-group">
                        <label for="savedOpenAIKey">
                            <strong>OpenAI API Key</strong>
                            <span style="color: var(--text-light); font-weight: normal; margin-left: 0.5rem;">(Good for image analysis)</span>
                        </label>
                        <input type="password" id="savedOpenAIKey" placeholder="sk-proj-...">
                        <p style="font-size: 0.9rem; color: var(--text-light); margin-top: 0.5rem;">
                            Get your key at: <a href="https://platform.openai.com/api-keys" target="_blank" style="color: var(--primary);">platform.openai.com/api-keys</a>
                        </p>
                    </div>

                    <div class="form-group">
                        <label for="savedClaudeKey">
                            <strong>Anthropic Claude API Key</strong>
                            <span style="color: var(--text-light); font-weight: normal; margin-left: 0.5rem;">(Audio transcription only)</span>
                        </label>
                        <input type="password" id="savedClaudeKey" placeholder="sk-ant-...">
                        <p style="font-size: 0.9rem; color: var(--text-light); margin-top: 0.5rem;">
                            Get your key at: <a href="https://console.anthropic.com/" target="_blank" style="color: var(--primary);">console.anthropic.com</a>
                        </p>
                    </div>
                </div>

                <div style="margin-top: 2rem;">
                    <h3 style="margin-bottom: 1rem;">Theme Customization</h3>
                    
                    <div class="form-group">
                        <label>Custom Logo</label>
                        <input type="file" id="logoUpload" accept="image/*" onchange="handleLogoUpload(event)">
                        <div id="logoPreview" class="hidden" style="margin-top: 1rem;">
                            <img id="logoPreviewImg" style="max-width: 200px; border-radius: 0.5rem;">
                            <button type="button" onclick="clearLogo()" class="btn-small btn-danger" style="display: block; margin-top: 0.5rem;">Remove Logo</button>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="primaryColor">Primary Color</label>
                        <input type="color" id="primaryColor" value="#1e3a5f" onchange="updatePrimaryColor(this.value)">
                    </div>

                    <div class="form-group">
                        <label for="headingFont">Heading Font</label>
                        <select id="headingFont" onchange="updateFonts()">
                            <option value="'Crimson Pro', serif">Crimson Pro (Default)</option>
                            <option value="'Montserrat', sans-serif">Montserrat</option>
                            <option value="'Roboto', sans-serif">Roboto</option>
                            <option value="'Open Sans', sans-serif">Open Sans</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="bodyFont">Body Font</label>
                        <select id="bodyFont" onchange="updateFonts()">
                            <option value="'Work Sans', sans-serif">Work Sans (Default)</option>
                            <option value="'Georgia', serif">Georgia</option>
                            <option value="'Roboto', sans-serif">Roboto</option>
                            <option value="'Open Sans', sans-serif">Open Sans</option>
                        </select>
                    </div>
                </div>

                <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                    <button onclick="saveSettings()">üíæ Save Settings</button>
                    <button onclick="resetSettings()" class="btn-secondary">üîÑ Reset to Defaults</button>
                </div>

                <div id="settingsMessage" class="hidden"></div>
            </div>
        </section>

        <!-- Class Detail Section (Simple) -->
        <section id="classDetailSection" class="section">
            <div class="card">
                <div class="card-header">
                    <span id="classDetailTitle">Class Details</span>
                    <button onclick="showDashboard()">‚Üê Back to Dashboard</button>
                </div>
                
                <div id="classDetailContent"></div>
            </div>
            
            <!-- Add Student Form -->
            <div id="addStudentCard" class="card hidden">
                <div class="card-header">Add Student</div>
                <form id="addStudentForm">
                    <div class="form-group">
                        <label for="studentFirstName">First Name *</label>
                        <input type="text" id="studentFirstName" required>
                    </div>
                    <div class="form-group">
                        <label for="studentLastName">Last Name *</label>
                        <input type="text" id="studentLastName" required>
                    </div>
                    <div class="form-group">
                        <label for="studentEmailAdd">Email</label>
                        <input type="email" id="studentEmailAdd">
                    </div>
                    <div class="form-group">
                        <label for="studentIdAdd">Student ID (optional)</label>
                        <input type="text" id="studentIdAdd">
                    </div>
                    <div style="display: flex; gap: 1rem;">
                        <button type="button" onclick="cancelAddStudent()" class="btn-secondary">Cancel</button>
                        <button type="submit">Add Student</button>
                    </div>
                </form>
            </div>
        </section>

        <!-- Upload Rubric Form -->
        <div id="uploadRubricCard" class="card hidden" style="margin-top: 2rem;">
            <div class="card-header">üìÑ Upload Rubric from PDF or Image</div>
            <div style="background: #e3f2fd; padding: 1rem; border-radius: 0.5rem; margin-bottom: 1.5rem; border-left: 4px solid #2196f3;">
                <strong>üìã How it works:</strong>
                <p style="margin: 0.5rem 0 0 0;">Upload a PDF or image of your rubric, and AI will extract the categories, criteria, and point values to create a digital rubric automatically.</p>
            </div>
            
            <form id="uploadRubricForm">
                <div class="form-group">
                    <label for="uploadRubricFile">Upload Rubric File *</label>
                    <input 
                        type="file" 
                        id="uploadRubricFile" 
                        accept=".pdf,.png,.jpg,.jpeg,.webp" 
                        required
                        style="width: 100%; padding: 0.75rem; border: 2px dashed var(--border); border-radius: 0.5rem; background: var(--bg);"
                    >
                    <small style="color: var(--text-light); display: block; margin-top: 0.5rem;">
                        Supported formats: PDF, PNG, JPG, JPEG, WebP (max 10MB)
                    </small>
                </div>
                
                <div class="form-group">
                    <label for="uploadRubricName">Rubric Name *</label>
                    <input 
                        type="text" 
                        id="uploadRubricName" 
                        placeholder="e.g., Persuasive Speech Rubric" 
                        required
                    >
                </div>
                
                <div class="form-group">
                    <label for="uploadAiProvider">AI Provider for Extraction *</label>
                    <select id="uploadAiProvider" required>
                        <option value="">-- Select AI Provider --</option>
                        <option value="gemini">Google Gemini (Recommended - Free)</option>
                        <option value="gpt4o">OpenAI GPT-4o (Supports images)</option>
                        <option value="claude">Anthropic Claude (Best accuracy)</option>
                    </select>
                </div>
                
                <div class="form-group" id="uploadApiKeyGroup">
                    <label for="uploadApiKey" id="uploadApiKeyLabel">API Key *</label>
                    <input 
                        type="password" 
                        id="uploadApiKey" 
                        placeholder="Enter your API key"
                    >
                    <small style="color: var(--text-light); display: block; margin-top: 0.5rem;">
                        Your API key will be used to process the rubric. You can save it in Settings for future use.
                    </small>
                </div>
                
                <div id="uploadProgress" class="hidden" style="margin: 1.5rem 0; padding: 1rem; background: var(--bg); border-radius: 0.5rem;">
                    <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem;">
                        <div class="spinner"></div>
                        <span id="uploadProgressText">Processing rubric...</span>
                    </div>
                    <div style="background: white; height: 8px; border-radius: 4px; overflow: hidden;">
                        <div id="uploadProgressBar" style="width: 0%; height: 100%; background: var(--primary); transition: width 0.3s;"></div>
                    </div>
                </div>
                
                <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                    <button type="button" onclick="cancelUploadRubric()">Cancel</button>
                    <button type="submit" style="background: var(--primary);">üöÄ Extract & Create Rubric</button>
                </div>
            </form>
        </div>

        <!-- Help Section -->
        <section id="helpSection" class="section">
            <div class="card">
                <div class="card-header">‚ùì Help & Documentation</div>
                
                <h3 style="margin-bottom: 1rem;">Getting Started</h3>
                <p style="margin-bottom: 2rem;">
                    Speech Gradebook uses AI to automatically evaluate speech recordings based on customizable rubrics. 
                    Simply upload your speech file, provide student details, and let our AI analyze the content and delivery.
                </p>

                <h3 style="margin-bottom: 1rem;">How to Evaluate a Speech</h3>
                <ol style="margin-bottom: 2rem; padding-left: 1.5rem;">
                    <li style="margin-bottom: 0.5rem;">Click "Evaluate Speech" in the navigation</li>
                    <li style="margin-bottom: 0.5rem;">Upload your audio or video file</li>
                    <li style="margin-bottom: 0.5rem;">Enter student details and your Anthropic API key</li>
                    <li style="margin-bottom: 0.5rem;">Click "Continue to Evaluation" and wait for AI analysis</li>
                    <li style="margin-bottom: 0.5rem;">Review results, download PDF, or email to student</li>
                </ol>

                <h3 style="margin-bottom: 1rem;">Getting an API Key</h3>
                <p style="margin-bottom: 2rem;">
                    You'll need an Anthropic API key to use this service:
                </p>
                <ol style="margin-bottom: 2rem; padding-left: 1.5rem;">
                    <li style="margin-bottom: 0.5rem;">Visit <a href="https://console.anthropic.com" target="_blank" style="color: var(--primary);">console.anthropic.com</a></li>
                    <li style="margin-bottom: 0.5rem;">Sign up or log in to your account</li>
                    <li style="margin-bottom: 0.5rem;">Navigate to API Keys section</li>
                    <li style="margin-bottom: 0.5rem;">Generate a new API key</li>
                    <li style="margin-bottom: 0.5rem;">Save it in Settings to avoid re-entering it</li>
                </ol>

                <h3 style="margin-bottom: 1rem;">Managing Classes</h3>
                <p style="margin-bottom: 2rem;">
                    Use the Dashboard to create and manage your classes. Track students, assignments, and evaluation history 
                    all in one place. All data is stored locally in your browser.
                </p>

                <h3 style="margin-bottom: 1rem;">Custom Rubrics</h3>
                <p style="margin-bottom: 2rem;">
                    Create custom rubrics tailored to your specific assignment requirements. The AI will evaluate speeches 
                    based on your rubric criteria and provide detailed feedback.
                </p>

                <h3 style="margin-bottom: 1rem;">Support</h3>
                <p>
                    For questions or technical support, contact: <strong id="supportEmail"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7c0f090c0c130e083c0f0c19191f141b0e1d18191e131317521f1311">[email&#160;protected]</a></strong>
                </p>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-links" id="footerLinks">
                    <a href="#">Privacy Policy</a>
                    <a href="#">Terms of Service</a>
                </div>
                <p id="footerCopyright">¬© 2026 Speech Gradebook</p>
                <p id="footerAdditional" style="opacity: 0.8; font-size: 0.9rem;"></p>
            </div>
        </div>
    </footer>

    <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>
        // ===== SUPABASE CONFIGURATION =====
        const SUPABASE_URL = 'https://mqhbfefylpfqsbtrshpu.supabase.co';
        const SUPABASE_ANON_KEY = 'sb_publishable_dypr7H7lUg2JGsvewz3VTQ_uov-ty72';
        
        // Initialize Supabase client
        let supabaseClient = null;
        
        try {
            if (window.supabase) {
                supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log('‚úì Supabase client initialized');
            } else {
                console.warn('‚ö†Ô∏è Supabase library not loaded - using localStorage fallback');
            }
        } catch (error) {
            console.error('‚ùå Supabase initialization failed:', error);
            console.log('Using localStorage fallback mode');
        }
        
        // Test Supabase connection
        async function testSupabaseConnection() {
            if (!supabaseClient) {
                console.log('Supabase not available - running in offline mode');
                return false;
            }
            
            try {
                console.log('Testing Supabase connection...');
                const { data, error } = await supabaseClient
                    .from('organizations')
                    .select('name')
                    .limit(1);
                
                if (error) {
                    console.error('‚ùå Supabase connection failed:', error.message);
                    return false;
                } else {
                    console.log('‚úÖ Supabase connected successfully!');
                    if (data && data.length > 0) {
                        console.log('   Organization:', data[0].name);
                    }
                    return true;
                }
            } catch (error) {
                console.error('‚ùå Supabase test error:', error);
                return false;
            }
        }
        
        // ===== TENANT CONFIGURATION =====
        const TENANT_CONFIGS = {
            'utk': {
                name: 'University of Tennessee, Knoxville',
                shortName: 'UTK',
                domain: 'utk.edu',
                branding: {
                    appName: 'Speech Gradebook',
                    tagline: 'AI-Powered Speech Assessment'
                },
                colors: {
                    primary: '#FF8200',
                    primaryDark: '#D66D00',
                    secondary: '#58595B',
                    accent: '#FF8200'
                },
                typography: {
                    headingFont: "'Montserrat', sans-serif",
                    bodyFont: "'Georgia', serif",
                    headingWeight: '600',
                    bodyWeight: '400'
                },
                contact: {
                    supportEmail: 'speecheval-support@utk.edu'
                },
                footer: {
                    links: [
                        { text: 'Privacy Policy', url: 'https://www.utk.edu/aboutut/privacy/' },
                        { text: 'Accessibility', url: 'https://dae.utk.edu/eoa/ada/' },
                        { text: 'Title IX', url: 'https://titleix.utk.edu/' },
                        { text: 'IT Help', url: 'https://oit.utk.edu/help' }
                    ],
                    copyright: '¬© 2026 Speech Gradebook',
                    additionalText: 'The flagship campus of the University of Tennessee System'
                }
            },
            'default': {
                name: 'Speech Gradebook',
                shortName: 'SG',
                domain: null,
                branding: {
                    appName: 'Speech Gradebook',
                    tagline: 'AI-Powered Speech Assessment'
                },
                colors: {
                    primary: '#1e3a5f',
                    primaryDark: '#142940',
                    secondary: '#c8a882',
                    accent: '#d4af37'
                },
                typography: {
                    headingFont: "'Crimson Pro', serif",
                    bodyFont: "'Work Sans', sans-serif",
                    headingWeight: '700',
                    bodyWeight: '400'
                },
                contact: {
                    supportEmail: 'support@speechgradebook.com'
                },
                footer: {
                    links: [
                        { text: 'Privacy Policy', url: '#' },
                        { text: 'Terms of Service', url: '#' }
                    ],
                    copyright: '¬© 2026 Speech Gradebook',
                    additionalText: null
                }
            }
        };

        // ===== GLOBAL STATE =====
        console.log('üöÄ Speech Gradebook JavaScript Loading...');
        let currentTenant = 'default';
        let uploadedFile = null;
        let evaluationResults = null;
        let currentStep = 1;
        console.log('‚úì Global variables initialized');
        
        // Update API key field based on provider
        function updateApiKeyPlaceholder() {
            const provider = document.getElementById('apiProvider').value;
            const apiKeyInput = document.getElementById('apiKey');
            const apiKeyLabel = document.getElementById('apiKeyLabel');
            
            if (provider === 'gpt4o') {
                apiKeyLabel.textContent = 'OpenAI API Key *';
                apiKeyInput.placeholder = 'sk-proj-...';
                const savedKey = localStorage.getItem('openai_api_key');
                if (savedKey) {
                    apiKeyInput.value = savedKey;
                } else {
                    apiKeyInput.value = '';
                }
            } else if (provider === 'gemini') {
                apiKeyLabel.textContent = 'Google Gemini API Key *';
                apiKeyInput.placeholder = 'AIza...';
                const savedKey = localStorage.getItem('gemini_api_key');
                if (savedKey) {
                    apiKeyInput.value = savedKey;
                } else {
                    apiKeyInput.value = '';
                }
            } else {
                apiKeyLabel.textContent = 'Anthropic Claude API Key *';
                apiKeyInput.placeholder = 'sk-ant-...';
                const savedKey = localStorage.getItem('anthropic_api_key');
                if (savedKey) {
                    apiKeyInput.value = savedKey;
                } else {
                    apiKeyInput.value = '';
                }
            }
        }

        // ===== RUBRIC SYSTEM =====
        // Define the Self-Introduction Speech Rubric
        const SELF_INTRO_RUBRIC = {
            name: "Self Introduction Speech",
            totalPoints: 50,
            gradeScale: {
                A: { label: "Professional", percentage: 1.00, range: "100-91" },
                B: { label: "Proficient", percentage: 0.90, range: "90-89" },
                C: { label: "Developing", percentage: 0.80, range: "80-71" },
                D: { label: "Unprofessional", percentage: 0.70, range: "70-61" },
                F: { label: "Unacceptable", percentage: 0.60, range: "60-0" }
            },
            categories: [
                {
                    name: "Content - Introduction",
                    subcategories: [
                        "Capture Attention",
                        "Relevance to Audience",
                        "Introduction of Topic/Purpose"
                    ]
                },
                {
                    name: "Content - Organization",
                    subcategories: [
                        "Pattern",
                        "Connectives",
                        "Within Time Limits"
                    ]
                },
                {
                    name: "Content - Conclusion",
                    subcategories: [
                        "Recap/Summary",
                        "Memorable Final Thought"
                    ]
                },
                {
                    name: "Content - Assignment",
                    subcategories: [
                        "Your passion(s)",
                        "Career Goals",
                        "Philosophy",
                        "Clear Development of Ideas"
                    ]
                },
                {
                    name: "Delivery - Nonverbal",
                    subcategories: [
                        "Eye Contact",
                        "Gestures/Bodily Movements",
                        "Desire to Communicate/Enthusiasm",
                        "Professionalism"
                    ]
                },
                {
                    name: "Delivery - Verbal",
                    subcategories: [
                        "Vocal volume/variety/tone",
                        "Speaking Rate/Effective Use of Pauses",
                        "Extemporaneous style - use of notes",
                        "Use of vocalized pauses/fillers (ums, uhs, like...)"
                    ]
                }
            ]
        };

        // Calculate rubric metrics
        function calculateRubricMetrics(rubric) {
            const totalSubcategories = rubric.categories.reduce(
                (sum, cat) => sum + cat.subcategories.length, 
                0
            );
            const pointsPerSubcategory = rubric.totalPoints / totalSubcategories;
            
            return {
                totalSubcategories,
                pointsPerSubcategory,
                categoryPoints: rubric.categories.map(cat => ({
                    name: cat.name,
                    maxPoints: cat.subcategories.length * pointsPerSubcategory,
                    subcategoryCount: cat.subcategories.length
                }))
            };
        }

        // Calculate score for a category based on grade selections
        function calculateCategoryScore(rubric, categoryIndex, gradeSelections) {
            const metrics = calculateRubricMetrics(rubric);
            const category = rubric.categories[categoryIndex];
            const pointsPerSub = metrics.pointsPerSubcategory;
            
            let totalScore = 0;
            gradeSelections.forEach(grade => {
                const gradePercentage = rubric.gradeScale[grade].percentage;
                totalScore += pointsPerSub * gradePercentage;
            });
            
            return {
                score: parseFloat(totalScore.toFixed(2)),
                maxScore: parseFloat((category.subcategories.length * pointsPerSub).toFixed(2))
            };
        }
        let currentClassId = null;

        // ===== INITIALIZATION =====
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üìÑ DOM Content Loaded');
            
            // Test Supabase connection
            testSupabaseConnection();
            
            // Set default tenant
            currentTenant = 'default';
            applyTenant(currentTenant);
            console.log('‚úì Tenant applied');
            
            // Initialize file upload
            initializeFileUpload();
            console.log('‚úì File upload initialized');
            
            // Initialize form handlers
            initializeForms();
            console.log('‚úì Forms initialized');
            
            // Load saved data
            loadClasses();
            loadRubrics();
            loadSavedSettings();
            console.log('‚úì Data loaded');
            
            // Set current date
            document.getElementById('speechDate').valueAsDate = new Date();
            console.log('‚úì Application fully initialized and ready');
        });

        // ===== NAVIGATION =====
        function showEvaluate() {
            setActiveSection('evaluateSection', 'navEvaluate');
        }

        function showDashboard() {
            setActiveSection('dashboardSection', 'navDashboard');
            loadClasses();
        }

        function showSettings() {
            setActiveSection('settingsSection', 'navSettings');
        }

        function showHelp() {
            setActiveSection('helpSection', 'navHelp');
        }

        function setActiveSection(sectionId, navId) {
            // Hide all sections
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
            // Show selected section
            document.getElementById(sectionId).classList.add('active');
            
            // Update nav
            document.querySelectorAll('.nav-link').forEach(n => n.classList.remove('active'));
            document.getElementById(navId).classList.add('active');
        }

        // ===== TENANT/THEME MANAGEMENT =====
        function switchTenant(tenantId) {
            currentTenant = tenantId;
            applyTenant(tenantId);
            localStorage.setItem('current_tenant', tenantId);
        }

        function applyTenant(tenantId) {
            const config = TENANT_CONFIGS[tenantId] || TENANT_CONFIGS['default'];
            
            // Apply colors
            const root = document.documentElement;
            root.style.setProperty('--primary', config.colors.primary);
            root.style.setProperty('--primary-dark', config.colors.primaryDark);
            root.style.setProperty('--secondary', config.colors.secondary);
            root.style.setProperty('--accent', config.colors.accent);
            
            // Apply fonts
            root.style.setProperty('--heading-font', config.typography.headingFont);
            root.style.setProperty('--body-font', config.typography.bodyFont);
            root.style.setProperty('--heading-weight', config.typography.headingWeight);
            root.style.setProperty('--body-weight', config.typography.bodyWeight);
            
            // Apply branding
            document.getElementById('appName').textContent = config.branding.appName;
            document.getElementById('appTagline').textContent = config.branding.tagline;
            document.getElementById('appLogo').textContent = config.shortName;
            document.title = `${config.branding.appName} - ${config.name}`;
            
            // Apply footer
            const footerLinks = document.getElementById('footerLinks');
            footerLinks.innerHTML = config.footer.links.map(link => 
                `<a href="${link.url}">${link.text}</a>`
            ).join('');
            
            document.getElementById('footerCopyright').textContent = config.footer.copyright;
            document.getElementById('footerAdditional').textContent = config.footer.additionalText || '';
            
            // Apply contact
            document.getElementById('supportEmail').textContent = config.contact.supportEmail;
            
            // Update tenant selector
            document.getElementById('tenantSelect').value = tenantId;
        }

        // ===== FILE UPLOAD =====
        function initializeFileUpload() {
            const uploadZone = document.getElementById('uploadZone');
            const fileInput = document.getElementById('fileInput');

            uploadZone.addEventListener('click', () => fileInput.click());

            uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadZone.classList.add('drag-over');
            });

            uploadZone.addEventListener('dragleave', () => {
                uploadZone.classList.remove('drag-over');
            });

            uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadZone.classList.remove('drag-over');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });

            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFile(e.target.files[0]);
                }
            });
        }

        function handleFile(file) {
            const sizeMB = (file.size / 1024 / 1024).toFixed(2);
            
            uploadedFile = file;
            document.getElementById('fileName').textContent = `üìé ${file.name} (${formatFileSize(file.size)})`;
            document.getElementById('fileInfo').classList.remove('hidden');
            document.getElementById('continueButtonContainer').style.display = 'block';
        }

        function removeFile() {
            uploadedFile = null;
            document.getElementById('fileInfo').classList.add('hidden');
            document.getElementById('fileInput').value = '';
            document.getElementById('continueButtonContainer').style.display = 'none';
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        // ===== STEP NAVIGATION =====
        function moveToStep(step) {
            currentStep = step;
            console.log('=== moveToStep(' + step + ') called ===');
            
            // Hide all steps
            document.getElementById('uploadStep').classList.add('hidden');
            document.getElementById('detailsStep').classList.add('hidden');
            document.getElementById('processingStep').classList.add('hidden');
            document.getElementById('resultsStep').classList.add('hidden');
            
            // Update step indicators
            for (let i = 1; i <= 4; i++) {
                const stepEl = document.getElementById(`step${i}`);
                stepEl.classList.remove('active', 'completed');
                if (i < step) {
                    stepEl.classList.add('completed');
                } else if (i === step) {
                    stepEl.classList.add('active');
                }
            }
            
            // Update card header based on step
            const headerEl = document.getElementById('evaluateCardHeader');
            if (step === 4) {
                headerEl.textContent = 'üìä Speech Evaluation Results';
            } else {
                headerEl.textContent = 'üìä Evaluate a Speech';
            }
            
            // Show current step
            if (step === 1) {
                document.getElementById('uploadStep').classList.remove('hidden');
            } else if (step === 2) {
                document.getElementById('detailsStep').classList.remove('hidden');
                // Update API key field based on selected provider
                updateApiKeyPlaceholder();
                // Populate rubric selector
                populateRubricSelector();
            } else if (step === 3) {
                document.getElementById('processingStep').classList.remove('hidden');
            } else if (step === 4) {
                console.log('Showing results step');
                document.getElementById('resultsStep').classList.remove('hidden');
            }
        }

        async function populateRubricSelector() {
            const select = document.getElementById('rubricSelect');
            if (!select) return;
            
            const rubrics = await getAllRubrics();
            const classes = JSON.parse(localStorage.getItem('classes') || '[]');
            
            // Clear existing options except the first one
            select.innerHTML = '<option value="">-- Select a Rubric --</option>';
            
            // Separate rubrics by type
            const defaultRubrics = rubrics.filter(r => r.id === 'default');
            
            // Filter unassigned rubrics (no courseId or courseIds)
            const unassignedRubrics = rubrics.filter(r => {
                if (r.id === 'default') return false;
                const hasOldCourseId = r.courseId && r.courseId !== '';
                const hasNewCourseIds = r.courseIds && Array.isArray(r.courseIds) && r.courseIds.length > 0;
                return !hasOldCourseId && !hasNewCourseIds;
            });
            
            // Add default rubric
            if (defaultRubrics.length > 0) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = 'System Default';
                defaultRubrics.forEach(rubric => {
                    const option = document.createElement('option');
                    option.value = rubric.id;
                    option.textContent = `${rubric.name} (${rubric.totalPoints} pts)`;
                    optgroup.appendChild(option);
                });
                select.appendChild(optgroup);
            }
            
            // Group rubrics by course NAME (not ID) to consolidate sections
            const rubricsByCourse = {};
            rubrics.filter(r => r.id !== 'default').forEach(rubric => {
                // Get courseIds for this rubric (handle both old and new format)
                let courseIds = [];
                if (rubric.courseIds && Array.isArray(rubric.courseIds)) {
                    courseIds = rubric.courseIds;
                } else if (rubric.courseId) {
                    courseIds = [rubric.courseId];
                }
                
                // Add rubric to each course it's assigned to
                courseIds.forEach(courseId => {
                    const course = classes.find(c => c.id === courseId);
                    if (course) {
                        // Use course name + semester + year as key
                        const courseKey = `${course.name}|${course.semester}|${course.year}`;
                        if (!rubricsByCourse[courseKey]) {
                            rubricsByCourse[courseKey] = {
                                name: course.name,
                                semester: course.semester,
                                year: course.year,
                                rubrics: []
                            };
                        }
                        // Avoid duplicates
                        if (!rubricsByCourse[courseKey].rubrics.find(r => r.id === rubric.id)) {
                            rubricsByCourse[courseKey].rubrics.push(rubric);
                        }
                    }
                });
            });
            
            // Add course-specific rubrics grouped by course name
            Object.keys(rubricsByCourse).sort().forEach(courseKey => {
                const courseGroup = rubricsByCourse[courseKey];
                
                const optgroup = document.createElement('optgroup');
                optgroup.label = `${courseGroup.name} - ${courseGroup.semester} ${courseGroup.year}`;
                
                courseGroup.rubrics.forEach(rubric => {
                    const option = document.createElement('option');
                    option.value = rubric.id;
                    option.textContent = `${rubric.name} (${rubric.totalPoints} pts)`;
                    if (rubric.speechType) {
                        option.textContent += ` - ${rubric.speechType}`;
                    }
                    optgroup.appendChild(option);
                });
                
                select.appendChild(optgroup);
            });
            
            // Add unassigned custom rubrics
            if (unassignedRubrics.length > 0) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = 'My Rubrics (No Course)';
                unassignedRubrics.forEach(rubric => {
                    const option = document.createElement('option');
                    option.value = rubric.id;
                    option.textContent = `${rubric.name} (${rubric.totalPoints} pts)`;
                    if (rubric.speechType) {
                        option.textContent += ` - ${rubric.speechType}`;
                    }
                    optgroup.appendChild(option);
                });
                select.appendChild(optgroup);
            }
            
            // Pre-select the Self-Introduction rubric if available
            const selfIntroRubric = rubrics.find(r => r.id === 'self-intro-1');
            if (selfIntroRubric) {
                select.value = selfIntroRubric.id;
            }
        }

        // ===== FORMS =====
        function initializeForms() {
            console.log('initializeForms() called');
            
            // Student form
            const studentForm = document.getElementById('studentForm');
            console.log('studentForm element:', studentForm);
            
            if (!studentForm) {
                console.error('ERROR: studentForm element not found!');
                return;
            }
            
            console.log('Adding submit event listener to studentForm...');
            studentForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                console.log('>>> FORM SUBMITTED <<<');
                
                try {
                    if (!uploadedFile) {
                        console.log('Form validation: No file uploaded');
                        alert('Please upload a speech recording first.');
                        return;
                    }
                    console.log('Form validation: File OK');

                    console.log('Form handler: Calling moveToStep(3)');
                    moveToStep(3);
                    console.log('Form handler: Calling processAndEvaluate()');
                    await processAndEvaluate();
                    console.log('Form handler: processAndEvaluate() completed');
                } catch (error) {
                    console.error('FORM HANDLER ERROR:', error);
                    alert('Form submission error: ' + error.message);
                    moveToStep(2);
                }
            });
            console.log('‚úì Submit event listener attached to studentForm');
            
            // Also add click listener to submit button for debugging
            const submitBtn = document.getElementById('submitEvaluationBtn');
            if (submitBtn) {
                submitBtn.addEventListener('click', function(e) {
                    console.log('Submit button clicked!');
                    console.log('Form validity:', studentForm.checkValidity());
                    console.log('Student name:', document.getElementById('studentName').value);
                    console.log('Rubric selected:', document.getElementById('rubricSelect').value);
                    console.log('API key:', document.getElementById('apiKey').value ? 'Present' : 'Empty');
                    
                    // Check if form is valid
                    if (!studentForm.checkValidity()) {
                        console.log('Form is INVALID - browser will show validation message');
                        return;
                    }
                    
                    console.log('Form is valid, but submit event not firing - manually triggering...');
                    // Manually call the submit handler since the form submit event isn't firing
                    e.preventDefault();
                    studentForm.dispatchEvent(new Event('submit'));
                });
                console.log('‚úì Click listener attached to submit button');
            }

            // Create class form
            document.getElementById('createClassForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const newClass = {
                    id: Date.now().toString(),
                    name: document.getElementById('className').value,
                    semester: document.getElementById('classSemester').value,
                    section: document.getElementById('classSection').value,
                    year: document.getElementById('classYear').value,
                    notes: document.getElementById('classNotes').value,
                    roster: [],
                    evaluations: [],
                    createdAt: new Date().toISOString()
                };
                
                // Save to localStorage first (immediate)
                const classes = JSON.parse(localStorage.getItem('classes') || '[]');
                classes.push(newClass);
                localStorage.setItem('classes', JSON.stringify(classes));
                console.log('‚úì Class saved to localStorage');
                
                // Also save to Supabase (async)
                if (supabaseClient) {
                    saveCourseToSupabase(newClass).then(supabaseCourse => {
                        if (supabaseCourse) {
                            // Update with Supabase ID
                            newClass.supabaseId = supabaseCourse.id;
                            const updated = classes.find(c => c.id === newClass.id);
                            if (updated) {
                                updated.supabaseId = supabaseCourse.id;
                                localStorage.setItem('classes', JSON.stringify(classes));
                            }
                        }
                    }).catch(err => {
                        console.log('Supabase save failed, but localStorage succeeded');
                    });
                }
                
                alert('‚úì Class created successfully!');
                document.getElementById('createClassForm').reset();
                cancelCreateClass();
                await loadClasses();
            });

            // Create rubric form
            document.getElementById('createRubricForm').addEventListener('submit', (e) => {
                e.preventDefault();
                
                try {
                    const rubricData = collectRubricData();
                    
                    // Validation
                    if (!rubricData.name) {
                        alert('Please enter a rubric name');
                        return;
                    }
                    
                    if (rubricData.totalPoints < 1) {
                        alert('Total points must be at least 1');
                        return;
                    }
                    
                    if (rubricData.categories.length === 0) {
                        alert('Please add at least one category with subcategories');
                        return;
                    }
                    
                    // Check that all categories have subcategories
                    const emptyCategories = rubricData.categories.filter(cat => cat.subcategories.length === 0);
                    if (emptyCategories.length > 0) {
                        alert('All categories must have at least one subcategory');
                        return;
                    }
                    
                    // Save using the new storage system
                    const savedRubric = saveRubric(rubricData);
                    
                    const isEditing = document.getElementById('editingRubricId').value !== '';
                    alert(isEditing ? '‚úì Rubric updated successfully!' : '‚úì Rubric created successfully!');
                    
                    document.getElementById('createRubricForm').reset();
                    cancelCreateRubric();
                    loadRubrics();
                } catch (error) {
                    console.error('Error saving rubric:', error);
                    alert('Error saving rubric: ' + error.message);
                }
            });

            // Add student form
            document.getElementById('addStudentForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const newStudent = {
                    id: Date.now().toString(),
                    firstName: document.getElementById('studentFirstName').value,
                    lastName: document.getElementById('studentLastName').value,
                    email: document.getElementById('studentEmailAdd').value,
                    studentId: document.getElementById('studentIdAdd').value,
                    addedAt: new Date().toISOString()
                };
                
                const classes = JSON.parse(localStorage.getItem('classes') || '[]');
                const classIndex = classes.findIndex(c => c.id === currentClassId);
                
                if (classIndex !== -1) {
                    if (!classes[classIndex].roster) {
                        classes[classIndex].roster = [];
                    }
                    classes[classIndex].roster.push(newStudent);
                    localStorage.setItem('classes', JSON.stringify(classes));
                    console.log('‚úì Student saved to localStorage');
                    
                    // Also save to Supabase if course has supabaseId
                    const course = classes[classIndex];
                    if (supabaseClient && course.supabaseId) {
                        await saveStudentsToSupabase(course.supabaseId, [newStudent]);
                    }
                    
                    alert('‚úì Student added successfully!');
                    document.getElementById('addStudentForm').reset();
                    cancelAddStudent();
                    await viewClass(currentClassId); // Refresh the view
                }
            });
        }

        // ===== SPEECH EVALUATION =====
        async function processAndEvaluate() {
            console.log('=== processAndEvaluate START ===');
            console.log('uploadedFile:', uploadedFile);
            
            // Check if file is uploaded
            if (!uploadedFile) {
                console.log('FAILURE: No file uploaded');
                alert('No file uploaded. Please go back to Step 1 and upload a speech recording.');
                moveToStep(1);
                return;
            }
            console.log('‚úì File uploaded:', uploadedFile.name);
            
            // Get selected API provider
            const apiProvider = document.getElementById('apiProvider').value;
            console.log('API Provider:', apiProvider);
            
            // Get API key from form or localStorage (based on provider)
            let apiKey = document.getElementById('apiKey').value.trim();
            console.log('API key from form field:', apiKey ? '***' + apiKey.slice(-4) : '(empty)');
            
            if (!apiKey) {
                const storageKey = apiProvider === 'gemini' ? 'gemini_api_key' : 
                                  apiProvider === 'gpt4o' ? 'openai_api_key' : 
                                  'anthropic_api_key';
                const savedKey = localStorage.getItem(storageKey);
                console.log(`API key from localStorage (${storageKey}):`, savedKey ? '***' + savedKey.slice(-4) : '(empty)');
                apiKey = savedKey || '';
            }
            console.log('Final API key:', apiKey ? 'Yes (***' + apiKey.slice(-4) + ')' : 'No');
            
            const selectedRubricId = document.getElementById('rubricSelect').value;
            console.log('Selected rubric ID:', selectedRubricId);
            
            if (!apiKey) {
                console.log('FAILURE: No API key');
                const providerName = apiProvider === 'gemini' ? 'Google Gemini' : 
                                    apiProvider === 'gpt4o' ? 'OpenAI' :
                                    'Anthropic Claude';
                alert(`Please enter your ${providerName} API key in the form or save it in Settings.`);
                moveToStep(2);
                return;
            }
            console.log('‚úì API key present');
            
            if (!selectedRubricId) {
                console.log('FAILURE: No rubric selected');
                alert('Please select a rubric for evaluation.');
                moveToStep(2);
                return;
            }
            console.log('‚úì Rubric selected');

            const studentName = document.getElementById('studentName').value;
            const assignmentType = document.getElementById('assignmentType').value;
            
            console.log('Student name:', studentName);
            console.log('Assignment type:', assignmentType);
            console.log('=== All validations passed, starting evaluation ===');
            
            document.getElementById('processingMessage').textContent = 
                'Analyzing speech content and delivery for ' + studentName + '...';

            try {
                // Get the selected rubric
                const selectedRubric = getRubricById(selectedRubricId);
                if (!selectedRubric) {
                    console.log('FAILURE: Rubric not found in storage');
                    throw new Error('Selected rubric not found');
                }
                
                console.log('‚úì Using rubric:', selectedRubric.name);
                
                // Pass rubric and provider to evaluation function
                console.log('Calling evaluateSpeech...');
                const result = await evaluateSpeech(apiKey, uploadedFile, assignmentType, selectedRubric, apiProvider);
                console.log('‚úì Evaluation complete');
                evaluationResults = result;
                moveToStep(4);
                displayResults(result);
            } catch (error) {
                console.error('EVALUATION ERROR:', error);
                alert('Error evaluating speech: ' + error.message);
                moveToStep(2);
            }
        }

        async function evaluateSpeech(apiKey, file, assignmentType, rubric, apiProvider = 'gemini') {
            console.log('>>> evaluateSpeech called');
            console.log('    API Provider:', apiProvider);
            console.log('    API key:', apiKey ? 'Present' : 'Missing');
            console.log('    File:', file ? file.name : 'Missing');
            console.log('    File size:', file ? (file.size / 1024 / 1024).toFixed(2) + ' MB' : 'N/A');
            console.log('    Assignment type:', assignmentType);
            console.log('    Rubric:', rubric ? rubric.name : 'Missing');
            
            // Check file size based on provider
            let maxSizeBytes;
            if (apiProvider === 'gemini') {
                maxSizeBytes = 100 * 1024 * 1024; // 100MB for Gemini
            } else if (apiProvider === 'gpt4o') {
                maxSizeBytes = 100 * 1024 * 1024; // 100MB for GPT-4o (generous limit)
            } else {
                maxSizeBytes = 25 * 1024 * 1024; // 25MB for Claude (due to base64 encoding)
            }
            
            if (file.size > maxSizeBytes) {
                const sizeMB = (file.size / 1024 / 1024).toFixed(2);
                const limitMB = (maxSizeBytes / 1024 / 1024).toFixed(0);
                const providerName = apiProvider === 'gemini' ? 'Gemini' : 
                                    apiProvider === 'gpt4o' ? 'GPT-4o' : 'Claude';
                throw new Error(
                    `File is ${sizeMB} MB, which exceeds the ${limitMB} MB limit for ${providerName}.\n\n` +
                    `Please compress the file or use a different format.`
                );
            }
            
            // Use the passed rubric (or fallback to default if not provided)
            if (!rubric) {
                rubric = getRubricById('default') || DEFAULT_RUBRIC;
            }
            
            const metrics = calculateRubricMetrics(rubric);
            console.log('    Metrics calculated:', metrics);
            
            // Route to the appropriate API
            if (apiProvider === 'gpt4o') {
                return await evaluateWithGPT4o(apiKey, file, assignmentType, rubric);
            } else if (apiProvider === 'gemini') {
                return await evaluateWithGemini(apiKey, file, assignmentType, rubric);
            } else {
                return await evaluateWithClaude(apiKey, file, assignmentType, rubric);
            }
        }
        
        // ===== CLAUDE API EVALUATION =====
        async function evaluateWithClaude(apiKey, file, assignmentType, rubric) {
            console.log('>>> Using Claude API (Audio Only)');
            const metrics = calculateRubricMetrics(rubric);
            
            try {
                let audioFile = file;
                
                // If file is video, extract audio automatically
                if (file.type.startsWith('video/')) {
                    console.log('>>> Video detected, extracting audio...');
                    updateProcessingMessage('Extracting audio from video...');
                    audioFile = await extractAudioFromVideo(file);
                    console.log('‚úì Audio extracted from video');
                }
                
                // Phase 2a: File Processing - Convert audio to base64
                console.log('>>> Phase 2a: Processing audio file...');
                updateProcessingMessage('Processing audio file...');
                const { base64Audio, mediaType, duration } = await processAudioFile(audioFile);
                console.log('‚úì Audio processed:', mediaType, duration);
                
                // Phase 2b: Speech Transcription
                console.log('>>> Phase 2b: Transcribing speech...');
                updateProcessingMessage('Transcribing speech...');
                const transcript = await transcribeSpeech(apiKey, base64Audio, mediaType);
                console.log('‚úì Transcription received, length:', transcript.length);
                
                if (!transcript || transcript.trim().length === 0) {
                    throw new Error('Transcription failed or returned empty. Please ensure the audio is clear and try again.');
                }
                
                // Phase 2c: AI Evaluation Against Rubric
                updateProcessingMessage('Analyzing speech against rubric...');
                const aiEvaluation = await evaluateWithClaudeAI(apiKey, transcript, rubric);
                
                // Phase 2d: Results Validation & Formatting
                updateProcessingMessage('Calculating final scores...');
                const results = formatEvaluationResults(aiEvaluation, rubric, transcript, duration);
                
                return results;
                
            } catch (error) {
                console.error('Claude evaluation error:', error);
                throw new Error(`Claude evaluation failed: ${error.message}`);
            }
        }
        
        // Extract audio from video file using Web Audio API and MediaRecorder
        async function extractAudioFromVideo(videoFile) {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                video.preload = 'metadata';
                video.muted = true;
                
                video.onloadedmetadata = async function() {
                    try {
                        // Create media element source
                        const source = audioContext.createMediaElementSource(video);
                        
                        // Create destination for recording
                        const dest = audioContext.createMediaStreamDestination();
                        source.connect(dest);
                        
                        // Set up MediaRecorder
                        const mediaRecorder = new MediaRecorder(dest.stream);
                        const chunks = [];
                        
                        mediaRecorder.ondataavailable = (e) => {
                            if (e.data.size > 0) {
                                chunks.push(e.data);
                            }
                        };
                        
                        mediaRecorder.onstop = () => {
                            const audioBlob = new Blob(chunks, { type: 'audio/webm' });
                            const audioFile = new File([audioBlob], 'extracted-audio.webm', { type: 'audio/webm' });
                            URL.revokeObjectURL(video.src);
                            resolve(audioFile);
                        };
                        
                        // Start recording and play video
                        mediaRecorder.start();
                        video.play();
                        
                        // Stop when video ends
                        video.onended = () => {
                            mediaRecorder.stop();
                            audioContext.close();
                        };
                        
                    } catch (error) {
                        URL.revokeObjectURL(video.src);
                        reject(new Error('Failed to extract audio: ' + error.message));
                    }
                };
                
                video.onerror = function() {
                    URL.revokeObjectURL(video.src);
                    reject(new Error('Failed to load video for audio extraction'));
                };
                
                video.src = URL.createObjectURL(videoFile);
            });
        }
        
        // ===== GPT-4O-MINI API EVALUATION =====
        async function evaluateWithGPT4o(apiKey, file, assignmentType, rubric) {
            console.log('>>> Using GPT-4o-mini API (Image/Frame Analysis)');
            const metrics = calculateRubricMetrics(rubric);
            
            try {
                let frameBase64;
                
                // Check if file is an image or video
                if (file.type.startsWith('image/')) {
                    // Direct image upload
                    console.log('>>> Phase 1: Processing uploaded image...');
                    updateProcessingMessage('Processing image...');
                    frameBase64 = await fileToBase64(file);
                    console.log('‚úì Image processed');
                } else {
                    // Extract frame from video
                    console.log('>>> Phase 1: Extracting frame from video...');
                    updateProcessingMessage('Extracting video frame...');
                    frameBase64 = await extractVideoFrame(file);
                    console.log('‚úì Video frame extracted');
                }
                
                // Phase 2: Send to GPT-4o for analysis
                console.log('>>> Phase 2: Analyzing with GPT-4o...');
                updateProcessingMessage('Analyzing speech delivery...');
                const gptEvaluation = await analyzeWithGPT4o(apiKey, frameBase64, rubric);
                console.log('‚úì GPT-4o analysis complete');
                
                // Phase 3: Format results
                updateProcessingMessage('Calculating final scores...');
                const duration = file.type.startsWith('image/') ? '0:00' : await getVideoDuration(file);
                const results = formatGPTResults(gptEvaluation, rubric, duration);
                
                return results;
                
            } catch (error) {
                console.error('GPT-4o evaluation error:', error);
                throw new Error(`GPT-4o evaluation failed: ${error.message}`);
            }
        }
        
        // Extract a representative frame from video
        async function extractVideoFrame(file) {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                let hasResolved = false;
                
                // Set timeout to prevent hanging
                const timeout = setTimeout(() => {
                    if (!hasResolved) {
                        URL.revokeObjectURL(video.src);
                        reject(new Error('Video loading timed out after 30 seconds. The video format may not be supported by your browser. Try converting to MP4.'));
                    }
                }, 30000);
                
                video.preload = 'metadata';
                video.muted = true;
                video.playsInline = true;
                
                video.onloadedmetadata = function() {
                    console.log('Video metadata loaded. Duration:', video.duration, 'seconds');
                    // Seek to 2 seconds in (or middle if shorter)
                    const seekTime = Math.min(2, video.duration / 2);
                    console.log('Seeking to:', seekTime, 'seconds');
                    video.currentTime = seekTime;
                };
                
                video.onseeked = function() {
                    console.log('Video seeked successfully');
                    
                    if (hasResolved) return;
                    hasResolved = true;
                    clearTimeout(timeout);
                    
                    try {
                        // Set canvas size to video size (limit to reasonable dimensions)
                        const maxWidth = 1280;
                        const maxHeight = 720;
                        let width = video.videoWidth;
                        let height = video.videoHeight;
                        
                        // Scale down if too large
                        if (width > maxWidth) {
                            height = (height * maxWidth) / width;
                            width = maxWidth;
                        }
                        if (height > maxHeight) {
                            width = (width * maxHeight) / height;
                            height = maxHeight;
                        }
                        
                        canvas.width = width;
                        canvas.height = height;
                        
                        console.log('Canvas size:', width, 'x', height);
                        
                        // Draw video frame to canvas
                        ctx.drawImage(video, 0, 0, width, height);
                        
                        // Convert to base64
                        const base64 = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];
                        console.log('Frame extracted, base64 length:', base64.length);
                        
                        // Clean up
                        URL.revokeObjectURL(video.src);
                        
                        resolve(base64);
                    } catch (error) {
                        URL.revokeObjectURL(video.src);
                        reject(new Error('Failed to extract frame: ' + error.message));
                    }
                };
                
                video.onerror = function(e) {
                    if (hasResolved) return;
                    hasResolved = true;
                    clearTimeout(timeout);
                    
                    URL.revokeObjectURL(video.src);
                    
                    let errorMsg = 'Failed to load video.';
                    if (video.error) {
                        switch (video.error.code) {
                            case 1:
                                errorMsg += ' Video loading was aborted.';
                                break;
                            case 2:
                                errorMsg += ' Network error occurred.';
                                break;
                            case 3:
                                errorMsg += ' Video codec not supported by browser. Try converting to MP4.';
                                break;
                            case 4:
                                errorMsg += ' Video format not supported. Try converting to MP4.';
                                break;
                        }
                    }
                    reject(new Error(errorMsg));
                };
                
                // Load the video
                try {
                    const url = URL.createObjectURL(file);
                    console.log('Loading video from blob URL...');
                    video.src = url;
                    video.load();
                } catch (error) {
                    hasResolved = true;
                    clearTimeout(timeout);
                    reject(new Error('Failed to create video URL: ' + error.message));
                }
            });
        }
        
        // Analyze with GPT-4o API
        async function analyzeWithGPT4o(apiKey, frameBase64, rubric) {
            const prompt = buildGPTPrompt(rubric);
            
            console.log('GPT-4o API Request Details:');
            console.log('  - API Key format check:', apiKey.startsWith('sk-') ? 'Looks valid (starts with sk-)' : 'WARNING: Does not start with sk-');
            console.log('  - API Key length:', apiKey.length);
            console.log('  - Frame base64 length:', frameBase64.length);
            
            // Validate API key format
            if (!apiKey.startsWith('sk-')) {
                throw new Error('Invalid OpenAI API key format. Key should start with "sk-". Make sure you\'re using an OpenAI API key from https://platform.openai.com/api-keys');
            }
            
            const requestBody = {
                model: 'gpt-4o-mini',
                messages: [{
                    role: 'user',
                    content: [
                        {
                            type: 'text',
                            text: prompt
                        },
                        {
                            type: 'image_url',
                            image_url: {
                                url: `data:image/jpeg;base64,${frameBase64}`
                            }
                        }
                    ]
                }],
                max_tokens: 4096
            };
            
            console.log('Calling OpenAI API...');
            
            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(requestBody)
                });
                
                console.log('GPT-4o API Response Status:', response.status);
                console.log('GPT-4o API Response OK:', response.ok);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('GPT-4o API Error Response:', errorText);
                    
                    let errorMessage;
                    try {
                        const errorData = JSON.parse(errorText);
                        errorMessage = errorData.error?.message || errorText;
                    } catch (e) {
                        errorMessage = errorText;
                    }
                    
                    throw new Error(`GPT-4o API error (${response.status}): ${errorMessage}`);
                }
                
                const data = await response.json();
                console.log('GPT-4o API Response received successfully');
                
                const responseText = data.choices?.[0]?.message?.content || '';
                
                if (!responseText) {
                    console.error('GPT-4o response structure:', JSON.stringify(data, null, 2));
                    throw new Error('GPT-4o returned empty response');
                }
                
                return parseGPTEvaluation(responseText);
            } catch (error) {
                console.error('GPT-4o API fetch error:', error);
                throw error;
            }
        }
        
        // Build prompt for GPT-4o
        function buildGPTPrompt(rubric) {
            let prompt = `You are an expert speech instructor evaluating a student's speech presentation. You are viewing a SINGLE FRAME from the middle of their speech video. Analyze this frame for nonverbal delivery cues, and infer verbal content quality based on context clues.

IMPORTANT: You only have ONE FRAME to work with, so focus on:
- What you CAN see: posture, body language, facial expression, eye direction, hand position, professional appearance
- What you can INFER: likely confidence level, engagement, preparation

RUBRIC INFORMATION:
- Assignment Type: ${rubric.speechType || 'General Speech'}
- Total Points: ${rubric.totalPoints}
- Grading Scale:
`;
            
            Object.entries(rubric.gradeScale).forEach(([grade, info]) => {
                prompt += `  ${grade} (${info.label}): ${Math.round(info.percentage * 100)}% of points\n`;
            });
            
            prompt += '\nCATEGORIES TO EVALUATE:\n';
            
            rubric.categories.forEach((category, index) => {
                prompt += `\n${index + 1}. ${category.name}\n`;
                category.subcategories.forEach((sub, subIndex) => {
                    prompt += `   ${String.fromCharCode(97 + subIndex)}. ${sub}\n`;
                });
            });
            
            prompt += `
EVALUATION INSTRUCTIONS:
1. Analyze the single frame carefully
2. For NONVERBAL categories (eye contact, gestures, body language, appearance):
   - Give specific grades based on what you observe
   - Note: "Eye contact appears direct/averted", "Posture is upright/slouched", etc.
3. For VERBAL categories (content, organization, language):
   - Make reasonable inferences based on the speaker's apparent confidence and preparation
   - Grade conservatively (B/C range) since you can't hear the actual content
4. For EACH subcategory, assign a letter grade (A, B, C, D, or F)
5. Be fair but realistic about the limitations of single-frame analysis

CRITICAL: Return your evaluation in this EXACT JSON format (no additional text before or after):
{
  "evaluations": [
    {
      "category": "Category Name",
      "feedback": "Detailed feedback based on visible cues in the frame",
      "subcategories": [
        { "name": "Subcategory Name", "grade": "A" },
        { "name": "Another Subcategory", "grade": "B" }
      ]
    }
  ],
  "overallComments": "Overall assessment noting this is based on a single frame analysis, with observations about visible delivery and inferred content quality",
  "transcript": "Note: Single frame analysis - actual speech content not available"
}

Ensure every subcategory receives a grade. Be honest about limitations while being as helpful as possible.`;

            return prompt;
        }
        
        // Parse GPT evaluation response
        function parseGPTEvaluation(responseText) {
            try {
                let jsonText = responseText.trim();
                
                // Remove markdown code blocks if present
                const codeBlockMatch = jsonText.match(/```(?:json)?\s*([\s\S]*?)```/);
                if (codeBlockMatch) {
                    jsonText = codeBlockMatch[1].trim();
                }
                
                // Try to find JSON object
                const jsonMatch = jsonText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    jsonText = jsonMatch[0];
                }
                
                const evaluation = JSON.parse(jsonText);
                
                // Validate structure
                if (!evaluation.evaluations || !Array.isArray(evaluation.evaluations)) {
                    throw new Error('Invalid evaluation format: missing evaluations array');
                }
                
                if (!evaluation.overallComments) {
                    throw new Error('Invalid evaluation format: missing overallComments');
                }
                
                return evaluation;
                
            } catch (error) {
                console.error('Failed to parse GPT evaluation:', error);
                console.error('Response text:', responseText);
                throw new Error('Failed to parse GPT evaluation response. Please try again.');
            }
        }
        
        // Format GPT results into expected structure
        function formatGPTResults(gptEvaluation, rubric, duration) {
            const metrics = calculateRubricMetrics(rubric);
            const sections = {};
            let totalScore = 0;
            
            rubric.categories.forEach((category, categoryIndex) => {
                const gptCategory = gptEvaluation.evaluations.find(
                    e => e.category === category.name
                );
                
                if (!gptCategory) {
                    console.warn(`No GPT evaluation found for category: ${category.name}`);
                    return;
                }
                
                const grades = category.subcategories.map((subName) => {
                    const gptSub = gptCategory.subcategories.find(s => s.name === subName);
                    return gptSub ? gptSub.grade : 'C';
                });
                
                const categoryScore = calculateCategoryScore(rubric, categoryIndex, grades);
                const pointsPerSub = metrics.pointsPerSubcategory;
                
                const subcategoryDetails = category.subcategories.map((subName, subIndex) => {
                    const grade = grades[subIndex];
                    const gradePercentage = rubric.gradeScale[grade]?.percentage || 0.8;
                    const points = pointsPerSub * gradePercentage;
                    
                    return {
                        name: subName,
                        grade: grade,
                        gradeLabel: rubric.gradeScale[grade]?.label || 'Developing',
                        points: parseFloat(points.toFixed(2)),
                        maxPoints: parseFloat(pointsPerSub.toFixed(2))
                    };
                });
                
                sections[category.name] = {
                    score: categoryScore.score,
                    maxScore: categoryScore.maxScore,
                    feedback: gptCategory.feedback || 'No feedback provided.',
                    subcategories: subcategoryDetails
                };
                
                totalScore += categoryScore.score;
            });
            
            return {
                studentName: document.getElementById('studentName').value,
                speechDate: document.getElementById('speechDate').value,
                assignmentType: rubric.speechType || 'General Speech',
                speechTime: duration || '0:00',
                sections: sections,
                totalScore: parseFloat(totalScore.toFixed(2)),
                maxScore: rubric.totalPoints,
                rubricUsed: rubric.name,
                overallComments: gptEvaluation.overallComments,
                transcript: gptEvaluation.transcript || ''
            };
        }
        
        // ===== GEMINI API EVALUATION =====
        async function evaluateWithGemini(apiKey, file, assignmentType, rubric) {
            console.log('>>> Using Gemini API (Full Video Analysis)');
            const metrics = calculateRubricMetrics(rubric);
            
            try {
                // Phase 1: Convert file to base64
                console.log('>>> Phase 1: Processing video/audio file...');
                updateProcessingMessage('Processing video file...');
                const base64Data = await fileToBase64(file);
                console.log('‚úì File converted to base64');
                
                // Phase 2: Send to Gemini for comprehensive analysis
                console.log('>>> Phase 2: Analyzing video with Gemini...');
                updateProcessingMessage('Analyzing speech content and delivery...');
                const geminiEvaluation = await analyzeWithGemini(apiKey, base64Data, file.type, rubric);
                console.log('‚úì Gemini analysis complete');
                
                // Phase 3: Format results
                updateProcessingMessage('Calculating final scores...');
                const duration = await getVideoDuration(file);
                const results = formatGeminiResults(geminiEvaluation, rubric, duration);
                
                return results;
                
            } catch (error) {
                console.error('Gemini evaluation error:', error);
                throw new Error(`Gemini evaluation failed: ${error.message}`);
            }
        }
        
        // Convert file to base64
        async function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const base64 = e.target.result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        // Get video/audio duration
        async function getVideoDuration(file) {
            return new Promise((resolve) => {
                const url = URL.createObjectURL(file);
                const media = document.createElement(file.type.startsWith('video') ? 'video' : 'audio');
                media.onloadedmetadata = function() {
                    const duration = Math.floor(media.duration);
                    const minutes = Math.floor(duration / 60);
                    const seconds = duration % 60;
                    URL.revokeObjectURL(url);
                    resolve(`${minutes}:${seconds.toString().padStart(2, '0')}`);
                };
                media.onerror = function() {
                    URL.revokeObjectURL(url);
                    resolve('0:00');
                };
                media.src = url;
            });
        }
        
        // Analyze with Gemini API
        async function analyzeWithGemini(apiKey, base64Data, mimeType, rubric) {
            const prompt = buildGeminiPrompt(rubric);
            
            console.log('Gemini API Request Details:');
            console.log('  - API Key format check:', apiKey.startsWith('AIza') ? 'Looks valid (starts with AIza)' : 'WARNING: Does not start with AIza');
            console.log('  - API Key length:', apiKey.length, '(should be around 39 characters)');
            console.log('  - MIME type:', mimeType);
            console.log('  - Base64 data length:', base64Data.length);
            console.log('  - Prompt length:', prompt.length);
            
            // Validate API key format
            if (!apiKey.startsWith('AIza')) {
                throw new Error('Invalid Gemini API key format. Key should start with "AIza". Make sure you\'re using a Gemini API key from https://aistudio.google.com/app/apikey');
            }
            
            const requestBody = {
                contents: [{
                    parts: [
                        {
                            inline_data: {
                                mime_type: mimeType,
                                data: base64Data
                            }
                        },
                        {
                            text: prompt
                        }
                    ]
                }]
            };
            
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`;
            console.log('Gemini API URL:', url.substring(0, 100) + '...');
            console.log('Request size: ~' + Math.round(JSON.stringify(requestBody).length / 1024 / 1024) + ' MB');
            
            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                console.log('Gemini API Response Status:', response.status);
                console.log('Gemini API Response OK:', response.ok);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Gemini API Error Response:', errorText);
                    
                    let errorMessage;
                    try {
                        const errorData = JSON.parse(errorText);
                        errorMessage = errorData.error?.message || errorText;
                    } catch (e) {
                        errorMessage = errorText;
                    }
                    
                    throw new Error(`Gemini API error (${response.status}): ${errorMessage}`);
                }
                
                const data = await response.json();
                console.log('Gemini API Response received successfully');
                
                const responseText = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                
                if (!responseText) {
                    console.error('Gemini response structure:', JSON.stringify(data, null, 2));
                    throw new Error('Gemini returned empty response');
                }
                
                return parseGeminiEvaluation(responseText);
            } catch (error) {
                console.error('Gemini API fetch error:', error);
                console.error('Error name:', error.name);
                console.error('Error message:', error.message);
                throw error;
            }
        }
        
        // Build prompt for Gemini
        function buildGeminiPrompt(rubric) {
            let prompt = `You are an expert speech instructor evaluating a student's speech presentation. Analyze this video recording for BOTH verbal content AND nonverbal delivery.

RUBRIC INFORMATION:
- Assignment Type: ${rubric.speechType || 'General Speech'}
- Total Points: ${rubric.totalPoints}
- Grading Scale:
`;
            
            Object.entries(rubric.gradeScale).forEach(([grade, info]) => {
                prompt += `  ${grade} (${info.label}): ${Math.round(info.percentage * 100)}% of points\n`;
            });
            
            prompt += '\nCATEGORIES TO EVALUATE:\n';
            
            rubric.categories.forEach((category, index) => {
                prompt += `\n${index + 1}. ${category.name}\n`;
                category.subcategories.forEach((sub, subIndex) => {
                    prompt += `   ${String.fromCharCode(97 + subIndex)}. ${sub}\n`;
                });
            });
            
            prompt += `
EVALUATION INSTRUCTIONS:
1. Watch the ENTIRE video carefully
2. Evaluate BOTH:
   - VERBAL: Speech content, organization, language use, clarity
   - NONVERBAL: Eye contact, gestures, body language, facial expressions, posture, movement
3. For EACH subcategory, assign a letter grade (A, B, C, D, or F)
4. Base your evaluation on evidence from the video
5. Be fair but rigorous in your assessment

For nonverbal categories (eye contact, gestures, body language):
- Observe actual behavior in the video
- Note specific examples (e.g., "maintained eye contact 80% of the time", "used descriptive hand gestures")
- Consider camera angle limitations but evaluate what is visible

CRITICAL: Return your evaluation in this EXACT JSON format (no additional text before or after):
{
  "evaluations": [
    {
      "category": "Category Name",
      "feedback": "Detailed feedback including specific observations from the video (both verbal and visual)",
      "subcategories": [
        { "name": "Subcategory Name", "grade": "A" },
        { "name": "Another Subcategory", "grade": "B" }
      ]
    }
  ],
  "overallComments": "Overall assessment referencing specific moments from the video, both verbal content and physical delivery",
  "transcript": "Brief summary of what was said (2-3 sentences)"
}

Ensure every subcategory receives a grade. Be specific in your feedback and reference actual observations from the video.`;

            return prompt;
        }
        
        // Parse Gemini evaluation response
        function parseGeminiEvaluation(responseText) {
            try {
                let jsonText = responseText.trim();
                
                // Remove markdown code blocks if present
                const codeBlockMatch = jsonText.match(/```(?:json)?\s*([\s\S]*?)```/);
                if (codeBlockMatch) {
                    jsonText = codeBlockMatch[1].trim();
                }
                
                // Try to find JSON object
                const jsonMatch = jsonText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    jsonText = jsonMatch[0];
                }
                
                const evaluation = JSON.parse(jsonText);
                
                // Validate structure
                if (!evaluation.evaluations || !Array.isArray(evaluation.evaluations)) {
                    throw new Error('Invalid evaluation format: missing evaluations array');
                }
                
                if (!evaluation.overallComments) {
                    throw new Error('Invalid evaluation format: missing overallComments');
                }
                
                return evaluation;
                
            } catch (error) {
                console.error('Failed to parse Gemini evaluation:', error);
                console.error('Response text:', responseText);
                throw new Error('Failed to parse Gemini evaluation response. Please try again.');
            }
        }
        
        // Format Gemini results into expected structure
        function formatGeminiResults(geminiEvaluation, rubric, duration) {
            const metrics = calculateRubricMetrics(rubric);
            const sections = {};
            let totalScore = 0;
            
            rubric.categories.forEach((category, categoryIndex) => {
                const geminiCategory = geminiEvaluation.evaluations.find(
                    e => e.category === category.name
                );
                
                if (!geminiCategory) {
                    console.warn(`No Gemini evaluation found for category: ${category.name}`);
                    return;
                }
                
                const grades = category.subcategories.map((subName) => {
                    const geminiSub = geminiCategory.subcategories.find(s => s.name === subName);
                    return geminiSub ? geminiSub.grade : 'C';
                });
                
                const categoryScore = calculateCategoryScore(rubric, categoryIndex, grades);
                const pointsPerSub = metrics.pointsPerSubcategory;
                
                const subcategoryDetails = category.subcategories.map((subName, subIndex) => {
                    const grade = grades[subIndex];
                    const gradePercentage = rubric.gradeScale[grade]?.percentage || 0.8;
                    const points = pointsPerSub * gradePercentage;
                    
                    return {
                        name: subName,
                        grade: grade,
                        gradeLabel: rubric.gradeScale[grade]?.label || 'Developing',
                        points: parseFloat(points.toFixed(2)),
                        maxPoints: parseFloat(pointsPerSub.toFixed(2))
                    };
                });
                
                sections[category.name] = {
                    score: categoryScore.score,
                    maxScore: categoryScore.maxScore,
                    feedback: geminiCategory.feedback || 'No feedback provided.',
                    subcategories: subcategoryDetails
                };
                
                totalScore += categoryScore.score;
            });
            
            return {
                studentName: document.getElementById('studentName').value,
                speechDate: document.getElementById('speechDate').value,
                assignmentType: rubric.speechType || 'General Speech',
                speechTime: duration || '0:00',
                sections: sections,
                totalScore: parseFloat(totalScore.toFixed(2)),
                maxScore: rubric.totalPoints,
                rubricUsed: rubric.name,
                overallComments: geminiEvaluation.overallComments,
                transcript: geminiEvaluation.transcript || ''
            };
        }
        
        // Helper function to update processing message
        function updateProcessingMessage(message) {
            const messageElement = document.getElementById('processingMessage');
            if (messageElement) {
                messageElement.textContent = message;
            }
        }
        
        // Phase 2a: Process audio/video file and convert to base64
        async function processAudioFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const base64Data = e.target.result.split(',')[1];
                    
                    // Determine media type
                    let mediaType = file.type;
                    
                    // Handle common audio formats
                    if (!mediaType || mediaType === '') {
                        const extension = file.name.split('.').pop().toLowerCase();
                        const typeMap = {
                            'mp3': 'audio/mpeg',
                            'wav': 'audio/wav',
                            'webm': 'audio/webm',
                            'mp4': 'audio/mp4',
                            'm4a': 'audio/mp4',
                            'ogg': 'audio/ogg'
                        };
                        mediaType = typeMap[extension] || 'audio/mpeg';
                    }
                    
                    // Estimate duration (not exact, just for display)
                    const estimatedDuration = Math.floor(file.size / 16000); // Rough estimate
                    const minutes = Math.floor(estimatedDuration / 60);
                    const seconds = estimatedDuration % 60;
                    const duration = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    
                    resolve({
                        base64Audio: base64Data,
                        mediaType: mediaType,
                        duration: duration
                    });
                };
                
                reader.onerror = function(error) {
                    reject(new Error('Failed to read audio file: ' + error));
                };
                
                reader.readAsDataURL(file);
            });
        }
        
        // Phase 2b: Transcribe speech using Claude API
        async function transcribeSpeech(apiKey, base64Audio, mediaType) {
            console.log('transcribeSpeech - API key length:', apiKey.length);
            
            // Sanitize API key - remove any non-ASCII characters
            const cleanApiKey = apiKey.replace(/[^\x00-\x7F]/g, '').trim();
            console.log('transcribeSpeech - Cleaned API key length:', cleanApiKey.length);
            
            if (cleanApiKey !== apiKey) {
                console.warn('API key contained non-ASCII characters that were removed');
            }
            
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': cleanApiKey,
                    'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                    model: 'claude-sonnet-4-20250514',
                    max_tokens: 4096,
                    messages: [
                        {
                            role: 'user',
                            content: [
                                {
                                    type: 'document',
                                    source: {
                                        type: 'base64',
                                        media_type: mediaType,
                                        data: base64Audio
                                    }
                                },
                                {
                                    type: 'text',
                                    text: 'Please transcribe this speech audio. Provide only the transcript text without any additional commentary or formatting.'
                                }
                            ]
                        }
                    ]
                })
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error?.message || `API request failed with status ${response.status}`);
            }
            
            const data = await response.json();
            const transcript = data.content[0]?.text || '';
            
            return transcript.trim();
        }
        
        // Phase 2c: Evaluate transcript against rubric using Claude API
        async function evaluateWithClaudeAI(apiKey, transcript, rubric) {
            // Build the evaluation prompt
            const prompt = buildEvaluationPrompt(transcript, rubric);
            
            // Sanitize API key - remove any non-ASCII characters
            const cleanApiKey = apiKey.replace(/[^\x00-\x7F]/g, '').trim();
            
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': cleanApiKey,
                    'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                    model: 'claude-sonnet-4-20250514',
                    max_tokens: 4096,
                    messages: [
                        {
                            role: 'user',
                            content: prompt
                        }
                    ]
                })
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error?.message || `API request failed with status ${response.status}`);
            }
            
            const data = await response.json();
            const responseText = data.content[0]?.text || '';
            
            // Parse the JSON response
            return parseAIEvaluation(responseText);
        }
        
        // Build the evaluation prompt for Claude
        function buildEvaluationPrompt(transcript, rubric) {
            let prompt = `You are an expert speech instructor grading a student's speech. Evaluate the following speech transcript against the provided rubric.

SPEECH TRANSCRIPT:
${transcript}

RUBRIC INFORMATION:
- Assignment Type: ${rubric.speechType || 'General Speech'}
- Total Points: ${rubric.totalPoints}
- Grading Scale:
`;
            
            // Add grade scale information
            Object.entries(rubric.gradeScale).forEach(([grade, info]) => {
                prompt += `  ${grade} (${info.label}): ${Math.round(info.percentage * 100)}% of points\n`;
            });
            
            prompt += '\nCATEGORIES AND SUBCATEGORIES TO EVALUATE:\n';
            
            // Add all categories and subcategories
            rubric.categories.forEach((category, index) => {
                prompt += `\n${index + 1}. ${category.name}\n`;
                category.subcategories.forEach((sub, subIndex) => {
                    prompt += `   ${String.fromCharCode(97 + subIndex)}. ${sub}\n`;
                });
            });
            
            prompt += `
TASK:
For EACH subcategory listed above, you must:
1. Assign a letter grade (A, B, C, D, or F) based on how well the speech demonstrates that specific criterion
2. Base your evaluation on evidence from the transcript
3. Be fair but rigorous in your assessment

Additionally, provide:
- Specific feedback for each CATEGORY (not subcategory) explaining the overall performance
- Overall comments on the entire speech with constructive suggestions for improvement

IMPORTANT: Return your evaluation in this EXACT JSON format (no additional text before or after):
{
  "evaluations": [
    {
      "category": "Category Name",
      "feedback": "Detailed feedback for this category based on the transcript",
      "subcategories": [
        { "name": "Subcategory Name", "grade": "A" },
        { "name": "Another Subcategory", "grade": "B" }
      ]
    }
  ],
  "overallComments": "Overall assessment of the speech with specific examples from the transcript and actionable suggestions for improvement"
}

Ensure every subcategory from the rubric receives a grade. Be specific in your feedback and reference actual content from the speech.`;

            return prompt;
        }
        
        // Parse AI evaluation response
        function parseAIEvaluation(responseText) {
            try {
                // Try to extract JSON from the response
                // Handle cases where Claude might wrap it in markdown code blocks
                let jsonText = responseText.trim();
                
                // Remove markdown code blocks if present
                const codeBlockMatch = jsonText.match(/```(?:json)?\s*([\s\S]*?)```/);
                if (codeBlockMatch) {
                    jsonText = codeBlockMatch[1].trim();
                }
                
                // Try to find JSON object
                const jsonMatch = jsonText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    jsonText = jsonMatch[0];
                }
                
                const evaluation = JSON.parse(jsonText);
                
                // Validate the structure
                if (!evaluation.evaluations || !Array.isArray(evaluation.evaluations)) {
                    throw new Error('Invalid evaluation format: missing evaluations array');
                }
                
                if (!evaluation.overallComments) {
                    throw new Error('Invalid evaluation format: missing overallComments');
                }
                
                return evaluation;
                
            } catch (error) {
                console.error('Failed to parse AI evaluation:', error);
                console.error('Response text:', responseText);
                throw new Error('Failed to parse AI evaluation response. Please try again.');
            }
        }
        
        // Phase 2d: Format evaluation results into the expected structure
        function formatEvaluationResults(aiEvaluation, rubric, transcript, duration) {
            const metrics = calculateRubricMetrics(rubric);
            const sections = {};
            let totalScore = 0;
            
            // Process each category from the AI evaluation
            rubric.categories.forEach((category, categoryIndex) => {
                // Find matching evaluation from AI response
                const aiCategory = aiEvaluation.evaluations.find(
                    e => e.category === category.name
                );
                
                if (!aiCategory) {
                    console.warn(`No AI evaluation found for category: ${category.name}`);
                    return;
                }
                
                // Build grade array for this category
                const grades = category.subcategories.map((subName) => {
                    const aiSub = aiCategory.subcategories.find(s => s.name === subName);
                    return aiSub ? aiSub.grade : 'C'; // Default to C if missing
                });
                
                // Calculate category score
                const categoryScore = calculateCategoryScore(rubric, categoryIndex, grades);
                const pointsPerSub = metrics.pointsPerSubcategory;
                
                // Build subcategory details
                const subcategoryDetails = category.subcategories.map((subName, subIndex) => {
                    const grade = grades[subIndex];
                    const gradePercentage = rubric.gradeScale[grade]?.percentage || 0.8;
                    const points = pointsPerSub * gradePercentage;
                    
                    return {
                        name: subName,
                        grade: grade,
                        gradeLabel: rubric.gradeScale[grade]?.label || 'Developing',
                        points: parseFloat(points.toFixed(2)),
                        maxPoints: parseFloat(pointsPerSub.toFixed(2))
                    };
                });
                
                sections[category.name] = {
                    score: categoryScore.score,
                    maxScore: categoryScore.maxScore,
                    feedback: aiCategory.feedback || 'No feedback provided.',
                    subcategories: subcategoryDetails
                };
                
                totalScore += categoryScore.score;
            });
            
            return {
                studentName: document.getElementById('studentName').value,
                speechDate: document.getElementById('speechDate').value,
                assignmentType: rubric.speechType || 'General Speech',
                speechTime: duration || '0:00',
                sections: sections,
                totalScore: parseFloat(totalScore.toFixed(2)),
                maxScore: rubric.totalPoints,
                rubricUsed: rubric.name,
                overallComments: aiEvaluation.overallComments,
                transcript: transcript // Store transcript for reference
            };
        }

        // Generate feedback based on category and grades
        function generateCategoryFeedback(categoryName, grades) {
            const avgGrade = calculateAverageGrade(grades);
            
            const feedbackMap = {
                'Content - Introduction': {
                    'A': 'Excellent opening with clear attention getter. Introduction effectively established topic relevance and purpose.',
                    'B': 'Strong opening with clear attention getter. Introduction effectively established topic relevance. Good connection to audience.',
                    'C': 'Adequate introduction present. Could improve attention-getting technique and clearer statement of purpose.',
                    'D': 'Introduction present but lacks clear attention getter or purpose statement.',
                    'F': 'Introduction needs significant improvement in capturing attention and establishing purpose.'
                },
                'Content - Organization': {
                    'A': 'Excellent organizational structure with clear pattern. Smooth transitions and perfect time management.',
                    'B': 'Clear organizational pattern evident. Transitions could be smoother. Excellent time management.',
                    'C': 'Basic organizational structure present. Transitions need improvement. Time management adequate.',
                    'D': 'Organization unclear. Transitions weak. Time management needs attention.',
                    'F': 'Lacks clear organizational pattern. Poor transitions and time management.'
                },
                'Content - Conclusion': {
                    'A': 'Excellent conclusion with memorable final thought and effective summary of main points.',
                    'B': 'Strong conclusion with good summary. Final thought could be more memorable.',
                    'C': 'Adequate conclusion present. Could strengthen summary and final thought.',
                    'D': 'Weak conclusion. Lacks clear summary or memorable ending.',
                    'F': 'No clear conclusion or summary provided.'
                },
                'Content - Assignment': {
                    'A': 'Outstanding content that fully addresses all assignment requirements. Personal stories highly engaging and philosophy exceptionally well-articulated.',
                    'B': 'Content clearly addressed assignment requirements. Personal stories were engaging and philosophy was well-articulated.',
                    'C': 'Content addresses most assignment requirements. Could develop ideas more fully.',
                    'D': 'Content partially addresses assignment. Ideas need more development.',
                    'F': 'Content does not adequately address assignment requirements.'
                },
                'Delivery - Nonverbal': {
                    'A': 'Excellent eye contact, natural gestures, and enthusiastic delivery. Highly professional appearance.',
                    'B': 'Good eye contact and gestures. Enthusiastic delivery. Some improvement needed in reducing nervous movements. Professional appearance.',
                    'C': 'Adequate eye contact and gestures. Could improve enthusiasm and reduce distracting movements.',
                    'D': 'Limited eye contact. Gestures need improvement. Lacks enthusiasm.',
                    'F': 'Poor eye contact and minimal effective gestures. Unprofessional delivery.'
                },
                'Delivery - Verbal': {
                    'A': 'Excellent vocal variety, volume, and speaking rate. Perfect use of pauses. Fully extemporaneous with no filler words.',
                    'B': 'Excellent vocal variety and appropriate volume. Good speaking rate. Mostly extemporaneous style with minimal notes. Some filler words present.',
                    'C': 'Adequate vocal delivery. Could improve variety and reduce dependence on notes. Noticeable filler words.',
                    'D': 'Limited vocal variety. Over-reliant on notes. Excessive filler words.',
                    'F': 'Poor vocal delivery. Reading from notes. Excessive filler words interfere with message.'
                }
            };
            
            return feedbackMap[categoryName]?.[avgGrade] || 'Feedback not available.';
        }

        // Calculate average grade from an array of grades
        function calculateAverageGrade(grades) {
            const gradeValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'F': 1 };
            const sum = grades.reduce((total, grade) => total + gradeValues[grade], 0);
            const avg = sum / grades.length;
            
            if (avg >= 4.5) return 'A';
            if (avg >= 3.5) return 'B';
            if (avg >= 2.5) return 'C';
            if (avg >= 1.5) return 'D';
            return 'F';
        }

        // ===== RUBRIC STORAGE & MANAGEMENT =====
        
        // Create a default "General Speech Evaluation" rubric
        const DEFAULT_RUBRIC = {
            id: 'default',
            name: "General Speech Evaluation",
            description: "Simplified evaluation for verbal and nonverbal communication",
            totalPoints: 50,
            courseId: null,
            speechType: "General",
            createdDate: new Date().toISOString(),
            gradeScale: {
                A: { label: "Professional", percentage: 1.00, range: "100-91" },
                B: { label: "Proficient", percentage: 0.90, range: "90-89" },
                C: { label: "Developing", percentage: 0.80, range: "80-71" },
                D: { label: "Unprofessional", percentage: 0.70, range: "70-61" },
                F: { label: "Unacceptable", percentage: 0.60, range: "60-0" }
            },
            categories: [
                {
                    name: "Verbal Delivery",
                    subcategories: [
                        "Vocal Volume and Clarity",
                        "Speaking Rate and Pacing",
                        "Vocal Variety and Expression",
                        "Minimal Filler Words"
                    ]
                },
                {
                    name: "Nonverbal Delivery",
                    subcategories: [
                        "Eye Contact",
                        "Gestures and Body Language",
                        "Confidence and Enthusiasm",
                        "Professional Appearance"
                    ]
                }
            ]
        };

        // Initialize rubrics in localStorage if not exists
        function initializeRubrics() {
            const existingRubrics = localStorage.getItem('speech_rubrics');
            if (!existingRubrics) {
                // Create initial rubrics array with default and self-intro
                const initialRubrics = [
                    DEFAULT_RUBRIC,
                    {
                        id: 'self-intro-1',
                        name: "Self Introduction Speech",
                        description: "Comprehensive rubric for self-introduction speeches",
                        totalPoints: 50,
                        courseId: null,
                        speechType: "Self-Introduction",
                        createdDate: new Date().toISOString(),
                        gradeScale: SELF_INTRO_RUBRIC.gradeScale,
                        categories: SELF_INTRO_RUBRIC.categories
                    }
                ];
                localStorage.setItem('speech_rubrics', JSON.stringify(initialRubrics));
            }
        }

        // Get all rubrics
        // ===== SUPABASE COURSE FUNCTIONS =====
        
        // Save course to Supabase
        async function saveCourseToSupabase(course) {
            if (!supabaseClient) {
                console.log('Supabase not available, using localStorage only');
                return null;
            }
            
            try {
                // Get admin user ID for temporary creator
                let creatorId = localStorage.getItem('temp_creator_id');
                
                if (!creatorId) {
                    const { data: users } = await supabaseClient
                        .from('users')
                        .select('id')
                        .eq('email', 'admin@speechgradebook.com')
                        .limit(1);
                    
                    if (users && users.length > 0) {
                        creatorId = users[0].id;
                        localStorage.setItem('temp_creator_id', creatorId);
                    } else {
                        console.error('Could not find admin user');
                        return null;
                    }
                }
                
                const courseData = {
                    instructor_id: creatorId,
                    name: course.name,
                    code: course.section || null,
                    semester: course.semester || null,
                    year: parseInt(course.year) || null
                };
                
                // If course has Supabase ID, update it
                if (course.supabaseId) {
                    const { data, error } = await supabaseClient
                        .from('courses')
                        .update(courseData)
                        .eq('id', course.supabaseId)
                        .select();
                    
                    if (error) {
                        console.error('Failed to update course:', error);
                        return null;
                    }
                    console.log('‚úì Course updated in Supabase');
                    return data[0];
                } else {
                    const { data, error } = await supabaseClient
                        .from('courses')
                        .insert([courseData])
                        .select();
                    
                    if (error) {
                        console.error('Failed to save course:', error);
                        return null;
                    }
                    console.log('‚úì Course saved to Supabase');
                    
                    // Save students if they exist
                    if (course.roster && course.roster.length > 0) {
                        await saveStudentsToSupabase(data[0].id, course.roster);
                    }
                    
                    return data[0];
                }
            } catch (error) {
                console.error('Supabase error saving course:', error);
                return null;
            }
        }
        
        // Save students to Supabase
        async function saveStudentsToSupabase(courseId, students) {
            if (!supabaseClient || !students || students.length === 0) {
                return null;
            }
            
            try {
                const studentsData = students.map(student => ({
                    course_id: courseId,
                    student_user_id: null,
                    first_name: student.firstName || student.name?.split(' ')[0] || '',
                    last_name: student.lastName || student.name?.split(' ').slice(1).join(' ') || '',
                    email: student.email || null,
                    student_id: student.studentId || null
                }));
                
                const { data, error } = await supabaseClient
                    .from('course_students')
                    .insert(studentsData)
                    .select();
                
                if (error) {
                    console.error('Failed to save students:', error);
                    return null;
                }
                
                console.log(`‚úì ${data.length} students saved to Supabase`);
                return data;
            } catch (error) {
                console.error('Supabase error saving students:', error);
                return null;
            }
        }
        
        // Load courses from Supabase
        async function loadCoursesFromSupabase() {
            if (!supabaseClient) {
                return null;
            }
            
            try {
                const { data: courses, error } = await supabaseClient
                    .from('courses')
                    .select(`
                        *,
                        course_students (
                            id,
                            first_name,
                            last_name,
                            email,
                            student_id
                        )
                    `)
                    .order('created_at', { ascending: false });
                
                if (error) {
                    console.error('Failed to load courses:', error);
                    return null;
                }
                
                console.log(`‚úì Loaded ${courses.length} courses from Supabase`);
                return courses;
            } catch (error) {
                console.error('Supabase error loading courses:', error);
                return null;
            }
        }
        
        // ===== SUPABASE RUBRIC FUNCTIONS =====
        
        // Save rubric to Supabase
        async function saveRubricToSupabase(rubric) {
            if (!supabaseClient) {
                console.log('Supabase not available, using localStorage only');
                return null;
            }
            
            try {
                // Get the admin user ID to use as temporary creator
                // In Phase B4, this will be replaced with actual authenticated user
                let creatorId = localStorage.getItem('temp_creator_id');
                
                if (!creatorId) {
                    // Fetch the admin user ID once
                    const { data: users, error: userError } = await supabaseClient
                        .from('users')
                        .select('id')
                        .eq('email', 'admin@speechgradebook.com')
                        .limit(1);
                    
                    if (users && users.length > 0) {
                        creatorId = users[0].id;
                        localStorage.setItem('temp_creator_id', creatorId);
                        console.log('‚úì Got admin user ID:', creatorId);
                    } else {
                        console.error('Could not find admin user for creator_id');
                        return null;
                    }
                }
                
                // Validate UUID format
                const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
                if (!uuidRegex.test(creatorId)) {
                    console.error('Invalid UUID format for creator_id:', creatorId);
                    // Clear invalid cached ID and retry
                    localStorage.removeItem('temp_creator_id');
                    return await saveRubricToSupabase(rubric);
                }
                
                const rubricData = {
                    creator_id: creatorId, // Using admin user temporarily
                    name: rubric.name,
                    speech_type: rubric.speechType || null,
                    total_points: rubric.totalPoints || 0,
                    grade_scale: rubric.gradeScale,
                    categories: rubric.categories,
                    is_template: rubric.isTemplate || false
                };
                
                // If rubric has a Supabase ID, update it
                if (rubric.supabaseId) {
                    const { data, error } = await supabaseClient
                        .from('rubrics')
                        .update(rubricData)
                        .eq('id', rubric.supabaseId)
                        .select();
                    
                    if (error) {
                        console.error('Failed to update rubric in Supabase:', error);
                        return null;
                    }
                    console.log('‚úì Rubric updated in Supabase');
                    return data[0];
                } else {
                    // Insert new rubric
                    const { data, error } = await supabaseClient
                        .from('rubrics')
                        .insert([rubricData])
                        .select();
                    
                    if (error) {
                        console.error('Failed to save rubric to Supabase:', error);
                        return null;
                    }
                    console.log('‚úì Rubric saved to Supabase');
                    return data[0];
                }
            } catch (error) {
                console.error('Supabase error saving rubric:', error);
                return null;
            }
        }
        
        // Load rubrics from Supabase
        async function loadRubricsFromSupabase() {
            if (!supabaseClient) {
                return null;
            }
            
            try {
                const { data, error } = await supabaseClient
                    .from('rubrics')
                    .select('*')
                    .order('created_at', { ascending: false });
                
                if (error) {
                    console.error('Failed to load rubrics from Supabase:', error);
                    return null;
                }
                
                console.log(`‚úì Loaded ${data.length} rubrics from Supabase`);
                return data;
            } catch (error) {
                console.error('Supabase error loading rubrics:', error);
                return null;
            }
        }
        
        // Hybrid function: Get all rubrics (Supabase + localStorage)
        async function getAllRubrics() {
            // Try Supabase first
            const supabaseRubrics = await loadRubricsFromSupabase();
            
            if (supabaseRubrics && supabaseRubrics.length > 0) {
                // Convert Supabase format to app format
                return supabaseRubrics.map(sr => ({
                    id: sr.id,
                    supabaseId: sr.id,
                    name: sr.name,
                    speechType: sr.speech_type,
                    totalPoints: sr.total_points,
                    gradeScale: sr.grade_scale,
                    categories: sr.categories,
                    isTemplate: sr.is_template,
                    createdDate: sr.created_at,
                    modifiedDate: sr.updated_at
                }));
            }
            
            // Fallback to localStorage
            const rubrics = localStorage.getItem('speech_rubrics');
            return rubrics ? JSON.parse(rubrics) : [];
        }

        // Get rubrics by course
        async function getRubricsByCourse(courseId) {
            const rubrics = await getAllRubrics();
            return rubrics.filter(r => r.courseId === courseId);
        }

        // Get rubric by ID
        async function getRubricById(rubricId) {
            const rubrics = await getAllRubrics();
            return rubrics.find(r => r.id === rubricId);
        }

        // Save/update rubric (hybrid: Supabase + localStorage)
        async function saveRubric(rubric) {
            // Save to localStorage first (immediate, synchronous)
            const rubrics = localStorage.getItem('speech_rubrics');
            const localRubrics = rubrics ? JSON.parse(rubrics) : [];
            const existingIndex = localRubrics.findIndex(r => r.id === rubric.id);
            
            if (existingIndex >= 0) {
                // Update existing
                rubric.modifiedDate = new Date().toISOString();
                localRubrics[existingIndex] = rubric;
            } else {
                // Add new
                if (!rubric.id) {
                    rubric.id = 'rubric-' + Date.now();
                }
                rubric.createdDate = new Date().toISOString();
                localRubrics.push(rubric);
            }
            
            localStorage.setItem('speech_rubrics', JSON.stringify(localRubrics));
            console.log('‚úì Rubric saved to localStorage');
            
            // Also save to Supabase (async, non-blocking)
            if (supabaseClient) {
                saveRubricToSupabase(rubric).then(supabaseRubric => {
                    if (supabaseRubric) {
                        // Update the rubric with Supabase ID
                        rubric.supabaseId = supabaseRubric.id;
                        const updated = localRubrics.find(r => r.id === rubric.id);
                        if (updated) {
                            updated.supabaseId = supabaseRubric.id;
                            localStorage.setItem('speech_rubrics', JSON.stringify(localRubrics));
                        }
                    }
                }).catch(err => {
                    console.log('Supabase save failed, but localStorage succeeded');
                });
            }
            
            return rubric;
        }

        // Duplicate rubric
        async function duplicateRubric(rubricId) {
            const original = await getRubricById(rubricId);
            if (!original) return null;
            
            const duplicate = {
                ...JSON.parse(JSON.stringify(original)), // Deep copy
                id: 'rubric-' + Date.now(),
                supabaseId: undefined, // Remove supabaseId so it creates new in database
                name: original.name + " (Copy)",
                createdDate: new Date().toISOString(),
                modifiedDate: null
            };
            
            return await saveRubric(duplicate);
        }

        // Delete rubric
        async function deleteRubric(rubricId) {
            // Don't allow deleting the default rubric
            if (rubricId === 'default') {
                alert('Cannot delete the default rubric.');
                return false;
            }
            
            const rubrics = await getAllRubrics();
            const filtered = rubrics.filter(r => r.id !== rubricId);
            localStorage.setItem('speech_rubrics', JSON.stringify(filtered));
            
            // Also delete from Supabase if it has a supabase ID
            if (supabaseClient) {
                const rubricToDelete = rubrics.find(r => r.id === rubricId);
                if (rubricToDelete && rubricToDelete.supabaseId) {
                    await supabaseClient
                        .from('rubrics')
                        .delete()
                        .eq('id', rubricToDelete.supabaseId);
                }
            }
            
            return true;
        }

        // Get rubrics grouped by course
        function getRubricsGroupedByCourse() {
            const rubrics = getAllRubrics();
            const grouped = {
                'unassigned': []
            };
            
            rubrics.forEach(rubric => {
                if (!rubric.courseId) {
                    grouped['unassigned'].push(rubric);
                } else {
                    if (!grouped[rubric.courseId]) {
                        grouped[rubric.courseId] = [];
                    }
                    grouped[rubric.courseId].push(rubric);
                }
            });
            
            return grouped;
        }

        // Populate course selector in rubric form with checkboxes
        function populateCourseSelector(selectedCourseIds = []) {
            const classes = JSON.parse(localStorage.getItem('classes') || '[]');
            const container = document.getElementById('rubricCoursesContainer');
            
            if (!container) return;
            
            // Clear container
            container.innerHTML = '';
            
            if (classes.length === 0) {
                container.innerHTML = '<p style="color: var(--text-light); text-align: center;">No courses available. Create courses in "My Classes" first.</p>';
                return;
            }
            
            // Group courses by course name for better organization
            const courseGroups = {};
            classes.forEach(cls => {
                if (!courseGroups[cls.name]) {
                    courseGroups[cls.name] = [];
                }
                courseGroups[cls.name].push(cls);
            });
            
            // Create checkboxes grouped by course name
            Object.keys(courseGroups).sort().forEach(courseName => {
                const sections = courseGroups[courseName];
                
                // Add course name header if multiple sections exist
                if (sections.length > 1) {
                    const header = document.createElement('div');
                    header.style.cssText = 'font-weight: 600; color: var(--primary); margin-top: 0.5rem; margin-bottom: 0.25rem; font-size: 0.9rem;';
                    header.textContent = courseName;
                    container.appendChild(header);
                }
                
                // Add checkbox for each section
                sections.forEach(cls => {
                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.style.cssText = 'padding: 0.4rem; display: flex; align-items: center;';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `course_${cls.id}`;
                    checkbox.value = cls.id;
                    checkbox.className = 'course-checkbox';
                    checkbox.style.cssText = 'margin-right: 0.5rem; cursor: pointer;';
                    
                    // Check if this course is in the selected list
                    if (selectedCourseIds.includes(cls.id)) {
                        checkbox.checked = true;
                    }
                    
                    const label = document.createElement('label');
                    label.htmlFor = `course_${cls.id}`;
                    label.style.cssText = 'cursor: pointer; user-select: none;';
                    label.textContent = `${cls.name} - ${cls.semester} ${cls.year} (Section ${cls.section})`;
                    
                    checkboxDiv.appendChild(checkbox);
                    checkboxDiv.appendChild(label);
                    container.appendChild(checkboxDiv);
                });
            });
        }

        // Populate course filter dropdown in My Rubrics section
        function populateCourseFilter() {
            const classes = JSON.parse(localStorage.getItem('classes') || '[]');
            const filter = document.getElementById('courseFilter');
            
            if (!filter) return;
            
            // Clear existing options except "All Courses"
            filter.innerHTML = '<option value="">All Courses</option>';
            
            // Add "Unassigned" option
            filter.innerHTML += '<option value="unassigned">Unassigned (No Course)</option>';
            
            // Group classes by course name + semester + year
            const courseGroups = {};
            classes.forEach(cls => {
                const courseKey = `${cls.name}|${cls.semester}|${cls.year}`;
                if (!courseGroups[courseKey]) {
                    courseGroups[courseKey] = {
                        name: cls.name,
                        semester: cls.semester,
                        year: cls.year,
                        ids: []
                    };
                }
                courseGroups[courseKey].ids.push(cls.id);
            });
            
            // Add grouped courses to filter
            Object.keys(courseGroups).sort().forEach(courseKey => {
                const group = courseGroups[courseKey];
                const option = document.createElement('option');
                option.value = group.ids.join(','); // Store all section IDs as comma-separated
                option.textContent = `${group.name} - ${group.semester} ${group.year}`;
                filter.appendChild(option);
            });
        }

        // Filter rubrics display based on selected course
        function filterRubricsByCourse() {
            const filterValue = document.getElementById('courseFilter').value;
            
            // Initialize rubrics storage if needed
            initializeRubrics();
            
            // Get all rubrics and classes
            const allRubrics = getAllRubrics();
            const classes = JSON.parse(localStorage.getItem('classes') || '[]');
            
            // Filter rubrics based on selection
            let filteredRubrics = allRubrics;
            
            if (filterValue === 'unassigned') {
                // Show only rubrics with no courses assigned
                filteredRubrics = allRubrics.filter(r => {
                    const hasOldCourseId = r.courseId && r.courseId !== '';
                    const hasNewCourseIds = r.courseIds && Array.isArray(r.courseIds) && r.courseIds.length > 0;
                    return !hasOldCourseId && !hasNewCourseIds;
                });
            } else if (filterValue !== '') {
                // Filter by course - filterValue contains comma-separated IDs for all sections of a course
                const courseIdsToMatch = filterValue.split(',');
                
                filteredRubrics = allRubrics.filter(rubric => {
                    // Get rubric's course IDs (handle both old and new format)
                    let rubricCourseIds = [];
                    if (rubric.courseIds && Array.isArray(rubric.courseIds)) {
                        rubricCourseIds = rubric.courseIds;
                    } else if (rubric.courseId) {
                        rubricCourseIds = [rubric.courseId];
                    }
                    
                    // Check if rubric is assigned to any of the course sections
                    return rubricCourseIds.some(id => courseIdsToMatch.includes(id));
                });
            }
            
            // Display filtered rubrics
            const list = document.getElementById('rubricsList');
            if (!list) return;
            
            if (filteredRubrics.length === 0) {
                list.innerHTML = '<p style="color: var(--text-light); text-align: center; padding: 2rem;">No rubrics found for this filter.</p>';
                return;
            }
            
            list.innerHTML = filteredRubrics.map(rubric => {
                // Get course info - handle both courseIds array and old courseId
                let courseInfo = '';
                let courseIdsToDisplay = [];
                
                if (rubric.courseIds && Array.isArray(rubric.courseIds) && rubric.courseIds.length > 0) {
                    courseIdsToDisplay = rubric.courseIds;
                } else if (rubric.courseId) {
                    courseIdsToDisplay = [rubric.courseId];
                }
                
                if (courseIdsToDisplay.length > 0) {
                    const courses = courseIdsToDisplay
                        .map(id => classes.find(c => c.id === id))
                        .filter(c => c);
                    
                    if (courses.length > 0) {
                        // Group by course name
                        const courseGroups = {};
                        courses.forEach(course => {
                            if (!courseGroups[course.name]) {
                                courseGroups[course.name] = [];
                            }
                            courseGroups[course.name].push(course);
                        });
                        
                        // Format display
                        const courseDisplays = Object.keys(courseGroups).map(courseName => {
                            const sections = courseGroups[courseName];
                            const firstCourse = sections[0];
                            const sectionNums = sections.map(s => s.section).join(', ');
                            const sectionText = sections.length > 1 ? `Sections ${sectionNums}` : `Section ${sectionNums}`;
                            return `${courseName} (${firstCourse.semester} ${firstCourse.year}) - ${sectionText}`;
                        });
                        
                        courseInfo = ` ‚Ä¢ <span style="color: var(--primary); font-weight: 500;">${courseDisplays.join(' ‚Ä¢ ')}</span>`;
                    } else if (courseIdsToDisplay.length > 0) {
                        courseInfo = ' ‚Ä¢ <span style="color: #999;">Course(s) not found</span>';
                    }
                }
                
                return `
                <div class="rubric-item">
                    <div class="rubric-info">
                        <h4>${rubric.name}</h4>
                        <p>${rubric.description || 'No description'} ‚Ä¢ ${rubric.totalPoints} points${rubric.speechType ? ' ‚Ä¢ ' + rubric.speechType : ''}${courseInfo}</p>
                    </div>
                    <div class="rubric-actions">
                        <button class="btn-small btn-view" data-rubric-id="${rubric.id}">View</button>
                        <button class="btn-small btn-edit" data-rubric-id="${rubric.id}">Edit</button>
                        <button class="btn-small btn-duplicate" data-rubric-id="${rubric.id}">Duplicate</button>
                        ${rubric.id !== 'default' ? `
                            <button class="btn-small btn-danger btn-delete" data-rubric-id="${rubric.id}">Delete</button>
                        ` : ''}
                    </div>
                </div>
            `;
            }).join('');
            
            // Re-attach event listeners to all buttons
            document.querySelectorAll('.btn-view').forEach(btn => {
                btn.addEventListener('click', () => viewRubric(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-edit').forEach(btn => {
                btn.addEventListener('click', () => editRubric(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-duplicate').forEach(btn => {
                btn.addEventListener('click', () => duplicateRubricUI(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-delete').forEach(btn => {
                btn.addEventListener('click', () => deleteRubricUI(btn.dataset.rubricId));
            });
        }


        function displayResults(results) {
            let html = `
                <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 2rem;">
                    <strong>Student:</strong> ${results.studentName}<br>
                    <strong>Date:</strong> ${results.speechDate}<br>
                    <strong>Assignment:</strong> ${results.assignmentType}<br>
                    <strong>Speech Time:</strong> ${results.speechTime}
                </div>
                
                <div class="score-banner">
                    <h2 style="color: white;">Final Score</h2>
                    <div class="score-value">${results.totalScore} / ${results.maxScore}</div>
                    <div class="score-percentage">${((results.totalScore / results.maxScore) * 100).toFixed(1)}%</div>
                </div>
                
                <h3 style="margin-bottom: 1rem;">Detailed Scores by Category</h3>
                <div style="display: grid; gap: 1rem; margin-bottom: 2rem;">
            `;
            
            for (const [section, data] of Object.entries(results.sections)) {
                html += `
                    <div style="background: var(--bg-alt); padding: 1rem; border-radius: 0.5rem; border-left: 4px solid var(--primary);">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                            <strong style="text-transform: capitalize;">${section}</strong>
                            <strong style="color: var(--primary);">${data.score} / ${data.maxScore}</strong>
                        </div>
                        <p style="color: var(--text-light); font-size: 0.9rem; margin-bottom: 0.75rem;">${data.feedback}</p>
                `;
                
                // Show subcategory breakdown if available
                if (data.subcategories && data.subcategories.length > 0) {
                    html += `<div style="background: white; padding: 0.75rem; border-radius: 0.25rem; margin-top: 0.75rem;">
                        <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text);">Subcategory Breakdown:</div>
                    `;
                    
                    data.subcategories.forEach(sub => {
                        const gradeColor = sub.grade === 'A' ? '#28a745' : 
                                          sub.grade === 'B' ? '#5cb85c' :
                                          sub.grade === 'C' ? '#f0ad4e' :
                                          sub.grade === 'D' ? '#d9534f' : '#c9302c';
                        
                        html += `
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.4rem 0; border-bottom: 1px solid var(--border);">
                                <span style="font-size: 0.85rem; color: var(--text);">${sub.name}</span>
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <span style="background: ${gradeColor}; color: white; padding: 0.15rem 0.4rem; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600;">${sub.grade}</span>
                                    <span style="font-size: 0.85rem; color: var(--text-light);">${sub.points} / ${sub.maxPoints} pts</span>
                                </div>
                            </div>
                        `;
                    });
                    
                    html += `</div>`;
                }
                
                html += `</div>`;
            }
            
            html += `
                </div>
                
                <div style="background: #fffef7; border: 2px solid var(--accent); padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 1rem;">
                    <h3 style="color: var(--primary); margin-bottom: 1rem;">Overall Comments</h3>
                    <p>${results.overallComments}</p>
                </div>
            `;
            
            // Add transcript section if available
            if (results.transcript && results.transcript.trim().length > 0) {
                html += `
                    <details style="background: var(--bg-alt); padding: 1rem; border-radius: 0.5rem; margin-top: 1rem;">
                        <summary style="cursor: pointer; font-weight: 600; color: var(--primary); padding: 0.5rem;">
                            üìù View Speech Transcript
                        </summary>
                        <div style="margin-top: 1rem; padding: 1rem; background: white; border-radius: 0.25rem; max-height: 300px; overflow-y: auto; font-family: monospace; font-size: 0.9rem; line-height: 1.6;">
                            ${results.transcript.replace(/\n/g, '<br>')}
                        </div>
                    </details>
                `;
            }
            
            document.getElementById('resultsContent').innerHTML = html;
        }

        function downloadPDF() {
            if (!evaluationResults) {
                alert('No evaluation results to download.');
                return;
            }
            
            // Create a simple text version for now
            let text = `SPEECH EVALUATION REPORT\n\n`;
            text += `Student: ${evaluationResults.studentName}\n`;
            text += `Date: ${evaluationResults.speechDate}\n`;
            text += `Assignment: ${evaluationResults.assignmentType}\n`;
            text += `Speech Time: ${evaluationResults.speechTime}\n`;
            if (evaluationResults.rubricUsed) {
                text += `Rubric Used: ${evaluationResults.rubricUsed}\n`;
            }
            text += `\nFINAL SCORE: ${evaluationResults.totalScore} / ${evaluationResults.maxScore} (${((evaluationResults.totalScore / evaluationResults.maxScore) * 100).toFixed(1)}%)\n\n`;
            text += `SECTION SCORES:\n`;
            
            for (const [section, data] of Object.entries(evaluationResults.sections)) {
                text += `\n${section.toUpperCase()}: ${data.score} / ${data.maxScore}\n`;
                text += `${data.feedback}\n`;
                
                // Add subcategory details
                if (data.subcategories && data.subcategories.length > 0) {
                    text += `  Subcategories:\n`;
                    data.subcategories.forEach(sub => {
                        text += `    - ${sub.name}: ${sub.grade} (${sub.points}/${sub.maxPoints} pts)\n`;
                    });
                }
            }
            
            text += `\nOVERALL COMMENTS:\n${evaluationResults.overallComments}\n`;
            
            // Add transcript if available
            if (evaluationResults.transcript && evaluationResults.transcript.trim().length > 0) {
                text += `\n${'='.repeat(80)}\n`;
                text += `SPEECH TRANSCRIPT:\n`;
                text += `${'='.repeat(80)}\n\n`;
                text += evaluationResults.transcript;
                text += `\n\n${'='.repeat(80)}\n`;
            }
            
            // Copy to clipboard
            navigator.clipboard.writeText(text).then(() => {
                alert('‚úì Evaluation copied to clipboard!\n\nYou can paste it into a document to save as PDF.');
            }).catch(() => {
                alert('Could not copy to clipboard. PDF generation requires additional library integration.');
            });
        }

        function emailResults() {
            const studentEmail = document.getElementById('studentEmail').value;
            if (!studentEmail) {
                alert('Please enter student email in Step 2 (Details) first.');
                return;
            }
            
            if (!evaluationResults) {
                alert('No evaluation results to email.');
                return;
            }
            
            const subject = `Speech Evaluation Results - ${evaluationResults.assignmentType}`;
            const body = `Dear ${evaluationResults.studentName},\n\nYour speech evaluation results are ready.\n\nFinal Score: ${evaluationResults.totalScore} / ${evaluationResults.maxScore}\n\nPlease contact your instructor for the complete evaluation details.\n\nBest regards`;
            
            const mailtoLink = `mailto:${studentEmail}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
            window.open(mailtoLink);
        }

        function startOver() {
            uploadedFile = null;
            evaluationResults = null;
            document.getElementById('studentForm').reset();
            document.getElementById('fileInfo').classList.add('hidden');
            document.getElementById('fileInput').value = '';
            moveToStep(1);
        }

        // ===== CLASSES MANAGEMENT =====
        async function loadClasses() {
            // Try Supabase first
            const supabaseCourses = await loadCoursesFromSupabase();
            
            let classes = [];
            
            if (supabaseCourses && supabaseCourses.length > 0) {
                // Convert Supabase format to app format
                classes = supabaseCourses.map(course => ({
                    id: course.id,
                    supabaseId: course.id,
                    name: course.name,
                    semester: course.semester || 'Fall',
                    section: course.code || '001',
                    year: course.year?.toString() || '2024',
                    notes: '',
                    roster: (course.course_students || []).map(student => ({
                        supabaseId: student.id,
                        firstName: student.first_name,
                        lastName: student.last_name,
                        name: `${student.first_name} ${student.last_name}`,
                        email: student.email || '',
                        studentId: student.student_id || '',
                        evaluations: []
                    })),
                    evaluations: []
                }));
                
                // Store in localStorage so viewClass can find them
                localStorage.setItem('classes', JSON.stringify(classes));
                console.log('‚úì Synced Supabase classes to localStorage');
            } else {
                // Fallback to localStorage
                classes = JSON.parse(localStorage.getItem('classes') || '[]');
            }
            
            // Initialize with demo classes if empty
            if (classes.length === 0) {
                const demoClasses = [
                    {
                        id: '1',
                        name: 'CMST 210',
                        semester: 'Fall',
                        section: '001',
                        year: '2024',
                        notes: 'Intro to Public Speaking',
                        roster: [],
                        evaluations: []
                    },
                    {
                        id: '2',
                        name: 'CMST 210',
                        semester: 'Fall',
                        section: '002',
                        year: '2024',
                        notes: 'Intro to Public Speaking',
                        roster: [],
                        evaluations: []
                    },
                    {
                        id: '3',
                        name: 'CMST 240',
                        semester: 'Spring',
                        section: '001',
                        year: '2025',
                        notes: 'Argumentation and Debate',
                        roster: [],
                        evaluations: []
                    }
                ];
                localStorage.setItem('classes', JSON.stringify(demoClasses));
                return loadClasses();
            }
            
            const grid = document.getElementById('classesGrid');
            grid.innerHTML = classes.map(cls => {
                let evalCount = 0;
                if (cls.roster) {
                    cls.roster.forEach(student => {
                        if (student.evaluations) {
                            evalCount += student.evaluations.length;
                        }
                    });
                }
                
                return `
                <div class="class-card" data-class-id="${cls.id}">
                    <div class="class-header">${cls.name}</div>
                    <div class="class-meta">
                        ${cls.semester} ${cls.year} ‚Ä¢ Section ${cls.section}
                    </div>
                    <p style="color: var(--text-light); font-size: 0.9rem; margin-bottom: 1rem;">
                        ${cls.notes || 'No description'}
                    </p>
                    <div class="class-stats">
                        <div class="stat">
                            <div class="stat-value">${(cls.roster || []).length}</div>
                            <div class="stat-label">Students</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value">${evalCount}</div>
                            <div class="stat-label">Evaluations</div>
                        </div>
                    </div>
                </div>
                `;
            }).join('');
            
            // Add click handlers
            document.querySelectorAll('.class-card').forEach(card => {
                card.addEventListener('click', async function() {
                    const classId = this.getAttribute('data-class-id');
                    await viewClass(classId);
                });
            });
        }

        function showCreateClass() {
            document.getElementById('createClassCard').classList.remove('hidden');
        }

        function cancelCreateClass() {
            document.getElementById('createClassCard').classList.add('hidden');
            document.getElementById('createClassForm').reset();
        }

        function toggleEvalType(typeId) {
            const content = document.getElementById(typeId);
            const arrow = document.getElementById(typeId + '-arrow');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.style.transform = 'rotate(90deg)';
            } else {
                content.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
            }
        }

        async function viewClass(classId) {
            currentClassId = classId; // Store for later use
            
            // Load classes fresh from Supabase/localStorage
            await loadClasses();
            const classes = JSON.parse(localStorage.getItem('classes') || '[]');
            const selectedClass = classes.find(c => c.id === classId);
            
            if (!selectedClass) {
                alert('Class not found');
                console.error('Class ID not found:', classId, 'Available IDs:', classes.map(c => c.id));
                return;
            }
            
            const roster = selectedClass.roster || [];
            
            // Gather all evaluations from students
            const evals = [];
            roster.forEach(student => {
                if (student.evaluations) {
                    student.evaluations.forEach(ev => {
                        evals.push({
                            studentName: student.firstName + ' ' + student.lastName,
                            studentId: student.id,
                            date: ev.date,
                            type: ev.type,
                            totalScore: ev.results.totalScore,
                            maxScore: ev.results.maxScore,
                            results: ev.results
                        });
                    });
                }
            });
            
            // Update title
            document.getElementById('classDetailTitle').textContent = 
                `${selectedClass.name} - ${selectedClass.semester} ${selectedClass.year}`;
            
            // Build content
            let html = `
                <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 2rem;">
                    <strong>Section:</strong> ${selectedClass.section}<br>
                    <strong>Notes:</strong> ${selectedClass.notes || 'None'}<br>
                    <strong>Students:</strong> ${roster.length}<br>
                    <strong>Evaluations:</strong> ${evals.length}
                </div>
            `;
            
            // Students section with Add button
            html += `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 2rem; margin-bottom: 1rem;">
                    <h3 style="margin: 0;">üë• Students</h3>
                    <button onclick="showAddStudent()">‚ûï Add Student</button>
                </div>
            `;
            
            if (roster.length === 0) {
                html += '<p style="color: var(--text-light);">No students yet. Click "Add Student" to get started.</p>';
            } else {
                html += '<ul style="list-style: none; padding: 0;">';
                roster.forEach(student => {
                    const evalCount = (student.evaluations || []).length;
                    let evalText = '';
                    if (evalCount > 0) {
                        evalText = ` ‚Ä¢ ${evalCount} evaluation${evalCount > 1 ? 's' : ''}`;
                    }
                    
                    html += `<li style="background: var(--bg-alt); padding: 1rem; margin-bottom: 0.5rem; border-radius: 0.5rem; display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong>${student.firstName} ${student.lastName}</strong><br>
                            <span style="color: var(--text-light); font-size: 0.9rem;">${student.email}${evalText}</span>
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            ${evalCount > 0 ? `<button onclick="viewStudentEvals('${student.id}')" class="btn-small">View Evals</button>` : ''}
                            <button onclick="deleteStudent('${student.id}')" class="btn-small btn-danger">Delete</button>
                        </div>
                    </li>`;
                });
                html += '</ul>';
            }
            
            // Evaluations section - grouped by speech type
            html += '<h3 style="margin-top: 2rem;">üìä Recent Evaluations</h3>';
            if (evals.length === 0) {
                html += '<p style="color: var(--text-light);">No evaluations yet. Evaluations will appear here when speeches are graded.</p>';
            } else {
                // Group evaluations by type
                const evalsByType = {};
                evals.forEach(e => {
                    const type = e.type || 'Unknown';
                    if (!evalsByType[type]) {
                        evalsByType[type] = [];
                    }
                    evalsByType[type].push(e);
                });
                
                // Display each type with its average (collapsible)
                Object.keys(evalsByType).forEach((type, index) => {
                    const typeEvals = evalsByType[type];
                    const avgScore = (typeEvals.reduce((sum, e) => sum + e.totalScore, 0) / typeEvals.length).toFixed(1);
                    const avgPercent = ((avgScore / 50) * 100).toFixed(0);
                    const typeId = 'evalType' + index;
                    
                    html += `
                        <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 1rem;">
                            <div onclick="toggleEvalType('${typeId}')" style="display: flex; justify-content: space-between; align-items: center; cursor: pointer; user-select: none;">
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <span id="${typeId}-arrow" style="font-size: 1.2rem; transition: transform 0.2s;">‚ñ∂</span>
                                    <h4 style="margin: 0; color: var(--primary); font-family: var(--body-font); font-weight: 600;">${type}</h4>
                                </div>
                                <div style="text-align: right;">
                                    <div style="font-size: 1.5rem; font-weight: bold; color: var(--primary);">${avgScore} / 50</div>
                                    <div style="color: var(--text-light);">Average (${avgPercent}%)</div>
                                </div>
                            </div>
                            <div id="${typeId}" style="display: none; margin-top: 1rem; padding-top: 1rem; border-top: 2px solid var(--border);">
                                <div style="display: grid; gap: 0.75rem;">
                    `;
                    
                    typeEvals.forEach(e => {
                        const percentage = ((e.totalScore / e.maxScore) * 100).toFixed(0);
                        let color = 'var(--success)';
                        if (percentage < 70) color = 'var(--error)';
                        else if (percentage < 80) color = 'var(--warning)';
                        
                        html += `
                            <div style="background: white; padding: 0.75rem; border-radius: 0.5rem; border-left: 3px solid ${color};">
                                <div style="display: flex; justify-content: space-between;">
                                    <strong>${e.studentName}</strong>
                                    <strong style="color: var(--primary);">${e.totalScore}/${e.maxScore} (${percentage}%)</strong>
                                </div>
                                <div style="font-size: 0.85rem; color: var(--text-light); margin-top: 0.25rem;">
                                    ${e.date}
                                </div>
                            </div>
                        `;
                    });
                    
                    html += `
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                // Overall class average
                const overallAvg = (evals.reduce((sum, e) => sum + e.totalScore, 0) / evals.length).toFixed(1);
                const overallPercent = ((overallAvg / 50) * 100).toFixed(0);
                html += `
                    <div style="background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%); color: white; padding: 1.5rem; border-radius: 0.5rem; margin-top: 1rem; display: flex; justify-content: space-between; align-items: center;">
                        <div style="margin: 0; color: white; font-size: 1rem; font-family: var(--body-font); font-weight: 600;">Overall Class Average</div>
                        <div style="text-align: right;">
                            <div style="font-size: 1.5rem; font-weight: bold;">${overallAvg} / 50</div>
                            <div style="font-size: 0.9rem; opacity: 0.9;">${overallPercent}%</div>
                        </div>
                    </div>
                `;
            }
            
            // Show content
            document.getElementById('classDetailContent').innerHTML = html;
            
            // Switch to class detail view
            setActiveSection('classDetailSection', 'navDashboard');
        }

        // ===== RUBRICS MANAGEMENT =====
        async function loadRubrics() {
            // Initialize rubrics storage if needed
            initializeRubrics();
            
            // Populate course filter dropdown
            populateCourseFilter();
            
            // Get all rubrics from storage (now async)
            const allRubrics = await getAllRubrics();
            
            // Get all classes for course name lookup
            const classes = JSON.parse(localStorage.getItem('classes') || '[]');
            
            const list = document.getElementById('rubricsList');
            if (!list) return; // Exit if element doesn't exist yet
            
            list.innerHTML = allRubrics.map(rubric => {
                // Get course info - handle both new courseIds array and old single courseId
                let courseInfo = '';
                let courseIdsToDisplay = [];
                
                if (rubric.courseIds && Array.isArray(rubric.courseIds) && rubric.courseIds.length > 0) {
                    courseIdsToDisplay = rubric.courseIds;
                } else if (rubric.courseId) {
                    // Backward compatibility with single courseId
                    courseIdsToDisplay = [rubric.courseId];
                }
                
                if (courseIdsToDisplay.length > 0) {
                    const courses = courseIdsToDisplay
                        .map(id => classes.find(c => c.id === id))
                        .filter(c => c); // Remove undefined (deleted courses)
                    
                    if (courses.length > 0) {
                        // Group by course name
                        const courseGroups = {};
                        courses.forEach(course => {
                            if (!courseGroups[course.name]) {
                                courseGroups[course.name] = [];
                            }
                            courseGroups[course.name].push(course);
                        });
                        
                        // Format display: "CMST 210 (Fall 2024) - Sections 001, 002"
                        const courseDisplays = Object.keys(courseGroups).map(courseName => {
                            const sections = courseGroups[courseName];
                            const firstCourse = sections[0];
                            const sectionNums = sections.map(s => s.section).join(', ');
                            const sectionText = sections.length > 1 ? `Sections ${sectionNums}` : `Section ${sectionNums}`;
                            return `${courseName} (${firstCourse.semester} ${firstCourse.year}) - ${sectionText}`;
                        });
                        
                        courseInfo = ` ‚Ä¢ <span style="color: var(--primary); font-weight: 500;">${courseDisplays.join(' ‚Ä¢ ')}</span>`;
                    } else if (courseIdsToDisplay.length > 0) {
                        courseInfo = ' ‚Ä¢ <span style="color: #999;">Course(s) not found</span>';
                    }
                }
                
                return `
                <div class="rubric-item">
                    <div class="rubric-info">
                        <h4>${rubric.name}</h4>
                        <p>${rubric.description || 'No description'} ‚Ä¢ ${rubric.totalPoints} points${rubric.speechType ? ' ‚Ä¢ ' + rubric.speechType : ''}${courseInfo}</p>
                    </div>
                    <div class="rubric-actions">
                        <button class="btn-small btn-view" data-rubric-id="${rubric.id}">View</button>
                        <button class="btn-small btn-edit" data-rubric-id="${rubric.id}">Edit</button>
                        <button class="btn-small btn-duplicate" data-rubric-id="${rubric.id}">Duplicate</button>
                        ${rubric.id !== 'default' ? `
                            <button class="btn-small btn-danger btn-delete" data-rubric-id="${rubric.id}">Delete</button>
                        ` : ''}
                    </div>
                </div>
            `;
            }).join('');
            
            // Add event listeners to all buttons
            document.querySelectorAll('.btn-view').forEach(btn => {
                btn.addEventListener('click', () => viewRubric(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-edit').forEach(btn => {
                btn.addEventListener('click', () => editRubric(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-duplicate').forEach(btn => {
                btn.addEventListener('click', () => duplicateRubricUI(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-delete').forEach(btn => {
                btn.addEventListener('click', () => {
                    console.log('Delete button clicked via event listener!');
                    deleteRubricUI(btn.dataset.rubricId);
                });
            });
        }

        function viewRubric(rubricId) {
            const rubric = getRubricById(rubricId);
            if (!rubric) return;
            
            const metrics = calculateRubricMetrics(rubric);
            const maxPointsPerSub = metrics.pointsPerSubcategory;
            
            // Get course info - handle both courseIds array and old courseId
            let courseInfo = '';
            let courseIdsToDisplay = [];
            
            if (rubric.courseIds && Array.isArray(rubric.courseIds) && rubric.courseIds.length > 0) {
                courseIdsToDisplay = rubric.courseIds;
            } else if (rubric.courseId) {
                courseIdsToDisplay = [rubric.courseId];
            }
            
            if (courseIdsToDisplay.length > 0) {
                const classes = JSON.parse(localStorage.getItem('classes') || '[]');
                const courses = courseIdsToDisplay
                    .map(id => classes.find(c => c.id === id))
                    .filter(c => c);
                
                if (courses.length > 0) {
                    const courseDisplays = courses.map(course => 
                        `${course.name} - ${course.semester} ${course.year} (Section ${course.section})`
                    ).join('<br>');
                    courseInfo = `<strong>Course${courses.length > 1 ? 's' : ''}:</strong> ${courseDisplays}<br>`;
                }
            }
            
            let html = `
                <div style="background: white; padding: 2rem; border-radius: 0.5rem; max-width: 800px; margin: 2rem auto;">
                    <h2>${rubric.name}</h2>
                    <p style="color: var(--text-light); margin-bottom: 1rem;">${rubric.description || ''}</p>
                    <div style="background: var(--bg-alt); padding: 1rem; border-radius: 0.5rem; margin-bottom: 1.5rem;">
                        ${courseInfo}
                        <strong>Total Points:</strong> ${rubric.totalPoints}<br>
                        <strong>Total Subcategories:</strong> ${metrics.totalSubcategories}<br>
                        <strong>Maximum Points per Subcategory:</strong> ${maxPointsPerSub.toFixed(2)} (when graded as A)
                    </div>
                    <h3>Grade Scale & Points per Subcategory</h3>
                    <p style="color: var(--text-light); font-size: 0.9rem; margin-bottom: 0.5rem;">Each subcategory can earn different points based on the grade received:</p>
                    <div style="margin-bottom: 1.5rem;">
            `;
            
            for (const [grade, info] of Object.entries(rubric.gradeScale)) {
                const points = (maxPointsPerSub * info.percentage).toFixed(2);
                html += `<div style="padding: 0.5rem; border-left: 3px solid var(--primary); margin-bottom: 0.5rem; background: var(--bg-alt);">
                    <strong>${grade} - ${info.label}:</strong> ${info.percentage * 100}% ‚Üí <strong>${points} points</strong> per subcategory (Range: ${info.range})
                </div>`;
            }
            
            html += `</div><h3>Categories & Subcategories</h3>`;
            
            rubric.categories.forEach((cat, idx) => {
                const catMetrics = metrics.categoryPoints[idx];
                html += `
                    <div style="margin-bottom: 1.5rem; padding: 1rem; border: 1px solid var(--border); border-radius: 0.5rem;">
                        <h4>${cat.name} <span style="color: var(--primary);">(Max: ${catMetrics.maxPoints.toFixed(1)} points)</span></h4>
                        <p style="color: var(--text-light); font-size: 0.9rem;">${catMetrics.subcategoryCount} subcategories √ó ${maxPointsPerSub.toFixed(2)} points each (if all A's)</p>
                        <ul style="margin-top: 0.5rem;">
                            ${cat.subcategories.map(sub => `<li>${sub}</li>`).join('')}
                        </ul>
                    </div>
                `;
            });
            
            html += `<button onclick="closeModal()">Close</button></div>`;
            
            showModal(html);
        }

        function editRubric(rubricId) {
            const rubric = getRubricById(rubricId);
            if (!rubric) {
                alert('Rubric not found');
                return;
            }
            loadRubricIntoForm(rubric);
        }

        async function duplicateRubricUI(rubricId) {
            console.log('Duplicating rubric:', rubricId);
            const newRubric = await duplicateRubric(rubricId);
            if (newRubric) {
                await loadRubrics();
                alert(`‚úì Rubric duplicated: ${newRubric.name}`);
            }
        }

        async function deleteRubricUI(rubricId) {
            console.log('Delete button clicked for:', rubricId);
            const rubric = await getRubricById(rubricId);
            if (!rubric) {
                console.error('Rubric not found:', rubricId);
                return;
            }
            
            console.log('Found rubric:', rubric.name);
            
            // Use custom confirmation modal instead of native confirm
            showConfirmModal(
                'Delete Rubric',
                `Are you sure you want to delete "${rubric.name}"? This action cannot be undone.`,
                async () => {
                    // User clicked Yes/Confirm
                    console.log('User confirmed deletion via custom modal');
                    const deleteResult = await deleteRubric(rubricId);
                    console.log('deleteRubric returned:', deleteResult);
                    
                    if (deleteResult) {
                        console.log('Rubric deleted successfully');
                        await loadRubrics();
                        alert('‚úì Rubric deleted successfully');
                    } else {
                        console.error('Delete function returned false');
                    }
                },
                () => {
                    // User clicked No/Cancel
                    console.log('User cancelled deletion via custom modal');
                }
            );
        }

        // Make functions globally accessible
        window.deleteRubricUI = deleteRubricUI;
        window.duplicateRubricUI = duplicateRubricUI;
        window.viewRubric = viewRubric;
        window.editRubric = editRubric;
        window.showCreateRubric = showCreateRubric;
        window.cancelCreateRubric = cancelCreateRubric;
        window.addCategory = addCategory;
        window.removeCategory = removeCategory;
        window.addSubcategory = addSubcategory;
        window.removeSubcategory = removeSubcategory;

        // Test function to verify everything is working
        function testDeleteFunction() {
            console.log('=== TEST FUNCTION CALLED ===');
            console.log('deleteRubricUI exists?', typeof window.deleteRubricUI);
            console.log('deleteRubric exists?', typeof deleteRubric);
            console.log('getRubricById exists?', typeof getRubricById);
            
            const allRubrics = getAllRubrics();
            console.log('All rubrics:', allRubrics);
            
            if (allRubrics.length > 0) {
                const testId = allRubrics[allRubrics.length - 1].id;
                console.log('Attempting to call deleteRubricUI with ID:', testId);
                try {
                    deleteRubricUI(testId);
                } catch (e) {
                    console.error('Error calling deleteRubricUI:', e);
                }
            }
        }
        window.testDeleteFunction = testDeleteFunction;

        function showModal(content) {
            const modal = document.getElementById('saveModal');
            if (!modal) return;
            
            modal.innerHTML = `
                <div onclick="closeModal()" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 9999; display: flex; align-items: center; justify-content: center;">
                    <div onclick="event.stopPropagation()" style="background: white; border-radius: 0.5rem; max-height: 90vh; overflow-y: auto; max-width: 90vw;">
                        ${content}
                    </div>
                </div>
            `;
            modal.style.display = 'flex';
        }

        function closeModal() {
            const modal = document.getElementById('saveModal');
            if (modal) {
                modal.style.display = 'none';
                modal.innerHTML = '';
            }
        }

        function showConfirmModal(title, message, onConfirm, onCancel) {
            const modal = document.getElementById('saveModal');
            if (!modal) {
                console.error('Modal element not found');
                return;
            }
            
            modal.innerHTML = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 9999; display: flex; align-items: center; justify-content: center;">
                    <div onclick="event.stopPropagation()" style="background: white; border-radius: 0.5rem; padding: 2rem; max-width: 500px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                        <h3 style="margin-bottom: 1rem; color: var(--primary);">${title}</h3>
                        <p style="margin-bottom: 2rem; color: var(--text);">${message}</p>
                        <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                            <button id="confirmCancel" class="btn-secondary" style="padding: 0.5rem 1.5rem;">Cancel</button>
                            <button id="confirmYes" class="btn-danger" style="padding: 0.5rem 1.5rem;">Delete</button>
                        </div>
                    </div>
                </div>
            `;
            modal.style.display = 'flex';
            
            // Add event listeners
            document.getElementById('confirmYes').addEventListener('click', () => {
                closeModal();
                if (onConfirm) onConfirm();
            });
            
            document.getElementById('confirmCancel').addEventListener('click', () => {
                closeModal();
                if (onCancel) onCancel();
            });
        }

        // Make modal functions globally accessible
        window.showModal = showModal;
        window.closeModal = closeModal;
        window.showConfirmModal = showConfirmModal;

        function showCreateRubric() {
            document.getElementById('rubricFormHeader').textContent = 'Create Custom Rubric';
            document.getElementById('rubricSubmitBtn').textContent = 'Create Rubric';
            document.getElementById('editingRubricId').value = '';
            document.getElementById('createRubricForm').reset();
            
            // Populate course selector
            populateCourseSelector();
            
            // Initialize with one empty category
            document.getElementById('categoriesContainer').innerHTML = '';
            addCategory();
            
            document.getElementById('createRubricCard').classList.remove('hidden');
            document.getElementById('createRubricCard').scrollIntoView({ behavior: 'smooth' });
        }

        function cancelCreateRubric() {
            document.getElementById('createRubricCard').classList.add('hidden');
            document.getElementById('createRubricForm').reset();
            document.getElementById('categoriesContainer').innerHTML = '';
        }

        // ===== UPLOAD RUBRIC FUNCTIONS =====
        
        function showUploadRubric() {
            document.getElementById('uploadRubricForm').reset();
            document.getElementById('uploadProgress').classList.add('hidden');
            document.getElementById('uploadRubricCard').classList.remove('hidden');
            document.getElementById('uploadRubricCard').scrollIntoView({ behavior: 'smooth' });
            
            // Load saved API keys
            const savedGeminiKey = localStorage.getItem('gemini_api_key');
            const savedOpenAIKey = localStorage.getItem('openai_api_key');
            const savedClaudeKey = localStorage.getItem('anthropic_api_key');
            
            // Pre-fill API key if one is saved
            if (savedGeminiKey) {
                document.getElementById('uploadAiProvider').value = 'gemini';
                document.getElementById('uploadApiKey').value = savedGeminiKey;
            } else if (savedOpenAIKey) {
                document.getElementById('uploadAiProvider').value = 'gpt4o';
                document.getElementById('uploadApiKey').value = savedOpenAIKey;
            } else if (savedClaudeKey) {
                document.getElementById('uploadAiProvider').value = 'claude';
                document.getElementById('uploadApiKey').value = savedClaudeKey;
            }
        }
        
        function cancelUploadRubric() {
            document.getElementById('uploadRubricCard').classList.add('hidden');
            document.getElementById('uploadRubricForm').reset();
        }
        
        // Handle upload rubric form submission
        document.getElementById('uploadRubricForm')?.addEventListener('submit', async function(e) {
            e.preventDefault();
            await processUploadedRubric();
        });
        
        async function processUploadedRubric() {
            const fileInput = document.getElementById('uploadRubricFile');
            const rubricName = document.getElementById('uploadRubricName').value;
            const aiProvider = document.getElementById('uploadAiProvider').value;
            const apiKey = document.getElementById('uploadApiKey').value;
            
            if (!fileInput.files || !fileInput.files[0]) {
                alert('Please select a file to upload');
                return;
            }
            
            const file = fileInput.files[0];
            const maxSize = 10 * 1024 * 1024; // 10MB
            
            if (file.size > maxSize) {
                alert('File size exceeds 10MB limit. Please use a smaller file.');
                return;
            }
            
            // Show progress
            const progressDiv = document.getElementById('uploadProgress');
            const progressText = document.getElementById('uploadProgressText');
            const progressBar = document.getElementById('uploadProgressBar');
            progressDiv.classList.remove('hidden');
            progressText.textContent = 'Reading file...';
            progressBar.style.width = '20%';
            
            try {
                // Convert file to base64
                const base64Data = await fileToBase64(file);
                progressText.textContent = 'Analyzing rubric structure...';
                progressBar.style.width = '40%';
                
                // Extract rubric using AI
                const extractedRubric = await extractRubricWithAI(base64Data, file.type, aiProvider, apiKey);
                progressText.textContent = 'Creating rubric...';
                progressBar.style.width = '80%';
                
                if (!extractedRubric) {
                    throw new Error('Failed to extract rubric from file');
                }
                
                // Create the rubric object
                const rubric = {
                    name: rubricName,
                    speechType: extractedRubric.speechType || 'General',
                    totalPoints: extractedRubric.totalPoints || 100,
                    gradeScale: extractedRubric.gradeScale || {
                        A: { min: 90, label: 'Excellent' },
                        B: { min: 80, label: 'Good' },
                        C: { min: 70, label: 'Satisfactory' },
                        D: { min: 60, label: 'Needs Improvement' },
                        F: { min: 0, label: 'Unsatisfactory' }
                    },
                    categories: extractedRubric.categories,
                    isTemplate: false,
                    extractedFrom: file.name
                };
                
                // Save the rubric
                await saveRubric(rubric);
                
                progressText.textContent = '‚úÖ Rubric created successfully!';
                progressBar.style.width = '100%';
                
                // Reload rubrics display
                await loadRubrics();
                
                // Close form after brief delay
                setTimeout(() => {
                    cancelUploadRubric();
                    alert(`Rubric "${rubricName}" has been created successfully from ${file.name}!`);
                }, 1500);
                
            } catch (error) {
                console.error('Error processing rubric:', error);
                progressDiv.classList.add('hidden');
                alert('Failed to process rubric: ' + error.message + '\n\nPlease check:\n- Your API key is correct\n- The file contains a clear rubric structure\n- Your internet connection is working');
            }
        }
        
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    const base64 = reader.result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        async function extractRubricWithAI(base64Data, mimeType, provider, apiKey) {
            console.log('Extracting rubric with', provider);
            
            const prompt = `You are analyzing a rubric document. Extract ALL the information and return ONLY a valid JSON object (no markdown, no explanation, no preamble).

The JSON must have this exact structure:
{
  "speechType": "type of speech if mentioned, or 'General'",
  "totalPoints": total possible points as a number,
  "categories": [
    {
      "name": "Category Name",
      "subcategories": [
        {
          "name": "Subcategory Name",
          "points": point value as number,
          "description": "criteria description"
        }
      ]
    }
  ],
  "gradeScale": {
    "A": {"min": 90, "label": "Excellent"},
    "B": {"min": 80, "label": "Good"},
    "C": {"min": 70, "label": "Satisfactory"},
    "D": {"min": 60, "label": "Needs Improvement"},
    "F": {"min": 0, "label": "Unsatisfactory"}
  }
}

Extract every category, subcategory, point value, and grading criterion you can find. If the grading scale is specified in the rubric, use those values instead of the defaults shown above.

Return ONLY the JSON object, nothing else.`;

            if (provider === 'gemini') {
                return await extractWithGemini(base64Data, mimeType, prompt, apiKey);
            } else if (provider === 'gpt4o') {
                return await extractWithOpenAI(base64Data, mimeType, prompt, apiKey);
            } else if (provider === 'claude') {
                return await extractWithClaude(base64Data, mimeType, prompt, apiKey);
            }
        }
        
        async function extractWithGemini(base64Data, mimeType, prompt, apiKey) {
            // Use gemini-1.5-flash which supports both text and images
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{
                        parts: [
                            { text: prompt },
                            {
                                inline_data: {
                                    mime_type: mimeType,
                                    data: base64Data
                                }
                            }
                        ]
                    }],
                    generationConfig: {
                        temperature: 0.4,
                        topK: 32,
                        topP: 1,
                        maxOutputTokens: 2048
                    }
                })
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                console.error('Gemini API error:', errorData);
                
                // Provide helpful error message
                if (response.status === 404) {
                    throw new Error(`API key may be invalid. Please:\n1. Get a new key from https://aistudio.google.com/app/apikey\n2. Make sure it's enabled for Gemini API\n3. Try again with the new key`);
                } else if (response.status === 400) {
                    throw new Error(`Bad request: ${errorData.error?.message || 'Check your file format'}`);
                } else {
                    throw new Error(`Gemini API error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
                }
            }
            
            const data = await response.json();
            
            if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
                throw new Error('Unexpected response format from Gemini API');
            }
            
            const text = data.candidates[0].content.parts[0].text;
            
            // Clean up the response to extract JSON
            const jsonMatch = text.match(/\{[\s\S]*\}/);
            if (!jsonMatch) {
                console.error('AI Response:', text);
                throw new Error('No valid JSON found in AI response. The AI may not have recognized a rubric structure in the image.');
            }
            
            return JSON.parse(jsonMatch[0]);
        }
        
        async function extractWithOpenAI(base64Data, mimeType, prompt, apiKey) {
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: 'gpt-4o',
                    messages: [{
                        role: 'user',
                        content: [
                            { type: 'text', text: prompt },
                            {
                                type: 'image_url',
                                image_url: {
                                    url: `data:${mimeType};base64,${base64Data}`
                                }
                            }
                        ]
                    }],
                    max_tokens: 2000
                })
            });
            
            if (!response.ok) {
                throw new Error(`OpenAI API error: ${response.status}`);
            }
            
            const data = await response.json();
            const text = data.choices[0].message.content;
            
            const jsonMatch = text.match(/\{[\s\S]*\}/);
            if (!jsonMatch) {
                throw new Error('No valid JSON found in AI response');
            }
            
            return JSON.parse(jsonMatch[0]);
        }
        
        async function extractWithClaude(base64Data, mimeType, prompt, apiKey) {
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                    model: 'claude-3-5-sonnet-20241022',
                    max_tokens: 2000,
                    messages: [{
                        role: 'user',
                        content: [
                            { type: 'text', text: prompt },
                            {
                                type: 'image',
                                source: {
                                    type: 'base64',
                                    media_type: mimeType,
                                    data: base64Data
                                }
                            }
                        ]
                    }]
                })
            });
            
            if (!response.ok) {
                throw new Error(`Claude API error: ${response.status}`);
            }
            
            const data = await response.json();
            const text = data.content[0].text;
            
            const jsonMatch = text.match(/\{[\s\S]*\}/);
            if (!jsonMatch) {
                throw new Error('No valid JSON found in AI response');
            }
            
            return JSON.parse(jsonMatch[0]);
        }

        let categoryCounter = 0;

        function addCategory() {
            categoryCounter++;
            const container = document.getElementById('categoriesContainer');
            const categoryDiv = document.createElement('div');
            categoryDiv.className = 'category-item';
            categoryDiv.id = `category-${categoryCounter}`;
            categoryDiv.style.cssText = 'background: var(--bg-alt); padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem; border: 1px solid var(--border);';
            
            categoryDiv.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                    <input type="text" placeholder="Category Name (e.g., Content - Introduction)" 
                           class="category-name" style="flex: 1; margin-right: 1rem; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;" required>
                    <button type="button" onclick="removeCategory('category-${categoryCounter}')" class="btn-small btn-danger">Remove Category</button>
                </div>
                <div class="subcategories-container" id="subcategories-${categoryCounter}"></div>
                <button type="button" onclick="addSubcategory('subcategories-${categoryCounter}')" class="btn-small" style="margin-top: 0.5rem;">‚ûï Add Subcategory</button>
            `;
            
            container.appendChild(categoryDiv);
            
            // Add one default subcategory
            addSubcategory(`subcategories-${categoryCounter}`);
        }

        function removeCategory(categoryId) {
            const element = document.getElementById(categoryId);
            if (element) {
                element.remove();
            }
        }

        let subcategoryCounter = 0;

        function addSubcategory(containerId) {
            subcategoryCounter++;
            const container = document.getElementById(containerId);
            const subDiv = document.createElement('div');
            subDiv.id = `subcategory-${subcategoryCounter}`;
            subDiv.style.cssText = 'display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.5rem;';
            
            subDiv.innerHTML = `
                <span style="color: var(--text-light); font-size: 0.9rem;">‚Ä¢</span>
                <input type="text" placeholder="Subcategory (e.g., Eye Contact)" 
                       class="subcategory-name" style="flex: 1; padding: 0.4rem; border: 1px solid var(--border); border-radius: 0.25rem;" required>
                <button type="button" onclick="removeSubcategory('subcategory-${subcategoryCounter}')" class="btn-small btn-danger" style="padding: 0.25rem 0.5rem; font-size: 0.8rem;">‚úï</button>
            `;
            
            container.appendChild(subDiv);
        }

        function removeSubcategory(subId) {
            const element = document.getElementById(subId);
            if (element) {
                element.remove();
            }
        }

        function collectRubricData() {
            // Collect selected course IDs from checkboxes
            const selectedCourseIds = Array.from(document.querySelectorAll('.course-checkbox:checked'))
                .map(checkbox => checkbox.value);
            
            const rubricData = {
                id: document.getElementById('editingRubricId').value || ('rubric-' + Date.now()),
                name: document.getElementById('rubricName').value.trim(),
                description: document.getElementById('rubricDescription').value.trim(),
                totalPoints: parseInt(document.getElementById('rubricTotalPoints').value),
                speechType: document.getElementById('rubricSpeechType').value.trim() || null,
                courseIds: selectedCourseIds.length > 0 ? selectedCourseIds : [], // Array of course IDs
                gradeScale: {
                    A: {
                        label: document.getElementById('gradeA_label').value,
                        percentage: parseFloat(document.getElementById('gradeA_pct').value) / 100,
                        range: document.getElementById('gradeA_range').value
                    },
                    B: {
                        label: document.getElementById('gradeB_label').value,
                        percentage: parseFloat(document.getElementById('gradeB_pct').value) / 100,
                        range: document.getElementById('gradeB_range').value
                    },
                    C: {
                        label: document.getElementById('gradeC_label').value,
                        percentage: parseFloat(document.getElementById('gradeC_pct').value) / 100,
                        range: document.getElementById('gradeC_range').value
                    },
                    D: {
                        label: document.getElementById('gradeD_label').value,
                        percentage: parseFloat(document.getElementById('gradeD_pct').value) / 100,
                        range: document.getElementById('gradeD_range').value
                    },
                    F: {
                        label: document.getElementById('gradeF_label').value,
                        percentage: parseFloat(document.getElementById('gradeF_pct').value) / 100,
                        range: document.getElementById('gradeF_range').value
                    }
                },
                categories: []
            };

            // Collect categories and subcategories
            const categoryElements = document.querySelectorAll('.category-item');
            
            categoryElements.forEach((catEl) => {
                const categoryName = catEl.querySelector('.category-name').value.trim();
                if (!categoryName) return;

                const subcategories = [];
                const subInputs = catEl.querySelectorAll('.subcategory-name');
                
                subInputs.forEach((subInput) => {
                    const subName = subInput.value.trim();
                    if (subName) {
                        subcategories.push(subName);
                    }
                });

                if (subcategories.length > 0) {
                    rubricData.categories.push({
                        name: categoryName,
                        subcategories: subcategories
                    });
                }
            });

            return rubricData;
        }

        function loadRubricIntoForm(rubric) {
            document.getElementById('rubricFormHeader').textContent = 'Edit Rubric';
            document.getElementById('rubricSubmitBtn').textContent = 'Save Changes';
            document.getElementById('editingRubricId').value = rubric.id;
            
            // Basic info
            document.getElementById('rubricName').value = rubric.name;
            document.getElementById('rubricDescription').value = rubric.description || '';
            document.getElementById('rubricTotalPoints').value = rubric.totalPoints;
            document.getElementById('rubricSpeechType').value = rubric.speechType || '';
            
            // Populate course selector with pre-selected courses
            // Handle both old single courseId and new courseIds array for backward compatibility
            let selectedCourseIds = [];
            if (rubric.courseIds && Array.isArray(rubric.courseIds)) {
                selectedCourseIds = rubric.courseIds;
            } else if (rubric.courseId) {
                // Backward compatibility: convert old single courseId to array
                selectedCourseIds = [rubric.courseId];
            }
            populateCourseSelector(selectedCourseIds);
            
            // Grade scale
            for (const grade of ['A', 'B', 'C', 'D', 'F']) {
                const gradeData = rubric.gradeScale[grade];
                document.getElementById(`grade${grade}_label`).value = gradeData.label;
                document.getElementById(`grade${grade}_pct`).value = gradeData.percentage * 100;
                document.getElementById(`grade${grade}_range`).value = gradeData.range;
            }
            
            // Clear and rebuild categories
            document.getElementById('categoriesContainer').innerHTML = '';
            categoryCounter = 0;
            subcategoryCounter = 0;
            
            rubric.categories.forEach((category) => {
                addCategory();
                const lastCategory = document.querySelector('.category-item:last-child');
                lastCategory.querySelector('.category-name').value = category.name;
                
                // Clear default subcategory and add the actual ones
                const subContainer = lastCategory.querySelector('.subcategories-container');
                subContainer.innerHTML = '';
                
                category.subcategories.forEach((subName) => {
                    const containerId = subContainer.id;
                    addSubcategory(containerId);
                    
                    // Get all subcategory inputs in this container and set the last one
                    const allSubInputs = subContainer.querySelectorAll('.subcategory-name');
                    const lastSubInput = allSubInputs[allSubInputs.length - 1];
                    
                    if (lastSubInput) {
                        lastSubInput.value = subName;
                    }
                });
            });
            
            document.getElementById('createRubricCard').classList.remove('hidden');
            document.getElementById('createRubricCard').scrollIntoView({ behavior: 'smooth' });
        }

        // ===== STUDENT MANAGEMENT =====
        function showAddStudent() {
            document.getElementById('addStudentCard').classList.remove('hidden');
        }

        function cancelAddStudent() {
            document.getElementById('addStudentCard').classList.add('hidden');
            document.getElementById('addStudentForm').reset();
        }

        function viewStudentEvals(studentId) {
            const classes = JSON.parse(localStorage.getItem('classes') || '[]');
            const cls = classes.find(c => c.id === currentClassId);
            if (!cls) return;
            
            const student = cls.roster.find(s => s.id === studentId);
            if (!student || !student.evaluations || student.evaluations.length === 0) {
                alert('No evaluations found for this student.');
                return;
            }
            
            let html = `
                <div class="card">
                    <div class="card-header">${student.firstName} ${student.lastName} - Evaluations</div>
                    <div style="margin-bottom: 1rem;">
                        <button onclick="viewClass('${currentClassId}')" class="btn-secondary">‚Üê Back to Class</button>
                    </div>
            `;
            
            student.evaluations.forEach(ev => {
                const date = ev.date || 'No date';
                const type = ev.type || 'Unknown';
                const results = ev.results;
                
                html += `
                    <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 1rem;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 1rem;">
                            <div>
                                <strong style="font-size: 1.2rem;">${type}</strong><br>
                                <span style="color: var(--text-light);">${date}</span>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: var(--primary);">
                                    ${results.totalScore || 0}/${results.maxScore || 50}
                                </div>
                                <div style="color: var(--text-light);">${(((results.totalScore || 0) / (results.maxScore || 50)) * 100).toFixed(1)}%</div>
                            </div>
                        </div>
                `;
                
                // Display individual sections
                if (results.sections) {
                    html += '<div style="background: white; padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem;">';
                    html += '<strong style="display: block; margin-bottom: 0.75rem;">Section Scores:</strong>';
                    
                    Object.keys(results.sections).forEach(sectionKey => {
                        const section = results.sections[sectionKey];
                        const sectionName = sectionKey.charAt(0).toUpperCase() + sectionKey.slice(1);
                        html += `
                            <div style="border-left: 3px solid var(--primary); padding-left: 1rem; margin-bottom: 1rem;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                                    <strong>${sectionName}</strong>
                                    <span style="color: var(--primary); font-weight: bold;">${section.score}/${section.maxScore}</span>
                                </div>
                                <p style="color: var(--text-light); margin: 0; font-size: 0.9rem;">${section.feedback}</p>
                            </div>
                        `;
                    });
                    
                    html += '</div>';
                }
                
                // Display overall comments
                html += `
                    <div style="background: white; padding: 1rem; border-radius: 0.5rem;">
                        <strong>Overall Comments:</strong><br>
                        <p style="margin: 0.5rem 0 0 0;">${results.overallComments || 'No comments'}</p>
                    </div>
                    </div>
                `;
            });
            
            html += '</div>';
            document.getElementById('classDetailContent').innerHTML = html;
        }

        function deleteStudent(studentId) {
            if (!confirm('Are you sure you want to delete this student?')) return;
            
            const classes = JSON.parse(localStorage.getItem('classes') || '[]');
            const classIndex = classes.findIndex(c => c.id === currentClassId);
            
            if (classIndex !== -1) {
                classes[classIndex].roster = classes[classIndex].roster.filter(s => s.id !== studentId);
                localStorage.setItem('classes', JSON.stringify(classes));
                viewClass(currentClassId); // Refresh the view
            }
        }

        // ===== SETTINGS =====
        function loadSavedSettings() {
            // Load all three API keys
            const geminiKey = localStorage.getItem('gemini_api_key');
            const openaiKey = localStorage.getItem('openai_api_key');
            const claudeKey = localStorage.getItem('anthropic_api_key');
            
            if (geminiKey) {
                document.getElementById('savedGeminiKey').value = geminiKey;
            }
            if (openaiKey) {
                document.getElementById('savedOpenAIKey').value = openaiKey;
            }
            if (claudeKey) {
                document.getElementById('savedClaudeKey').value = claudeKey;
            }
            
            // Load theme settings
            const savedTenant = localStorage.getItem('current_tenant');
            if (savedTenant) {
                currentTenant = savedTenant;
                applyTenant(savedTenant);
                document.getElementById('tenantSelect').value = savedTenant;
            }
            
            const savedColor = localStorage.getItem('primary_color');
            if (savedColor) {
                document.getElementById('primaryColor').value = savedColor;
                updatePrimaryColor(savedColor);
            }
            
            const savedHeadingFont = localStorage.getItem('heading_font');
            if (savedHeadingFont) {
                document.getElementById('headingFont').value = savedHeadingFont;
            }
            
            const savedBodyFont = localStorage.getItem('body_font');
            if (savedBodyFont) {
                document.getElementById('bodyFont').value = savedBodyFont;
            }
            
            if (savedHeadingFont || savedBodyFont) {
                updateFonts();
            }
        }

        function saveSettings() {
            // Save all three API keys
            const geminiKey = document.getElementById('savedGeminiKey').value.trim();
            const openaiKey = document.getElementById('savedOpenAIKey').value.trim();
            const claudeKey = document.getElementById('savedClaudeKey').value.trim();
            
            if (geminiKey) {
                localStorage.setItem('gemini_api_key', geminiKey);
            }
            if (openaiKey) {
                localStorage.setItem('openai_api_key', openaiKey);
            }
            if (claudeKey) {
                localStorage.setItem('anthropic_api_key', claudeKey);
            }
            
            // Save theme settings
            const primaryColor = document.getElementById('primaryColor').value;
            const headingFont = document.getElementById('headingFont').value;
            const bodyFont = document.getElementById('bodyFont').value;
            
            localStorage.setItem('primary_color', primaryColor);
            localStorage.setItem('heading_font', headingFont);
            localStorage.setItem('body_font', bodyFont);
            
            showMessage('settingsMessage', '‚úÖ Settings saved successfully! Your API keys are now stored securely.', 'success');
        }

        function resetSettings() {
            if (!confirm('Reset all settings to defaults? This will clear all saved API keys.')) return;
            
            // Clear all API keys
            localStorage.removeItem('gemini_api_key');
            localStorage.removeItem('openai_api_key');
            localStorage.removeItem('anthropic_api_key');
            localStorage.removeItem('current_tenant');
            localStorage.removeItem('custom_logo');
            localStorage.removeItem('primary_color');
            localStorage.removeItem('heading_font');
            localStorage.removeItem('body_font');
            
            // Reset form fields
            document.getElementById('savedGeminiKey').value = '';
            document.getElementById('savedOpenAIKey').value = '';
            document.getElementById('savedClaudeKey').value = '';
            
            currentTenant = 'default';
            applyTenant('default');
            
            showMessage('settingsMessage', '‚úÖ Settings reset to defaults.', 'success');
        }

        function handleLogoUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const logoData = e.target.result;
                localStorage.setItem('custom_logo', logoData);
                
                document.getElementById('logoPreviewImg').src = logoData;
                document.getElementById('logoPreview').classList.remove('hidden');
                
                // Update header logo
                document.getElementById('appLogo').innerHTML = `<img src="${logoData}" alt="Logo">`;
            };
            reader.readAsDataURL(file);
        }

        function clearLogo() {
            localStorage.removeItem('custom_logo');
            document.getElementById('logoPreview').classList.add('hidden');
            document.getElementById('logoUpload').value = '';
            
            // Reset to text logo
            const config = TENANT_CONFIGS[currentTenant];
            document.getElementById('appLogo').textContent = config.shortName;
        }

        function updatePrimaryColor(color) {
            document.documentElement.style.setProperty('--primary', color);
            
            // Generate dark variant
            const darkColor = adjustColorBrightness(color, -20);
            document.documentElement.style.setProperty('--primary-dark', darkColor);
        }

        function adjustColorBrightness(hex, percent) {
            const num = parseInt(hex.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255))
                .toString(16).slice(1);
        }

        function updateFonts() {
            const headingFont = document.getElementById('headingFont').value;
            const bodyFont = document.getElementById('bodyFont').value;
            
            document.documentElement.style.setProperty('--heading-font', headingFont);
            document.documentElement.style.setProperty('--body-font', bodyFont);
        }

        // ===== UTILITIES =====
        function showMessage(elementId, message, type) {
            const el = document.getElementById(elementId);
            el.textContent = message;
                el.className = type === 'error' ? 'error-message' : 'success-message';
        }

        // ===== SAVE TO CLASS FUNCTIONS =====
        function openSaveModal() {
            try {
                var classes = JSON.parse(localStorage.getItem('classes') || '[]');
                var sel = document.getElementById('saveClassSel');
                sel.innerHTML = '<option value="">-- Select Class --</option>';
                for (var i = 0; i < classes.length; i++) {
                    var opt = document.createElement('option');
                    opt.value = i;
                    opt.textContent = classes[i].name + ' - ' + classes[i].semester + ' ' + classes[i].year;
                    sel.appendChild(opt);
                }
                document.getElementById('saveModal').style.display = 'flex';
            } catch(e) {
                console.error(e);
            }
        }

        function loadSaveStudents() {
            try {
                var idx = document.getElementById('saveClassSel').value;
                var sel = document.getElementById('saveStudentSel');
                sel.innerHTML = '<option value="">-- Select Student --</option>';
                if (!idx) return;
                var classes = JSON.parse(localStorage.getItem('classes') || '[]');
                var cls = classes[idx];
                if (cls && cls.roster) {
                    for (var i = 0; i < cls.roster.length; i++) {
                        var s = cls.roster[i];
                        var opt = document.createElement('option');
                        opt.value = i;
                        opt.textContent = s.firstName + ' ' + s.lastName;
                        sel.appendChild(opt);
                    }
                }
            } catch(e) {
                console.error(e);
            }
        }

        function doSaveEval() {
            try {
                var cIdx = document.getElementById('saveClassSel').value;
                var sIdx = document.getElementById('saveStudentSel').value;
                if (!cIdx || sIdx === '') {
                    alert('Please select both class and student');
                    return;
                }
                if (!evaluationResults) {
                    alert('No evaluation to save');
                    return;
                }
                var classes = JSON.parse(localStorage.getItem('classes') || '[]');
                var student = classes[cIdx].roster[sIdx];
                if (!student.evaluations) {
                    student.evaluations = [];
                }
                var rec = {
                    id: Date.now().toString(),
                    date: document.getElementById('speechDate').value,
                    type: document.getElementById('assignmentType').value,
                    results: evaluationResults,
                    savedAt: new Date().toISOString()
                };
                student.evaluations.push(rec);
                classes[cIdx].roster[sIdx] = student;
                localStorage.setItem('classes', JSON.stringify(classes));
                alert('‚úì Evaluation saved for ' + student.firstName + ' ' + student.lastName);
                closeSaveModal();
            } catch(e) {
                alert('Error: ' + e.message);
            }
        }

        function closeSaveModal() {
            document.getElementById('saveModal').style.display = 'none';
        }
    </script>
</body>
</html>
