<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speech Gradebook v3.0 - Supabase Edition</title>
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&family=Roboto:wght@400;500;700&family=Open+Sans:wght@400;600;700&family=Georgia&family=Crimson+Pro:wght@400;600;700&family=Work+Sans:wght@400;600;700&display=swap" rel="stylesheet">
    
    <!-- Supabase JS Library -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <style>
        /* CSS Variables for Theming */
        :root {
            --primary: #1e3a5f;
            --primary-dark: #142940;
            --secondary: #c8a882;
            --accent: #d4af37;
            --text: #2c3e50;
            --text-light: #6c757d;
            --bg: #fafbfc;
            --bg-alt: #f1f4f7;
            --card: #ffffff;
            --border: #e1e8ed;
            --success: #28a745;
            --warning: #ffc107;
            --error: #dc3545;
            --heading-font: 'Crimson Pro', serif;
            --body-font: 'Work Sans', sans-serif;
            --heading-weight: 700;
            --body-weight: 400;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* Targeted approach: Only force normal weight on text content elements */
        /* This prevents custom fonts from appearing bold while preserving button styles */
        p, span, a:not(.button):not(.btn):not(.nav-link),
        li, td, label:not([for]), 
        .class-card, .student-card, .eval-card,
        .class-meta, .class-stats, .stat-label,
        textarea, input[type="text"], input[type="email"], input[type="password"], select {
            font-weight: 400 !important;
            font-style: normal !important;
        }
        
        /* Explicitly allow bold for semantic elements */
        h1, h2, h3, h4, h5, h6,
        strong, b, .font-bold,
        th {
            font-weight: 700 !important;
        }
        
        /* Explicitly allow italic for semantic elements */
        em, i, .font-italic {
            font-style: italic !important;
        }
        
        /* Preserve button and UI element weights (semi-bold for clarity) */
        button, .btn, .button,
        input[type="button"], input[type="submit"],
        .nav-link,
        .card-header,
        .step-label.active {
            font-weight: 600 !important;
        }
        
        body {
            font-family: var(--body-font);
            font-weight: 400; /* Always normal weight */
            font-style: normal; /* Always normal style */
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
        }
        
        h1, h2, h3, h4, h5, h6 {
            font-family: var(--heading-font);
            font-weight: 700; /* Always bold for headings */
            font-style: normal; /* Always normal style */
            color: var(--primary);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 1rem;
        }
        
        /* Header */
        header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            padding: 1.25rem 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .logo {
            width: 70px;
            height: 70px;
            background: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.8rem;
            color: var(--primary);
            flex-shrink: 0; /* Prevent compression */
        }
        
        .logo img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
        }
        
        .app-title h1 {
            color: white;
            font-size: 1.8rem;
            margin-bottom: 0.2rem;
        }
        
        .tagline {
            font-size: 0.9rem;
            opacity: 0.9;
        }
        
        /* Navigation */
        nav {
            display: flex;
            gap: 1.5rem;
        }
        
        .nav-link {
            color: white;
            text-decoration: none;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            transition: background 0.3s;
        }
        
        .nav-link:hover {
            background: rgba(255,255,255,0.1);
        }
        
        .nav-link.active {
            background: rgba(255,255,255,0.2);
        }
        
        /* Main Content */
        main {
            padding: 2rem 0;
            min-height: calc(100vh - 200px);
        }
        
        .section {
            display: none;
        }
        
        .section.active {
            display: block;
        }
        
        /* Cards */
        .card {
            background: var(--card);
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            margin-bottom: 2rem;
        }
        
        .card-header {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: var(--primary);
            border-bottom: 2px solid var(--border);
            padding-bottom: 1rem;
        }
        
        /* Upload Zone */
        .upload-zone {
            border: 3px dashed var(--border);
            border-radius: 1rem;
            padding: 3rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: var(--bg-alt);
        }
        
        .upload-zone:hover {
            border-color: var(--primary);
            background: white;
        }
        
        .upload-zone.drag-over {
            border-color: var(--primary);
            background: rgba(30, 58, 95, 0.05);
        }
        
        .upload-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
        
        .file-info {
            background: var(--success);
            color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        /* Forms */
        .form-group {
            margin-bottom: 1.5rem;
        }
        
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--text);
        }
        
        input[type="text"],
        input[type="email"],
        input[type="date"],
        input[type="number"],
        input[type="password"],
        select,
        textarea {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--border);
            border-radius: 0.5rem;
            font-size: 1rem;
            font-family: var(--body-font);
            transition: border-color 0.3s;
        }
        
        input:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        textarea {
            resize: vertical;
            min-height: 100px;
        }
        
        /* Buttons */
        button,
        .btn {
            background: var(--primary);
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-block;
            text-decoration: none;
            text-align: center;
        }
        
        button:hover,
        .btn:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .btn-secondary {
            background: var(--secondary);
        }
        
        .btn-success {
            background: var(--success);
        }
        
        .btn-danger {
            background: var(--error);
        }
        
        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
        }
        
        /* Progress Steps */
        .progress-steps {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2rem;
            position: relative;
        }
        
        .progress-steps::before {
            content: '';
            position: absolute;
            top: 25px;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--border);
            z-index: 1;
        }
        
        .step {
            flex: 1;
            text-align: center;
            position: relative;
            z-index: 2;
        }
        
        .step-circle {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--border);
            color: var(--text-light);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin: 0 auto 0.5rem;
            transition: all 0.3s;
        }
        
        .step.active .step-circle {
            background: var(--primary);
            color: white;
        }
        
        .step.completed .step-circle {
            background: var(--success);
            color: white;
        }
        
        .step-label {
            font-size: 0.9rem;
            color: var(--text-light);
        }
        
        .step.active .step-label {
            color: var(--primary);
            font-weight: 600;
        }
        
        /* Classes Grid */
        .classes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }
        
        /* Data Table Styles */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            background: var(--card);
            border-radius: 0.5rem;
            overflow: hidden;
        }
        
        .data-table thead {
            background: var(--primary);
            color: white;
        }
        
        .data-table th {
            padding: 1rem;
            text-align: left;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
        }
        
        .data-table th:hover {
            background: rgba(0, 0, 0, 0.1);
        }
        
        .data-table tbody tr {
            border-bottom: 1px solid var(--border);
            transition: background 0.2s;
        }
        
        .data-table tbody tr:hover {
            background: rgba(0, 0, 0, 0.02);
        }
        
        .data-table td {
            padding: 0.75rem 1rem;
            color: var(--text);
        }
        
        .data-table td:last-child {
            text-align: center;
        }
        
        /* Filter Controls */
        .filter-controls {
            padding: 1rem;
            background: rgba(0, 0, 0, 0.02);
            border-radius: 0.5rem;
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
        }
        
        .class-card {
            background: var(--card);
            border: 2px solid var(--border);
            border-radius: 1rem;
            padding: 1.5rem;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .class-card:hover {
            border-color: var(--primary);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }
        
        .class-header {
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 0.5rem;
        }
        
        .class-meta {
            color: var(--text-light);
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }
        
        .class-stats {
            display: flex;
            justify-content: space-between;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary);
        }
        
        .stat-label {
            font-size: 0.8rem;
            color: var(--text-light);
        }
        
        /* Rubrics */
        .rubrics-list {
            display: grid;
            gap: 1rem;
        }
        
        .rubric-item {
            background: var(--bg-alt);
            padding: 1rem;
            border-radius: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .rubric-info h4 {
            margin-bottom: 0.25rem;
        }
        
        .rubric-info p {
            font-size: 0.9rem;
            color: var(--text-light);
        }
        
        .rubric-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        /* Loading Spinner */
        .spinner {
            border: 4px solid var(--border);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 2rem auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Score Display */
        .score-banner {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            margin: 2rem 0;
        }
        
        .score-value {
            font-size: 3rem;
            font-weight: bold;
            margin: 1rem 0;
        }
        
        .score-percentage {
            font-size: 1.5rem;
            opacity: 0.9;
        }
        
        /* Footer */
        footer {
            background: var(--primary);
            color: white;
            padding: 2rem 0;
            margin-top: 3rem;
        }
        
        .footer-content {
            text-align: center;
        }
        
        .footer-links {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-bottom: 1rem;
        }
        
        .footer-links a {
            color: white;
            text-decoration: none;
            opacity: 0.8;
            transition: opacity 0.3s;
        }
        
        .footer-links a:hover {
            opacity: 1;
        }
        
        /* Utility Classes */
        .hidden {
            display: none !important;
        }
        
        .text-center {
            text-align: center;
        }
        
        .mt-2 {
            margin-top: 2rem;
        }
        
        .mb-2 {
            margin-bottom: 2rem;
        }
        
        .alert {
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }
        
        .alert-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            nav {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .header-content {
                flex-direction: column;
                gap: 1rem;
            }
            
            .classes-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* Edit functionality animations */
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <!-- Login/Register Screen (shown when not authenticated) -->
    <div id="authScreen" class="hidden" style="min-height: 100vh; display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);">
        <div style="background: white; padding: 3rem; border-radius: 1rem; max-width: 450px; width: 90%; box-shadow: 0 20px 60px rgba(0,0,0,0.3);">
            <div style="text-align: center; margin-bottom: 2rem;">
                <div class="logo" style="width: 80px; height: 80px; margin: 0 auto 1rem; font-size: 2rem;">SG</div>
                <h2 style="margin: 0; color: var(--primary);">Speech Gradebook</h2>
                <p style="color: var(--text-light); margin: 0.5rem 0 0 0;">AI-Powered Speech Assessment</p>
            </div>
            
            <!-- Login Form -->
            <div id="loginFormDiv">
                <h3 style="margin-bottom: 1.5rem; color: var(--text);">Login to Your Account</h3>
                <form id="loginForm">
                    <div class="form-group">
                        <label for="loginEmail">Email</label>
                        <input type="email" id="loginEmail" required placeholder="you@example.com">
                    </div>
                    <div class="form-group">
                        <label for="loginPassword">Password</label>
                        <input type="password" id="loginPassword" required placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢">
                    </div>
                    <button type="submit" style="width: 100%; padding: 0.75rem; font-size: 1rem;">Login</button>
                </form>
                <p style="text-align: center; margin-top: 1.5rem; color: var(--text-light);">
                    Don't have an account? <a href="#" onclick="showRegisterForm(); return false;" style="color: var(--primary); font-weight: 600;">Create one</a>
                </p>
            </div>
            
            <!-- Register Form -->
            <div id="registerFormDiv" class="hidden">
                <h3 style="margin-bottom: 1.5rem; color: var(--text);">Create Your Account</h3>
                <form id="registerForm">
                    <div class="form-group">
                        <label for="registerName">Full Name</label>
                        <input type="text" id="registerName" required placeholder="John Doe">
                    </div>
                    <div class="form-group">
                        <label for="registerEmail">Email</label>
                        <input type="email" id="registerEmail" required placeholder="you@example.com">
                    </div>
                    <div class="form-group">
                        <label for="registerPassword">Password</label>
                        <input type="password" id="registerPassword" required placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" minlength="6">
                        <small style="color: var(--text-light);">At least 6 characters</small>
                    </div>
                    <button type="submit" style="width: 100%; padding: 0.75rem; font-size: 1rem;">Create Account</button>
                </form>
                <p style="text-align: center; margin-top: 1.5rem; color: var(--text-light);">
                    Already have an account? <a href="#" onclick="showLoginForm(); return false;" style="color: var(--primary); font-weight: 600;">Login</a>
                </p>
            </div>
        </div>
    </div>

    <!-- Main App (shown when authenticated) -->
    <div id="mainApp">
    <header>
        <div class="container">
            <div class="header-content">
                <div class="logo-section">
                    <div class="logo" id="appLogo">SG</div>
                    <div class="app-title">
                        <h1 id="appName">Speech Gradebook</h1>
                        <div class="tagline" id="appTagline">AI-Powered Speech Assessment</div>
                    </div>
                </div>
                <nav>
                    <a href="#" class="nav-link active" id="navEvaluate" onclick="showEvaluate(); return false;">Evaluate Speech</a>
                    <a href="#" class="nav-link" id="navDashboard" onclick="showDashboard(); return false;">Dashboard</a>
                    <a href="#" class="nav-link" id="navSettings" onclick="showSettings(); return false;">Settings</a>
                    <a href="#" class="nav-link" id="navHelp" onclick="showHelp(); return false;">Help</a>
                    <a href="#" class="nav-link" id="navAdmin" onclick="showAdmin(); return false;" style="display: none;">‚öôÔ∏è Admin</a>
                    
                    <!-- View Switcher (for admins and super admins) -->
                    <div id="viewSwitcher" style="display: none; margin: 0 1rem;">
                        <select id="viewModeSelect" onchange="switchViewMode(this.value)" style="
                            padding: 0.5rem 1rem;
                            border: 2px solid var(--primary);
                            border-radius: 0.5rem;
                            background: var(--bg);
                            color: var(--text);
                            font-weight: 600;
                            cursor: pointer;
                        ">
                            <!-- Options populated dynamically based on user tier -->
                        </select>
                    </div>
                    
                    <a href="#" id="logoutLink" class="nav-link" onclick="logout(); return false;">
                        <span id="userEmailDisplay"></span> | Logout
                    </a>
                </nav>
            </div>
        </div>
    </header>

    <main class="container">
        <!-- Evaluate Section -->
        <section id="evaluateSection" class="section active">
            <div class="card">
                <div class="card-header" id="evaluateCardHeader">üìä Evaluate a Speech</div>
                
                <div class="progress-steps">
                    <div class="step active" id="step1">
                        <div class="step-circle">1</div>
                        <div class="step-label">Upload</div>
                    </div>
                    <div class="step" id="step2">
                        <div class="step-circle">2</div>
                        <div class="step-label">Details</div>
                    </div>
                    <div class="step" id="step3">
                        <div class="step-circle">3</div>
                        <div class="step-label">Evaluate</div>
                    </div>
                    <div class="step" id="step4">
                        <div class="step-circle">4</div>
                        <div class="step-label">Results</div>
                    </div>
                </div>

                <!-- Step 1: Upload -->
                <div id="uploadStep">
                    <div class="upload-zone" id="uploadZone">
                        <div class="upload-icon">üìÅ</div>
                        <h3>Upload Speech Recording</h3>
                        <p>Click or drag & drop your audio/video file here</p>
                        <p style="color: var(--text-light); font-size: 0.9rem; margin-top: 0.5rem;">
                            Supported: MP3, MP4, WAV, M4A, WebM<br>
                            <strong>For GPT-4o:</strong> Can also upload image/screenshot (JPG, PNG)
                        </p>
                    </div>
                    <input type="file" id="fileInput" accept="audio/*,video/*,image/*" style="display: none;">
                    <div id="fileInfo" class="file-info hidden">
                        <span id="fileName"></span>
                        <button onclick="removeFile()" class="btn-small btn-danger">Remove</button>
                    </div>
                    <div id="continueButtonContainer" style="margin-top: 2rem; display: none;">
                        <button onclick="moveToStep(2)" id="continueToDetails">Continue to Details ‚Üí</button>
                    </div>
                </div>

                <!-- Step 2: Details -->
                <div id="detailsStep" class="hidden">
                    <form id="studentForm">
                        <div class="form-group">
                            <label for="speechDate">Speech Date</label>
                            <input type="date" id="speechDate">
                        </div>
                        <div class="form-group">
                            <label for="assignmentType">Assignment Type</label>
                            <select id="assignmentType">
                                <option value="self-introduction">Self Introduction Speech</option>
                                <option value="informative">Informative Speech</option>
                                <option value="persuasive">Persuasive Speech</option>
                                <option value="demonstration">Demonstration Speech</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="rubricSelect">Evaluation Rubric *</label>
                            <select id="rubricSelect" required>
                                <option value="">-- Select a Rubric --</option>
                            </select>
                            <p style="font-size: 0.9rem; color: var(--text-light); margin-top: 0.5rem;">
                                Choose which rubric to use for evaluation. <a href="#" onclick="showDashboard(); return false;" style="color: var(--primary);">Manage rubrics</a>
                            </p>
                        </div>
                        <div class="form-group">
                            <label for="apiProvider">AI Provider *</label>
                            <select id="apiProvider" onchange="updateApiKeyPlaceholder()">
                                <option value="demo">üé≠ Demo Mode (No API Key Needed - Try It Out!)</option>
                                <option value="gpt4o">OpenAI GPT-4o-mini (FREE $5 Credits - Best Value!)</option>
                                <option value="gemini">Google Gemini (Full Video Analysis)</option>
                                <option value="claude">Anthropic Claude (Audio Only)</option>
                            </select>
                            <p style="font-size: 0.9rem; color: var(--text-light); margin-top: 0.5rem;">
                                <strong>Demo Mode:</strong> Generates realistic AI feedback instantly - no API needed!<br>
                                <strong>GPT-4o-mini:</strong> FREE $5 credits! Video frames + audio analysis<br>
                                <strong>Gemini:</strong> Full video analysis (requires billing)<br>
                                <strong>Claude:</strong> Audio transcription only
                            </p>
                        </div>
                        <div class="form-group">
                            <label for="apiKey" id="apiKeyLabel">OpenAI API Key *</label>
                            <input type="password" id="apiKey" placeholder="sk-proj-...">
                            <p style="font-size: 0.9rem; color: var(--text-light); margin-top: 0.5rem;">
                                üí° <strong>Tip:</strong> Save your key in <a href="#" onclick="showSettings(); return false;" style="color: var(--primary);">Settings</a> to avoid entering it each time!
                            </p>
                        </div>
                        <div style="display: flex; gap: 1rem;">
                            <button type="button" onclick="moveToStep(1)" class="btn-secondary">‚Üê Back</button>
                            <button type="submit" id="submitEvaluationBtn">Continue to Evaluation ‚Üí</button>
                        </div>
                    </form>
                </div>

                <!-- Step 3: Processing -->
                <div id="processingStep" class="hidden text-center">
                    <div class="spinner"></div>
                    <h3>Evaluating Speech...</h3>
                    <p id="processingMessage">Analyzing speech content and delivery...</p>
                </div>

                <!-- Step 4: Results -->
                <div id="resultsStep" class="hidden">
                    <div id="resultsContent"></div>
                    <div style="display: flex; gap: 1rem; margin-top: 2rem; flex-wrap: wrap;">
                        <button onclick="openSaveModal()">üíæ Save Results</button>
                        <button onclick="downloadPDF()" class="btn-secondary">üìÑ Download Report (HTML)</button>
                        <button onclick="emailResults()" class="btn-secondary">üìß Email Results</button>
                        <button onclick="viewCorrectionHistory()" class="btn-secondary" id="viewCorrectionsBtn" style="display: none;">üìã View Corrections (<span id="correctionCount">0</span>)</button>
                        <button onclick="startOver()" class="btn-secondary">üîÑ Start Over</button>
                    </div>
                </div>
            </div>
        </section>

        <!-- Save Modal -->
        <div id="saveModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
            <div style="background:white;padding:2rem;border-radius:1rem;max-width:500px;width:90%;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                <h3 style="margin-top:0;color:var(--primary);">üíæ Save Evaluation</h3>
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">Class:</label>
                    <select id="saveClassSel" onchange="loadSaveStudents()" style="width:100%;padding:0.75rem;font-size:1rem;border:2px solid #ddd;border-radius:0.5rem;">
                        <option value="">-- Select Class --</option>
                    </select>
                </div>
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">Student:</label>
                    <select id="saveStudentSel" style="width:100%;padding:0.75rem;font-size:1rem;border:2px solid #ddd;border-radius:0.5rem;">
                        <option value="">-- Select Student --</option>
                    </select>
                </div>
                <div style="display:flex;gap:1rem;justify-content:flex-end;margin-top:2rem;">
                    <button onclick="closeSaveModal()" style="padding:0.75rem 1.5rem;background:#6c757d;color:white;border:none;border-radius:0.5rem;cursor:pointer;">Cancel</button>
                    <button onclick="doSaveEval()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;font-weight:600;">Save</button>
                </div>
            </div>
        </div>

        <!-- Edit Section Modal -->
        <div id="editSectionModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
            <div style="background:white;padding:2rem;border-radius:1rem;max-width:700px;width:90%;box-shadow:0 10px 40px rgba(0,0,0,0.3);max-height:90vh;overflow-y:auto;">
                <h3 style="margin-top:0;color:var(--primary);">‚úèÔ∏è Edit <span id="editSectionName"></span></h3>
                
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">Overall Section Score:</label>
                    <div style="display:flex;gap:1rem;align-items:center;">
                        <input type="number" id="editSectionScore" min="0" style="width:80px;padding:0.5rem;font-size:1rem;border:2px solid #ddd;border-radius:0.5rem;" readonly disabled>
                        <span style="font-weight:600;">/ <span id="editSectionMaxScore"></span></span>
                        <span style="color:#999;font-size:0.9rem;">(Auto-calculated from subcategories)</span>
                    </div>
                </div>
                
                <!-- Subcategories Section -->
                <div id="editSubcategoriesContainer" style="margin:1.5rem 0;">
                    <!-- Subcategories will be populated here -->
                </div>
                
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">AI Feedback:</label>
                    <div style="background:#f8f9fa;padding:1rem;border-radius:0.5rem;border-left:4px solid #6c757d;margin-bottom:1rem;">
                        <p id="editSectionAIFeedback" style="margin:0;color:#555;font-size:0.9rem;"></p>
                    </div>
                </div>
                
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">Your Feedback (optional):</label>
                    <textarea id="editSectionFeedback" rows="4" style="width:100%;padding:0.75rem;font-size:1rem;border:2px solid #ddd;border-radius:0.5rem;resize:vertical;" placeholder="Add or modify feedback for the student..."></textarea>
                </div>
                
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">Why are you making changes? (helps improve AI):</label>
                    <textarea id="editSectionReason" rows="3" style="width:100%;padding:0.75rem;font-size:1rem;border:2px solid #ddd;border-radius:0.5rem;resize:vertical;" placeholder="e.g., 'AI didn't notice student was reading from notes'"></textarea>
                </div>
                
                <div style="display:flex;gap:1rem;justify-content:flex-end;margin-top:2rem;">
                    <button onclick="closeEditSectionModal()" style="padding:0.75rem 1.5rem;background:#6c757d;color:white;border:none;border-radius:0.5rem;cursor:pointer;">Cancel</button>
                    <button onclick="saveEditedSection()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;font-weight:600;">Save Changes</button>
                </div>
            </div>
        </div>

        <!-- Edit Overall Comments Modal -->
        <div id="editCommentsModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
            <div style="background:white;padding:2rem;border-radius:1rem;max-width:600px;width:90%;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                <h3 style="margin-top:0;color:var(--primary);">‚úèÔ∏è Edit Overall Comments</h3>
                
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">AI Comments:</label>
                    <div style="background:#f8f9fa;padding:1rem;border-radius:0.5rem;border-left:4px solid #6c757d;margin-bottom:1rem;">
                        <p id="editCommentsAI" style="margin:0;color:#555;font-size:0.9rem;"></p>
                    </div>
                </div>
                
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">Your Comments:</label>
                    <textarea id="editCommentsText" rows="6" style="width:100%;padding:0.75rem;font-size:1rem;border:2px solid #ddd;border-radius:0.5rem;resize:vertical;"></textarea>
                </div>
                
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">Reason for changes (optional, for AI training):</label>
                    <textarea id="editCommentsReason" rows="2" style="width:100%;padding:0.75rem;font-size:1rem;border:2px solid #ddd;border-radius:0.5rem;resize:vertical;" placeholder="What did the AI miss or get wrong?"></textarea>
                </div>
                
                <div style="display:flex;gap:1rem;justify-content:flex-end;margin-top:2rem;">
                    <button onclick="closeEditCommentsModal()" style="padding:0.75rem 1.5rem;background:#6c757d;color:white;border:none;border-radius:0.5rem;cursor:pointer;">Cancel</button>
                    <button onclick="saveEditedComments()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;font-weight:600;">Save Changes</button>
                </div>
            </div>
        </div>

        <!-- Edit Timeline Markers Modal -->
        <div id="editMarkersModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
            <div style="background:white;padding:2rem;border-radius:1rem;max-width:700px;width:90%;max-height:90vh;overflow-y:auto;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                <h3 style="margin-top:0;color:var(--primary);">‚úèÔ∏è Edit Timeline Markers</h3>
                
                <div id="editMarkersList" style="margin:1.5rem 0;">
                    <!-- Markers will be populated here -->
                </div>
                
                <button onclick="addNewMarker()" style="width:100%;padding:0.75rem;background:#28a745;color:white;border:none;border-radius:0.5rem;cursor:pointer;font-weight:600;margin:1rem 0;">+ Add New Marker</button>
                
                <div style="display:flex;gap:1rem;justify-content:flex-end;margin-top:2rem;">
                    <button onclick="closeEditMarkersModal()" style="padding:0.75rem 1.5rem;background:#6c757d;color:white;border:none;border-radius:0.5rem;cursor:pointer;">Cancel</button>
                    <button onclick="saveEditedMarkers()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;font-weight:600;">Save All Changes</button>
                </div>
            </div>
        </div>

        <!-- Correction History Modal -->
        <div id="correctionHistoryModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
            <div style="background:white;padding:2rem;border-radius:1rem;max-width:800px;width:90%;max-height:90vh;overflow-y:auto;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                <h3 style="margin-top:0;color:var(--primary);">üìã Instructor Corrections History</h3>
                <p style="color:var(--text-light);font-size:0.9rem;margin-bottom:1.5rem;">
                    This log shows all changes made to the AI's evaluation. This data helps improve future evaluations.
                </p>
                
                <div id="correctionHistoryContent" style="margin:1.5rem 0;">
                    <!-- Corrections will be populated here -->
                </div>
                
                <div style="display:flex;gap:1rem;justify-content:flex-end;margin-top:2rem;">
                    <button onclick="closeCorrectionHistoryModal()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;font-weight:600;">Close</button>
                </div>
            </div>
        </div>

        <!-- Dashboard Section -->
        <section id="dashboardSection" class="section">
            <!-- MY COURSES SECTION (Personal) - Always visible for all tiers -->
            <div class="card">
                <div class="card-header">üë§ My Courses</div>
                <div style="margin-bottom: 1.5rem;">
                    <button onclick="showCreateClass()">‚ûï Create New Class</button>
                </div>
                <div id="classesGrid" class="classes-grid"></div>
            </div>

            <!-- ALL INSTITUTIONS SECTION (Super Admin only) -->
            <div id="allInstitutionsSection" class="card" style="display: none; margin-top: 2rem;">
                <div class="card-header">üåê All Institutions</div>
                
                <!-- Filter Controls -->
                <div id="superAdminFilters" class="filter-controls" style="display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 1.5rem;">
                    <div class="filter-group">
                        <label for="filterInstitution" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Institution</label>
                        <select id="filterInstitution" onchange="onInstitutionFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; min-width: 200px;">
                            <option value="">All Institutions</option>
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="filterInstructor" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Instructor</label>
                        <select id="filterInstructor" onchange="onInstructorFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; min-width: 200px;">
                            <option value="">All Instructors</option>
                            <!-- Populated dynamically based on institution -->
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="filterYear" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Year</label>
                        <select id="filterYear" onchange="onYearFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                            <option value="">All Years</option>
                            <option value="2026">2026</option>
                            <option value="2025">2025</option>
                            <option value="2024">2024</option>
                            <option value="2023">2023</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="filterSemester" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Semester</label>
                        <select id="filterSemester" onchange="onSemesterFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                            <option value="">All Semesters</option>
                            <option value="Spring">Spring</option>
                            <option value="Summer">Summer</option>
                            <option value="Fall">Fall</option>
                            <option value="Winter">Winter</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="filterModality" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Modality</label>
                        <select id="filterModality" onchange="onModalityFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                            <option value="">All Modalities</option>
                            <option value="in-person">In-Person</option>
                            <option value="online">Online</option>
                            <option value="hybrid">Hybrid</option>
                        </select>
                    </div>
                    
                    <div class="filter-group" style="flex-grow: 1;">
                        <label for="filterSearch" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Search</label>
                        <input type="text" id="filterSearch" oninput="onSearchFilterChange()" placeholder="Search courses..." style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; width: 100%;">
                    </div>
                    
                    <div class="filter-group" style="align-self: flex-end;">
                        <button onclick="clearAllFilters()" class="btn-secondary" style="padding: 0.5rem 1rem;">Clear Filters</button>
                    </div>
                    
                    <div class="filter-group" style="align-self: flex-end;">
                        <button onclick="testTableRenderingWithMockData()" style="padding: 0.5rem 1rem; background: #28a745; color: white; border: none; border-radius: 0.25rem; cursor: pointer;">üß™ Test Table</button>
                    </div>
                </div>
                
                <!-- Results Info -->
                <div id="filterResultsInfo" style="margin-bottom: 1rem; color: var(--text-light); font-size: 0.9rem;">
                    Select filters to view courses
                </div>
                
                <!-- Data Table -->
                <div id="coursesTableContainer" style="overflow-x: auto;">
                    <table id="coursesTable" class="data-table" style="display: none;">
                        <thead>
                            <tr>
                                <th onclick="sortTableBy('name')">Course Name</th>
                                <th onclick="sortTableBy('code')">Code</th>
                                <th onclick="sortTableBy('instructor')">Instructor</th>
                                <th onclick="sortTableBy('institution')">Institution</th>
                                <th onclick="sortTableBy('semester')">Semester/Year</th>
                                <th onclick="sortTableBy('modality')">Modality</th>
                                <th onclick="sortTableBy('students')">Students</th>
                                <th onclick="sortTableBy('evaluations')">Evaluations</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="coursesTableBody">
                            <!-- Populated dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- DEPARTMENT COURSES SECTION (Admin only) -->
            <div id="departmentCoursesSection" class="card" style="display: none; margin-top: 2rem;">
                <div class="card-header">üèõÔ∏è Department Courses</div>
                
                <!-- Admin Filter Controls -->
                <div id="adminFilters" class="filter-controls" style="display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 1.5rem;">
                    <div class="filter-group">
                        <label for="adminFilterInstructor" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Instructor</label>
                        <select id="adminFilterInstructor" onchange="onAdminInstructorFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; min-width: 200px;">
                            <option value="">All Instructors</option>
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="adminFilterYear" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Year</label>
                        <select id="adminFilterYear" onchange="onAdminYearFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                            <option value="">All Years</option>
                            <option value="2026">2026</option>
                            <option value="2025">2025</option>
                            <option value="2024">2024</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="adminFilterSemester" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Semester</label>
                        <select id="adminFilterSemester" onchange="onAdminSemesterFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                            <option value="">All Semesters</option>
                            <option value="Spring">Spring</option>
                            <option value="Summer">Summer</option>
                            <option value="Fall">Fall</option>
                            <option value="Winter">Winter</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="adminFilterModality" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Modality</label>
                        <select id="adminFilterModality" onchange="onAdminModalityFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                            <option value="">All Modalities</option>
                            <option value="in-person">In-Person</option>
                            <option value="online">Online</option>
                            <option value="hybrid">Hybrid</option>
                        </select>
                    </div>
                    
                    <div class="filter-group" style="align-self: flex-end;">
                        <button onclick="clearAdminFilters()" class="btn-secondary" style="padding: 0.5rem 1rem;">Clear Filters</button>
                    </div>
                    
                    <div class="filter-group" style="align-self: flex-end;">
                        <button onclick="testTableRenderingWithMockData()" style="padding: 0.5rem 1rem; background: #28a745; color: white; border: none; border-radius: 0.25rem; cursor: pointer;">üß™ Test Table</button>
                    </div>
                </div>
                
                <!-- Admin Results Info -->
                <div id="adminFilterResultsInfo" style="margin-bottom: 1rem; color: var(--text-light); font-size: 0.9rem;">
                    Loading department courses...
                </div>
                
                <!-- Admin Data Table -->
                <div id="adminCoursesTableContainer" style="overflow-x: auto;">
                    <table id="adminCoursesTable" class="data-table">
                        <thead>
                            <tr>
                                <th onclick="sortAdminTableBy('name')">Course Name</th>
                                <th onclick="sortAdminTableBy('code')">Code</th>
                                <th onclick="sortAdminTableBy('instructor')">Instructor</th>
                                <th onclick="sortAdminTableBy('semester')">Semester/Year</th>
                                <th onclick="sortAdminTableBy('modality')">Modality</th>
                                <th onclick="sortAdminTableBy('students')">Students</th>
                                <th onclick="sortAdminTableBy('evaluations')">Evaluations</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="adminCoursesTableBody">
                            <!-- Populated dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- INSTRUCTOR FILTERS SECTION -->
            <div id="instructorFiltersSection" class="card" style="display: none; margin-top: 2rem;">
                <div class="card-header">üìö Filter My Courses</div>
                
                <!-- Instructor Filter Controls -->
                <div id="instructorFilters" class="filter-controls" style="display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 1.5rem;">
                    <div class="filter-group">
                        <label for="instructorFilterCourse" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Course Name</label>
                        <select id="instructorFilterCourse" onchange="onInstructorCourseFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; min-width: 200px;">
                            <option value="">All Courses</option>
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="instructorFilterSemester" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Semester</label>
                        <select id="instructorFilterSemester" onchange="onInstructorSemesterFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                            <option value="">All Semesters</option>
                            <option value="Spring">Spring</option>
                            <option value="Summer">Summer</option>
                            <option value="Fall">Fall</option>
                            <option value="Winter">Winter</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="instructorFilterYear" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Year</label>
                        <select id="instructorFilterYear" onchange="onInstructorYearFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                            <option value="">All Years</option>
                            <option value="2026">2026</option>
                            <option value="2025">2025</option>
                            <option value="2024">2024</option>
                        </select>
                    </div>
                    
                    <div class="filter-group" style="align-self: flex-end;">
                        <button onclick="clearInstructorFilters()" class="btn-secondary" style="padding: 0.5rem 1rem;">Clear Filters</button>
                    </div>
                </div>
            </div>

            <!-- Create Class Form -->
            <div id="createClassCard" class="card hidden">
                <div class="card-header">Create New Class</div>
                <form id="createClassForm">
                    <div class="form-group">
                        <label for="className">Class Name *</label>
                        <input type="text" id="className" required placeholder="e.g., CMST 210">
                    </div>
                    <div class="form-group">
                        <label for="classSemester">Semester</label>
                        <select id="classSemester">
                            <option value="Spring">Spring</option>
                            <option value="Summer">Summer</option>
                            <option value="Fall" selected>Fall</option>
                            <option value="Winter">Winter</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="classSection">Section</label>
                        <input type="text" id="classSection" placeholder="e.g., 001">
                    </div>
                    <div class="form-group">
                        <label for="classYear">Year</label>
                        <input type="number" id="classYear" value="2026">
                    </div>
                    <div class="form-group">
                        <label for="classNotes">Notes</label>
                        <textarea id="classNotes" placeholder="Optional notes about this class"></textarea>
                    </div>
                    <div style="display: flex; gap: 1rem;">
                        <button type="button" onclick="cancelCreateClass()" class="btn-secondary">Cancel</button>
                        <button type="submit">Create Class</button>
                    </div>
                </form>
            </div>

            <!-- Rubric Management -->
            <div class="card">
                <div class="card-header">üìã My Rubrics</div>
                
                <!-- Course Filter -->
                <div style="margin-bottom: 1rem;">
                    <label for="courseFilter" style="font-weight: 500; margin-bottom: 0.5rem; display: block;">Filter by Course:</label>
                    <select id="courseFilter" onchange="filterRubricsByCourse()" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                        <option value="">All Courses</option>
                        <!-- Will be populated dynamically -->
                    </select>
                </div>
                
                <div style="margin-bottom: 1.5rem; display: flex; gap: 1rem;">
                    <button onclick="showCreateRubric()">‚ûï Create Custom Rubric</button>
                    <button onclick="showUploadRubric()" style="background: var(--secondary);">üìÑ Upload Rubric (PDF/Image)</button>
                </div>
                <div id="rubricsList" class="rubrics-list"></div>
            </div>

            <!-- Create/Edit Rubric Form -->
            <div id="createRubricCard" class="card hidden">
                <div class="card-header" id="rubricFormHeader">Create Custom Rubric</div>
                <form id="createRubricForm">
                    <input type="hidden" id="editingRubricId" value="">
                    
                    <!-- Basic Info -->
                    <h4 style="margin-bottom: 1rem; color: var(--primary);">Basic Information</h4>
                    <div class="form-group">
                        <label for="rubricName">Rubric Name *</label>
                        <input type="text" id="rubricName" placeholder="e.g., Persuasive Speech" required>
                    </div>
                    <div class="form-group">
                        <label for="rubricDescription">Description</label>
                        <textarea id="rubricDescription" placeholder="Brief description of this rubric..."></textarea>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                        <div class="form-group">
                            <label for="rubricTotalPoints">Total Points *</label>
                            <input type="number" id="rubricTotalPoints" value="50" min="1" required>
                        </div>
                        <div class="form-group">
                            <label for="rubricSpeechType">Speech Type</label>
                            <input type="text" id="rubricSpeechType" placeholder="e.g., Persuasive, Informative">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Associated Courses (Optional)</label>
                        <p style="font-size: 0.9rem; color: var(--text-light); margin-bottom: 0.5rem;">
                            Select one or more courses/sections. This helps organize your rubrics and makes them easier to find during evaluation.
                        </p>
                        <div id="rubricCoursesContainer" style="max-height: 200px; overflow-y: auto; border: 1px solid var(--border); border-radius: 0.25rem; padding: 0.75rem; background: white;">
                            <!-- Will be populated with checkboxes dynamically -->
                            <p style="color: var(--text-light); text-align: center;">No courses available. Create courses in "My Classes" first.</p>
                        </div>
                    </div>

                    <!-- Grade Scale -->
                    <h4 style="margin: 1.5rem 0 1rem; color: var(--primary);">Grade Scale</h4>
                    <p style="font-size: 0.9rem; color: var(--text-light); margin-bottom: 1rem;">
                        Define what percentage of maximum points each grade represents:
                    </p>
                    <div style="display: grid; gap: 0.5rem; margin-bottom: 1.5rem;">
                        <div style="display: grid; grid-template-columns: auto 1fr 1fr 1fr; gap: 0.5rem; align-items: center;">
                            <strong style="font-size: 0.9rem;">Grade</strong>
                            <strong style="font-size: 0.9rem;">Label</strong>
                            <strong style="font-size: 0.9rem;">Percentage</strong>
                            <strong style="font-size: 0.9rem;">Range</strong>
                        </div>
                        <div style="display: grid; grid-template-columns: auto 1fr 1fr 1fr; gap: 0.5rem; align-items: center;">
                            <span style="font-weight: 600;">A</span>
                            <input type="text" id="gradeA_label" value="Professional" style="padding: 0.4rem;">
                            <input type="number" id="gradeA_pct" value="100" min="0" max="100" style="padding: 0.4rem;">
                            <input type="text" id="gradeA_range" value="100-91" style="padding: 0.4rem;">
                        </div>
                        <div style="display: grid; grid-template-columns: auto 1fr 1fr 1fr; gap: 0.5rem; align-items: center;">
                            <span style="font-weight: 600;">B</span>
                            <input type="text" id="gradeB_label" value="Proficient" style="padding: 0.4rem;">
                            <input type="number" id="gradeB_pct" value="90" min="0" max="100" style="padding: 0.4rem;">
                            <input type="text" id="gradeB_range" value="90-81" style="padding: 0.4rem;">
                        </div>
                        <div style="display: grid; grid-template-columns: auto 1fr 1fr 1fr; gap: 0.5rem; align-items: center;">
                            <span style="font-weight: 600;">C</span>
                            <input type="text" id="gradeC_label" value="Developing" style="padding: 0.4rem;">
                            <input type="number" id="gradeC_pct" value="80" min="0" max="100" style="padding: 0.4rem;">
                            <input type="text" id="gradeC_range" value="80-71" style="padding: 0.4rem;">
                        </div>
                        <div style="display: grid; grid-template-columns: auto 1fr 1fr 1fr; gap: 0.5rem; align-items: center;">
                            <span style="font-weight: 600;">D</span>
                            <input type="text" id="gradeD_label" value="Unprofessional" style="padding: 0.4rem;">
                            <input type="number" id="gradeD_pct" value="70" min="0" max="100" style="padding: 0.4rem;">
                            <input type="text" id="gradeD_range" value="70-61" style="padding: 0.4rem;">
                        </div>
                        <div style="display: grid; grid-template-columns: auto 1fr 1fr 1fr; gap: 0.5rem; align-items: center;">
                            <span style="font-weight: 600;">F</span>
                            <input type="text" id="gradeF_label" value="Unacceptable" style="padding: 0.4rem;">
                            <input type="number" id="gradeF_pct" value="60" min="0" max="100" style="padding: 0.4rem;">
                            <input type="text" id="gradeF_range" value="60-0" style="padding: 0.4rem;">
                        </div>
                    </div>

                    <!-- Categories -->
                    <h4 style="margin: 1.5rem 0 1rem; color: var(--primary);">Categories & Subcategories</h4>
                    <div id="categoriesContainer"></div>
                    <button type="button" onclick="addCategory()" class="btn-secondary" style="margin-top: 1rem;">‚ûï Add Category</button>

                    <!-- Action Buttons -->
                    <div style="display: flex; gap: 1rem; margin-top: 2rem; padding-top: 1.5rem; border-top: 2px solid var(--border);">
                        <button type="button" onclick="cancelCreateRubric()" class="btn-secondary">Cancel</button>
                        <button type="submit" id="rubricSubmitBtn">Create Rubric</button>
                    </div>
                </form>
            </div>
        </section>

        <!-- Settings Section -->
        <section id="settingsSection" class="section">
            <div class="card">
                <div class="card-header">‚öôÔ∏è Settings</div>
                
                <div class="form-group">
                    <label for="tenantSelect">University / Theme</label>
                    <select id="tenantSelect" onchange="switchTenant(this.value)">
                        <option value="default">Generic / Default</option>
                        <option value="utk">University of Tennessee, Knoxville</option>
                    </select>
                </div>

                <div style="margin-top: 2rem;">
                    <h3 style="margin-bottom: 1rem;">üîë API Keys</h3>
                    <p style="font-size: 0.9rem; color: var(--text-light); margin-bottom: 1.5rem;">
                        Save your API keys here so you don't have to enter them every time. Keys are stored securely in your browser.
                    </p>

                    <div class="form-group">
                        <label for="savedGeminiKey">
                            <strong>Google Gemini API Key</strong>
                            <span style="color: var(--text-light); font-weight: normal; margin-left: 0.5rem;">(Recommended - Full video analysis)</span>
                        </label>
                        <input type="password" id="savedGeminiKey" placeholder="AIza...">
                        <p style="font-size: 0.9rem; color: var(--text-light); margin-top: 0.5rem;">
                            Get your key at: <a href="https://aistudio.google.com/app/apikey" target="_blank" style="color: var(--primary);">aistudio.google.com/app/apikey</a>
                        </p>
                    </div>

                    <div class="form-group">
                        <label for="savedOpenAIKey">
                            <strong>OpenAI API Key</strong>
                            <span style="color: var(--text-light); font-weight: normal; margin-left: 0.5rem;">(Good for image analysis)</span>
                        </label>
                        <input type="password" id="savedOpenAIKey" placeholder="sk-proj-...">
                        <p style="font-size: 0.9rem; color: var(--text-light); margin-top: 0.5rem;">
                            Get your key at: <a href="https://platform.openai.com/api-keys" target="_blank" style="color: var(--primary);">platform.openai.com/api-keys</a>
                        </p>
                    </div>

                    <div class="form-group">
                        <label for="savedClaudeKey">
                            <strong>Anthropic Claude API Key</strong>
                            <span style="color: var(--text-light); font-weight: normal; margin-left: 0.5rem;">(Audio transcription only)</span>
                        </label>
                        <input type="password" id="savedClaudeKey" placeholder="sk-ant-...">
                        <p style="font-size: 0.9rem; color: var(--text-light); margin-top: 0.5rem;">
                            Get your key at: <a href="https://console.anthropic.com/" target="_blank" style="color: var(--primary);">console.anthropic.com</a>
                        </p>
                    </div>
                </div>

                <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                    <button onclick="saveSettings()">üíæ Save Settings</button>
                </div>

                <div id="settingsMessage" class="hidden"></div>
            </div>
        </section>

        <!-- Class Detail Section (Simple) -->
        <section id="classDetailSection" class="section">
            <div class="card">
                <div class="card-header">
                    <span id="classDetailTitle">Class Details</span>
                    <button onclick="showDashboard()">‚Üê Back to Dashboard</button>
                </div>
                
                <div id="classDetailContent"></div>
            </div>
            
            <!-- Add Student Form -->
            <div id="addStudentCard" class="card hidden">
                <div class="card-header">Add Student</div>
                <form id="addStudentForm">
                    <div class="form-group">
                        <label for="studentFirstName">First Name *</label>
                        <input type="text" id="studentFirstName" required>
                    </div>
                    <div class="form-group">
                        <label for="studentLastName">Last Name *</label>
                        <input type="text" id="studentLastName" required>
                    </div>
                    <div class="form-group">
                        <label for="studentEmailAdd">Email</label>
                        <input type="email" id="studentEmailAdd">
                    </div>
                    <div class="form-group">
                        <label for="studentIdAdd">Student ID (optional)</label>
                        <input type="text" id="studentIdAdd">
                    </div>
                    <div style="display: flex; gap: 1rem;">
                        <button type="button" onclick="cancelAddStudent()" class="btn-secondary">Cancel</button>
                        <button type="submit">Add Student</button>
                    </div>
                </form>
            </div>
        </section>

        <!-- Upload Rubric Form -->
        <div id="uploadRubricCard" class="card hidden" style="margin-top: 2rem;">
            <div class="card-header">üìÑ Upload Rubric from PDF or Image</div>
            <div style="background: #e3f2fd; padding: 1rem; border-radius: 0.5rem; margin-bottom: 1.5rem; border-left: 4px solid #2196f3;">
                <strong>üìã How it works:</strong>
                <p style="margin: 0.5rem 0 0 0;">Upload a PDF or image of your rubric, and AI will extract the categories, criteria, and point values to create a digital rubric automatically.</p>
            </div>
            
            <form id="uploadRubricForm">
                <div class="form-group">
                    <label for="uploadRubricFile">Upload Rubric File *</label>
                    <input 
                        type="file" 
                        id="uploadRubricFile" 
                        accept=".pdf,.png,.jpg,.jpeg,.webp" 
                        required
                        style="width: 100%; padding: 0.75rem; border: 2px dashed var(--border); border-radius: 0.5rem; background: var(--bg);"
                    >
                    <small style="color: var(--text-light); display: block; margin-top: 0.5rem;">
                        Supported formats: PDF, PNG, JPG, JPEG, WebP (max 10MB)
                    </small>
                </div>
                
                <div class="form-group">
                    <label for="uploadRubricName">Rubric Name *</label>
                    <input 
                        type="text" 
                        id="uploadRubricName" 
                        placeholder="e.g., Persuasive Speech Rubric" 
                        required
                    >
                </div>
                
                <div class="form-group">
                    <label for="uploadAiProvider">AI Provider for Extraction *</label>
                    <select id="uploadAiProvider" required>
                        <option value="">-- Select AI Provider --</option>
                        <option value="gemini">Google Gemini (Recommended - Free)</option>
                        <option value="gpt4o">OpenAI GPT-4o (Supports images)</option>
                        <option value="claude">Anthropic Claude (Best accuracy)</option>
                    </select>
                </div>
                
                <div class="form-group" id="uploadApiKeyGroup">
                    <label for="uploadApiKey" id="uploadApiKeyLabel">API Key *</label>
                    <input 
                        type="password" 
                        id="uploadApiKey" 
                        placeholder="Enter your API key"
                    >
                    <small style="color: var(--text-light); display: block; margin-top: 0.5rem;">
                        Your API key will be used to process the rubric. You can save it in Settings for future use.
                    </small>
                </div>
                
                <div id="uploadProgress" class="hidden" style="margin: 1.5rem 0; padding: 1rem; background: var(--bg); border-radius: 0.5rem;">
                    <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem;">
                        <div class="spinner"></div>
                        <span id="uploadProgressText">Processing rubric...</span>
                    </div>
                    <div style="background: white; height: 8px; border-radius: 4px; overflow: hidden;">
                        <div id="uploadProgressBar" style="width: 0%; height: 100%; background: var(--primary); transition: width 0.3s;"></div>
                    </div>
                </div>
                
                <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                    <button type="button" onclick="cancelUploadRubric()">Cancel</button>
                    <button type="submit" style="background: var(--primary);">üöÄ Extract & Create Rubric</button>
                </div>
            </form>
        </div>

        <!-- Help Section -->
        <section id="helpSection" class="section">
            <div class="card">
                <div class="card-header">‚ùì Help & Documentation</div>
                
                <h3 style="margin-bottom: 1rem;">Getting Started</h3>
                <p style="margin-bottom: 2rem;">
                    Speech Gradebook uses AI to automatically evaluate speech recordings based on customizable rubrics. 
                    Simply upload your speech file, provide student details, and let our AI analyze the content and delivery.
                </p>

                <h3 style="margin-bottom: 1rem;">How to Evaluate a Speech</h3>
                <ol style="margin-bottom: 2rem; padding-left: 1.5rem;">
                    <li style="margin-bottom: 0.5rem;">Click "Evaluate Speech" in the navigation</li>
                    <li style="margin-bottom: 0.5rem;">Upload your audio or video file</li>
                    <li style="margin-bottom: 0.5rem;">Enter student details and your Anthropic API key</li>
                    <li style="margin-bottom: 0.5rem;">Click "Continue to Evaluation" and wait for AI analysis</li>
                    <li style="margin-bottom: 0.5rem;">Review results, download PDF, or email to student</li>
                </ol>

                <h3 style="margin-bottom: 1rem;">Getting an API Key</h3>
                <p style="margin-bottom: 2rem;">
                    You'll need an Anthropic API key to use this service:
                </p>
                <ol style="margin-bottom: 2rem; padding-left: 1.5rem;">
                    <li style="margin-bottom: 0.5rem;">Visit <a href="https://console.anthropic.com" target="_blank" style="color: var(--primary);">console.anthropic.com</a></li>
                    <li style="margin-bottom: 0.5rem;">Sign up or log in to your account</li>
                    <li style="margin-bottom: 0.5rem;">Navigate to API Keys section</li>
                    <li style="margin-bottom: 0.5rem;">Generate a new API key</li>
                    <li style="margin-bottom: 0.5rem;">Save it in Settings to avoid re-entering it</li>
                </ol>

                <h3 style="margin-bottom: 1rem;">Managing Classes</h3>
                <p style="margin-bottom: 2rem;">
                    Use the Dashboard to create and manage your classes. Track students, assignments, and evaluation history 
                    all in one place. All data is stored locally in your browser.
                </p>

                <h3 style="margin-bottom: 1rem;">Custom Rubrics</h3>
                <p style="margin-bottom: 2rem;">
                    Create custom rubrics tailored to your specific assignment requirements. The AI will evaluate speeches 
                    based on your rubric criteria and provide detailed feedback.
                </p>

                <h3 style="margin-bottom: 1rem;">Support</h3>
                <p>
                    For questions or technical support, contact: <strong id="supportEmail"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7c0f090c0c130e083c0f0c19191f141b0e1d18191e131317521f1311">[email&#160;protected]</a></strong>
                </p>
            </div>
        </section>

        <!-- Admin Section -->
        <section id="adminSection" class="section">
            <div class="card">
                <div class="card-header">‚öôÔ∏è Admin Panel</div>
                
                <!-- Department Instructors Section (for Admins) -->
                <div id="departmentInstructorsSection" style="margin-bottom: 3rem;">
                    <h3 style="margin-bottom: 1rem;">üèõÔ∏è Department Instructors</h3>
                    <p style="margin-bottom: 1rem; color: var(--text-light);">
                        View and manage instructors in your department.
                    </p>
                    
                    <div style="margin-bottom: 2rem; display: flex; gap: 1rem; align-items: center;">
                        <button onclick="loadDepartmentInstructors()">üîÑ Refresh Instructors</button>
                        
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <label for="semesterFilter" style="font-weight: 600;">Filter by Semester:</label>
                            <select id="semesterFilter" onchange="filterBySemester()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                <option value="all">All Semesters</option>
                                <option value="Fall 2024">Fall 2024</option>
                                <option value="Spring 2025">Spring 2025</option>
                                <option value="Fall 2025">Fall 2025</option>
                                <option value="Spring 2026">Spring 2026</option>
                            </select>
                        </div>
                    </div>
                    
                    <div id="departmentInstructorsContainer">
                        <p style="color: var(--text-light);">Click "Refresh Instructors" to load your department's instructors...</p>
                    </div>
                </div>
                
                <!-- Department Analytics Section (for Admins) -->
                <div id="departmentAnalyticsSection" style="margin-bottom: 3rem;">
                    <h3 style="margin-bottom: 1rem;">üìä Department Analytics</h3>
                    <p style="margin-bottom: 1rem; color: var(--text-light);">
                        Comprehensive analytics with drill-down capabilities from department-wide to individual evaluations.
                    </p>
                    
                    <!-- Analytics Controls -->
                    <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 2rem;">
                        <div style="display: flex; gap: 1rem; flex-wrap: wrap; align-items: flex-end;">
                            <!-- Load/Export -->
                            <div style="display: flex; gap: 0.5rem;">
                                <button onclick="loadEnhancedAnalytics()" style="background: var(--primary);">üìà Load Analytics</button>
                                <button onclick="exportDepartmentData()" style="background: var(--success);">üíæ Export CSV</button>
                            </div>
                            
                            <!-- Date Range -->
                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                <label style="font-weight: 600; font-size: 0.9rem;">Date Range:</label>
                                <input type="date" id="analyticsStartDate" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; font-size: 0.9rem;">
                                <span style="color: var(--text-light);">to</span>
                                <input type="date" id="analyticsEndDate" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; font-size: 0.9rem;">
                            </div>
                            
                            <!-- Filters -->
                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                <label style="font-weight: 600; font-size: 0.9rem;">Filter:</label>
                                <select id="analyticsInstructorFilter" onchange="filterAnalytics()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; font-size: 0.9rem;">
                                    <option value="all">All Instructors</option>
                                </select>
                                <select id="analyticsCourseFilter" onchange="filterAnalytics()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; font-size: 0.9rem;">
                                    <option value="all">All Courses</option>
                                </select>
                            </div>
                            
                            <!-- Search -->
                            <div style="display: flex; gap: 0.5rem; align-items: center; flex: 1; min-width: 200px;">
                                <label style="font-weight: 600; font-size: 0.9rem;">Search:</label>
                                <input type="text" id="analyticsSearch" placeholder="Student name, course..." 
                                       onkeyup="searchEvaluations()" 
                                       style="flex: 1; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; font-size: 0.9rem;">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Analytics Tabs -->
                    <div style="display: flex; gap: 0.5rem; margin-bottom: 1.5rem; border-bottom: 2px solid var(--border);">
                        <button id="tabOverview" onclick="switchAnalyticsTab('overview')" 
                                style="padding: 0.75rem 1.5rem; border: none; background: none; cursor: pointer; border-bottom: 3px solid var(--primary); font-weight: 600; color: var(--primary);">
                            Overview
                        </button>
                        <button id="tabRubrics" onclick="switchAnalyticsTab('rubrics')" 
                                style="padding: 0.75rem 1.5rem; border: none; background: none; cursor: pointer; border-bottom: 3px solid transparent; color: var(--text-light);">
                            Rubric Analysis
                        </button>
                        <button id="tabComparisons" onclick="switchAnalyticsTab('comparisons')" 
                                style="padding: 0.75rem 1.5rem; border: none; background: none; cursor: pointer; border-bottom: 3px solid transparent; color: var(--text-light);">
                            Comparisons
                        </button>
                        <button id="tabEvaluations" onclick="switchAnalyticsTab('evaluations')" 
                                style="padding: 0.75rem 1.5rem; border: none; background: none; cursor: pointer; border-bottom: 3px solid transparent; color: var(--text-light);">
                            All Evaluations
                        </button>
                    </div>
                    
                    <!-- Analytics Content -->
                    <div id="analyticsOverviewTab" style="display: block;">
                        <p style="color: var(--text-light);">Click "Load Analytics" to view department statistics...</p>
                    </div>
                    
                    <div id="analyticsRubricsTab" style="display: none;">
                        <p style="color: var(--text-light);">Rubric analysis will appear here...</p>
                    </div>
                    
                    <div id="analyticsComparisonsTab" style="display: none;">
                        <p style="color: var(--text-light);">Comparison data will appear here...</p>
                    </div>
                    
                    <div id="analyticsEvaluationsTab" style="display: none;">
                        <p style="color: var(--text-light);">Evaluation list will appear here...</p>
                    </div>
                </div>
                
                <!-- Theme Customizer Section (for Admins and Super Admins) -->
                <div id="themeCustomizerSection" style="margin-bottom: 3rem;">
                    <h3 style="margin-bottom: 1rem;">üé® Theme Customizer</h3>
                    <p style="margin-bottom: 1rem; color: var(--text-light);">
                        Customize your institution's colors, branding, and typography. Changes apply to all users in your institution.
                    </p>
                    
                    <div style="background: var(--bg-alt); padding: 2rem; border-radius: 0.5rem;">
                        
                        <!-- Institution Logo -->
                        <div style="margin-bottom: 2rem; padding-bottom: 2rem; border-bottom: 1px solid var(--border);">
                            <h4 style="margin-bottom: 1rem;">Institution Logo</h4>
                            <div style="display: flex; gap: 2rem; align-items: center;">
                                <div>
                                    <div id="logoPreview" style="width: 100px; height: 100px; border-radius: 50%; background: white; display: flex; align-items: center; justify-content: center; border: 2px solid var(--border); overflow: hidden;">
                                        <span id="logoPlaceholder" style="font-size: 2rem; font-weight: bold; color: var(--primary);">LOGO</span>
                                        <img id="logoPreviewImage" style="width: 100%; height: 100%; object-fit: cover; display: none;">
                                    </div>
                                </div>
                                <div style="flex: 1;">
                                    <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Upload Logo Image</label>
                                    <input type="file" id="institutionLogoUpload" accept="image/*" 
                                           onchange="handleLogoUpload(event)"
                                           style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; width: 100%;">
                                    <p style="margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-light);">
                                        Recommended: Square image, at least 200x200px. Will be displayed as a circle.
                                    </p>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Color Settings -->
                        <div style="margin-bottom: 2rem; padding-bottom: 2rem; border-bottom: 1px solid var(--border);">
                            <h4 style="margin-bottom: 1rem;">Institution Colors</h4>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem;">
                                <!-- Primary Color -->
                                <div>
                                    <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Primary Color (Buttons)</label>
                                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                                        <input type="color" id="themePrimaryColor" value="#FF8200" 
                                               style="width: 60px; height: 40px; border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">
                                        <input type="text" id="themePrimaryText" value="#FF8200" 
                                               style="flex: 1; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                    </div>
                                </div>
                                
                                <!-- Header Background -->
                                <div>
                                    <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Header Background</label>
                                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                                        <input type="color" id="themeHeaderColor" value="#4B4B4B" 
                                               style="width: 60px; height: 40px; border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">
                                        <input type="text" id="themeHeaderText" value="#4B4B4B" 
                                               style="flex: 1; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                    </div>
                                </div>
                                
                                <!-- Secondary Color -->
                                <div>
                                    <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Secondary Color</label>
                                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                                        <input type="color" id="themeSecondaryColor" value="#4B4B4B" 
                                               style="width: 60px; height: 40px; border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">
                                        <input type="text" id="themeSecondaryText" value="#4B4B4B" 
                                               style="flex: 1; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                    </div>
                                </div>
                                
                                <!-- Text Color -->
                                <div>
                                    <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Primary Text</label>
                                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                                        <input type="color" id="themeTextColor" value="#4B4B4B" 
                                               style="width: 60px; height: 40px; border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">
                                        <input type="text" id="themeTextText" value="#4B4B4B" 
                                               style="flex: 1; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Typography Settings -->
                        <div style="margin-bottom: 2rem; padding-bottom: 2rem; border-bottom: 1px solid var(--border);">
                            <h4 style="margin-bottom: 1rem;">Typography</h4>
                            
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin-bottom: 1.5rem;">
                                <!-- Heading Font -->
                                <div>
                                    <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Heading Font</label>
                                    <select id="themeHeadingFont" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                        <option value="'Inter', -apple-system, sans-serif">Inter (Default)</option>
                                        <option value="'Crimson Pro', serif">Crimson Pro (Serif)</option>
                                        <option value="'Montserrat', sans-serif">Montserrat</option>
                                        <option value="'Roboto', sans-serif">Roboto</option>
                                        <option value="'Open Sans', sans-serif">Open Sans</option>
                                        <option value="'Lato', sans-serif">Lato</option>
                                        <option value="'Poppins', sans-serif">Poppins</option>
                                        <option value="'Raleway', sans-serif">Raleway</option>
                                        <option value="'Playfair Display', serif">Playfair Display</option>
                                        <option value="'Georgia', serif">Georgia</option>
                                    </select>
                                </div>
                                
                                <!-- Body Font -->
                                <div>
                                    <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Body Font</label>
                                    <select id="themeBodyFont" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                        <option value="'Inter', -apple-system, sans-serif">Inter (Default)</option>
                                        <option value="'Work Sans', sans-serif">Work Sans</option>
                                        <option value="'Roboto', sans-serif">Roboto</option>
                                        <option value="'Open Sans', sans-serif">Open Sans</option>
                                        <option value="'Lato', sans-serif">Lato</option>
                                        <option value="'Source Sans Pro', sans-serif">Source Sans Pro</option>
                                        <option value="'Noto Sans', sans-serif">Noto Sans</option>
                                        <option value="'Georgia', serif">Georgia</option>
                                        <option value="'Times New Roman', serif">Times New Roman</option>
                                    </select>
                                </div>
                            </div>
                            
                            <!-- Custom Font Upload -->
                            <div style="background: var(--bg); padding: 1.5rem; border-radius: 0.5rem; border: 2px dashed var(--border);">
                                <h5 style="margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                                    <span>üì¶</span> Custom Font Packages
                                </h5>
                                <p style="font-size: 0.9rem; color: var(--text-light); margin-bottom: 1rem;">
                                    Upload your institution's official font files. Supported formats: WOFF2, WOFF, TTF, OTF
                                </p>
                                
                                <div style="margin-bottom: 1rem;">
                                    <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Font Family Name</label>
                                    <input type="text" id="customFontName" placeholder="e.g., UT Volunteer"
                                           style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                    <p style="font-size: 0.85rem; color: var(--text-light); margin-top: 0.25rem;">
                                        This is the display name that will appear in the font selector.
                                    </p>
                                </div>
                                
                                <div style="margin-bottom: 1rem;">
                                    <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Font Files</label>
                                    <input type="file" id="customFontFiles" accept=".woff2,.woff,.ttf,.otf" multiple
                                           style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                    <p style="font-size: 0.85rem; color: var(--text-light); margin-top: 0.25rem;">
                                        Select a folder or multiple font files. The system will automatically find and use only the Regular variant.
                                    </p>
                                    <div style="margin-top: 0.75rem; padding: 0.75rem; background: #fff3cd; border: 1px solid #ffc107; border-radius: 0.25rem;">
                                        <strong style="color: #856404;">‚ÑπÔ∏è Storage Optimization:</strong>
                                        <span style="color: #856404; font-size: 0.85rem;">
                                            Only the <strong>Regular</strong> (normal weight) font file will be saved to the database. 
                                            All Bold, Italic, and other variants will be discarded to save storage space.
                                        </span>
                                    </div>
                                </div>
                                
                                <button onclick="uploadCustomFont()" style="background: var(--secondary);">
                                    ‚¨ÜÔ∏è Upload Font Package
                                </button>
                                
                                <!-- Custom Fonts List -->
                                <div id="customFontsList" style="margin-top: 1rem; display: none;">
                                    <h6 style="margin-bottom: 0.5rem; font-weight: 600;">Installed Custom Fonts:</h6>
                                    <div id="customFontsContainer" style="display: flex; flex-direction: column; gap: 0.5rem;">
                                        <!-- Custom fonts will be listed here -->
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div style="display: flex; gap: 1rem; padding-top: 2rem; border-top: 1px solid var(--border);">
                            <button onclick="previewTheme()" style="background: var(--secondary);">üëÅÔ∏è Preview</button>
                            <button onclick="saveInstitutionTheme()" style="background: var(--success);">üíæ Save Theme</button>
                            <button onclick="resetThemeForm()" style="background: var(--error);">üîÑ Reset</button>
                        </div>
                        
                        <div id="themeStatus" style="margin-top: 1rem;"></div>
                    </div>
                </div>
                
                <!-- User Management Section (for Super Admins) -->
                <div id="userManagementSection">
                    <h3 style="margin-bottom: 1rem;">User Management</h3>
                    <p style="margin-bottom: 1rem; color: var(--text-light);">
                        Manage user account tiers and research partner access.
                    </p>
                    
                    <div style="margin-bottom: 2rem;">
                        <button onclick="loadAllUsers()" style="margin-right: 1rem;">üîÑ Refresh Users</button>
                        <button onclick="showInviteForm()" style="background: var(--success);">‚ûï Invite Research Partner</button>
                    </div>
                    
                    <div id="usersListContainer">
                        <p style="color: var(--text-light);">Click "Refresh Users" to load user list...</p>
                    </div>
                </div>
            </div>
            
            <!-- Invite Form (hidden by default) -->
            <div id="inviteFormCard" class="card hidden">
                <div class="card-header">Invite New Research Partner</div>
                <form id="inviteForm" onsubmit="sendInvite(event)">
                    <div class="form-group">
                        <label for="inviteEmail">Email Address *</label>
                        <input type="email" id="inviteEmail" required placeholder="instructor@university.edu">
                    </div>
                    <div class="form-group">
                        <label for="inviteName">Name</label>
                        <input type="text" id="inviteName" placeholder="Dr. Jane Smith">
                    </div>
                    <div class="form-group">
                        <label for="inviteInstitution">Institution</label>
                        <input type="text" id="inviteInstitution" placeholder="University Name">
                    </div>
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="inviteAutoApprove" checked>
                            Automatically grant Research Partner access
                        </label>
                    </div>
                    <div style="display: flex; gap: 1rem;">
                        <button type="button" onclick="cancelInvite()" class="btn-secondary">Cancel</button>
                        <button type="submit">Send Invitation</button>
                    </div>
                </form>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-links" id="footerLinks">
                    <a href="#">Privacy Policy</a>
                    <a href="#">Terms of Service</a>
                </div>
                <p id="footerCopyright">¬© 2026 Speech Gradebook</p>
                <p id="footerAdditional" style="opacity: 0.8; font-size: 0.9rem;"></p>
            </div>
        </div>
    </footer>

    <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>
        // ===== SUPABASE CONFIGURATION =====
        const SUPABASE_URL = 'https://mqhbfefylpfqsbtrshpu.supabase.co';
        const SUPABASE_ANON_KEY = 'sb_publishable_dypr7H7lUg2JGsvewz3VTQ_uov-ty72';
        
        // Initialize Supabase client
        let supabaseClient = null;
        
        try {
            if (window.supabase) {
                supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log('‚úì Supabase client initialized');
            } else {
                console.warn('‚ö†Ô∏è Supabase library not loaded - using localStorage fallback');
            }
        } catch (error) {
            console.error('‚ùå Supabase initialization failed:', error);
            console.log('Using localStorage fallback mode');
        }
        
        // Test Supabase connection
        async function testSupabaseConnection() {
            if (!supabaseClient) {
                console.log('Supabase not available - running in offline mode');
                return false;
            }
            
            try {
                console.log('Testing Supabase connection...');
                const { data, error } = await supabaseClient
                    .from('organizations')
                    .select('name')
                    .limit(1);
                
                if (error) {
                    console.error('‚ùå Supabase connection failed:', error.message);
                    return false;
                } else {
                    console.log('‚úÖ Supabase connected successfully!');
                    if (data && data.length > 0) {
                        console.log('   Organization:', data[0].name);
                    }
                    return true;
                }
            } catch (error) {
                console.error('‚ùå Supabase test error:', error);
                return false;
            }
        }
        
        // ===== AUTHENTICATION FUNCTIONS =====
        
        let currentUser = null;
        let userTier = 'demo'; // 'demo', 'instructor', 'admin', or 'super_admin'
        let currentViewMode = 'own'; // 'own' (default), 'institution' (admin), 'all' (super_admin), 'demo'
        let currentInstitution = null;
        let currentInstitutionTheme = null; // Store loaded theme
        let cachedDepartmentInstructors = []; // Cache for semester filtering
        
        // User-scoped localStorage helpers
        // These ensure each user's data is isolated
        function getUserStorageKey(key) {
            if (!currentUser || !currentUser.id) {
                return `guest_${key}`; // Fallback for non-logged-in users
            }
            return `user_${currentUser.id}_${key}`;
        }
        
        function getUserItem(key) {
            return localStorage.getItem(getUserStorageKey(key));
        }
        
        function setUserItem(key, value) {
            return localStorage.setItem(getUserStorageKey(key), value);
        }
        
        function removeUserItem(key) {
            return localStorage.removeItem(getUserStorageKey(key));
        }
        
        // Switch view mode (admin and super admin only)
        function switchViewMode(mode) {
            if (!canManageUsers()) {
                alert('Only administrators can switch views');
                return;
            }
            
            console.log('=== SWITCHING VIEW MODE ===');
            console.log('From:', currentViewMode);
            console.log('To:', mode);
            console.log('User tier:', userTier);
            console.log('Institution:', currentInstitution?.name);
            
            currentViewMode = mode;
            
            // Save preference
            localStorage.setItem('adminViewMode', mode);
            
            console.log('‚úì View mode updated to:', currentViewMode);
            
            // Update UI based on mode
            updateViewMode();
            
            // Show notification
            const modeNames = {
                'own': 'üë§ My Courses',
                'institution': 'üèõÔ∏è Institution View',
                'all': 'üåê All Institutions',
                'demo': 'üé≠ Demo Mode'
            };
            showNotification(`Switched to ${modeNames[mode]}`, 'success');
            
            console.log('=== VIEW MODE SWITCH COMPLETE ===');
        }
        
        // Update UI based on current view mode
        function updateViewMode() {
            // Remove any existing mode banner
            const existingBanner = document.getElementById('viewModeBanner');
            if (existingBanner) {
                existingBanner.remove();
            }
            
            // Add mode banner for non-default views
            const header = document.querySelector('header .container');
            if (header && currentViewMode !== 'own') {
                const banner = document.createElement('div');
                banner.id = 'viewModeBanner';
                banner.style.cssText = 'background: var(--primary); color: white; padding: 0.75rem; text-align: center; font-weight: 600; border-radius: 0.5rem; margin-top: 0.5rem;';
                
                const modeInfo = {
                    'demo': 'üé≠ DEMO MODE - Testing functionality (localStorage only, no database)',
                    'institution': `üèõÔ∏è INSTITUTION VIEW - Viewing all courses at ${currentInstitution?.name || 'your institution'}`,
                    'all': 'üåê ALL INSTITUTIONS - System-wide view (Super Admin)'
                };
                
                banner.innerHTML = modeInfo[currentViewMode] || '';
                header.appendChild(banner);
            }
            
            // Reload data for current view
            loadClasses();
        }
        
        // ===== FILTER HANDLER FUNCTIONS (PHASE 2) =====
        
        // Super Admin Filter Handlers
        function onInstitutionFilterChange() {
            const value = document.getElementById('filterInstitution')?.value;
            console.log('üîç Institution filter changed:', value || 'All Institutions');
            
            // PHASE 5: Reload instructors for selected institution
            loadInstructorsForFilter(value);
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForSuperAdmin();
        }
        
        function onInstructorFilterChange() {
            const value = document.getElementById('filterInstructor')?.value;
            console.log('üîç Instructor filter changed:', value || 'All Instructors');
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForSuperAdmin();
        }
        
        function onYearFilterChange() {
            const value = document.getElementById('filterYear')?.value;
            console.log('üîç Year filter changed:', value || 'All Years');
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForSuperAdmin();
        }
        
        function onSemesterFilterChange() {
            const value = document.getElementById('filterSemester')?.value;
            console.log('üîç Semester filter changed:', value || 'All Semesters');
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForSuperAdmin();
        }
        
        function onModalityFilterChange() {
            const value = document.getElementById('filterModality')?.value;
            console.log('üîç Modality filter changed:', value || 'All Modalities');
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForSuperAdmin();
        }
        
        function onSearchFilterChange() {
            const value = document.getElementById('filterSearch')?.value;
            console.log('üîç Search filter changed:', value || '(empty)');
            
            // PHASE 5: Reload courses with new filter (with debounce would be better, but simple for now)
            loadFilteredCoursesForSuperAdmin();
        }
        
        function clearAllFilters() {
            console.log('üßπ Clearing all super admin filters');
            document.getElementById('filterInstitution').value = '';
            document.getElementById('filterInstructor').value = '';
            document.getElementById('filterYear').value = '';
            document.getElementById('filterSemester').value = '';
            document.getElementById('filterModality').value = '';
            document.getElementById('filterSearch').value = '';
            
            // PHASE 5: Reset instructor dropdown and reload all instructors
            loadInstructorsForFilter('');
            
            // PHASE 5: Reload courses without filters
            loadFilteredCoursesForSuperAdmin();
        }
        
        // Admin Filter Handlers
        function onAdminInstructorFilterChange() {
            const value = document.getElementById('adminFilterInstructor')?.value;
            console.log('üîç Admin instructor filter changed:', value || 'All Instructors');
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForAdmin();
        }
        
        function onAdminYearFilterChange() {
            const value = document.getElementById('adminFilterYear')?.value;
            console.log('üîç Admin year filter changed:', value || 'All Years');
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForAdmin();
        }
        
        function onAdminSemesterFilterChange() {
            const value = document.getElementById('adminFilterSemester')?.value;
            console.log('üîç Admin semester filter changed:', value || 'All Semesters');
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForAdmin();
        }
        
        function onAdminModalityFilterChange() {
            const value = document.getElementById('adminFilterModality')?.value;
            console.log('üîç Admin modality filter changed:', value || 'All Modalities');
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForAdmin();
        }
        
        function clearAdminFilters() {
            console.log('üßπ Clearing admin filters');
            document.getElementById('adminFilterInstructor').value = '';
            document.getElementById('adminFilterYear').value = '';
            document.getElementById('adminFilterSemester').value = '';
            document.getElementById('adminFilterModality').value = '';
            
            // PHASE 5: Reload all courses
            loadFilteredCoursesForAdmin();
        }
        
        // Instructor Filter Handlers
        function onInstructorCourseFilterChange() {
            const value = document.getElementById('instructorFilterCourse')?.value;
            console.log('üîç Instructor course filter changed:', value || 'All Courses');
            // TODO Phase 8: Load filtered courses
        }
        
        function onInstructorSemesterFilterChange() {
            const value = document.getElementById('instructorFilterSemester')?.value;
            console.log('üîç Instructor semester filter changed:', value || 'All Semesters');
            // TODO Phase 8: Load filtered courses
        }
        
        function onInstructorYearFilterChange() {
            const value = document.getElementById('instructorFilterYear')?.value;
            console.log('üîç Instructor year filter changed:', value || 'All Years');
            // TODO Phase 8: Load filtered courses
        }
        
        function clearInstructorFilters() {
            console.log('üßπ Clearing instructor filters');
            document.getElementById('instructorFilterCourse').value = '';
            document.getElementById('instructorFilterSemester').value = '';
            document.getElementById('instructorFilterYear').value = '';
            // TODO Phase 8: Reload all courses
        }
        
        // Table Sorting Placeholders
        function sortTableBy(column) {
            console.log('‚ÜïÔ∏è Sort super admin table by:', column);
            // TODO Phase 4: Implement table sorting
        }
        
        function sortAdminTableBy(column) {
            console.log('‚ÜïÔ∏è Sort admin table by:', column);
            // TODO Phase 4: Implement table sorting
        }
        
        // ===== TABLE RENDERING FUNCTIONS (PHASE 4) =====
        
        /**
         * Render courses in super admin table
         * @param {Array} courses - Array of course objects
         */
        function renderSuperAdminCoursesTable(courses) {
            console.log('üìä Rendering super admin table with', courses.length, 'courses');
            
            const table = document.getElementById('coursesTable');
            const tbody = document.getElementById('coursesTableBody');
            const resultsInfo = document.getElementById('filterResultsInfo');
            
            if (!tbody || !table || !resultsInfo) {
                console.error('Table elements not found');
                return;
            }
            
            // Update results info
            if (courses.length === 0) {
                resultsInfo.textContent = 'No courses found matching filters';
                table.style.display = 'none';
                return;
            }
            
            resultsInfo.textContent = `Showing ${courses.length} course${courses.length === 1 ? '' : 's'}`;
            table.style.display = 'table';
            
            // Build table rows
            tbody.innerHTML = courses.map(course => {
                const courseName = course.name || 'Untitled Course';
                const courseCode = course.code || course.section || 'N/A';
                const instructorName = course.instructor_name || 'Unknown';
                const institutionName = course.institution_name || 'Unknown';
                const semester = course.semester || 'N/A';
                const year = course.year || '';
                const semesterYear = `${semester} ${year}`.trim();
                const modality = course.modality || 'N/A';
                const studentCount = course.student_count || (course.roster ? course.roster.length : 0);
                const evalCount = course.evaluation_count || 0;
                const courseId = course.id || course.supabaseId;
                
                return `
                    <tr>
                        <td><strong>${courseName}</strong></td>
                        <td>${courseCode}</td>
                        <td>${instructorName}</td>
                        <td>${institutionName}</td>
                        <td>${semesterYear}</td>
                        <td>${modality}</td>
                        <td>${studentCount}</td>
                        <td>${evalCount}</td>
                        <td>
                            <button onclick="viewCourse('${courseId}')" style="padding: 0.5rem 1rem; background: var(--primary); color: white; border: none; border-radius: 0.25rem; cursor: pointer; font-size: 0.9rem;">
                                View
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');
            
            console.log('‚úÖ Super admin table rendered');
        }
        
        /**
         * Render courses in admin table
         * @param {Array} courses - Array of course objects
         */
        function renderAdminCoursesTable(courses) {
            console.log('üìä Rendering admin table with', courses.length, 'courses');
            
            const table = document.getElementById('adminCoursesTable');
            const tbody = document.getElementById('adminCoursesTableBody');
            const resultsInfo = document.getElementById('adminFilterResultsInfo');
            
            if (!tbody || !table || !resultsInfo) {
                console.error('Admin table elements not found');
                return;
            }
            
            // Update results info
            if (courses.length === 0) {
                resultsInfo.textContent = 'No courses found in your department';
                tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; padding: 2rem; color: var(--text-light);">No courses found</td></tr>';
                return;
            }
            
            resultsInfo.textContent = `Showing ${courses.length} course${courses.length === 1 ? '' : 's'}`;
            
            // Build table rows
            tbody.innerHTML = courses.map(course => {
                const courseName = course.name || 'Untitled Course';
                const courseCode = course.code || course.section || 'N/A';
                const instructorName = course.instructor_name || 'Unknown';
                const semester = course.semester || 'N/A';
                const year = course.year || '';
                const semesterYear = `${semester} ${year}`.trim();
                const modality = course.modality || 'N/A';
                const studentCount = course.student_count || (course.roster ? course.roster.length : 0);
                const evalCount = course.evaluation_count || 0;
                const courseId = course.id || course.supabaseId;
                
                return `
                    <tr>
                        <td><strong>${courseName}</strong></td>
                        <td>${courseCode}</td>
                        <td>${instructorName}</td>
                        <td>${semesterYear}</td>
                        <td>${modality}</td>
                        <td>${studentCount}</td>
                        <td>${evalCount}</td>
                        <td>
                            <button onclick="viewCourse('${courseId}')" style="padding: 0.5rem 1rem; background: var(--primary); color: white; border: none; border-radius: 0.25rem; cursor: pointer; font-size: 0.9rem;">
                                View
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');
            
            console.log('‚úÖ Admin table rendered');
        }
        
        /**
         * Test table rendering with mock data (for Phase 4 testing only)
         */
        function testTableRenderingWithMockData() {
            console.log('üß™ Testing table rendering with mock data');
            
            const mockCourses = [
                {
                    id: '1',
                    name: 'Public Speaking 101',
                    code: 'CMST 210',
                    instructor_name: 'John Doe',
                    institution_name: 'University of Tennessee',
                    semester: 'Fall',
                    year: '2024',
                    modality: 'in-person',
                    student_count: 25,
                    evaluation_count: 12
                },
                {
                    id: '2',
                    name: 'Advanced Rhetoric',
                    code: 'CMST 340',
                    instructor_name: 'Jane Smith',
                    institution_name: 'University of Tennessee',
                    semester: 'Spring',
                    year: '2025',
                    modality: 'online',
                    student_count: 18,
                    evaluation_count: 8
                }
            ];
            
            // Test super admin table
            if (userTier === 'super_admin') {
                renderSuperAdminCoursesTable(mockCourses);
            }
            
            // Test admin table
            if (userTier === 'admin') {
                renderAdminCoursesTable(mockCourses);
            }
        }
        
        // ===== END TABLE RENDERING FUNCTIONS =====
        
        // ===== DATA LOADING FUNCTIONS (PHASE 5) =====
        
        /**
         * Load all institutions for super admin filter dropdown
         */
        async function loadInstitutionsForFilter() {
            if (!supabaseClient) return;
            
            console.log('üìä Loading institutions for filter...');
            
            try {
                const { data: institutions, error } = await supabaseClient
                    .from('institutions')
                    .select('id, name')
                    .order('name');
                
                if (error) {
                    console.error('Error loading institutions:', error);
                    return;
                }
                
                console.log('‚úÖ Loaded', institutions.length, 'institutions');
                
                // Populate institution dropdown
                const institutionSelect = document.getElementById('filterInstitution');
                if (institutionSelect) {
                    const options = institutions.map(inst => 
                        `<option value="${inst.id}">${inst.name}</option>`
                    ).join('');
                    institutionSelect.innerHTML = '<option value="">All Institutions</option>' + options;
                }
            } catch (error) {
                console.error('Error in loadInstitutionsForFilter:', error);
            }
        }
        
        /**
         * Load instructors for a specific institution
         */
        async function loadInstructorsForFilter(institutionId) {
            if (!supabaseClient) return;
            
            console.log('üìä Loading instructors for institution:', institutionId || 'All');
            
            try {
                let query = supabaseClient
                    .from('user_profiles')
                    .select('id, first_name, last_name, institution_id');
                
                // Filter by institution if specified
                if (institutionId) {
                    query = query.eq('institution_id', institutionId);
                }
                
                query = query.order('last_name');
                
                const { data: instructors, error } = await query;
                
                if (error) {
                    console.error('Error loading instructors:', error);
                    return;
                }
                
                console.log('‚úÖ Loaded', instructors.length, 'instructors');
                
                // Populate instructor dropdown
                const instructorSelect = document.getElementById('filterInstructor');
                if (instructorSelect) {
                    const options = instructors.map(inst => {
                        const name = `${inst.first_name || ''} ${inst.last_name || ''}`.trim() || 'Unknown';
                        return `<option value="${inst.id}">${name}</option>`;
                    }).join('');
                    instructorSelect.innerHTML = '<option value="">All Instructors</option>' + options;
                }
            } catch (error) {
                console.error('Error in loadInstructorsForFilter:', error);
            }
        }
        
        /**
         * Load instructors for admin (department only)
         */
        async function loadDepartmentInstructorsForFilter() {
            if (!supabaseClient || !currentUser) return;
            
            console.log('üìä Loading department instructors...');
            
            try {
                const { data: instructors, error } = await supabaseClient
                    .from('user_profiles')
                    .select('id, first_name, last_name')
                    .eq('institution_id', currentUser.institution_id)
                    .order('last_name');
                
                if (error) {
                    console.error('Error loading department instructors:', error);
                    return;
                }
                
                console.log('‚úÖ Loaded', instructors.length, 'department instructors');
                
                // Populate admin instructor dropdown
                const instructorSelect = document.getElementById('adminFilterInstructor');
                if (instructorSelect) {
                    const options = instructors.map(inst => {
                        const name = `${inst.first_name || ''} ${inst.last_name || ''}`.trim() || 'Unknown';
                        return `<option value="${inst.id}">${name}</option>`;
                    }).join('');
                    instructorSelect.innerHTML = '<option value="">All Instructors</option>' + options;
                }
            } catch (error) {
                console.error('Error in loadDepartmentInstructorsForFilter:', error);
            }
        }
        
        /**
         * Load courses with current filter settings (Super Admin)
         */
        async function loadFilteredCoursesForSuperAdmin() {
            if (!supabaseClient) return;
            
            console.log('=== LOADING FILTERED COURSES (SUPER ADMIN) ===');
            
            // Get filter values
            const institutionId = document.getElementById('filterInstitution')?.value;
            const instructorId = document.getElementById('filterInstructor')?.value;
            const year = document.getElementById('filterYear')?.value;
            const semester = document.getElementById('filterSemester')?.value;
            const modality = document.getElementById('filterModality')?.value;
            const searchTerm = document.getElementById('filterSearch')?.value;
            
            console.log('Filters:', { institutionId, instructorId, year, semester, modality, searchTerm });
            
            try {
                // Build base query - simpler join
                let query = supabaseClient
                    .from('courses')
                    .select('*');
                
                // Apply instructor filter directly
                if (instructorId) {
                    query = query.eq('instructor_id', instructorId);
                } else if (institutionId) {
                    // If filtering by institution but no specific instructor,
                    // we need to get all instructors in that institution first
                    const { data: instInstructors } = await supabaseClient
                        .from('user_profiles')
                        .select('id')
                        .eq('institution_id', institutionId);
                    
                    if (instInstructors && instInstructors.length > 0) {
                        const instructorIds = instInstructors.map(i => i.id);
                        query = query.in('instructor_id', instructorIds);
                    } else {
                        // No instructors in this institution, return empty
                        renderSuperAdminCoursesTable([]);
                        return;
                    }
                }
                
                // Apply other filters
                if (year) {
                    query = query.eq('year', parseInt(year));
                }
                
                if (semester) {
                    query = query.eq('semester', semester);
                }
                
                if (modality) {
                    query = query.eq('modality', modality);
                }
                
                if (searchTerm) {
                    query = query.or(`name.ilike.%${searchTerm}%,code.ilike.%${searchTerm}%`);
                }
                
                query = query.order('created_at', { ascending: false });
                
                const { data: courses, error } = await query;
                
                if (error) {
                    console.error('‚ùå Error loading courses:', error);
                    renderSuperAdminCoursesTable([]);
                    return;
                }
                
                console.log('‚úÖ Loaded', courses.length, 'courses');
                
                // Now get instructor and institution names separately
                if (courses.length > 0) {
                    const instructorIds = [...new Set(courses.map(c => c.instructor_id))];
                    
                    // Get user profiles with institution info
                    const { data: profiles } = await supabaseClient
                        .from('user_profiles')
                        .select('id, first_name, last_name, institution_id')
                        .in('id', instructorIds);
                    
                    // Get institutions
                    const institutionIds = [...new Set(profiles?.map(p => p.institution_id).filter(Boolean) || [])];
                    const { data: institutions } = await supabaseClient
                        .from('institutions')
                        .select('id, name')
                        .in('id', institutionIds);
                    
                    // Create lookup maps
                    const institutionMap = {};
                    institutions?.forEach(inst => {
                        institutionMap[inst.id] = inst.name;
                    });
                    
                    const profileMap = {};
                    profiles?.forEach(prof => {
                        profileMap[prof.id] = {
                            name: `${prof.first_name || ''} ${prof.last_name || ''}`.trim() || 'Unknown',
                            institution_id: prof.institution_id,
                            institution_name: institutionMap[prof.institution_id] || 'Unknown'
                        };
                    });
                    
                    // Transform courses with joined data
                    const transformedCourses = courses.map(course => ({
                        ...course,
                        instructor_name: profileMap[course.instructor_id]?.name || 'Unknown',
                        institution_name: profileMap[course.instructor_id]?.institution_name || 'Unknown',
                        student_count: 0 // We'll calculate this separately if needed
                    }));
                    
                    renderSuperAdminCoursesTable(transformedCourses);
                } else {
                    renderSuperAdminCoursesTable([]);
                }
            } catch (error) {
                console.error('‚ùå Error in loadFilteredCoursesForSuperAdmin:', error);
                renderSuperAdminCoursesTable([]);
            }
        }
        
        /**
         * Load courses for admin (department only)
         */
        async function loadFilteredCoursesForAdmin() {
            if (!supabaseClient || !currentUser) return;
            
            console.log('=== LOADING FILTERED COURSES (ADMIN) ===');
            
            // Get filter values
            const instructorId = document.getElementById('adminFilterInstructor')?.value;
            const year = document.getElementById('adminFilterYear')?.value;
            const semester = document.getElementById('adminFilterSemester')?.value;
            const modality = document.getElementById('adminFilterModality')?.value;
            
            console.log('Filters:', { instructorId, year, semester, modality });
            
            try {
                // Get all users in this institution
                const { data: institutionUsers } = await supabaseClient
                    .from('user_profiles')
                    .select('id, first_name, last_name')
                    .eq('institution_id', currentUser.institution_id);
                
                const userIds = institutionUsers?.map(u => u.id) || [];
                
                // Create instructor name lookup
                const instructorMap = {};
                institutionUsers?.forEach(user => {
                    instructorMap[user.id] = `${user.first_name || ''} ${user.last_name || ''}`.trim() || 'Unknown';
                });
                
                // Build query without joins
                let query = supabaseClient
                    .from('courses')
                    .select('*')
                    .in('instructor_id', userIds);
                
                // Apply filters
                if (instructorId) {
                    query = query.eq('instructor_id', instructorId);
                }
                
                if (year) {
                    query = query.eq('year', parseInt(year));
                }
                
                if (semester) {
                    query = query.eq('semester', semester);
                }
                
                if (modality) {
                    query = query.eq('modality', modality);
                }
                
                query = query.order('created_at', { ascending: false });
                
                const { data: courses, error } = await query;
                
                if (error) {
                    console.error('‚ùå Error loading courses:', error);
                    renderAdminCoursesTable([]);
                    return;
                }
                
                console.log('‚úÖ Loaded', courses.length, 'courses');
                
                // Transform data for table rendering
                const transformedCourses = courses.map(course => ({
                    ...course,
                    instructor_name: instructorMap[course.instructor_id] || 'Unknown',
                    student_count: 0
                }));
                
                renderAdminCoursesTable(transformedCourses);
            } catch (error) {
                console.error('‚ùå Error in loadFilteredCoursesForAdmin:', error);
                renderAdminCoursesTable([]);
            }
        }
        
        // ===== END DATA LOADING FUNCTIONS =====
        
        // Load user's account tier from user_profiles table
        async function loadUserTier() {
            if (!currentUser || !supabaseClient) {
                userTier = 'demo';
                return;
            }
            
            try {
                // Fetch user profile with institution, department, and theme info
                const { data, error } = await supabaseClient
                    .from('user_profiles')
                    .select(`
                        account_tier,
                        is_admin,
                        is_super_admin,
                        institution_id,
                        department_id,
                        institutions (
                            id,
                            name,
                            domain
                        ),
                        departments (
                            id,
                            name,
                            description
                        )
                    `)
                    .eq('id', currentUser.id)
                    .single();
                
                if (error) {
                    console.warn('Could not load user profile:', error.message);
                    userTier = 'demo';
                } else if (data) {
                    userTier = data.account_tier || 'demo';
                    currentUser.is_admin = data.is_admin;
                    currentUser.is_super_admin = data.is_super_admin;
                    currentUser.institution_id = data.institution_id;
                    currentUser.department_id = data.department_id;
                    currentInstitution = data.institutions;
                    currentUser.department = data.departments;
                    
                    console.log('‚úì Account tier:', userTier, 
                        data.is_super_admin ? '(Super Admin)' : 
                        data.is_admin ? '(Admin)' : '(Instructor)',
                        currentInstitution ? `at ${currentInstitution.name}` : '');
                    
                    if (data.departments) {
                        console.log('‚úì Department:', data.departments.name);
                    }
                    
                    // Load institutional theme if user has an institution
                    if (currentUser.institution_id) {
                        await loadInstitutionalTheme(currentUser.institution_id);
                    }
                } else {
                    userTier = 'demo';
                }
            } catch (err) {
                console.error('Error loading tier:', err);
                userTier = 'demo';
            }
            
            // Route to appropriate interface (each interface handles its own UI setup)
            routeToInterface();
        }
        
        // Load institutional theme from database
        async function loadInstitutionalTheme(institutionId) {
            if (!supabaseClient) {
                console.log('‚ö†Ô∏è No Supabase client, skipping theme load');
                return;
            }
            
            if (!institutionId) {
                console.log('‚ö†Ô∏è No institution ID provided, skipping theme load');
                return;
            }
            
            console.log('=== LOADING THEME ===');
            console.log('Loading theme for institution_id:', institutionId);
            
            try {
                const { data, error } = await supabaseClient
                    .from('institution_themes')
                    .select('*')
                    .eq('institution_id', institutionId)
                    .single();
                
                if (error) {
                    console.log('‚ÑπÔ∏è No custom theme found for institution:', institutionId);
                    console.log('   Using default theme');
                    currentUser.theme = null;
                    currentInstitutionTheme = null;
                    return;
                }
                
                if (data) {
                    // CRITICAL: Verify institution_id matches what we requested
                    if (data.institution_id !== institutionId) {
                        console.error('‚ùå SECURITY: Theme institution mismatch!');
                        console.error('   Requested:', institutionId);
                        console.error('   Received:', data.institution_id);
                        currentUser.theme = null;
                        currentInstitutionTheme = null;
                        return;
                    }
                    
                    currentUser.theme = data;
                    currentInstitutionTheme = data; // Store globally
                    
                    console.log('‚úì Theme loaded successfully');
                    console.log('   Institution ID:', data.institution_id);
                    console.log('   Primary color:', data.primary_color);
                    console.log('   Header color:', data.header_bg_color);
                    console.log('   Has logo:', !!data.logo_url);
                    console.log('   Has custom fonts:', !!data.custom_fonts);
                    console.log('   Heading font:', data.font_heading || 'default');
                    console.log('   Body font:', data.font_body || 'default');
                    
                    // Apply theme to CSS immediately
                    applyThemeToCSS(data);
                    
                    // Apply fonts if set
                    if (data.font_heading || data.font_body) {
                        const root = document.documentElement;
                        if (data.font_heading) {
                            root.style.setProperty('--heading-font', data.font_heading);
                            console.log('‚úì Applied heading font:', data.font_heading);
                        }
                        if (data.font_body) {
                            root.style.setProperty('--body-font', data.font_body);
                            console.log('‚úì Applied body font:', data.font_body);
                        }
                    }
                    
                    // Load custom fonts if exists
                    if (data.custom_fonts) {
                        console.log('Loading custom fonts...');
                        loadCustomFontsOnStartup(data.custom_fonts);
                    }
                    
                    console.log('=== THEME LOAD COMPLETE ===');
                }
            } catch (err) {
                console.error('‚ùå Error loading theme:', err);
                currentUser.theme = null;
                currentInstitutionTheme = null;
            }
        }
        
        // Load custom fonts on startup (for all users)
        function loadCustomFontsOnStartup(customFontsData) {
            if (!customFontsData) return;
            
            let fonts = [];
            try {
                fonts = typeof customFontsData === 'string' ? JSON.parse(customFontsData) : customFontsData;
            } catch (e) {
                console.error('Error parsing custom fonts:', e);
                return;
            }
            
            if (!Array.isArray(fonts) || fonts.length === 0) return;
            
            // Inject font-face CSS for each font
            fonts.forEach(font => {
                injectFontFace(font);
            });
            
            console.log('‚úì Loaded', fonts.length, 'custom font(s)');
        }
        
        // Apply theme to CSS variables
        function applyThemeToCSS(theme) {
            if (!theme) return;
            
            const root = document.documentElement;
            
            console.log('üé® Applying theme to CSS...');
            
            // Apply colors to CSS variables
            if (theme.primary_color) {
                root.style.setProperty('--primary', theme.primary_color);
                root.style.setProperty('--primary-dark', theme.primary_color); // Use same color, no gradient
            }
            if (theme.secondary_color) root.style.setProperty('--secondary', theme.secondary_color);
            
            // Apply extended theme colors if available
            if (theme.bg_primary) root.style.setProperty('--bg', theme.bg_primary);
            if (theme.bg_secondary) root.style.setProperty('--bg-alt', theme.bg_secondary);
            if (theme.bg_tertiary) {
                root.style.setProperty('--bg-elevated', theme.bg_tertiary);
                root.style.setProperty('--card', theme.bg_tertiary); // Also update card background
            }
            
            if (theme.text_primary) {
                root.style.setProperty('--text', theme.text_primary);
            }
            if (theme.text_secondary) {
                root.style.setProperty('--text-light', theme.text_secondary);
            }
            if (theme.border_color) root.style.setProperty('--border', theme.border_color);
            
            if (theme.accent_color) root.style.setProperty('--success', theme.accent_color);
            if (theme.warning_color) root.style.setProperty('--warning', theme.warning_color);
            if (theme.error_color) root.style.setProperty('--error', theme.error_color);
            
            // Apply font family if specified
            if (theme.font_family) {
                root.style.setProperty('--font-family', theme.font_family);
                root.style.setProperty('--body-font', theme.font_family);
            }
            
            // Apply header background - use solid color instead of gradient
            const header = document.querySelector('header');
            if (header && theme.header_bg_color) {
                header.style.background = theme.header_bg_color; // Solid color
                header.style.backgroundImage = 'none'; // Remove gradient
                
                // Set header text color (white for dark backgrounds, dark for light)
                const headerColor = theme.header_bg_color;
                // Simple brightness check: if background is dark, use white text
                if (headerColor) {
                    const isDark = headerColor.toLowerCase() === '#4b4b4b' || 
                                   headerColor.toLowerCase() === '#061e29' ||
                                   headerColor.toLowerCase() === '#0f172a' ||
                                   parseInt(headerColor.replace('#', ''), 16) < 0x808080;
                    
                    const textColor = isDark ? 'white' : '#4B4B4B';
                    header.style.color = textColor;
                    
                    // Also update heading text colors
                    const h1 = header.querySelector('h1');
                    const subtitle = header.querySelector('.subtitle');
                    const logoutLink = document.getElementById('logoutLink');
                    const navLinks = header.querySelectorAll('.nav-link');
                    
                    if (h1) h1.style.color = textColor;
                    if (subtitle) subtitle.style.color = textColor;
                    if (logoutLink) logoutLink.style.color = textColor;
                    
                    // Update all nav links
                    navLinks.forEach(link => {
                        link.style.color = textColor;
                    });
                }
            }
            
            // Update logo based on institution
            updateInstitutionLogo();
            
            // Log what was applied
            console.log('‚úì Theme applied successfully');
            console.log('  - Primary:', theme.primary_color);
            console.log('  - Background:', theme.bg_primary);
            console.log('  - Text:', theme.text_primary);
            console.log('  - Mode:', theme.is_dark_mode ? 'Dark' : 'Light');
        }
        
        // Update logo based on institution
        async function updateInstitutionLogo() {
            const logo = document.getElementById('appLogo');
            if (!logo) {
                console.error('‚ùå Logo element not found');
                return;
            }
            
            console.log('üîÑ Updating institution logo...');
            console.log('Current user institution:', currentUser?.institution_id);
            console.log('Current theme institution:', currentInstitutionTheme?.institution_id);
            
            // CRITICAL: Only use theme if it matches current user's institution
            // This prevents theme bleeding across institutions
            if (currentInstitutionTheme && 
                currentUser && 
                currentUser.institution_id &&
                currentInstitutionTheme.institution_id === currentUser.institution_id) {
                
                console.log('‚úì Institution match verified - theme belongs to this user');
                
                // Check if institution has a custom logo in theme
                if (currentInstitutionTheme.logo_url) {
                    console.log('‚úì Custom logo URL found:', currentInstitutionTheme.logo_url.substring(0, 50) + '...');
                    
                    // Use custom logo image
                    try {
                        logo.innerHTML = `<img src="${currentInstitutionTheme.logo_url}" 
                                              style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;" 
                                              onerror="console.error('Logo image failed to load'); this.style.display='none';"
                                              onload="console.log('‚úì Logo image loaded successfully');">`;
                        console.log('‚úì Logo HTML updated with custom image');
                        return;
                    } catch (error) {
                        console.error('Error setting logo image:', error);
                    }
                }
            } else if (currentInstitutionTheme && currentUser && currentInstitutionTheme.institution_id !== currentUser.institution_id) {
                console.warn('‚ö†Ô∏è Institution mismatch detected! Theme will not be applied.');
                console.warn('  User institution:', currentUser.institution_id);
                console.warn('  Theme institution:', currentInstitutionTheme.institution_id);
            } else {
                console.log('No custom logo URL in theme or no theme loaded');
            }
            
            // Fallback to text logo based on institution
            let logoText = 'SG'; // Default
            
            if (currentInstitution) {
                if (currentInstitution.name === 'University of Tennessee') {
                    logoText = 'UTK';
                } else if (currentInstitution.name === 'SpeechGradebook') {
                    logoText = 'SG';
                } else {
                    // For other institutions, use first letters of name
                    const words = currentInstitution.name.split(' ');
                    logoText = words.map(w => w.charAt(0)).join('').substring(0, 3).toUpperCase();
                }
            }
            
            logo.textContent = logoText;
            console.log('‚úì Logo updated with text:', logoText);
        }
        
        // Route user to appropriate interface based on their tier
        function routeToInterface() {
            console.log('üéØ Routing to interface for tier:', userTier);
            
            // Determine interface type based on account tier
            let interfaceType = 'demo'; // default
            
            if (userTier === 'super_admin') {
                interfaceType = 'super_admin';
            } else if (userTier === 'admin') {
                interfaceType = 'admin';
            } else if (userTier === 'instructor') {
                interfaceType = 'instructor';
            } else if (userTier === 'demo') {
                interfaceType = 'demo';
            }
            
            console.log('‚úì Interface type:', interfaceType);
            
            // Initialize the appropriate interface
            initializeInterface(interfaceType);
        }
        
        // Initialize interface based on user type
        function initializeInterface(interfaceType) {
            console.log('üöÄ Initializing interface:', interfaceType);
            
            // CRITICAL: Hide ALL sections first to prevent flashing wrong interface
            document.querySelectorAll('.section').forEach(section => {
                section.style.display = 'none';
            });
            
            // Hide admin button and view switcher by default (each interface shows what it needs)
            const adminLink = document.getElementById('navAdmin');
            const viewSwitcher = document.getElementById('viewSwitcher');
            if (adminLink) adminLink.style.display = 'none';
            if (viewSwitcher) viewSwitcher.style.display = 'none';
            
            console.log('‚úì Previous interface cleared');
            
            switch(interfaceType) {
                case 'super_admin':
                    initializeSuperAdminInterface();
                    break;
                case 'admin':
                    initializeAdminInterface();
                    break;
                case 'instructor':
                    initializeInstructorInterface();
                    break;
                case 'demo':
                    initializeDemoInterface();
                    break;
                default:
                    console.warn('Unknown interface type:', interfaceType);
                    initializeDemoInterface();
            }
        }
        
        // Initialize Super Admin interface
        function initializeSuperAdminInterface() {
            console.log('üåê Setting up Super Admin interface');
            
            // Show admin button (super admins have full access)
            const adminLink = document.getElementById('navAdmin');
            if (adminLink) {
                adminLink.style.display = 'block';
                console.log('  ‚úì Admin button visible');
            }
            
            // Show view switcher for super admins
            const viewSwitcher = document.getElementById('viewSwitcher');
            const viewSelect = document.getElementById('viewModeSelect');
            
            if (viewSwitcher && viewSelect) {
                viewSwitcher.style.display = 'block';
                
                // Super admin sees all 4 modes
                const options = `
                    <option value="own">üë§ My Courses</option>
                    <option value="institution">üèõÔ∏è Institution View</option>
                    <option value="all">üåê All Institutions</option>
                    <option value="demo">üé≠ Demo Mode</option>
                `;
                viewSelect.innerHTML = options;
                
                // Restore saved view mode or default to 'all'
                const savedMode = localStorage.getItem('viewMode') || 'all';
                viewSelect.value = savedMode;
                currentViewMode = savedMode;
                
                console.log('  ‚úì View switcher configured (4 modes)');
            }
            
            // PHASE 3: Show All Institutions section with filters
            const allInstitutionsSection = document.getElementById('allInstitutionsSection');
            if (allInstitutionsSection) {
                allInstitutionsSection.style.display = 'block';
                console.log('  ‚úì All Institutions section visible');
            }
            
            // Hide department and instructor filter sections (not for super admin)
            const deptCoursesSection = document.getElementById('departmentCoursesSection');
            const instructorFiltersSection = document.getElementById('instructorFiltersSection');
            if (deptCoursesSection) deptCoursesSection.style.display = 'none';
            if (instructorFiltersSection) instructorFiltersSection.style.display = 'none';
            
            // Hide department section, show user management (super admins manage all users)
            const deptSection = document.getElementById('departmentInstructorsSection');
            const userMgmtSection = document.getElementById('userManagementSection');
            if (deptSection) deptSection.style.display = 'none';
            if (userMgmtSection) userMgmtSection.style.display = 'block';
            
            // Remove any demo banners (unless in demo mode)
            if (currentViewMode !== 'demo') {
                const demoBanner = document.getElementById('demoBanner');
                if (demoBanner) demoBanner.remove();
            }
            
            console.log('‚úì Super Admin interface ready');
            console.log('  - View:', currentViewMode);
            console.log('  - Can manage:', 'All institutions and users');
            
            // PHASE 5: Load filter dropdowns
            loadInstitutionsForFilter();
            loadInstructorsForFilter(''); // Load all instructors initially
            
            // CRITICAL: Always start at dashboard after login
            setActiveSection('dashboardSection', 'navDashboard');
        }
        
        // Initialize Admin interface
        function initializeAdminInterface() {
            console.log('üèõÔ∏è Setting up Admin interface');
            
            // Show admin button (admins have access)
            const adminLink = document.getElementById('navAdmin');
            if (adminLink) {
                adminLink.style.display = 'block';
                console.log('  ‚úì Admin button visible');
            }
            
            // Show view switcher for admins
            const viewSwitcher = document.getElementById('viewSwitcher');
            const viewSelect = document.getElementById('viewModeSelect');
            
            if (viewSwitcher && viewSelect) {
                viewSwitcher.style.display = 'block';
                
                // Admin sees: My Courses, Institution View, Demo Mode
                const options = `
                    <option value="own">üë§ My Courses</option>
                    <option value="institution">üèõÔ∏è ${currentInstitution?.name || 'Institution'} View</option>
                    <option value="demo">üé≠ Demo Mode</option>
                `;
                viewSelect.innerHTML = options;
                
                // Restore saved view mode or default to 'own'
                const savedMode = localStorage.getItem('viewMode') || 'own';
                viewSelect.value = savedMode;
                currentViewMode = savedMode;
                
                console.log('  ‚úì View switcher configured (3 modes)');
            }
            
            // PHASE 3: Show Department Courses section with filters
            const deptCoursesSection = document.getElementById('departmentCoursesSection');
            if (deptCoursesSection) {
                deptCoursesSection.style.display = 'block';
                console.log('  ‚úì Department Courses section visible');
            }
            
            // Hide all institutions and instructor filter sections (not for admin)
            const allInstitutionsSection = document.getElementById('allInstitutionsSection');
            const instructorFiltersSection = document.getElementById('instructorFiltersSection');
            if (allInstitutionsSection) allInstitutionsSection.style.display = 'none';
            if (instructorFiltersSection) instructorFiltersSection.style.display = 'none';
            
            // Show department section, hide user management (admins manage department, not all users)
            const deptSection = document.getElementById('departmentInstructorsSection');
            const userMgmtSection = document.getElementById('userManagementSection');
            if (deptSection) deptSection.style.display = 'block';
            if (userMgmtSection) userMgmtSection.style.display = 'none';
            
            // Remove any demo banners (unless in demo mode)
            if (currentViewMode !== 'demo') {
                const demoBanner = document.getElementById('demoBanner');
                if (demoBanner) demoBanner.remove();
            }
            
            console.log('‚úì Admin interface ready');
            console.log('  - Theme:', currentInstitution?.name || 'Default');
            console.log('  - View:', currentViewMode);
            console.log('  - Can manage:', 'Department instructors');
            
            // PHASE 5: Load filter dropdowns and courses
            loadDepartmentInstructorsForFilter();
            loadFilteredCoursesForAdmin(); // Load all department courses by default
            
            // CRITICAL: Always start at dashboard after login
            setActiveSection('dashboardSection', 'navDashboard');
        }
        
        // Initialize Instructor interface
        // Initialize Instructor interface
        function initializeInstructorInterface() {
            console.log('üë§ Setting up Instructor interface');
            
            // Hide admin button (instructors don't have admin access)
            const adminLink = document.getElementById('navAdmin');
            if (adminLink) {
                adminLink.style.display = 'none';
                console.log('  ‚úì Admin button hidden');
            }
            
            // Hide view switcher (instructors see only their own courses)
            const viewSwitcher = document.getElementById('viewSwitcher');
            if (viewSwitcher) {
                viewSwitcher.style.display = 'none';
                console.log('  ‚úì View switcher hidden');
            }
            
            // PHASE 3: Show Instructor Filters section
            const instructorFiltersSection = document.getElementById('instructorFiltersSection');
            if (instructorFiltersSection) {
                instructorFiltersSection.style.display = 'block';
                console.log('  ‚úì Instructor Filters section visible');
            }
            
            // Hide all institutions and department sections (not for instructor)
            const allInstitutionsSection = document.getElementById('allInstitutionsSection');
            const deptCoursesSection = document.getElementById('departmentCoursesSection');
            if (allInstitutionsSection) allInstitutionsSection.style.display = 'none';
            if (deptCoursesSection) deptCoursesSection.style.display = 'none';
            
            // CRITICAL: Remove view mode banner (from previous admin session)
            const viewBanner = document.getElementById('viewModeBanner');
            if (viewBanner) {
                viewBanner.remove();
                console.log('  ‚úì View mode banner removed');
            }
            
            // Remove any demo banners
            const demoBanner = document.getElementById('demoBanner');
            if (demoBanner) {
                demoBanner.remove();
                console.log('  ‚úì Demo banner removed');
            }
            
            // CRITICAL: Set view mode to 'own' (instructor sees only their courses)
            // This prevents institution banner from showing
            currentViewMode = 'own';
            
            console.log('‚úì Instructor interface ready');
            console.log('  - Theme:', currentInstitution?.name || 'Default');
            console.log('  - View: Own courses only');
            
            // CRITICAL: Always start at dashboard after login
            setActiveSection('dashboardSection', 'navDashboard');
        }
        
        // Initialize Demo interface
        function initializeDemoInterface() {
            console.log('üé≠ Setting up Demo interface');
            
            // Hide admin button (demo users don't have admin access)
            const adminLink = document.getElementById('navAdmin');
            if (adminLink) {
                adminLink.style.display = 'none';
                console.log('  ‚úì Admin button hidden');
            }
            
            // Hide view switcher (demo users see only demo mode)
            const viewSwitcher = document.getElementById('viewSwitcher');
            if (viewSwitcher) {
                viewSwitcher.style.display = 'none';
                console.log('  ‚úì View switcher hidden');
            }
            
            // Show demo banner
            const header = document.querySelector('header .container');
            if (header && !document.getElementById('demoBanner')) {
                const banner = document.createElement('div');
                banner.id = 'demoBanner';
                banner.style.cssText = 'background: #ffc107; color: #000; padding: 0.5rem; text-align: center; font-weight: 600; border-radius: 0.25rem; margin-top: 0.5rem;';
                banner.innerHTML = 'üé≠ Demo Mode - Testing functionality (localStorage only, not saved to database)';
                header.appendChild(banner);
                console.log('  ‚úì Demo banner shown');
            }
            
            // Set view mode to demo
            currentViewMode = 'demo';
            
            console.log('‚úì Demo interface ready');
            console.log('  - Storage: localStorage only');
            console.log('  - Features: Full evaluation features for testing');
            
            // CRITICAL: Always start at dashboard after login
            setActiveSection('dashboardSection', 'navDashboard');
        }
        
        // Update UI elements based on account tier
        function updateTierUI() {
            const isDemoMode = userTier === 'demo' || currentViewMode === 'demo';
            
            // Remove old banners
            const oldDemoBanner = document.getElementById('demoBanner');
            if (oldDemoBanner) oldDemoBanner.remove();
            
            if (isDemoMode && currentViewMode === 'demo') {
                // Show demo banner
                const header = document.querySelector('header .container');
                if (header && !document.getElementById('demoBanner')) {
                    const banner = document.createElement('div');
                    banner.id = 'demoBanner';
                    banner.style.cssText = 'background: #ffc107; color: #000; padding: 0.5rem; text-align: center; font-weight: 600; border-radius: 0.25rem; margin-top: 0.5rem;';
                    banner.innerHTML = 'üé≠ Demo Mode - Data stored in localStorage only (not saved to database)';
                    header.appendChild(banner);
                }
            }
            
            // Show admin controls and view switcher
            if (canManageUsers()) {
                // Show admin nav link
                const adminLink = document.getElementById('navAdmin');
                if (adminLink) {
                    adminLink.style.display = 'block';
                }
                
                // Show and populate view switcher
                const viewSwitcher = document.getElementById('viewSwitcher');
                const viewSelect = document.getElementById('viewModeSelect');
                
                if (viewSwitcher && viewSelect) {
                    viewSwitcher.style.display = 'block';
                    
                    // Populate options based on user tier
                    let options = '';
                    
                    if (isSuperAdmin()) {
                        // Super admin sees all views
                        options = `
                            <option value="own">üë§ My Courses</option>
                            <option value="institution">üèõÔ∏è Institution View</option>
                            <option value="all">üåê All Institutions</option>
                            <option value="demo">üé≠ Demo Mode</option>
                        `;
                    } else if (isAdmin()) {
                        // Institution admin sees institution + demo
                        options = `
                            <option value="own">üë§ My Courses</option>
                            <option value="institution">üèõÔ∏è ${currentInstitution?.name || 'Institution'} View</option>
                            <option value="demo">üé≠ Demo Mode</option>
                        `;
                    }
                    
                    viewSelect.innerHTML = options;
                    
                    // Load saved view preference
                    const savedView = localStorage.getItem('adminViewMode');
                    if (savedView && viewSelect.querySelector(`option[value="${savedView}"]`)) {
                        currentViewMode = savedView;
                        viewSelect.value = savedView;
                        updateViewMode();
                    }
                }
            }
        }
        
        // Show information about upgrading to research partner
        function showUpgradeInfo() {
            alert('To become a Research Partner with full features:\n\n' +
                  '‚Ä¢ Full evaluation storage\n' +
                  '‚Ä¢ Correction tracking for AI improvement\n' +
                  '‚Ä¢ Contribute to research\n\n' +
                  'Contact: speechgradebook@proton.me');
        }
        
        // Check if user has research partner access (can save to database)
        function hasResearchAccess() {
            // Demo users can't save to database
            if (userTier === 'demo') {
                return false;
            }
            // All other tiers can save
            return ['instructor', 'admin', 'super_admin'].includes(userTier);
        }
        
        // Check if user is admin (institution admin)
        // Check if user is admin (institution admin, not super admin)
        function isAdmin() {
            return currentUser?.is_admin === true && userTier === 'admin';
        }
        
        // Check if user is super admin
        function isSuperAdmin() {
            return currentUser?.is_super_admin === true && userTier === 'super_admin';
        }
        
        // Check if user can manage other users (admin OR super admin)
        function canManageUsers() {
            return isAdmin() || isSuperAdmin();
        }
        
        // Check if user can view institution-wide data (admin OR super admin)
        function canViewInstitutionData() {
            return isAdmin() || isSuperAdmin();
        }
        
        // Check if user has any admin privileges (used for UI elements)
        function hasAdminAccess() {
            return currentUser?.is_admin === true || currentUser?.is_super_admin === true;
        }
        
        // Check if user is logged in
        async function checkAuth() {
            if (!supabaseClient) {
                console.log('Supabase not available - skipping auth');
                showMainApp();
                return;
            }
            
            const { data: { session } } = await supabaseClient.auth.getSession();
            
            if (session) {
                currentUser = session.user;
                console.log('‚úì Logged in as:', currentUser.email);
                
                // Load user's account tier
                await loadUserTier();
                
                showMainApp();
            } else {
                console.log('Not logged in - showing auth screen');
                showAuthScreen();
            }
        }
        
        function showAuthScreen() {
            document.getElementById('authScreen').classList.remove('hidden');
            document.getElementById('mainApp').style.display = 'none';
        }
        
        function showMainApp() {
            document.getElementById('authScreen').classList.add('hidden');
            document.getElementById('mainApp').style.display = 'block';
            
            if (currentUser) {
                document.getElementById('userEmailDisplay').textContent = currentUser.email;
            }
        }
        
        function showLoginForm() {
            document.getElementById('loginFormDiv').classList.remove('hidden');
            document.getElementById('registerFormDiv').classList.add('hidden');
        }
        
        function showRegisterForm() {
            document.getElementById('loginFormDiv').classList.add('hidden');
            document.getElementById('registerFormDiv').classList.remove('hidden');
        }
        
        // Login
        async function login(email, password) {
            try {
                console.log('=== LOGGING IN ===');
                
                // CRITICAL: Clear previous user state FIRST
                currentUser = null;
                userTier = 'demo';
                currentViewMode = 'own';
                currentInstitution = null;
                currentInstitutionTheme = null;
                window.institutionLogoData = null;
                window.pendingCustomFonts = null;
                cachedDepartmentInstructors = [];
                
                console.log('‚úì Previous state cleared');
                
                const { data, error } = await supabaseClient.auth.signInWithPassword({
                    email: email,
                    password: password
                });
                
                if (error) {
                    alert('Login failed: ' + error.message);
                    return false;
                }
                
                currentUser = data.user;
                console.log('‚úì Login successful:', email);
                
                // Load new user's profile and theme
                await checkAuth();
                
                // Reload data for this user
                await loadClasses();
                await loadRubrics();
                
                return true;
            } catch (error) {
                console.error('Login error:', error);
                alert('Login failed: ' + error.message);
                return false;
            }
        }
        
        // Register
        async function register(name, email, password) {
            try {
                // Check if user was invited
                let invitedTier = 'demo';
                let invitation = null;
                
                if (supabaseClient) {
                    try {
                        const { data: invites, error: inviteError } = await supabaseClient
                            .from('invitations')
                            .select('*')
                            .eq('email', email)
                            .eq('status', 'pending')
                            .gt('expires_at', new Date().toISOString())
                            .order('created_at', { ascending: false })
                            .limit(1);
                        
                        if (!inviteError && invites && invites.length > 0) {
                            invitation = invites[0];
                            invitedTier = invitation.account_tier || 'research_partner';
                            console.log('‚úì Found valid invitation for', email, '- will upgrade to', invitedTier);
                        }
                    } catch (err) {
                        console.log('Could not check invitations:', err);
                    }
                }
                
                // First create the auth user
                const { data: authData, error: authError } = await supabaseClient.auth.signUp({
                    email: email,
                    password: password
                });
                
                if (authError) {
                    alert('Registration failed: ' + authError.message);
                    return false;
                }
                
                if (!authData.user) {
                    alert('Registration failed: No user data returned');
                    return false;
                }
                
                // Split name into first and last
                const nameParts = name.trim().split(' ');
                const firstName = nameParts[0] || '';
                const lastName = nameParts.slice(1).join(' ') || '';
                
                // Create user record in users table (legacy)
                const { data: userData, error: userError } = await supabaseClient
                    .from('users')
                    .insert([{
                        id: authData.user.id,
                        email: email,
                        password_hash: 'managed_by_supabase_auth',
                        role: 'instructor',
                        account_type: 'individual',
                        status: 'active',
                        first_name: firstName,
                        last_name: lastName
                    }])
                    .select();
                
                if (userError) {
                    console.error('Failed to create user record:', userError);
                }
                
                // Update user_profile with invited tier
                if (supabaseClient && invitation) {
                    try {
                        // The trigger should have created the profile, now update it
                        const { error: profileError } = await supabaseClient
                            .from('user_profiles')
                            .update({
                                account_tier: invitedTier,
                                full_name: name,
                                institution: invitation.institution
                            })
                            .eq('id', authData.user.id);
                        
                        if (profileError) {
                            console.error('Could not upgrade account:', profileError);
                        } else {
                            console.log('‚úì Account upgraded to', invitedTier);
                            
                            // Mark invitation as accepted
                            await supabaseClient
                                .from('invitations')
                                .update({
                                    status: 'accepted',
                                    accepted_at: new Date().toISOString()
                                })
                                .eq('id', invitation.id);
                        }
                    } catch (err) {
                        console.error('Error upgrading account:', err);
                    }
                }
                
                console.log('‚úì User record created:', userData);
                
                if (invitation) {
                    alert('‚úì Account created successfully!\n\nYou have been upgraded to Research Partner with full access.\n\nYou can now login.');
                } else {
                    alert('‚úì Account created successfully! You can now login.');
                }
                
                showLoginForm();
                return true;
            } catch (error) {
                console.error('Registration error:', error);
                alert('Registration failed: ' + error.message);
                return false;
            }
        }
        
        // Logout
        async function logout() {
            console.log('=== LOGGING OUT ===');
            
            // Sign out from Supabase
            if (supabaseClient) {
                await supabaseClient.auth.signOut();
            }
            
            // Clear ALL global state
            currentUser = null;
            userTier = 'demo';
            currentViewMode = 'own';
            currentInstitution = null;
            currentInstitutionTheme = null;
            
            // Clear window variables
            window.institutionLogoData = null;
            window.pendingCustomFonts = null;
            
            // Clear any cached data
            cachedDepartmentInstructors = [];
            
            // CRITICAL: Clear login form
            const loginEmail = document.getElementById('loginEmail');
            const loginPassword = document.getElementById('loginPassword');
            if (loginEmail) loginEmail.value = '';
            if (loginPassword) loginPassword.value = '';
            
            // Remove all banners
            const viewBanner = document.getElementById('viewModeBanner');
            if (viewBanner) viewBanner.remove();
            const demoBanner = document.getElementById('demoBanner');
            if (demoBanner) demoBanner.remove();
            
            // Reset CSS to defaults (clear any theme styling)
            const root = document.documentElement;
            root.style.setProperty('--primary', '#3b82f6'); // Default blue
            root.style.setProperty('--header-bg', '#ffffff');
            root.style.setProperty('--text', '#1f2937');
            root.style.setProperty('--heading-font', 'Inter, -apple-system, sans-serif');
            root.style.setProperty('--body-font', 'Inter, -apple-system, sans-serif');
            
            // Reset logo to default
            const logo = document.getElementById('appLogo');
            if (logo) {
                logo.textContent = 'SG';
                logo.innerHTML = 'SG'; // Clear any image
            }
            
            // Hide all sections
            document.querySelectorAll('.section').forEach(section => {
                section.style.display = 'none';
            });
            
            console.log('‚úì State cleared');
            console.log('‚úì Login form cleared');
            console.log('‚úì Banners removed');
            console.log('‚úì Theme reset to defaults');
            console.log('‚úì Logged out');
            
            // Show login screen
            showAuthScreen();
        }
        
        // Handle login form
        document.getElementById('loginForm')?.addEventListener('submit', async (e) => {
            e.preventDefault();
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;
            await login(email, password);
        });
        
        // Handle register form
        document.getElementById('registerForm')?.addEventListener('submit', async (e) => {
            e.preventDefault();
            const name = document.getElementById('registerName').value;
            const email = document.getElementById('registerEmail').value;
            const password = document.getElementById('registerPassword').value;
            await register(name, email, password);
        });
        
        // ===== TENANT CONFIGURATION =====
        const TENANT_CONFIGS = {
            'utk': {
                name: 'University of Tennessee, Knoxville',
                shortName: 'UTK',
                domain: 'utk.edu',
                branding: {
                    appName: 'Speech Gradebook',
                    tagline: 'AI-Powered Speech Assessment'
                },
                colors: {
                    primary: '#FF8200',
                    primaryDark: '#D66D00',
                    secondary: '#58595B',
                    accent: '#FF8200'
                },
                typography: {
                    headingFont: "'Montserrat', sans-serif",
                    bodyFont: "'Georgia', serif",
                    headingWeight: '600',
                    bodyWeight: '400'
                },
                contact: {
                    supportEmail: 'speecheval-support@utk.edu'
                },
                footer: {
                    links: [
                        { text: 'Privacy Policy', url: 'https://www.utk.edu/aboutut/privacy/' },
                        { text: 'Accessibility', url: 'https://dae.utk.edu/eoa/ada/' },
                        { text: 'Title IX', url: 'https://titleix.utk.edu/' },
                        { text: 'IT Help', url: 'https://oit.utk.edu/help' }
                    ],
                    copyright: '¬© 2026 Speech Gradebook',
                    additionalText: 'The flagship campus of the University of Tennessee System'
                }
            },
            'default': {
                name: 'Speech Gradebook',
                shortName: 'SG',
                domain: null,
                branding: {
                    appName: 'Speech Gradebook',
                    tagline: 'AI-Powered Speech Assessment'
                },
                colors: {
                    primary: '#1e3a5f',
                    primaryDark: '#142940',
                    secondary: '#c8a882',
                    accent: '#d4af37'
                },
                typography: {
                    headingFont: "'Crimson Pro', serif",
                    bodyFont: "'Work Sans', sans-serif",
                    headingWeight: '700',
                    bodyWeight: '400'
                },
                contact: {
                    supportEmail: 'support@speechgradebook.com'
                },
                footer: {
                    links: [
                        { text: 'Privacy Policy', url: '#' },
                        { text: 'Terms of Service', url: '#' }
                    ],
                    copyright: '¬© 2026 Speech Gradebook',
                    additionalText: null
                }
            }
        };

        // ===== GLOBAL STATE =====
        console.log('üöÄ Speech Gradebook JavaScript Loading...');
        let currentTenant = 'default';
        let uploadedFile = null;
        let evaluationResults = null;
        let currentStep = 1;
        console.log('‚úì Global variables initialized');
        
        // Update API key field based on provider
        function updateApiKeyPlaceholder() {
            const provider = document.getElementById('apiProvider').value;
            const apiKeyInput = document.getElementById('apiKey');
            const apiKeyLabel = document.getElementById('apiKeyLabel');
            
            if (provider === 'gpt4o') {
                apiKeyLabel.textContent = 'OpenAI API Key *';
                apiKeyInput.placeholder = 'sk-proj-...';
                const savedKey = localStorage.getItem('openai_api_key');
                if (savedKey) {
                    apiKeyInput.value = savedKey;
                } else {
                    apiKeyInput.value = '';
                }
            } else if (provider === 'gemini') {
                apiKeyLabel.textContent = 'Google Gemini API Key *';
                apiKeyInput.placeholder = 'AIza...';
                const savedKey = localStorage.getItem('gemini_api_key');
                if (savedKey) {
                    apiKeyInput.value = savedKey;
                } else {
                    apiKeyInput.value = '';
                }
            } else {
                apiKeyLabel.textContent = 'Anthropic Claude API Key *';
                apiKeyInput.placeholder = 'sk-ant-...';
                const savedKey = localStorage.getItem('anthropic_api_key');
                if (savedKey) {
                    apiKeyInput.value = savedKey;
                } else {
                    apiKeyInput.value = '';
                }
            }
        }

        // ===== RUBRIC SYSTEM =====
        // Define the Self-Introduction Speech Rubric
        const SELF_INTRO_RUBRIC = {
            name: "Self Introduction Speech",
            totalPoints: 50,
            gradeScale: {
                A: { label: "Professional", percentage: 1.00, range: "100-91" },
                B: { label: "Proficient", percentage: 0.90, range: "90-89" },
                C: { label: "Developing", percentage: 0.80, range: "80-71" },
                D: { label: "Unprofessional", percentage: 0.70, range: "70-61" },
                F: { label: "Unacceptable", percentage: 0.60, range: "60-0" }
            },
            categories: [
                {
                    name: "Content - Introduction",
                    subcategories: [
                        "Capture Attention",
                        "Relevance to Audience",
                        "Introduction of Topic/Purpose"
                    ]
                },
                {
                    name: "Content - Organization",
                    subcategories: [
                        "Pattern",
                        "Connectives",
                        "Within Time Limits"
                    ]
                },
                {
                    name: "Content - Conclusion",
                    subcategories: [
                        "Recap/Summary",
                        "Memorable Final Thought"
                    ]
                },
                {
                    name: "Content - Assignment",
                    subcategories: [
                        "Your passion(s)",
                        "Career Goals",
                        "Philosophy",
                        "Clear Development of Ideas"
                    ]
                },
                {
                    name: "Delivery - Nonverbal",
                    subcategories: [
                        "Eye Contact",
                        "Gestures/Bodily Movements",
                        "Desire to Communicate/Enthusiasm",
                        "Professionalism"
                    ]
                },
                {
                    name: "Delivery - Verbal",
                    subcategories: [
                        "Vocal volume/variety/tone",
                        "Speaking Rate/Effective Use of Pauses",
                        "Extemporaneous style - use of notes",
                        "Use of vocalized pauses/fillers (ums, uhs, like...)"
                    ]
                }
            ]
        };

        // Calculate rubric metrics
        function calculateRubricMetrics(rubric) {
            const totalSubcategories = rubric.categories.reduce(
                (sum, cat) => sum + cat.subcategories.length, 
                0
            );
            const pointsPerSubcategory = rubric.totalPoints / totalSubcategories;
            
            return {
                totalSubcategories,
                pointsPerSubcategory,
                categoryPoints: rubric.categories.map(cat => ({
                    name: cat.name,
                    maxPoints: cat.subcategories.length * pointsPerSubcategory,
                    subcategoryCount: cat.subcategories.length
                }))
            };
        }

        // Calculate score for a category based on grade selections
        function calculateCategoryScore(rubric, categoryIndex, gradeSelections) {
            const metrics = calculateRubricMetrics(rubric);
            const category = rubric.categories[categoryIndex];
            const pointsPerSub = metrics.pointsPerSubcategory;
            
            let totalScore = 0;
            gradeSelections.forEach(grade => {
                const gradePercentage = rubric.gradeScale[grade].percentage;
                totalScore += pointsPerSub * gradePercentage;
            });
            
            return {
                score: parseFloat(totalScore.toFixed(2)),
                maxScore: parseFloat((category.subcategories.length * pointsPerSub).toFixed(2))
            };
        }
        let currentClassId = null;

        // ===== INITIALIZATION =====
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('üìÑ DOM Content Loaded');
            
            // Check for registration hash
            if (window.location.hash === '#register') {
                showRegisterForm();
            }
            
            // Test Supabase connection
            testSupabaseConnection();
            
            // Check authentication status
            await checkAuth();
            
            // Set default tenant
            currentTenant = 'default';
            applyTenant(currentTenant);
            console.log('‚úì Tenant applied');
            
            // Initialize file upload
            initializeFileUpload();
            console.log('‚úì File upload initialized');
            
            // Initialize form handlers
            initializeForms();
            console.log('‚úì Forms initialized');
            
            // Load saved data
            await loadClasses();
            await loadRubrics();
            loadSavedSettings();
            console.log('‚úì Data loaded');
            
            // Set current date
            document.getElementById('speechDate').valueAsDate = new Date();
            console.log('‚úì Application fully initialized and ready');
        });

        // ===== NAVIGATION =====
        function showEvaluate() {
            setActiveSection('evaluateSection', 'navEvaluate');
        }

        function showDashboard() {
            setActiveSection('dashboardSection', 'navDashboard');
            loadClasses();
        }

        function showSettings() {
            setActiveSection('settingsSection', 'navSettings');
        }

        function showHelp() {
            setActiveSection('helpSection', 'navHelp');
        }
        
        function showAdmin() {
            if (!canManageUsers()) {
                alert('Access denied. Admin privileges required.');
                return;
            }
            
            console.log('=== OPENING ADMIN PANEL ===');
            console.log('User:', currentUser?.email);
            console.log('Tier:', userTier);
            console.log('Institution:', currentUser?.institution_id);
            console.log('Admin can ONLY edit theme for this institution');
            
            setActiveSection('adminSection', 'navAdmin');
            
            // Auto-load department data
            console.log('üîÑ Auto-loading department data...');
            loadDepartmentInstructors();
            loadEnhancedAnalytics();
            
            // Load current theme into customizer
            loadCurrentThemeToForm();
        }
        
        // Load current institution theme into form
        async function loadCurrentThemeToForm() {
            if (!currentUser || !currentUser.institution_id) {
                console.warn('‚ö†Ô∏è Cannot load theme form: No user or institution');
                return;
            }
            
            console.log('Loading theme form for institution:', currentUser.institution_id);
            
            try {
                const { data: theme, error } = await supabaseClient
                    .from('institution_themes')
                    .select('*')
                    .eq('institution_id', currentUser.institution_id)
                    .single();
                
                if (error) {
                    console.log('‚ÑπÔ∏è No theme found for this institution');
                    throw error;
                }
                
                if (theme) {
                    // CRITICAL SECURITY CHECK: Verify institution_id matches
                    if (theme.institution_id !== currentUser.institution_id) {
                        console.error('‚ùå SECURITY VIOLATION: Theme institution mismatch!');
                        console.error('   User institution:', currentUser.institution_id);
                        console.error('   Theme institution:', theme.institution_id);
                        alert('Security error: You do not have permission to edit this theme.');
                        return;
                    }
                    
                    console.log('‚úì Loading theme form with data from institution:', theme.institution_id);
                    
                    document.getElementById('themePrimaryColor').value = theme.primary_color || '#FF8200';
                    document.getElementById('themePrimaryText').value = theme.primary_color || '#FF8200';
                    document.getElementById('themeHeaderColor').value = theme.header_bg_color || '#4B4B4B';
                    document.getElementById('themeHeaderText').value = theme.header_bg_color || '#4B4B4B';
                    document.getElementById('themeSecondaryColor').value = theme.secondary_color || '#4B4B4B';
                    document.getElementById('themeSecondaryText').value = theme.secondary_color || '#4B4B4B';
                    document.getElementById('themeTextColor').value = theme.text_primary || '#4B4B4B';
                    document.getElementById('themeTextText').value = theme.text_primary || '#4B4B4B';
                    
                    // Load fonts
                    if (theme.font_heading) {
                        document.getElementById('themeHeadingFont').value = theme.font_heading;
                    }
                    if (theme.font_body) {
                        document.getElementById('themeBodyFont').value = theme.font_body;
                    }
                    
                    // Load logo if exists
                    if (theme.logo_url) {
                        const logoImg = document.getElementById('logoPreviewImage');
                        const logoPlaceholder = document.getElementById('logoPlaceholder');
                        
                        if (logoImg && logoPlaceholder) {
                            logoImg.src = theme.logo_url;
                            logoImg.style.display = 'block';
                            logoPlaceholder.style.display = 'none';
                            
                            // IMPORTANT: Store in window variable so it persists
                            window.institutionLogoData = theme.logo_url;
                            console.log('‚úì Logo loaded from database');
                        }
                    }
                    
                    // Load custom fonts if exists
                    if (theme.custom_fonts) {
                        console.log('‚úì Loading custom fonts into form');
                        loadCustomFonts(theme.custom_fonts);
                    }
                    
                    // Sync color pickers with text inputs
                    syncColorInputs();
                    
                    console.log('‚úì Theme form loaded successfully');
                }
            } catch (error) {
                console.error('Error loading theme form:', error);
            }
        }
        
        // Load and display custom fonts
        function loadCustomFonts(customFontsData) {
            if (!customFontsData) return;
            
            let fonts = [];
            try {
                fonts = typeof customFontsData === 'string' ? JSON.parse(customFontsData) : customFontsData;
            } catch (e) {
                console.error('Error parsing custom fonts:', e);
                return;
            }
            
            if (!Array.isArray(fonts) || fonts.length === 0) return;
            
            const container = document.getElementById('customFontsContainer');
            const list = document.getElementById('customFontsList');
            
            if (!container || !list) return;
            
            // Show the list
            list.style.display = 'block';
            
            // Clear existing
            container.innerHTML = '';
            
            // Add each font
            fonts.forEach((font, index) => {
                // Inject font-face
                injectFontFace(font);
                
                // Add to selectors
                addFontToSelectors(font.name, font.family);
                
                // Display in list
                const fontItem = document.createElement('div');
                fontItem.style.cssText = 'padding: 0.75rem; background: var(--bg); border: 1px solid var(--border); border-radius: 0.25rem; display: flex; justify-content: space-between; align-items: center;';
                fontItem.innerHTML = `
                    <span style="font-family: ${font.family}, sans-serif; font-weight: 600;">${font.name}</span>
                    <button onclick="removeCustomFont(${index})" style="padding: 0.25rem 0.5rem; font-size: 0.85rem; background: var(--error);">
                        üóëÔ∏è Remove
                    </button>
                `;
                container.appendChild(fontItem);
            });
        }
        
        // Inject @font-face CSS - ONLY Regular weight to prevent auto-matching
        function injectFontFace(font) {
            const styleId = `custom-font-${font.family.replace(/[^a-zA-Z0-9]/g, '-')}`;
            
            // Check if already injected
            if (document.getElementById(styleId)) return;
            
            // CRITICAL: Only use Regular (400) Normal style variant
            // This prevents browser from auto-applying bold/italic variants
            const regularFile = font.files.find(f => f.weight === '400' && f.style === 'normal');
            
            if (!regularFile) {
                console.warn(`No Regular variant found for ${font.family}, using first file`);
                // Fallback to first file but force it as Regular
                const fallbackFile = font.files[0];
                if (!fallbackFile) return;
                
                const style = document.createElement('style');
                style.id = styleId;
                style.textContent = `
                    @font-face {
                        font-family: '${font.family}';
                        src: url('${fallbackFile.data}') format('${fallbackFile.format}');
                        font-weight: 400;
                        font-style: normal;
                        font-display: swap;
                    }
                `;
                document.head.appendChild(style);
                console.log(`‚úì Injected font-face for ${font.family} (forced as Regular)`);
                return;
            }
            
            // Inject ONLY the Regular variant
            const style = document.createElement('style');
            style.id = styleId;
            style.textContent = `
                @font-face {
                    font-family: '${font.family}';
                    src: url('${regularFile.data}') format('${regularFile.format}');
                    font-weight: 400;
                    font-style: normal;
                    font-display: swap;
                }
            `;
            
            document.head.appendChild(style);
            console.log(`‚úì Injected font-face for ${font.family} (Regular only - ${font.files.length} total variants ignored to prevent auto-matching)`);
        }
        
        // Add font to selectors
        function addFontToSelectors(name, family) {
            const headingSelect = document.getElementById('themeHeadingFont');
            const bodySelect = document.getElementById('themeBodyFont');
            
            if (!headingSelect || !bodySelect) return;
            
            const value = `'${family}', sans-serif`;
            
            // Check if already exists
            const existsInHeading = Array.from(headingSelect.options).some(opt => opt.value === value);
            const existsInBody = Array.from(bodySelect.options).some(opt => opt.value === value);
            
            if (!existsInHeading) {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = `${name} (Custom)`;
                headingSelect.appendChild(option);
            }
            
            if (!existsInBody) {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = `${name} (Custom)`;
                bodySelect.appendChild(option);
            }
        }
        
        // Upload custom font
        async function uploadCustomFont() {
            const nameInput = document.getElementById('customFontName');
            const filesInput = document.getElementById('customFontFiles');
            
            // Check which input has files
            const files = filesInput.files;
            
            if (!nameInput.value.trim()) {
                alert('Please enter a font family name.');
                return;
            }
            
            if (!files || files.length === 0) {
                alert('Please select font files or a folder containing fonts.');
                return;
            }
            
            const fontName = nameInput.value.trim();
            const fontFamily = fontName.replace(/[^a-zA-Z0-9 ]/g, '');
            
            const statusDiv = document.getElementById('themeStatus');
            statusDiv.innerHTML = '<p style="color: var(--text-light);">Processing font files...</p>';
            
            try {
                let regularFile = null;
                let processedCount = 0;
                
                // Find ONLY the Regular variant - discard all others to save storage
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    
                    // Skip non-font files
                    if (!file.name.match(/\.(woff2|woff|ttf|otf)$/i)) {
                        console.log('Skipping non-font file:', file.name);
                        continue;
                    }
                    
                    processedCount++;
                    
                    // Detect if this is the Regular variant
                    const fileName = file.name.toLowerCase();
                    const isRegular = (fileName.includes('regular') || fileName.includes('normal')) && 
                                     !fileName.includes('italic') && 
                                     !fileName.includes('oblique');
                    
                    // If no explicit "Regular" found, use first non-bold, non-italic file as fallback
                    const isFallbackRegular = !fileName.includes('bold') && 
                                             !fileName.includes('italic') && 
                                             !fileName.includes('black') && 
                                             !fileName.includes('heavy') && 
                                             !fileName.includes('light') && 
                                             !fileName.includes('thin') && 
                                             !fileName.includes('medium') &&
                                             !fileName.includes('semi') &&
                                             !fileName.includes('extra');
                    
                    if (isRegular || (isFallbackRegular && !regularFile)) {
                        // Validate size (max 2MB)
                        if (file.size > 2 * 1024 * 1024) {
                            console.warn(`${file.name} is too large (max 2MB), skipping.`);
                            continue;
                        }
                        
                        // Determine format
                        const format = file.name.toLowerCase().endsWith('.woff2') ? 'woff2' :
                                      file.name.toLowerCase().endsWith('.woff') ? 'woff' :
                                      file.name.toLowerCase().endsWith('.ttf') ? 'truetype' :
                                      file.name.toLowerCase().endsWith('.otf') ? 'opentype' : 'woff';
                        
                        // Read as base64
                        const base64 = await readFileAsBase64(file);
                        
                        regularFile = {
                            name: file.name,
                            format: format,
                            data: base64,
                            weight: '400',
                            style: 'normal'
                        };
                        
                        console.log(`‚úì Found Regular variant: ${file.name}`);
                        break; // Stop after finding Regular
                    } else {
                        console.log(`Skipping non-Regular variant: ${file.name} (not needed, saves storage)`);
                    }
                }
                
                if (!regularFile) {
                    throw new Error('No Regular (normal weight) font file found. Please include a Regular or Normal weight variant in your font package.');
                }
                
                // Create font package with ONLY Regular variant
                const fontPackage = {
                    name: fontName,
                    family: fontFamily,
                    files: [regularFile] // ONLY ONE FILE - saves storage!
                };
                
                // Get existing custom fonts
                let customFonts = [];
                if (currentInstitutionTheme && currentInstitutionTheme.custom_fonts) {
                    try {
                        customFonts = typeof currentInstitutionTheme.custom_fonts === 'string' 
                            ? JSON.parse(currentInstitutionTheme.custom_fonts)
                            : currentInstitutionTheme.custom_fonts;
                    } catch (e) {
                        customFonts = [];
                    }
                }
                
                // Add new font
                customFonts.push(fontPackage);
                
                // Temporarily store (will be saved with theme)
                window.pendingCustomFonts = customFonts;
                
                // Display the font
                loadCustomFonts(customFonts);
                
                // Clear inputs
                nameInput.value = '';
                filesInput.value = '';
                
                const discardedCount = processedCount - 1;
                
                statusDiv.innerHTML = 
                    '<p style="color: var(--success); padding: 1rem; background: #d1fae5; border-radius: 0.5rem;">' +
                    `‚úÖ Font "${fontName}" uploaded!<br>` +
                    `<span style="font-size: 0.9rem; color: var(--text-light); margin-top: 0.5rem; display: block;">` +
                    `Stored: 1 file (Regular variant, ${(regularFile.data.length / 1024).toFixed(1)}KB)<br>` +
                    (discardedCount > 0 ? `Discarded: ${discardedCount} file${discardedCount !== 1 ? 's' : ''} (Bold, Italic, etc. - not needed, saves storage)<br>` : '') +
                    `Click "Save Theme" to apply permanently.</span></p>`;
                
            } catch (error) {
                console.error('Error uploading font:', error);
                statusDiv.innerHTML = 
                    '<p style="color: var(--error); padding: 1rem; background: #fee; border-radius: 0.5rem;">' +
                    '‚ùå Error uploading font: ' + error.message + '</p>';
            }
        }
        
        // Read file as base64
        function readFileAsBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        // Remove custom font
        function removeCustomFont(index) {
            if (!confirm('Remove this custom font?')) return;
            
            let customFonts = window.pendingCustomFonts || [];
            customFonts.splice(index, 1);
            window.pendingCustomFonts = customFonts;
            
            loadCustomFonts(customFonts);
            
            document.getElementById('themeStatus').innerHTML = 
                '<p style="color: var(--text-light);">Font removed. Click "Save Theme" to apply changes.</p>';
        }
        
        // Handle logo upload for institution
        function handleLogoUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Validate file type
            if (!file.type.startsWith('image/')) {
                alert('Please upload an image file.');
                return;
            }
            
            // Validate file size (max 5MB)
            if (file.size > 5 * 1024 * 1024) {
                alert('Image must be less than 5MB.');
                return;
            }
            
            // Preview the image
            const reader = new FileReader();
            reader.onload = function(e) {
                const logoImg = document.getElementById('logoPreviewImage');
                const logoPlaceholder = document.getElementById('logoPlaceholder');
                
                if (logoImg && logoPlaceholder) {
                    logoImg.src = e.target.result;
                    logoImg.style.display = 'block';
                    logoPlaceholder.style.display = 'none';
                    
                    // Store base64 for saving
                    window.institutionLogoData = e.target.result;
                    
                    console.log('‚úì Logo preview loaded');
                }
            };
            reader.onerror = function(error) {
                console.error('Error reading logo file:', error);
                alert('Error loading logo preview. Please try again.');
            };
            reader.readAsDataURL(file);
        }
        
        // Sync color picker with text input
        function syncColorInputs() {
            const pairs = [
                ['themePrimaryColor', 'themePrimaryText'],
                ['themeHeaderColor', 'themeHeaderText'],
                ['themeSecondaryColor', 'themeSecondaryText'],
                ['themeTextColor', 'themeTextText']
            ];
            
            pairs.forEach(([pickerId, textId]) => {
                const picker = document.getElementById(pickerId);
                const text = document.getElementById(textId);
                
                if (picker && text) {
                    picker.addEventListener('input', () => {
                        text.value = picker.value.toUpperCase();
                    });
                    
                    text.addEventListener('input', () => {
                        if (/^#[0-9A-F]{6}$/i.test(text.value)) {
                            picker.value = text.value;
                        }
                    });
                }
            });
        }
        
        // Preview theme (temporary, doesn't save)
        function previewTheme() {
            const theme = {
                primary_color: document.getElementById('themePrimaryColor').value,
                header_bg_color: document.getElementById('themeHeaderColor').value,
                secondary_color: document.getElementById('themeSecondaryColor').value,
                text_primary: document.getElementById('themeTextColor').value,
                font_heading: document.getElementById('themeHeadingFont').value,
                font_body: document.getElementById('themeBodyFont').value
            };
            
            applyThemeToCSS(theme);
            
            // Apply fonts
            const root = document.documentElement;
            if (theme.font_heading) {
                root.style.setProperty('--heading-font', theme.font_heading);
            }
            if (theme.font_body) {
                root.style.setProperty('--body-font', theme.font_body);
            }
            
            // Preview logo if uploaded
            if (window.institutionLogoData) {
                const appLogo = document.getElementById('appLogo');
                if (appLogo) {
                    appLogo.innerHTML = `<img src="${window.institutionLogoData}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;">`;
                }
            }
            
            document.getElementById('themeStatus').innerHTML = 
                '<p style="color: var(--success); padding: 1rem; background: var(--bg-alt); border-radius: 0.5rem;">üëÅÔ∏è Preview applied! Click "Save Theme" to make permanent.</p>';
        }
        
        // Save theme to database
        async function saveInstitutionTheme() {
            if (!supabaseClient || !currentUser || !currentUser.institution_id) {
                alert('Error: Not connected to database or no institution assigned.');
                return;
            }
            
            const statusDiv = document.getElementById('themeStatus');
            statusDiv.innerHTML = '<p style="color: var(--text-light);">Saving theme...</p>';
            
            console.log('=== SAVING THEME ===');
            console.log('User institution:', currentUser.institution_id);
            console.log('User tier:', userTier);
            
            try {
                const themeData = {
                    primary_color: document.getElementById('themePrimaryColor').value,
                    header_bg_color: document.getElementById('themeHeaderColor').value,
                    secondary_color: document.getElementById('themeSecondaryColor').value,
                    text_primary: document.getElementById('themeTextColor').value,
                    text_secondary: document.getElementById('themeTextColor').value,
                    font_heading: document.getElementById('themeHeadingFont').value,
                    font_body: document.getElementById('themeBodyFont').value,
                    updated_at: new Date().toISOString()
                };
                
                // Add logo if uploaded
                if (window.institutionLogoData) {
                    themeData.logo_url = window.institutionLogoData;
                    console.log('‚úì Logo data prepared for save');
                    console.log('  Logo size:', (themeData.logo_url.length / 1024).toFixed(1) + 'KB');
                } else {
                    console.log('‚ÑπÔ∏è No new logo data to save (keeping existing if any)');
                }
                
                // Add custom fonts if uploaded
                if (window.pendingCustomFonts && window.pendingCustomFonts.length > 0) {
                    themeData.custom_fonts = window.pendingCustomFonts; // Store as JSONB directly
                    console.log('‚úì Custom fonts prepared for save:', window.pendingCustomFonts.length, 'font(s)');
                    console.log('  Font data size:', JSON.stringify(window.pendingCustomFonts).length, 'characters');
                } else {
                    console.log('‚ÑπÔ∏è No custom fonts to save (keeping existing if any)');
                }
                
                console.log('Saving theme to institution_id:', currentUser.institution_id);
                
                // Use upsert instead of update - creates row if doesn't exist, updates if it does
                const { data, error } = await supabaseClient
                    .from('institution_themes')
                    .upsert({
                        institution_id: currentUser.institution_id,
                        ...themeData
                    }, {
                        onConflict: 'institution_id'
                    })
                    .select(); // CRITICAL: .select() returns the saved data
                
                if (error) {
                    console.error('‚ùå Save failed:', error);
                    throw error;
                }
                
                if (!data || data.length === 0) {
                    console.error('‚ùå No data returned from upsert');
                    throw new Error('No data returned from save operation');
                }
                
                const savedTheme = data[0];
                console.log('‚úì Theme saved to database');
                console.log('  Saved to institution_id:', savedTheme.institution_id);
                console.log('  Has logo:', !!savedTheme.logo_url);
                console.log('  Has custom fonts:', !!savedTheme.custom_fonts);
                
                // CRITICAL: Update global theme variable with complete data from database
                // This ensures institution_id and all fields are properly set
                currentInstitutionTheme = savedTheme;
                currentUser.theme = savedTheme;
                
                console.log('‚úì Global theme variable updated');
                
                // Apply the theme immediately
                applyThemeToCSS(savedTheme);
                
                // Apply fonts
                const root = document.documentElement;
                if (savedTheme.font_heading) {
                    root.style.setProperty('--heading-font', savedTheme.font_heading);
                    console.log('‚úì Applied heading font:', savedTheme.font_heading);
                }
                if (savedTheme.font_body) {
                    root.style.setProperty('--body-font', savedTheme.font_body);
                    console.log('‚úì Applied body font:', savedTheme.font_body);
                }
                
                // Load custom fonts if saved
                if (savedTheme.custom_fonts) {
                    console.log('Loading custom fonts from saved data...');
                    loadCustomFontsOnStartup(savedTheme.custom_fonts);
                }
                
                // Update logo if uploaded
                if (window.institutionLogoData) {
                    console.log('Updating logo display...');
                    await updateInstitutionLogo();
                }
                
                statusDiv.innerHTML = 
                    '<p style="color: var(--success); padding: 1rem; background: #d1fae5; border-radius: 0.5rem; border-left: 4px solid var(--success);">' +
                    '‚úÖ Theme saved successfully! All users in your institution will see these colors, fonts, and logo on next login.</p>';
                
                console.log('=== THEME SAVE COMPLETE ===');
                
                // Clear pending fonts (they're now saved)
                window.pendingCustomFonts = null;
                
            } catch (error) {
                console.error('Error saving theme:', error);
                statusDiv.innerHTML = 
                    '<p style="color: var(--error); padding: 1rem; background: #fee; border-radius: 0.5rem; border-left: 4px solid var(--error);">' +
                    '‚ùå Error saving theme: ' + error.message + '</p>';
            }
        }
        
        // Reset theme form to current saved values
        function resetThemeForm() {
            loadCurrentThemeToForm(); // This will reload logo from database
            window.pendingCustomFonts = null;
            document.getElementById('institutionLogoUpload').value = '';
            document.getElementById('customFontName').value = '';
            document.getElementById('customFontFiles').value = '';
            document.getElementById('themeStatus').innerHTML = 
                '<p style="color: var(--text-light);">Reset to saved theme.</p>';
        }
        
        // Load department instructors (for admins)
        async function loadDepartmentInstructors() {
            if (!supabaseClient || !isAdmin()) return;
            
            if (!currentUser.department_id) {
                document.getElementById('departmentInstructorsContainer').innerHTML = 
                    '<p style="color: var(--warning);">‚ö†Ô∏è You are not assigned to a department.</p>';
                return;
            }
            
            try {
                const { data: instructors, error } = await supabaseClient
                    .from('user_profiles')
                    .select(`
                        id,
                        email,
                        full_name,
                        account_tier,
                        is_research_partner,
                        created_at,
                        departments (
                            name
                        )
                    `)
                    .eq('department_id', currentUser.department_id)
                    .eq('account_tier', 'instructor')
                    .order('email', { ascending: true });
                
                if (error) throw error;
                
                // Load course info for each instructor (for semester filtering)
                const instructorsWithCourses = await Promise.all(instructors.map(async (instructor) => {
                    const { data: courses } = await supabaseClient
                        .from('courses')
                        .select('id, name, semester, year')
                        .eq('instructor_id', instructor.id);
                    
                    return {
                        ...instructor,
                        courses: courses || []
                    };
                }));
                
                // Cache the full data
                cachedDepartmentInstructors = instructorsWithCourses;
                
                // Display all instructors initially
                displayDepartmentInstructors(instructorsWithCourses);
                
            } catch (error) {
                console.error('Error loading instructors:', error);
                document.getElementById('departmentInstructorsContainer').innerHTML = 
                    '<p style="color: var(--error);">Error loading instructors. Please try again.</p>';
            }
        }
        
        // Display department instructors (used by load and filter)
        function displayDepartmentInstructors(instructors) {
            const container = document.getElementById('departmentInstructorsContainer');
            
            if (!instructors || instructors.length === 0) {
                container.innerHTML = '<p style="color: var(--text-light);">No instructors found matching the filter.</p>';
                return;
            }
            
            // Build instructors list HTML
            let html = `
                <div style="background: var(--bg); border: 1px solid var(--border); border-radius: 0.5rem; overflow: hidden;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead style="background: var(--bg-alt);">
                            <tr>
                                <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Instructor</th>
                                <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Email</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Courses</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Research Partner</th>
                                <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            instructors.forEach(instructor => {
                const researchBadge = instructor.is_research_partner
                    ? '<span style="color: var(--success); font-size: 1.25rem;">‚úì</span>'
                    : '<span style="color: var(--text-light);">‚Äî</span>';
                
                const courseCount = instructor.courses?.length || 0;
                
                html += `
                    <tr style="border-bottom: 1px solid var(--border);">
                        <td style="padding: 0.75rem;">${instructor.full_name || '‚Äî'}</td>
                        <td style="padding: 0.75rem; color: var(--text-light);">${instructor.email}</td>
                        <td style="padding: 0.75rem; text-align: center;">${courseCount}</td>
                        <td style="padding: 0.75rem; text-align: center;">${researchBadge}</td>
                        <td style="padding: 0.75rem;">
                            <button onclick="viewInstructorCourses('${instructor.id}', '${instructor.email}')" 
                                    style="padding: 0.25rem 0.75rem; font-size: 0.875rem; margin-right: 0.5rem;">
                                üìö View Courses
                            </button>
                            <button onclick="viewInstructorDetails('${instructor.id}', '${instructor.email}')" 
                                    style="padding: 0.25rem 0.75rem; font-size: 0.875rem;">
                                üë§ Details
                            </button>
                        </td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
                <p style="margin-top: 1rem; color: var(--text-light); font-size: 0.875rem;">
                    Showing ${instructors.length} instructor${instructors.length !== 1 ? 's' : ''}
                </p>
            `;
            
            container.innerHTML = html;
            console.log('‚úì Displayed', instructors.length, 'instructors');
        }
        
        // Filter instructors by semester
        function filterBySemester() {
            const filter = document.getElementById('semesterFilter').value;
            console.log('üîç Filtering by semester:', filter);
            
            if (filter === 'all') {
                // Show all instructors
                displayDepartmentInstructors(cachedDepartmentInstructors);
                return;
            }
            
            // Filter instructors who have courses in the selected semester
            const filtered = cachedDepartmentInstructors.filter(instructor => {
                return instructor.courses.some(course => {
                    const courseSemester = course.semester && course.year 
                        ? `${course.semester} ${course.year}`
                        : '';
                    return courseSemester === filter;
                });
            });
            
            displayDepartmentInstructors(filtered);
        }
        
        // Enhanced analytics data cache
        let analyticsData = {
            evaluations: [],
            instructors: [],
            courses: [],
            filtered: []
        };
        
        // Switch analytics tabs
        function switchAnalyticsTab(tabName) {
            // Hide all tabs
            document.getElementById('analyticsOverviewTab').style.display = 'none';
            document.getElementById('analyticsRubricsTab').style.display = 'none';
            document.getElementById('analyticsComparisonsTab').style.display = 'none';
            document.getElementById('analyticsEvaluationsTab').style.display = 'none';
            
            // Reset tab styles
            ['tabOverview', 'tabRubrics', 'tabComparisons', 'tabEvaluations'].forEach(id => {
                const tab = document.getElementById(id);
                tab.style.borderBottom = '3px solid transparent';
                tab.style.color = 'var(--text-light)';
                tab.style.fontWeight = '400';
            });
            
            // Show selected tab
            const tabMap = {
                'overview': 'analyticsOverviewTab',
                'rubrics': 'analyticsRubricsTab',
                'comparisons': 'analyticsComparisonsTab',
                'evaluations': 'analyticsEvaluationsTab'
            };
            
            document.getElementById(tabMap[tabName]).style.display = 'block';
            
            // Style active tab
            const activeTabId = 'tab' + tabName.charAt(0).toUpperCase() + tabName.slice(1);
            const activeTab = document.getElementById(activeTabId);
            activeTab.style.borderBottom = '3px solid var(--primary)';
            activeTab.style.color = 'var(--primary)';
            activeTab.style.fontWeight = '600';
        }
        
        // Load enhanced analytics
        async function loadEnhancedAnalytics() {
            if (!supabaseClient || !isAdmin()) return;
            
            if (!currentUser.department_id) {
                alert('You are not assigned to a department.');
                return;
            }
            
            try {
                console.log('üìä Loading enhanced analytics...');
                
                // Show loading state
                document.getElementById('analyticsOverviewTab').innerHTML = '<p style="color: var(--text-light);">Loading analytics data...</p>';
                
                // Get date filters
                const startDate = document.getElementById('analyticsStartDate').value;
                const endDate = document.getElementById('analyticsEndDate').value;
                
                // Get instructors
                const { data: instructors, error: instError } = await supabaseClient
                    .from('user_profiles')
                    .select('id, email, full_name')
                    .eq('department_id', currentUser.department_id)
                    .eq('account_tier', 'instructor');
                
                if (instError) throw instError;
                
                // Get evaluations with full details
                let query = supabaseClient
                    .from('evaluations')
                    .select(`
                        id,
                        instructor_id,
                        course_id,
                        student_id,
                        created_at,
                        evaluation_data,
                        courses (id, name, semester, year),
                        course_students (first_name, last_name)
                    `)
                    .in('instructor_id', instructors.map(i => i.id));
                
                if (startDate) query = query.gte('created_at', startDate);
                if (endDate) query = query.lte('created_at', endDate + 'T23:59:59');
                
                const { data: evaluations, error: evalError } = await query;
                
                if (evalError) throw evalError;
                
                // Get unique courses
                const courseIds = [...new Set(evaluations.map(e => e.course_id))];
                const uniqueCourses = evaluations
                    .filter((e, i, arr) => arr.findIndex(x => x.course_id === e.course_id) === i)
                    .map(e => e.courses)
                    .filter(c => c);
                
                // Store in cache
                analyticsData.evaluations = evaluations || [];
                analyticsData.instructors = instructors || [];
                analyticsData.courses = uniqueCourses;
                analyticsData.filtered = evaluations || [];
                
                // Populate filter dropdowns
                populateAnalyticsFilters();
                
                // Render all tabs
                renderOverviewTab();
                renderRubricsTab();
                renderComparisonsTab();
                renderEvaluationsTab();
                
                console.log('‚úì Analytics loaded:', {
                    evaluations: evaluations.length,
                    instructors: instructors.length,
                    courses: uniqueCourses.length
                });
                
            } catch (error) {
                console.error('Error loading analytics:', error);
                document.getElementById('analyticsOverviewTab').innerHTML = 
                    '<p style="color: var(--error);">Error loading analytics. Please try again.</p>';
            }
        }
        
        // Populate filter dropdowns
        function populateAnalyticsFilters() {
            // Instructor filter
            const instFilter = document.getElementById('analyticsInstructorFilter');
            instFilter.innerHTML = '<option value="all">All Instructors</option>';
            analyticsData.instructors.forEach(inst => {
                instFilter.innerHTML += `<option value="${inst.id}">${inst.full_name || inst.email}</option>`;
            });
            
            // Course filter
            const courseFilter = document.getElementById('analyticsCourseFilter');
            courseFilter.innerHTML = '<option value="all">All Courses</option>';
            analyticsData.courses.forEach(course => {
                courseFilter.innerHTML += `<option value="${course.id}">${course.name}</option>`;
            });
        }
        
        // Filter analytics data
        function filterAnalytics() {
            const instFilter = document.getElementById('analyticsInstructorFilter').value;
            const courseFilter = document.getElementById('analyticsCourseFilter').value;
            
            let filtered = analyticsData.evaluations;
            
            if (instFilter !== 'all') {
                filtered = filtered.filter(e => e.instructor_id === instFilter);
            }
            
            if (courseFilter !== 'all') {
                filtered = filtered.filter(e => e.course_id === courseFilter);
            }
            
            analyticsData.filtered = filtered;
            
            // Re-render current tab
            renderOverviewTab();
            renderRubricsTab();
            renderComparisonsTab();
            renderEvaluationsTab();
        }
        
        // Search evaluations
        function searchEvaluations() {
            const searchTerm = document.getElementById('analyticsSearch').value.toLowerCase();
            
            if (!searchTerm) {
                filterAnalytics();
                return;
            }
            
            analyticsData.filtered = analyticsData.evaluations.filter(e => {
                const studentName = e.course_students 
                    ? `${e.course_students.first_name} ${e.course_students.last_name}`.toLowerCase()
                    : '';
                const courseName = e.courses?.name?.toLowerCase() || '';
                
                return studentName.includes(searchTerm) || courseName.includes(searchTerm);
            });
            
            renderEvaluationsTab();
        }
        
        // Render Overview Tab
        function renderOverviewTab() {
            const evals = analyticsData.filtered;
            const container = document.getElementById('analyticsOverviewTab');
            
            if (evals.length === 0) {
                container.innerHTML = '<p style="color: var(--text-light);">No evaluation data available.</p>';
                return;
            }
            
            // Calculate stats
            const uniqueStudents = new Set(evals.map(e => e.student_id)).size;
            const uniqueCourses = new Set(evals.map(e => e.course_id)).size;
            const uniqueInstructors = new Set(evals.map(e => e.instructor_id)).size;
            
            let html = `
                <!-- Overview Cards -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
                    <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; border-left: 4px solid var(--primary);">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--primary);">${evals.length}</div>
                        <div style="color: var(--text-light); margin-top: 0.5rem; font-size: 0.9rem;">Evaluations</div>
                    </div>
                    <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; border-left: 4px solid var(--success);">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--success);">${uniqueStudents}</div>
                        <div style="color: var(--text-light); margin-top: 0.5rem; font-size: 0.9rem;">Students</div>
                    </div>
                    <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; border-left: 4px solid var(--secondary);">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--secondary);">${uniqueCourses}</div>
                        <div style="color: var(--text-light); margin-top: 0.5rem; font-size: 0.9rem;">Courses</div>
                    </div>
                    <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; border-left: 4px solid var(--warning);">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--warning);">${uniqueInstructors}</div>
                        <div style="color: var(--text-light); margin-top: 0.5rem; font-size: 0.9rem;">Instructors</div>
                    </div>
                </div>
                
                <p style="color: var(--text-light); font-size: 0.9rem; margin-bottom: 1rem;">
                    Showing ${evals.length} evaluation${evals.length !== 1 ? 's' : ''} 
                    ${analyticsData.filtered.length !== analyticsData.evaluations.length ? '(filtered)' : ''}
                </p>
                
                <div style="background: var(--bg-alt); padding: 1rem; border-radius: 0.5rem;">
                    <p style="margin: 0; color: var(--text); font-size: 0.95rem;">
                        üí° <strong>Tip:</strong> Use the tabs above to explore rubric scores, compare courses/instructors, or drill down to individual evaluations.
                    </p>
                </div>
            `;
            
            container.innerHTML = html;
        }
        
        // Render Rubrics Tab - Detailed category analysis
        function renderRubricsTab() {
            const evals = analyticsData.filtered;
            const container = document.getElementById('analyticsRubricsTab');
            
            if (evals.length === 0) {
                container.innerHTML = '<p style="color: var(--text-light);">No evaluation data available for analysis.</p>';
                return;
            }
            
            // Extract and aggregate rubric scores (normalized to percentages)
            const categoryStats = {};
            let totalEvaluations = 0;
            
            evals.forEach(eval => {
                // Parse evaluation_data if it's a string
                let evalData = eval.evaluation_data;
                if (typeof evalData === 'string') {
                    try {
                        evalData = JSON.parse(evalData);
                    } catch (e) {
                        console.error('Error parsing evaluation data:', e);
                        return;
                    }
                }
                
                if (!evalData || !evalData.sections || typeof evalData.sections !== 'object') return;
                
                totalEvaluations++;
                
                // sections is an object like { "Content": {...}, "Delivery": {...} }
                Object.entries(evalData.sections).forEach(([sectionName, section]) => {
                    // Use section name as category
                    if (!categoryStats[sectionName]) {
                        categoryStats[sectionName] = {
                            name: sectionName,
                            percentages: [],
                            total: 0,
                            count: 0
                        };
                    }
                    
                    // Add section score (normalized to percentage)
                    if (section.score !== undefined && section.score !== null && section.maxScore) {
                        const percentage = (parseFloat(section.score) / parseFloat(section.maxScore)) * 100;
                        categoryStats[sectionName].percentages.push(percentage);
                        categoryStats[sectionName].total += percentage;
                        categoryStats[sectionName].count++;
                    }
                    
                    // Also process subcategories/feedback items
                    const items = section.subcategories || section.feedback || [];
                    if (Array.isArray(items)) {
                        items.forEach(item => {
                            const itemName = item.name;
                            if (!categoryStats[itemName]) {
                                categoryStats[itemName] = {
                                    name: itemName,
                                    percentages: [],
                                    total: 0,
                                    count: 0
                                };
                            }
                            
                            if (item.points !== undefined && item.points !== null && item.maxPoints) {
                                const percentage = (parseFloat(item.points) / parseFloat(item.maxPoints)) * 100;
                                categoryStats[itemName].percentages.push(percentage);
                                categoryStats[itemName].total += percentage;
                                categoryStats[itemName].count++;
                            }
                        });
                    }
                });
            });
            
            // Calculate averages and sort
            const categories = Object.values(categoryStats).map(cat => ({
                ...cat,
                average: cat.count > 0 ? (cat.total / cat.count).toFixed(1) : 0,
                min: cat.percentages.length > 0 ? Math.min(...cat.percentages).toFixed(1) : 0,
                max: cat.percentages.length > 0 ? Math.max(...cat.percentages).toFixed(1) : 0
            })).sort((a, b) => b.average - a.average);
            
            let html = `
                <h4 style="margin-bottom: 1rem;">Rubric Category Performance (Normalized %)</h4>
                <p style="color: var(--text-light); margin-bottom: 1.5rem; font-size: 0.9rem;">
                    Average percentages across all rubric categories based on ${totalEvaluations} evaluation${totalEvaluations !== 1 ? 's' : ''}. 
                    Scores are normalized to 0-100% scale for fair comparison across different point values.
                </p>
                
                <div style="background: var(--bg); border: 1px solid var(--border); border-radius: 0.5rem; overflow: hidden;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead style="background: var(--bg-alt);">
                            <tr>
                                <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Category</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Avg %</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Min %</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Max %</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Count</th>
                                <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Distribution</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            categories.forEach(cat => {
                const avgPct = parseFloat(cat.average);
                const barColor = avgPct >= 80 ? 'var(--success)' : avgPct >= 60 ? 'var(--warning)' : 'var(--error)';
                const barWidth = avgPct;
                
                html += `
                    <tr style="border-bottom: 1px solid var(--border);">
                        <td style="padding: 0.75rem;"><strong>${cat.name}</strong></td>
                        <td style="padding: 0.75rem; text-align: center; font-size: 1.1rem; font-weight: 600; color: ${barColor};">${cat.average}%</td>
                        <td style="padding: 0.75rem; text-align: center; color: var(--text-light);">${cat.min}%</td>
                        <td style="padding: 0.75rem; text-align: center; color: var(--text-light);">${cat.max}%</td>
                        <td style="padding: 0.75rem; text-align: center;">${cat.count}</td>
                        <td style="padding: 0.75rem;">
                            <div style="background: var(--bg-alt); height: 20px; border-radius: 10px; overflow: hidden;">
                                <div style="background: ${barColor}; width: ${barWidth}%; height: 100%;"></div>
                            </div>
                        </td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
            `;
            
            container.innerHTML = html;
        }
        
        // Render Comparisons Tab - Course and instructor comparisons
        function renderComparisonsTab() {
            const evals = analyticsData.filtered;
            const container = document.getElementById('analyticsComparisonsTab');
            
            if (evals.length === 0) {
                container.innerHTML = '<p style="color: var(--text-light);">No evaluation data available for comparison.</p>';
                return;
            }
            
            // Group by course
            const courseStats = {};
            evals.forEach(eval => {
                const courseId = eval.course_id;
                if (!courseStats[courseId]) {
                    courseStats[courseId] = {
                        name: eval.courses?.name || 'Unknown',
                        semester: eval.courses?.semester && eval.courses?.year 
                            ? `${eval.courses.semester} ${eval.courses.year}`
                            : 'Unknown',
                        evaluations: []
                    };
                }
                courseStats[courseId].evaluations.push(eval);
            });
            
            // Calculate averages per course (normalized to percentages)
            const courseComparisons = Object.values(courseStats).map(course => {
                let allPercentages = [];
                
                course.evaluations.forEach(e => {
                    // Parse evaluation_data if it's a string
                    let evalData = e.evaluation_data;
                    if (typeof evalData === 'string') {
                        try {
                            evalData = JSON.parse(evalData);
                        } catch (err) {
                            return;
                        }
                    }
                    
                    // Extract all section scores (sections is an object), normalized to percentages
                    if (evalData?.sections && typeof evalData.sections === 'object') {
                        Object.values(evalData.sections).forEach(section => {
                            if (section.score !== undefined && section.score !== null && section.maxScore) {
                                const percentage = (parseFloat(section.score) / parseFloat(section.maxScore)) * 100;
                                if (!isNaN(percentage)) {
                                    allPercentages.push(percentage);
                                }
                            }
                            
                            // Also get subcategory/feedback item percentages
                            const items = section.subcategories || section.feedback || [];
                            if (Array.isArray(items)) {
                                items.forEach(item => {
                                    if (item.points !== undefined && item.points !== null && item.maxPoints) {
                                        const percentage = (parseFloat(item.points) / parseFloat(item.maxPoints)) * 100;
                                        if (!isNaN(percentage)) {
                                            allPercentages.push(percentage);
                                        }
                                    }
                                });
                            }
                        });
                    }
                });
                
                const avg = allPercentages.length > 0 
                    ? (allPercentages.reduce((a, b) => a + b, 0) / allPercentages.length).toFixed(1) 
                    : 0;
                
                return {
                    ...course,
                    count: course.evaluations.length,
                    average: parseFloat(avg)
                };
            }).sort((a, b) => b.average - a.average);
            
            let html = `
                <h4 style="margin-bottom: 1rem;">Course Performance Comparison (Normalized %)</h4>
                <p style="color: var(--text-light); margin-bottom: 1.5rem; font-size: 0.9rem;">
                    Average percentages across all rubric categories for each course. Normalized for fair comparison.
                </p>
                
                <div style="background: var(--bg); border: 1px solid var(--border); border-radius: 0.5rem; overflow: hidden; margin-bottom: 2rem;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead style="background: var(--bg-alt);">
                            <tr>
                                <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Course</th>
                                <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Semester</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Evaluations</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Avg %</th>
                                <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Performance</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            courseComparisons.forEach(course => {
                const barColor = course.average >= 80 ? 'var(--success)' : course.average >= 60 ? 'var(--warning)' : 'var(--error)';
                const barWidth = course.average;
                
                html += `
                    <tr style="border-bottom: 1px solid var(--border);">
                        <td style="padding: 0.75rem;"><strong>${course.name}</strong></td>
                        <td style="padding: 0.75rem; color: var(--text-light); font-size: 0.9rem;">${course.semester}</td>
                        <td style="padding: 0.75rem; text-align: center;">${course.count}</td>
                        <td style="padding: 0.75rem; text-align: center; font-size: 1.1rem; font-weight: 600; color: ${barColor};">${course.average}%</td>
                        <td style="padding: 0.75rem;">
                            <div style="background: var(--bg-alt); height: 20px; border-radius: 10px; overflow: hidden;">
                                <div style="background: ${barColor}; width: ${barWidth}%; height: 100%;"></div>
                            </div>
                        </td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
            `;
            
            container.innerHTML = html;
        }
        
        // Render Evaluations Tab - Searchable list with drill-down
        function renderEvaluationsTab() {
            const evals = analyticsData.filtered;
            const container = document.getElementById('analyticsEvaluationsTab');
            
            if (evals.length === 0) {
                container.innerHTML = '<p style="color: var(--text-light);">No evaluations found. Try adjusting your filters or search.</p>';
                return;
            }
            
            // Add instructor names and calculate average scores
            const evalsWithDetails = evals.map(e => {
                const instructor = analyticsData.instructors.find(i => i.id === e.instructor_id);
                
                // Calculate overall score for this evaluation (normalized to percentage)
                let rawScores = [];
                let normalizedScores = [];
                let evalData = e.evaluation_data;
                if (typeof evalData === 'string') {
                    try {
                        evalData = JSON.parse(evalData);
                    } catch (err) {
                        console.error('Parse error for eval', e.id, err);
                        evalData = null;
                    }
                }
                
                // Handle sections as object (not array)
                if (evalData?.sections && typeof evalData.sections === 'object') {
                    // sections is an object like { "Content": {...}, "Delivery": {...} }
                    Object.values(evalData.sections).forEach(section => {
                        // Each section has a score and maxScore
                        if (section.score !== undefined && section.score !== null && section.maxScore) {
                            const raw = parseFloat(section.score);
                            const max = parseFloat(section.maxScore);
                            rawScores.push(raw);
                            // Normalize to 0-100 scale
                            normalizedScores.push((raw / max) * 100);
                        }
                        
                        // Also check subcategories/feedback arrays for individual item scores
                        const items = section.subcategories || section.feedback || [];
                        if (Array.isArray(items)) {
                            items.forEach(item => {
                                if (item.points !== undefined && item.points !== null && item.maxPoints) {
                                    const raw = parseFloat(item.points);
                                    const max = parseFloat(item.maxPoints);
                                    rawScores.push(raw);
                                    // Normalize to 0-100 scale
                                    normalizedScores.push((raw / max) * 100);
                                }
                            });
                        }
                    });
                }
                
                // Use normalized average for fair comparison across different rubrics
                const overallScore = normalizedScores.length > 0 
                    ? (normalizedScores.reduce((a, b) => a + b, 0) / normalizedScores.length).toFixed(1)
                    : 'N/A';
                
                return {
                    ...e,
                    instructorName: instructor?.full_name || instructor?.email || 'Unknown',
                    overallScore: overallScore, // Percentage
                    rawTotal: rawScores.length > 0 ? rawScores.reduce((a, b) => a + b, 0).toFixed(1) : 'N/A'
                };
            });
            
            let html = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; flex-wrap: wrap; gap: 1rem;">
                    <p style="color: var(--text-light); margin: 0; font-size: 0.9rem;">
                        Showing ${evals.length} evaluation${evals.length !== 1 ? 's' : ''}
                    </p>
                    <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                        <label style="font-size: 0.9rem; font-weight: 600;">Sort:</label>
                        <select id="evalSortField" onchange="sortEvaluations()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; font-size: 0.9rem;">
                            <option value="date">Date (Newest)</option>
                            <option value="date-asc">Date (Oldest)</option>
                            <option value="student">Student Name</option>
                            <option value="course">Course Name</option>
                            <option value="instructor">Instructor</option>
                            <option value="score">Score % (High)</option>
                            <option value="score-asc">Score % (Low)</option>
                        </select>
                        
                        <label style="font-size: 0.9rem; font-weight: 600; margin-left: 1rem;">Filter Score:</label>
                        <select id="evalScoreFilter" onchange="applyEvalFilters()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; font-size: 0.9rem;">
                            <option value="all">All Scores</option>
                            <option value="high">High (‚â•80%)</option>
                            <option value="medium">Medium (60-79%)</option>
                            <option value="low">Low (<60%)</option>
                        </select>
                    </div>
                </div>
                
                <div style="background: var(--bg); border: 1px solid var(--border); border-radius: 0.5rem; overflow: hidden;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead style="background: var(--bg-alt);">
                            <tr>
                                <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Date</th>
                                <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Student</th>
                                <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Course</th>
                                <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Instructor</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Score %</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="evaluationsTableBody">
            `;
            
            // Store for sorting and filtering
            window.currentEvaluationsList = evalsWithDetails;
            window.allEvaluationsList = evalsWithDetails;
            
            // Initial sort by date (newest first)
            evalsWithDetails.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            
            evalsWithDetails.slice(0, 100).forEach(eval => {
                const studentName = eval.course_students 
                    ? `${eval.course_students.first_name} ${eval.course_students.last_name}`
                    : 'Unknown';
                const courseName = eval.courses?.name || 'Unknown';
                const date = new Date(eval.created_at).toLocaleDateString();
                const evalId = eval.id;
                const scoreColor = eval.overallScore === 'N/A' ? 'var(--text-light)' :
                                  eval.overallScore >= 80 ? 'var(--success)' : 
                                  eval.overallScore >= 60 ? 'var(--warning)' : 'var(--error)';
                
                html += `
                    <tr style="border-bottom: 1px solid var(--border);">
                        <td style="padding: 0.75rem; color: var(--text-light); font-size: 0.9rem;">${date}</td>
                        <td style="padding: 0.75rem;"><strong>${studentName}</strong></td>
                        <td style="padding: 0.75rem; color: var(--text-light); font-size: 0.9rem;">${courseName}</td>
                        <td style="padding: 0.75rem; color: var(--text-light); font-size: 0.9rem;">${eval.instructorName}</td>
                        <td style="padding: 0.75rem; text-align: center; font-weight: 600; color: ${scoreColor};">${eval.overallScore === 'N/A' ? 'N/A' : `${eval.overallScore}%`}</td>
                        <td style="padding: 0.75rem; text-align: center;">
                            <button onclick="viewEvaluationDetails('${evalId}')" 
                                    style="padding: 0.25rem 0.75rem; font-size: 0.875rem;">
                                üîç View Details
                            </button>
                        </td>
                    </tr>
                `;
            });
            
            if (evals.length > 100) {
                html += `
                    <tr>
                        <td colspan="6" style="padding: 1rem; text-align: center; color: var(--text-light); font-style: italic;">
                            Showing first 100 of ${evals.length} evaluations. Use filters to narrow results.
                        </td>
                    </tr>
                `;
            }
            
            html += `
                        </tbody>
                    </table>
                </div>
            `;
            
            container.innerHTML = html;
        }
        
        // Sort evaluations
        function sortEvaluations() {
            const sortField = document.getElementById('evalSortField').value;
            const evals = window.currentEvaluationsList || [];
            
            if (evals.length === 0) return;
            
            switch(sortField) {
                case 'date':
                    evals.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
                    break;
                case 'date-asc':
                    evals.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
                    break;
                case 'student':
                    evals.sort((a, b) => {
                        const nameA = a.course_students ? `${a.course_students.first_name} ${a.course_students.last_name}` : 'Unknown';
                        const nameB = b.course_students ? `${b.course_students.first_name} ${b.course_students.last_name}` : 'Unknown';
                        return nameA.localeCompare(nameB);
                    });
                    break;
                case 'course':
                    evals.sort((a, b) => {
                        const courseA = a.courses?.name || 'Unknown';
                        const courseB = b.courses?.name || 'Unknown';
                        return courseA.localeCompare(courseB);
                    });
                    break;
                case 'instructor':
                    evals.sort((a, b) => a.instructorName.localeCompare(b.instructorName));
                    break;
                case 'score':
                    evals.sort((a, b) => {
                        const scoreA = a.overallScore === 'N/A' ? -1 : parseFloat(a.overallScore);
                        const scoreB = b.overallScore === 'N/A' ? -1 : parseFloat(b.overallScore);
                        return scoreB - scoreA;
                    });
                    break;
                case 'score-asc':
                    evals.sort((a, b) => {
                        const scoreA = a.overallScore === 'N/A' ? 999 : parseFloat(a.overallScore);
                        const scoreB = b.overallScore === 'N/A' ? 999 : parseFloat(b.overallScore);
                        return scoreA - scoreB;
                    });
                    break;
            }
            
            // Re-render table body
            updateEvaluationsTable(evals);
        }
        
        // Apply evaluation filters
        function applyEvalFilters() {
            const scoreFilter = document.getElementById('evalScoreFilter').value;
            let filtered = window.allEvaluationsList || [];
            
            // Apply score filter
            if (scoreFilter !== 'all') {
                filtered = filtered.filter(e => {
                    const score = e.overallScore === 'N/A' ? 0 : parseFloat(e.overallScore);
                    switch(scoreFilter) {
                        case 'high':
                            return score >= 80;
                        case 'medium':
                            return score >= 60 && score < 80;
                        case 'low':
                            return score < 60 && score > 0;
                        default:
                            return true;
                    }
                });
            }
            
            // Update current list and re-apply sort
            window.currentEvaluationsList = filtered;
            sortEvaluations();
        }
        
        // Update evaluations table display
        function updateEvaluationsTable(evals) {
            const tbody = document.getElementById('evaluationsTableBody');
            if (!tbody) return;
            
            let html = '';
            evals.slice(0, 100).forEach(eval => {
                const studentName = eval.course_students 
                    ? `${eval.course_students.first_name} ${eval.course_students.last_name}`
                    : 'Unknown';
                const courseName = eval.courses?.name || 'Unknown';
                const date = new Date(eval.created_at).toLocaleDateString();
                const evalId = eval.id;
                const scoreColor = eval.overallScore === 'N/A' ? 'var(--text-light)' :
                                  eval.overallScore >= 80 ? 'var(--success)' : 
                                  eval.overallScore >= 60 ? 'var(--warning)' : 'var(--error)';
                
                html += `
                    <tr style="border-bottom: 1px solid var(--border);">
                        <td style="padding: 0.75rem; color: var(--text-light); font-size: 0.9rem;">${date}</td>
                        <td style="padding: 0.75rem;"><strong>${studentName}</strong></td>
                        <td style="padding: 0.75rem; color: var(--text-light); font-size: 0.9rem;">${courseName}</td>
                        <td style="padding: 0.75rem; color: var(--text-light); font-size: 0.9rem;">${eval.instructorName}</td>
                        <td style="padding: 0.75rem; text-align: center; font-weight: 600; color: ${scoreColor};">${eval.overallScore === 'N/A' ? 'N/A' : `${eval.overallScore}%`}</td>
                        <td style="padding: 0.75rem; text-align: center;">
                            <button onclick="viewEvaluationDetails('${evalId}')" 
                                    style="padding: 0.25rem 0.75rem; font-size: 0.875rem;">
                                üîç View Details
                            </button>
                        </td>
                    </tr>
                `;
            });
            
            tbody.innerHTML = html;
            
            // Update count display
            const countText = document.querySelector('#analyticsEvaluationsTab p');
            if (countText) {
                countText.textContent = `Showing ${evals.length} evaluation${evals.length !== 1 ? 's' : ''}`;
            }
        }
        
        // View evaluation details modal
        function viewEvaluationDetails(evaluationId) {
            const evaluation = analyticsData.filtered.find(e => e.id === evaluationId);
            if (!evaluation) {
                alert('Evaluation not found');
                return;
            }
            
            console.log('üîç Viewing evaluation:', evaluation.id);
            
            const studentName = evaluation.course_students 
                ? `${evaluation.course_students.first_name} ${evaluation.course_students.last_name}`
                : 'Unknown';
            const courseName = evaluation.courses?.name || 'Unknown';
            const date = new Date(evaluation.created_at).toLocaleString();
            
            let detailsHTML = `
                <div style="margin-bottom: 1.5rem;">
                    <p><strong>Student:</strong> ${studentName}</p>
                    <p><strong>Course:</strong> ${courseName}</p>
                    <p><strong>Date:</strong> ${date}</p>
                </div>
            `;
            
            // Parse evaluation_data if it's a string
            let evalData = evaluation.evaluation_data;
            if (typeof evalData === 'string') {
                try {
                    evalData = JSON.parse(evalData);
                } catch (e) {
                    console.error('Error parsing evaluation data:', e);
                    evalData = null;
                }
            }
            
            // Show rubric scores if available
            if (evalData && evalData.sections && typeof evalData.sections === 'object') {
                detailsHTML += '<h4 style="margin-bottom: 1rem;">Rubric Scores</h4>';
                
                // sections is an object like { "Content": {...}, "Delivery": {...} }
                Object.entries(evalData.sections).forEach(([sectionName, section]) => {
                    detailsHTML += `<h5 style="margin-top: 1rem; color: var(--primary);">${sectionName}</h5>`;
                    
                    // Show section score
                    if (section.score !== undefined) {
                        const sectionScore = parseFloat(section.score);
                        const scoreColor = sectionScore >= section.maxScore * 0.8 ? 'var(--success)' : 
                                          sectionScore >= section.maxScore * 0.6 ? 'var(--warning)' : 'var(--error)';
                        detailsHTML += `
                            <div style="background: var(--bg-alt); padding: 0.75rem; border-radius: 0.5rem; margin-top: 0.5rem; margin-bottom: 0.5rem;">
                                <strong>Section Score:</strong> 
                                <span style="font-weight: 600; color: ${scoreColor};">${sectionScore}/${section.maxScore || 'N/A'}</span>
                            </div>
                        `;
                    }
                    
                    // Show subcategories/feedback items
                    const items = section.subcategories || section.feedback || [];
                    if (Array.isArray(items) && items.length > 0) {
                        detailsHTML += '<div style="background: var(--bg-alt); padding: 0.5rem; border-radius: 0.5rem; margin-top: 0.5rem;">';
                        items.forEach(item => {
                            const points = item.points !== undefined ? item.points : 'N/A';
                            const maxPoints = item.maxPoints || 10;
                            const scoreColor = points >= maxPoints * 0.8 ? 'var(--success)' : 
                                              points >= maxPoints * 0.6 ? 'var(--warning)' : 'var(--error)';
                            
                            detailsHTML += `
                                <div style="padding: 0.5rem 0; border-bottom: 1px solid var(--border);">
                                    <div style="display: flex; justify-content: space-between;">
                                        <span><strong>${item.name}</strong></span>
                                        <span style="font-weight: 600; color: ${scoreColor};">${points}/${maxPoints}</span>
                                    </div>
                                    ${item.feedback ? `<div style="color: var(--text-light); font-size: 0.9rem; margin-top: 0.25rem;">${item.feedback}</div>` : ''}
                                </div>
                            `;
                        });
                        detailsHTML += '</div>';
                    }
                });
            }
            
            // Show in modal
            const modal = `
                <div id="evaluationDetailsModal" style="display:flex;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
                    <div style="background:white;padding:2rem;border-radius:1rem;max-width:700px;width:90%;max-height:90vh;overflow-y:auto;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:1.5rem;">
                            <h3 style="margin:0;color:var(--primary);">üìä Evaluation Details</h3>
                            <button onclick="closeEvaluationDetailsModal()" style="background:none;border:none;font-size:1.5rem;cursor:pointer;color:var(--text-light);">‚úï</button>
                        </div>
                        ${detailsHTML}
                        <div style="margin-top:2rem;text-align:right;">
                            <button onclick="closeEvaluationDetailsModal()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;">
                                Close
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modal);
        }
        
        // Close evaluation details modal
        function closeEvaluationDetailsModal() {
            const modal = document.getElementById('evaluationDetailsModal');
            if (modal) modal.remove();
        }
        
        // Load department analytics (old function kept for compatibility)
        async function loadDepartmentAnalytics() {
            
            if (!currentUser.department_id) {
                document.getElementById('departmentAnalyticsContainer').innerHTML = 
                    '<p style="color: var(--warning);">‚ö†Ô∏è You are not assigned to a department.</p>';
                return;
            }
            
            const container = document.getElementById('departmentAnalyticsContainer');
            container.innerHTML = '<p style="color: var(--text-light);">Loading analytics...</p>';
            
            try {
                // Get date range filters
                const startDate = document.getElementById('analyticsStartDate').value;
                const endDate = document.getElementById('analyticsEndDate').value;
                
                // Get all instructors in department
                const { data: instructors, error: instError } = await supabaseClient
                    .from('user_profiles')
                    .select('id, email, full_name')
                    .eq('department_id', currentUser.department_id)
                    .eq('account_tier', 'instructor');
                
                if (instError) throw instError;
                
                if (!instructors || instructors.length === 0) {
                    container.innerHTML = '<p style="color: var(--text-light);">No instructors in department.</p>';
                    return;
                }
                
                // Get all evaluations for department instructors
                let query = supabaseClient
                    .from('evaluations')
                    .select(`
                        id,
                        instructor_id,
                        course_id,
                        student_id,
                        created_at,
                        evaluation_data
                    `)
                    .in('instructor_id', instructors.map(i => i.id));
                
                // Apply date filters if set
                if (startDate) {
                    query = query.gte('created_at', startDate);
                }
                if (endDate) {
                    query = query.lte('created_at', endDate + 'T23:59:59');
                }
                
                const { data: evaluations, error: evalError } = await query;
                
                if (evalError) throw evalError;
                
                // Calculate statistics
                const stats = calculateDepartmentStats(instructors, evaluations || []);
                
                // Display analytics
                displayDepartmentAnalytics(stats);
                
            } catch (error) {
                console.error('Error loading analytics:', error);
                container.innerHTML = '<p style="color: var(--error);">Error loading analytics. Please try again.</p>';
            }
        }
        
        // Calculate department statistics
        function calculateDepartmentStats(instructors, evaluations) {
            const stats = {
                totalInstructors: instructors.length,
                totalEvaluations: evaluations.length,
                instructorStats: [],
                dateRange: {
                    start: document.getElementById('analyticsStartDate').value || 'All time',
                    end: document.getElementById('analyticsEndDate').value || 'Present'
                }
            };
            
            // Calculate per-instructor stats
            instructors.forEach(instructor => {
                const instructorEvals = evaluations.filter(e => e.instructor_id === instructor.id);
                const uniqueStudents = new Set(instructorEvals.map(e => e.student_id)).size;
                const uniqueCourses = new Set(instructorEvals.map(e => e.course_id)).size;
                
                stats.instructorStats.push({
                    name: instructor.full_name || instructor.email,
                    email: instructor.email,
                    evaluationCount: instructorEvals.length,
                    studentCount: uniqueStudents,
                    courseCount: uniqueCourses
                });
            });
            
            // Sort by evaluation count
            stats.instructorStats.sort((a, b) => b.evaluationCount - a.evaluationCount);
            
            return stats;
        }
        
        // Display department analytics
        function displayDepartmentAnalytics(stats) {
            const container = document.getElementById('departmentAnalyticsContainer');
            
            let html = `
                <!-- Overview Cards -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
                    <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; border-left: 4px solid var(--primary);">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--primary);">${stats.totalInstructors}</div>
                        <div style="color: var(--text-light); margin-top: 0.5rem;">Total Instructors</div>
                    </div>
                    <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; border-left: 4px solid var(--success);">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--success);">${stats.totalEvaluations}</div>
                        <div style="color: var(--text-light); margin-top: 0.5rem;">Total Evaluations</div>
                    </div>
                    <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; border-left: 4px solid var(--secondary);">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--secondary);">${stats.totalEvaluations > 0 ? Math.round(stats.totalEvaluations / stats.totalInstructors) : 0}</div>
                        <div style="color: var(--text-light); margin-top: 0.5rem;">Avg per Instructor</div>
                    </div>
                </div>
                
                <div style="background: var(--bg-alt); padding: 1rem; border-radius: 0.5rem; margin-bottom: 2rem;">
                    <p style="margin: 0; color: var(--text-light); font-size: 0.9rem;">
                        üìÖ Date Range: ${stats.dateRange.start} to ${stats.dateRange.end}
                    </p>
                </div>
                
                <!-- Instructor Breakdown Table -->
                <h4 style="margin-bottom: 1rem;">Instructor Activity</h4>
                <div style="background: var(--bg); border: 1px solid var(--border); border-radius: 0.5rem; overflow: hidden;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead style="background: var(--bg-alt);">
                            <tr>
                                <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Instructor</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Courses</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Students</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Evaluations</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">% of Total</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            stats.instructorStats.forEach(instructor => {
                const percentage = stats.totalEvaluations > 0 
                    ? Math.round((instructor.evaluationCount / stats.totalEvaluations) * 100)
                    : 0;
                
                html += `
                    <tr style="border-bottom: 1px solid var(--border);">
                        <td style="padding: 0.75rem;">
                            <strong>${instructor.name}</strong>
                            <br><small style="color: var(--text-light);">${instructor.email}</small>
                        </td>
                        <td style="padding: 0.75rem; text-align: center;">${instructor.courseCount}</td>
                        <td style="padding: 0.75rem; text-align: center;">${instructor.studentCount}</td>
                        <td style="padding: 0.75rem; text-align: center;"><strong>${instructor.evaluationCount}</strong></td>
                        <td style="padding: 0.75rem; text-align: center;">
                            <div style="background: var(--bg-alt); border-radius: 0.25rem; padding: 0.25rem;">
                                ${percentage}%
                            </div>
                        </td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
            `;
            
            container.innerHTML = html;
            console.log('‚úì Analytics loaded:', stats);
        }
        
        // Export department data to CSV (for research - SPSS compatible)
        async function exportDepartmentData() {
            if (!supabaseClient || !isAdmin()) return;
            
            if (!currentUser.department_id) {
                alert('You are not assigned to a department.');
                return;
            }
            
            try {
                console.log('üíæ Exporting SPSS-compatible department data...');
                
                // Get date range filters
                const startDate = document.getElementById('analyticsStartDate').value;
                const endDate = document.getElementById('analyticsEndDate').value;
                
                // Get all instructors in department
                const { data: instructors, error: instError } = await supabaseClient
                    .from('user_profiles')
                    .select('id, email, full_name, is_research_partner')
                    .eq('department_id', currentUser.department_id)
                    .eq('account_tier', 'instructor');
                
                if (instError) throw instError;
                
                // Get all evaluations with full details
                let query = supabaseClient
                    .from('evaluations')
                    .select(`
                        id,
                        instructor_id,
                        course_id,
                        student_id,
                        created_at,
                        evaluation_data,
                        courses (id, name, semester, year),
                        course_students (id, first_name, last_name)
                    `)
                    .in('instructor_id', instructors.map(i => i.id));
                
                // Apply date filters
                if (startDate) query = query.gte('created_at', startDate);
                if (endDate) query = query.lte('created_at', endDate + 'T23:59:59');
                
                const { data: evaluations, error: evalError } = await query;
                
                if (evalError) throw evalError;
                
                if (!evaluations || evaluations.length === 0) {
                    alert('No evaluation data found for the selected date range.');
                    return;
                }
                
                // Create instructor lookup
                const instructorMap = {};
                instructors.forEach(i => {
                    instructorMap[i.id] = i;
                });
                
                // Collect all unique rubric categories across all evaluations
                const allCategories = new Set();
                evaluations.forEach(eval => {
                    let evalData = eval.evaluation_data;
                    if (typeof evalData === 'string') {
                        try {
                            evalData = JSON.parse(evalData);
                        } catch (e) {
                            return;
                        }
                    }
                    
                    // sections is an object like { "Content": {...}, "Delivery": {...} }
                    if (evalData?.sections && typeof evalData.sections === 'object') {
                        // Add section names
                        Object.keys(evalData.sections).forEach(sectionName => {
                            allCategories.add(sectionName);
                        });
                        
                        // Add subcategory/feedback item names
                        Object.values(evalData.sections).forEach(section => {
                            const items = section.subcategories || section.feedback || [];
                            if (Array.isArray(items)) {
                                items.forEach(item => {
                                    if (item.name) {
                                        allCategories.add(item.name);
                                    }
                                });
                            }
                        });
                    }
                });
                
                const categoryList = Array.from(allCategories).sort();
                
                // Build SPSS-compatible CSV header
                let csv = 'EvalID,Date,Year,Month,Day,';
                csv += 'InstructorID,InstructorName,InstructorEmail,ResearchPartner,';
                csv += 'CourseID,CourseName,Semester,';
                csv += 'StudentID,StudentFirstName,StudentLastName,';
                
                // Add columns for each rubric category - BOTH raw and percentage
                categoryList.forEach(cat => {
                    // Convert category name to valid variable name (remove spaces, special chars)
                    const varName = cat.replace(/[^a-zA-Z0-9]/g, '_');
                    csv += `${varName}_Raw,${varName}_Pct,${varName}_Max,`;
                });
                
                csv += 'OverallScore_Pct\n';
                
                // Build data rows
                evaluations.forEach(eval => {
                    const instructor = instructorMap[eval.instructor_id];
                    const date = new Date(eval.created_at);
                    
                    // Basic info
                    csv += `"${eval.id}",`;
                    csv += `"${date.toISOString().split('T')[0]}",`;
                    csv += `${date.getFullYear()},`;
                    csv += `${date.getMonth() + 1},`;
                    csv += `${date.getDate()},`;
                    
                    // Instructor info
                    csv += `"${instructor?.id || ''}",`;
                    csv += `"${(instructor?.full_name || '').replace(/"/g, '""')}",`;
                    csv += `"${instructor?.email || ''}",`;
                    csv += `${instructor?.is_research_partner ? '1' : '0'},`;
                    
                    // Course info
                    csv += `"${eval.course_id || ''}",`;
                    csv += `"${(eval.courses?.name || '').replace(/"/g, '""')}",`;
                    csv += `"${eval.courses?.semester && eval.courses?.year ? eval.courses.semester + ' ' + eval.courses.year : ''}",`;
                    
                    // Student info
                    csv += `"${eval.student_id || ''}",`;
                    csv += `"${(eval.course_students?.first_name || '').replace(/"/g, '""')}",`;
                    csv += `"${(eval.course_students?.last_name || '').replace(/"/g, '""')}",`;
                    
                    // Parse evaluation data
                    let evalData = eval.evaluation_data;
                    if (typeof evalData === 'string') {
                        try {
                            evalData = JSON.parse(evalData);
                        } catch (e) {
                            evalData = null;
                        }
                    }
                    
                    // Create score lookup for this evaluation
                    const scores = {};
                    let allPercentages = [];
                    
                    if (evalData?.sections && typeof evalData.sections === 'object') {
                        Object.entries(evalData.sections).forEach(([sectionName, section]) => {
                            // Add section score
                            if (section.score !== undefined && section.score !== null && section.maxScore) {
                                const raw = parseFloat(section.score);
                                const max = parseFloat(section.maxScore);
                                const pct = (raw / max) * 100;
                                
                                scores[sectionName] = {
                                    raw: raw,
                                    pct: pct.toFixed(1),
                                    max: max
                                };
                                allPercentages.push(pct);
                            }
                            
                            // Add subcategory/feedback item scores
                            const items = section.subcategories || section.feedback || [];
                            if (Array.isArray(items)) {
                                items.forEach(item => {
                                    if (item.name && item.points !== undefined && item.points !== null && item.maxPoints) {
                                        const raw = parseFloat(item.points);
                                        const max = parseFloat(item.maxPoints);
                                        const pct = (raw / max) * 100;
                                        
                                        scores[item.name] = {
                                            raw: raw,
                                            pct: pct.toFixed(1),
                                            max: max
                                        };
                                        allPercentages.push(pct);
                                    }
                                });
                            }
                        });
                    }
                    
                    // Add score for each category (or empty if not present) - raw, pct, max
                    categoryList.forEach(cat => {
                        if (scores[cat]) {
                            csv += `${scores[cat].raw},${scores[cat].pct},${scores[cat].max},`;
                        } else {
                            csv += ',,,'; // Empty raw, pct, max
                        }
                    });
                    
                    // Add overall percentage score
                    const overallPct = allPercentages.length > 0 
                        ? (allPercentages.reduce((a, b) => a + b, 0) / allPercentages.length).toFixed(1)
                        : '';
                    csv += `${overallPct}\n`;
                });
                
                // Download CSV
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                
                const departmentName = currentUser.department?.name || 'Department';
                const dateStr = new Date().toISOString().split('T')[0];
                a.download = `${departmentName}_SPSS_Data_${dateStr}.csv`;
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
                console.log('‚úì Exported', evaluations.length, 'evaluations to SPSS-compatible CSV');
                console.log('‚úì Rubric categories as columns:', categoryList.length);
                alert(`‚úì Exported ${evaluations.length} evaluations to SPSS-compatible CSV!\n\n` +
                      `File: ${a.download}\n\n` +
                      `Format: Each rubric category has 3 columns:\n` +
                      `  - CategoryName_Raw (actual points earned)\n` +
                      `  - CategoryName_Pct (normalized 0-100%)\n` +
                      `  - CategoryName_Max (max possible points)\n\n` +
                      `Normalized percentages allow fair comparison across different rubrics.\n` +
                      `Numeric codes: ResearchPartner (1=Yes, 0=No)\n` +
                      `Date components: Year, Month, Day for time series analysis`);
                
            } catch (error) {
                console.error('Error exporting data:', error);
                alert('Error exporting data. Please try again.');
            }
        }
        
        // View instructor's courses (for admins)
        async function viewInstructorCourses(instructorId, instructorEmail) {
            console.log('üìö Viewing courses for:', instructorEmail);
            
            if (!supabaseClient) return;
            
            try {
                // Load instructor's courses
                const { data: courses, error } = await supabaseClient
                    .from('courses')
                    .select(`
                        id,
                        name,
                        semester,
                        year,
                        created_at
                    `)
                    .eq('instructor_id', instructorId)
                    .order('created_at', { ascending: false });
                
                if (error) throw error;
                
                // Load student counts for each course
                const coursesWithCounts = await Promise.all(courses.map(async (course) => {
                    const { data: students, error: studError } = await supabaseClient
                        .from('course_students')
                        .select('id')
                        .eq('course_id', course.id);
                    
                    const { data: evaluations, error: evalError } = await supabaseClient
                        .from('evaluations')
                        .select('id')
                        .eq('course_id', course.id);
                    
                    return {
                        ...course,
                        student_count: students?.length || 0,
                        evaluation_count: evaluations?.length || 0
                    };
                }));
                
                // Show in modal
                showInstructorCoursesModal(instructorEmail, coursesWithCounts);
                
            } catch (error) {
                console.error('Error loading instructor courses:', error);
                alert('Error loading courses. Please try again.');
            }
        }
        
        // Show instructor courses modal
        function showInstructorCoursesModal(instructorEmail, courses) {
            // Create modal HTML
            let html = `
                <div id="instructorCoursesModal" style="display:flex;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
                    <div style="background:white;padding:2rem;border-radius:1rem;max-width:900px;width:90%;max-height:90vh;overflow-y:auto;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:1.5rem;">
                            <h3 style="margin:0;color:var(--primary);">üìö Courses - ${instructorEmail}</h3>
                            <button onclick="closeInstructorCoursesModal()" style="background:none;border:none;font-size:1.5rem;cursor:pointer;color:var(--text-light);">‚úï</button>
                        </div>
            `;
            
            if (!courses || courses.length === 0) {
                html += '<p style="color:var(--text-light);">This instructor has no courses yet.</p>';
            } else {
                html += `
                    <div style="background:var(--bg);border:1px solid var(--border);border-radius:0.5rem;overflow:hidden;">
                        <table style="width:100%;border-collapse:collapse;">
                            <thead style="background:var(--bg-alt);">
                                <tr>
                                    <th style="padding:0.75rem;text-align:left;border-bottom:1px solid var(--border);">Course</th>
                                    <th style="padding:0.75rem;text-align:left;border-bottom:1px solid var(--border);">Semester</th>
                                    <th style="padding:0.75rem;text-align:center;border-bottom:1px solid var(--border);">Students</th>
                                    <th style="padding:0.75rem;text-align:center;border-bottom:1px solid var(--border);">Evaluations</th>
                                    <th style="padding:0.75rem;text-align:left;border-bottom:1px solid var(--border);">Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                courses.forEach(course => {
                    const semester = course.semester && course.year 
                        ? `${course.semester} ${course.year}`
                        : '‚Äî';
                    
                    html += `
                        <tr style="border-bottom:1px solid var(--border);">
                            <td style="padding:0.75rem;">
                                <strong>${course.name}</strong>
                            </td>
                            <td style="padding:0.75rem;color:var(--text-light);">${semester}</td>
                            <td style="padding:0.75rem;text-align:center;">${course.student_count}</td>
                            <td style="padding:0.75rem;text-align:center;">${course.evaluation_count}</td>
                            <td style="padding:0.75rem;">
                                <button onclick="viewCourseStudents('${course.id}', '${course.name.replace(/'/g, "\\'")}', '${instructorEmail}')" 
                                        style="padding:0.25rem 0.75rem;font-size:0.875rem;">
                                    üë• View Students
                                </button>
                            </td>
                        </tr>
                    `;
                });
                
                html += `
                            </tbody>
                        </table>
                    </div>
                    <p style="margin-top:1rem;color:var(--text-light);font-size:0.875rem;">
                        Total courses: ${courses.length} | 
                        Total students: ${courses.reduce((sum, c) => sum + c.student_count, 0)} | 
                        Total evaluations: ${courses.reduce((sum, c) => sum + c.evaluation_count, 0)}
                    </p>
                `;
            }
            
            html += `
                        <div style="margin-top:1.5rem;text-align:right;">
                            <button onclick="closeInstructorCoursesModal()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;">
                                Close
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            // Add to page
            document.body.insertAdjacentHTML('beforeend', html);
        }
        
        // Close instructor courses modal
        function closeInstructorCoursesModal() {
            const modal = document.getElementById('instructorCoursesModal');
            if (modal) modal.remove();
        }
        
        // View course students (for admins viewing instructor's courses)
        async function viewCourseStudents(courseId, courseName, instructorEmail) {
            console.log('üë• Viewing students for course:', courseName);
            alert(`Feature coming soon!\n\nWill show all students in:\n${courseName}\n\nInstructor: ${instructorEmail}`);
            // TODO: Implement student list viewing
        }
        
        // View instructor details (for admins)
        async function viewInstructorDetails(instructorId, instructorEmail) {
            console.log('üë§ Viewing details for:', instructorEmail);
            
            if (!supabaseClient) return;
            
            try {
                // Get instructor info
                const { data: instructor, error: userError } = await supabaseClient
                    .from('user_profiles')
                    .select(`
                        id,
                        email,
                        full_name,
                        account_tier,
                        is_research_partner,
                        research_partner_opt_out_requested,
                        research_partner_opt_out_approved,
                        research_partner_opt_out_reason,
                        created_at,
                        departments (name),
                        institutions (name)
                    `)
                    .eq('id', instructorId)
                    .single();
                
                if (userError) throw userError;
                
                // Get course count
                const { data: courses, error: courseError } = await supabaseClient
                    .from('courses')
                    .select('id')
                    .eq('instructor_id', instructorId);
                
                // Get evaluation count
                const { data: evaluations, error: evalError } = await supabaseClient
                    .from('evaluations')
                    .select('id')
                    .eq('instructor_id', instructorId);
                
                // Show details modal
                showInstructorDetailsModal(instructor, courses?.length || 0, evaluations?.length || 0);
                
            } catch (error) {
                console.error('Error loading instructor details:', error);
                alert('Error loading details. Please try again.');
            }
        }
        
        // Show instructor details modal
        function showInstructorDetailsModal(instructor, courseCount, evaluationCount) {
            const researchStatus = instructor.is_research_partner 
                ? '<span style="color:var(--success);font-weight:600;">‚úì Active Research Partner</span>'
                : '<span style="color:var(--text-light);">Not a research partner</span>';
            
            let optOutStatus = '';
            if (instructor.research_partner_opt_out_requested && !instructor.research_partner_opt_out_approved) {
                optOutStatus = `
                    <div style="background:#fff3cd;border-left:4px solid var(--warning);padding:1rem;margin-top:1rem;border-radius:0.5rem;">
                        <strong>‚ö†Ô∏è Pending Opt-Out Request</strong>
                        <p style="margin:0.5rem 0 0 0;color:var(--text);">
                            ${instructor.research_partner_opt_out_reason || 'No reason provided'}
                        </p>
                    </div>
                `;
            }
            
            const html = `
                <div id="instructorDetailsModal" style="display:flex;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
                    <div style="background:white;padding:2rem;border-radius:1rem;max-width:600px;width:90%;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:1.5rem;">
                            <h3 style="margin:0;color:var(--primary);">üë§ Instructor Details</h3>
                            <button onclick="closeInstructorDetailsModal()" style="background:none;border:none;font-size:1.5rem;cursor:pointer;color:var(--text-light);">‚úï</button>
                        </div>
                        
                        <div style="margin-bottom:1.5rem;">
                            <p><strong>Name:</strong> ${instructor.full_name || 'Not set'}</p>
                            <p><strong>Email:</strong> ${instructor.email}</p>
                            <p><strong>Institution:</strong> ${instructor.institutions?.name || '‚Äî'}</p>
                            <p><strong>Department:</strong> ${instructor.departments?.name || '‚Äî'}</p>
                            <p><strong>Member since:</strong> ${new Date(instructor.created_at).toLocaleDateString()}</p>
                        </div>
                        
                        <div style="background:var(--bg-alt);padding:1rem;border-radius:0.5rem;margin-bottom:1.5rem;">
                            <h4 style="margin:0 0 0.5rem 0;">Activity Summary</h4>
                            <p style="margin:0.25rem 0;">üìö Courses: ${courseCount}</p>
                            <p style="margin:0.25rem 0;">üìä Evaluations: ${evaluationCount}</p>
                        </div>
                        
                        <div style="margin-bottom:1.5rem;">
                            <h4 style="margin:0 0 0.5rem 0;">Research Partner Status</h4>
                            <p style="margin:0;">${researchStatus}</p>
                            ${optOutStatus}
                        </div>
                        
                        <div style="text-align:right;">
                            <button onclick="closeInstructorDetailsModal()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;">
                                Close
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', html);
        }
        
        // Close instructor details modal
        function closeInstructorDetailsModal() {
            const modal = document.getElementById('instructorDetailsModal');
            if (modal) modal.remove();
        }
        
        // Admin Functions
        async function loadAllUsers() {
            if (!supabaseClient || !canManageUsers()) return;
            
            try {
                const { data: users, error } = await supabaseClient
                    .from('user_profiles')
                    .select(`
                        id,
                        email,
                        full_name,
                        account_tier,
                        is_admin,
                        is_super_admin,
                        created_at,
                        institutions (
                            name
                        ),
                        departments (
                            name
                        )
                    `)
                    .order('created_at', { ascending: false });
                
                if (error) throw error;
                
                const container = document.getElementById('usersListContainer');
                
                if (!users || users.length === 0) {
                    container.innerHTML = '<p style="color: var(--text-light);">No users found.</p>';
                    return;
                }
                
                // Build user list HTML
                let html = `
                    <div style="background: var(--bg); border: 1px solid var(--border); border-radius: 0.5rem; overflow: hidden;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead style="background: var(--bg-alt);">
                                <tr>
                                    <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Email</th>
                                    <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Name</th>
                                    <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Institution</th>
                                    <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Department</th>
                                    <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Tier</th>
                                    <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Admin</th>
                                    <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                users.forEach(user => {
                    // Determine tier badge based on new tier system
                    let tierBadge = '';
                    switch(user.account_tier) {
                        case 'super_admin':
                            tierBadge = '<span style="background: #9333ea; color: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600;">üåê Super Admin</span>';
                            break;
                        case 'admin':
                            tierBadge = '<span style="background: var(--primary); color: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600;">üèõÔ∏è Admin</span>';
                            break;
                        case 'instructor':
                            tierBadge = '<span style="background: var(--success); color: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600;">üë§ Instructor</span>';
                            break;
                        case 'demo':
                            tierBadge = '<span style="background: var(--warning); color: black; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600;">üé≠ Demo</span>';
                            break;
                        default:
                            tierBadge = '<span style="background: var(--text-light); color: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem;">Unknown</span>';
                    }
                    
                    const adminBadge = user.is_admin || user.is_super_admin
                        ? '<span style="color: var(--success); font-size: 1.25rem;">‚úì</span>'
                        : '<span style="color: var(--text-light);">‚Äî</span>';
                    
                    const institutionName = user.institutions?.name || '‚Äî';
                    const departmentName = user.departments?.name || '‚Äî';
                    
                    html += `
                        <tr style="border-bottom: 1px solid var(--border);">
                            <td style="padding: 0.75rem;">${user.email}</td>
                            <td style="padding: 0.75rem; color: var(--text-light);">${user.full_name || '‚Äî'}</td>
                            <td style="padding: 0.75rem; color: var(--text-light);">${institutionName}</td>
                            <td style="padding: 0.75rem; color: var(--text-light);">${departmentName}</td>
                            <td style="padding: 0.75rem;">${tierBadge}</td>
                            <td style="padding: 0.75rem; text-align: center;">${adminBadge}</td>
                            <td style="padding: 0.75rem;">
                                <button onclick="editUserTier('${user.id}', '${user.email}', '${user.account_tier}', ${user.is_admin})" 
                                        style="padding: 0.25rem 0.75rem; font-size: 0.875rem;">
                                    Edit
                                </button>
                            </td>
                        </tr>
                    `;
                });
                
                html += `
                            </tbody>
                        </table>
                    </div>
                    <p style="margin-top: 1rem; color: var(--text-light); font-size: 0.875rem;">
                        Total users: ${users.length}
                    </p>
                `;
                
                container.innerHTML = html;
                
            } catch (error) {
                console.error('Error loading users:', error);
                document.getElementById('usersListContainer').innerHTML = 
                    `<p style="color: var(--danger);">Error loading users: ${error.message}</p>`;
            }
        }
        
        // Edit user tier
        function editUserTier(userId, email, currentTier, isAdmin) {
            const newTier = prompt(
                `Change account tier for ${email}\n\n` +
                `Current tier: ${currentTier}\n` +
                `Current admin: ${isAdmin ? 'Yes' : 'No'}\n\n` +
                `Enter new tier:\n` +
                `- demo (testing only)\n` +
                `- instructor (faculty)\n` +
                `- admin (department head)\n` +
                `- super_admin (system-wide)`,
                currentTier
            );
            
            if (!newTier || newTier === currentTier) return;
            
            const validTiers = ['demo', 'instructor', 'admin', 'super_admin'];
            if (!validTiers.includes(newTier)) {
                alert('Invalid tier. Must be one of: demo, instructor, admin, super_admin');
                return;
            }
            
            // Warn when promoting to super_admin
            if (newTier === 'super_admin') {
                const confirm = window.confirm(
                    `‚ö†Ô∏è WARNING: Promoting ${email} to Super Admin\n\n` +
                    `This will give them:\n` +
                    `- Access to ALL institutions\n` +
                    `- Ability to manage ALL users\n` +
                    `- System-wide administration\n\n` +
                    `Are you sure?`
                );
                if (!confirm) return;
            }
            
            updateUserTier(userId, email, newTier, null);
        }
        
        // Update user tier in database
        async function updateUserTier(userId, email, newTier, toggleAdmin) {
            if (!supabaseClient || !canManageUsers()) return;
            
            try {
                const updates = {
                    account_tier: newTier,
                    updated_at: new Date().toISOString()
                };
                
                // If toggleAdmin is provided, update admin status
                if (toggleAdmin !== null) {
                    updates.is_admin = toggleAdmin;
                }
                
                const { error } = await supabaseClient
                    .from('user_profiles')
                    .update(updates)
                    .eq('id', userId);
                
                if (error) throw error;
                
                alert(`‚úì Updated ${email} to ${newTier}${toggleAdmin !== null ? (toggleAdmin ? ' (Admin)' : ' (Not Admin)') : ''}`);
                
                // Reload user list
                loadAllUsers();
                
            } catch (error) {
                console.error('Error updating user:', error);
                alert('Error updating user: ' + error.message);
            }
        }
        
        function showInviteForm() {
            document.getElementById('inviteFormCard').classList.remove('hidden');
        }
        
        function cancelInvite() {
            document.getElementById('inviteFormCard').classList.add('hidden');
            document.getElementById('inviteForm').reset();
        }
        
        async function sendInvite(event) {
            event.preventDefault();
            
            const recipientEmail = document.getElementById('inviteEmail').value;
            const name = document.getElementById('inviteName').value;
            const institution = document.getElementById('inviteInstitution').value;
            const autoApprove = document.getElementById('inviteAutoApprove').checked;
            
            // Get the current deployment URL
            const deploymentUrl = window.location.origin + window.location.pathname;
            const registrationUrl = `${deploymentUrl}#register`;
            
            // Create invitation record in database
            let inviteToken = null;
            if (supabaseClient && autoApprove) {
                try {
                    inviteToken = generateInviteToken();
                    const { error } = await supabaseClient
                        .from('invitations')
                        .insert({
                            email: recipientEmail,
                            name: name,
                            institution: institution,
                            invited_by: currentUser.email,
                            invite_token: inviteToken,
                            account_tier: 'research_partner',
                            expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString()
                        });
                    
                    if (error) {
                        console.error('Could not save invitation:', error);
                    }
                } catch (err) {
                    console.error('Error saving invitation:', err);
                }
            }
            
            // Show sending modal
            showSendingInvitationModal(recipientEmail, name, institution, registrationUrl, autoApprove);
            
            cancelInvite();
        }
        
        // Show modal for sending invitation
        function showSendingInvitationModal(recipientEmail, name, institution, registrationUrl, autoApprove) {
            const modal = document.createElement('div');
            modal.id = 'invitationModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                padding: 2rem;
            `;
            
            const institutionLine = institution ? `<tr><td style="padding: 8px 12px; color: var(--text-light); border-bottom: 1px solid var(--border);">Institution:</td><td style="padding: 8px 12px; border-bottom: 1px solid var(--border);"><strong>${institution}</strong></td></tr>` : '';
            
            modal.innerHTML = `
                <div style="background: var(--bg); border-radius: 12px; max-width: 700px; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3);">
                    <div style="background: var(--primary); padding: 2rem; border-radius: 12px 12px 0 0; color: white;">
                        <h2 style="margin: 0; font-size: 1.5rem; font-weight: 600;">üìß Send Research Partner Invitation</h2>
                        <p style="margin: 0.5rem 0 0 0; opacity: 0.9;">Review and send invitation to join SpeechGradebook</p>
                    </div>
                    
                    <div style="padding: 2rem;">
                        <!-- Recipient Info -->
                        <div style="background: var(--bg-alt); border-radius: 8px; padding: 1.5rem; margin-bottom: 1.5rem; border-left: 4px solid var(--primary);">
                            <h3 style="margin: 0 0 1rem 0; font-size: 1rem; color: var(--text);">Invitation Details</h3>
                            <table style="width: 100%; border-collapse: collapse;">
                                <tr>
                                    <td style="padding: 8px 12px; color: var(--text-light); border-bottom: 1px solid var(--border); width: 120px;">To:</td>
                                    <td style="padding: 8px 12px; border-bottom: 1px solid var(--border);"><strong>${recipientEmail}</strong></td>
                                </tr>
                                <tr>
                                    <td style="padding: 8px 12px; color: var(--text-light); border-bottom: 1px solid var(--border);">Name:</td>
                                    <td style="padding: 8px 12px; border-bottom: 1px solid var(--border);"><strong>${name || 'Not provided'}</strong></td>
                                </tr>
                                ${institutionLine}
                                <tr>
                                    <td style="padding: 8px 12px; color: var(--text-light);">Access Level:</td>
                                    <td style="padding: 8px 12px;"><span style="background: var(--success); color: white; padding: 4px 12px; border-radius: 4px; font-size: 0.875rem; font-weight: 600;">Research Partner</span></td>
                                </tr>
                            </table>
                        </div>
                        
                        <!-- Email Preview -->
                        <div style="background: var(--bg); border: 2px solid var(--border); border-radius: 8px; padding: 2rem; margin-bottom: 1.5rem;">
                            <div style="border-bottom: 2px solid var(--primary); padding-bottom: 1rem; margin-bottom: 1.5rem;">
                                <p style="margin: 0; color: var(--text-light); font-size: 0.875rem;">Subject:</p>
                                <p style="margin: 0.25rem 0 0 0; font-size: 1.125rem; font-weight: 600; color: var(--text);">Invitation to SpeechGradebook Research Partnership</p>
                            </div>
                            
                            <div style="line-height: 1.8; color: var(--text); font-size: 0.9375rem;">
                                <p style="margin: 0 0 1.5rem 0;">Dear ${name || 'Colleague'},</p>
                                
                                <p style="margin: 0 0 1.5rem 0;">You're invited to join <strong>SpeechGradebook</strong> as a <strong style="color: var(--primary);">Research Partner</strong>.</p>
                                
                                <div style="background: var(--bg-alt); border-left: 4px solid var(--primary); padding: 1rem 1.5rem; margin: 1.5rem 0; border-radius: 4px;">
                                    <p style="margin: 0 0 0.75rem 0; font-weight: 600; color: var(--primary);">Benefits:</p>
                                    <ul style="margin: 0; padding-left: 1.25rem;">
                                        <li style="margin-bottom: 0.5rem;">Full evaluation storage and correction tracking</li>
                                        <li style="margin-bottom: 0.5rem;">Contribute to AI training research</li>
                                        <li style="margin-bottom: 0.5rem;">Help improve speech education technology</li>
                                    </ul>
                                </div>
                                
                                <div style="background: var(--warning-bg); border-left: 4px solid var(--warning); padding: 1rem 1.5rem; margin: 1.5rem 0; border-radius: 4px;">
                                    <p style="margin: 0 0 0.75rem 0; font-weight: 600; color: var(--warning-dark);">To get started:</p>
                                    <ol style="margin: 0; padding-left: 1.25rem;">
                                        <li style="margin-bottom: 0.5rem;">Register at: <a href="${registrationUrl}" style="color: var(--primary); text-decoration: none; font-weight: 600;">${registrationUrl}</a></li>
                                        <li style="margin-bottom: 0.5rem;">Use this email address (<strong>${recipientEmail}</strong>) during registration</li>
                                        <li style="margin-bottom: 0;">Your account will be automatically upgraded to Research Partner</li>
                                    </ol>
                                </div>
                                
                                ${institution ? `<p style="margin: 1.5rem 0;"><strong>Institution:</strong> ${institution}</p>` : ''}
                                
                                <p style="margin: 1.5rem 0;">Questions? Contact us at <a href="mailto:speechgradebook@proton.me" style="color: var(--primary); text-decoration: none;">speechgradebook@proton.me</a></p>
                                
                                <div style="background: var(--success-bg); border-left: 4px solid var(--success); padding: 1rem 1.5rem; margin: 1.5rem 0; border-radius: 4px;">
                                    <p style="margin: 0 0 0.75rem 0; font-weight: 600; color: var(--success-dark);">After registration, you'll have full access to:</p>
                                    <ul style="margin: 0; padding-left: 1.25rem;">
                                        <li style="margin-bottom: 0.5rem;">Unlimited speech evaluations</li>
                                        <li style="margin-bottom: 0.5rem;">Save and track student progress</li>
                                        <li style="margin-bottom: 0.5rem;">Edit and correct AI evaluations</li>
                                        <li style="margin-bottom: 0;">Contribute to groundbreaking research</li>
                                    </ul>
                                </div>
                                
                                <div style="margin-top: 2rem; padding-top: 1.5rem; border-top: 1px solid var(--border);">
                                    <p style="margin: 0 0 0.25rem 0;">Best regards,</p>
                                    <p style="margin: 0; font-weight: 600;">Anna McClure, Ph.D.</p>
                                    <p style="margin: 0.25rem 0 0 0; color: var(--text-light); font-size: 0.875rem;">SpeechGradebook Research Team</p>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                            <button onclick="closeInvitationModal()" class="btn-secondary" style="padding: 0.75rem 1.5rem;">Cancel</button>
                            <button onclick="copyInvitationForManualSend('${recipientEmail.replace(/'/g, "\\'")}', '${name.replace(/'/g, "\\'")}', '${institution.replace(/'/g, "\\'")}', '${registrationUrl}')" style="padding: 0.75rem 1.5rem;">üìã Copy Text</button>
                            <button onclick="sendInvitationEmail('${recipientEmail.replace(/'/g, "\\'")}', '${name.replace(/'/g, "\\'")}', '${institution.replace(/'/g, "\\'")}', '${registrationUrl}')" style="padding: 0.75rem 2rem;">‚úâÔ∏è Send Invitation</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        // Send invitation email directly
        async function sendInvitationEmail(recipientEmail, name, institution, registrationUrl) {
            const button = event.target;
            const originalText = button.innerHTML;
            button.innerHTML = '‚è≥ Sending...';
            button.disabled = true;
            
            try {
                const subject = 'Invitation to SpeechGradebook Research Partnership';
                
                // Create HTML version
                const htmlBody = createHTMLInvitation(recipientEmail, name, institution, registrationUrl);
                
                // For Gmail, use their compose URL with HTML support
                const isGmail = currentUser.email && currentUser.email.includes('@gmail.com');
                
                if (isGmail) {
                    // Open Gmail compose
                    const gmailUrl = `https://mail.google.com/mail/?view=cm&fs=1&to=${encodeURIComponent(recipientEmail)}&su=${encodeURIComponent(subject)}`;
                    window.open(gmailUrl, '_blank');
                    
                    // Copy HTML to clipboard for pasting
                    navigator.clipboard.writeText(htmlBody).then(() => {
                        setTimeout(() => {
                            alert('‚úÖ Gmail opened!\n\nHTML email copied to clipboard.\n\n1. In Gmail, click the three dots (...) at bottom\n2. Select "Rich formatting mode"\n3. Paste (Ctrl+V or Cmd+V)\n4. Send!');
                            closeInvitationModal();
                        }, 500);
                    });
                } else {
                    // For other email clients, use mailto with plain text
                    const plainBody = createPlainTextInvitation(recipientEmail, name, institution, registrationUrl);
                    const mailtoLink = `mailto:${recipientEmail}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(plainBody)}`;
                    window.location.href = mailtoLink;
                    
                    setTimeout(() => {
                        alert('‚úÖ Email client opened!\n\nPlease send the invitation.');
                        closeInvitationModal();
                    }, 1000);
                }
                
            } catch (error) {
                console.error('Error sending invitation:', error);
                alert('‚ùå Could not send invitation.\n\nPlease use the "Copy Text" button and send manually.');
                button.innerHTML = originalText;
                button.disabled = false;
            }
        }
        
        // Create HTML email version
        function createHTMLInvitation(recipientEmail, name, institution, registrationUrl) {
            return `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body style="margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; background-color: #f5f5f5;">
    <div style="max-width: 600px; margin: 0 auto; background-color: #ffffff;">
        <!-- Header -->
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 40px 30px; text-align: center;">
            <h1 style="color: #ffffff; margin: 0; font-size: 28px; font-weight: 600;">SpeechGradebook</h1>
            <p style="color: rgba(255,255,255,0.9); margin: 10px 0 0 0; font-size: 16px;">Research Partnership Invitation</p>
        </div>
        
        <!-- Content -->
        <div style="padding: 40px 30px; line-height: 1.8; color: #333333;">
            <p style="margin: 0 0 20px 0; font-size: 16px;">Dear ${name || 'Colleague'},</p>
            
            <p style="margin: 0 0 24px 0; font-size: 16px;">You're invited to join <strong>SpeechGradebook</strong> as a <strong style="color: #667eea;">Research Partner</strong>.</p>
            
            <!-- Benefits Box -->
            <div style="background-color: #f0f4ff; border-left: 4px solid #667eea; padding: 20px; margin: 24px 0; border-radius: 4px;">
                <p style="margin: 0 0 12px 0; font-weight: 600; color: #667eea; font-size: 16px;">Benefits:</p>
                <ul style="margin: 0; padding-left: 20px; font-size: 15px;">
                    <li style="margin-bottom: 8px;">Full evaluation storage and correction tracking</li>
                    <li style="margin-bottom: 8px;">Contribute to AI training research</li>
                    <li style="margin-bottom: 0;">Help improve speech education technology</li>
                </ul>
            </div>
            
            <!-- Getting Started Box -->
            <div style="background-color: #fff9e6; border-left: 4px solid #ffc107; padding: 20px; margin: 24px 0; border-radius: 4px;">
                <p style="margin: 0 0 12px 0; font-weight: 600; color: #f57c00; font-size: 16px;">To get started:</p>
                <ol style="margin: 0; padding-left: 20px; font-size: 15px;">
                    <li style="margin-bottom: 8px;">Register at: <a href="${registrationUrl}" style="color: #667eea; text-decoration: none; font-weight: 600;">${registrationUrl}</a></li>
                    <li style="margin-bottom: 8px;">Use this email address (<strong>${recipientEmail}</strong>) during registration</li>
                    <li style="margin-bottom: 0;">Your account will be automatically upgraded to Research Partner</li>
                </ol>
            </div>
            
            ${institution ? `<p style="margin: 24px 0; font-size: 15px;"><strong>Institution:</strong> ${institution}</p>` : ''}
            
            <p style="margin: 24px 0; font-size: 15px;">Questions? Contact us at <a href="mailto:speechgradebook@proton.me" style="color: #667eea; text-decoration: none;">speechgradebook@proton.me</a></p>
            
            <!-- Access Box -->
            <div style="background-color: #e8f5e9; border-left: 4px solid #4caf50; padding: 20px; margin: 24px 0; border-radius: 4px;">
                <p style="margin: 0 0 12px 0; font-weight: 600; color: #2e7d32; font-size: 16px;">After registration, you'll have full access to:</p>
                <ul style="margin: 0; padding-left: 20px; font-size: 15px;">
                    <li style="margin-bottom: 8px;">Unlimited speech evaluations</li>
                    <li style="margin-bottom: 8px;">Save and track student progress</li>
                    <li style="margin-bottom: 8px;">Edit and correct AI evaluations</li>
                    <li style="margin-bottom: 0;">Contribute to groundbreaking research</li>
                </ul>
            </div>
            
            <!-- Signature -->
            <div style="margin-top: 40px; padding-top: 24px; border-top: 1px solid #e0e0e0;">
                <p style="margin: 0 0 4px 0; font-size: 15px;">Best regards,</p>
                <p style="margin: 0; font-weight: 600; font-size: 16px;">Anna McClure, Ph.D.</p>
                <p style="margin: 4px 0 0 0; color: #666666; font-size: 14px;">SpeechGradebook Research Team</p>
            </div>
        </div>
        
        <!-- Footer -->
        <div style="background-color: #f5f5f5; padding: 20px 30px; text-align: center; border-top: 1px solid #e0e0e0;">
            <p style="margin: 0; color: #999999; font-size: 13px;">SpeechGradebook | AI-Powered Speech Assessment</p>
        </div>
    </div>
</body>
</html>`;
        }
        
        // Create plain text version for email
        function createPlainTextInvitation(recipientEmail, name, institution, registrationUrl) {
            return `Dear ${name || 'Colleague'},

You're invited to join SpeechGradebook as a Research Partner.

BENEFITS:
‚Ä¢ Full evaluation storage and correction tracking
‚Ä¢ Contribute to AI training research
‚Ä¢ Help improve speech education technology

TO GET STARTED:
1. Register at: ${registrationUrl}
2. Use this email address (${recipientEmail}) during registration
3. Your account will be automatically upgraded to Research Partner

${institution ? `Institution: ${institution}\n\n` : ''}Questions? Contact us at speechgradebook@proton.me

AFTER REGISTRATION, YOU'LL HAVE FULL ACCESS TO:
‚Ä¢ Unlimited speech evaluations
‚Ä¢ Save and track student progress
‚Ä¢ Edit and correct AI evaluations
‚Ä¢ Contribute to groundbreaking research

Best regards,
Anna McClure, Ph.D.
SpeechGradebook Research Team`;
        }
        
        // Copy invitation text for manual sending
        function copyInvitationForManualSend(recipientEmail, name, institution, registrationUrl) {
            const text = createPlainTextInvitation(recipientEmail, name, institution, registrationUrl);
            
            navigator.clipboard.writeText(text).then(() => {
                alert(`‚úÖ Invitation text copied to clipboard!\n\nYou can now:\n1. Open your email client\n2. Compose new email to: ${recipientEmail}\n3. Paste the invitation text`);
            }).catch(() => {
                // Fallback
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                alert(`‚úÖ Invitation text copied!\n\nSend to: ${recipientEmail}`);
            });
        }
        
        // Close invitation modal
        function closeInvitationModal() {
            const modal = document.getElementById('invitationModal');
            if (modal) {
                modal.remove();
            }
        }
        
        // Generate a simple invite token
        function generateInviteToken() {
            return Math.random().toString(36).substring(2) + Date.now().toString(36);
        }

        function setActiveSection(sectionId, navId) {
            // Hide all sections using display (not just class)
            document.querySelectorAll('.section').forEach(s => {
                s.classList.remove('active');
                s.style.display = 'none'; // CRITICAL: Actually hide the section
            });
            
            // Show selected section
            const selectedSection = document.getElementById(sectionId);
            if (selectedSection) {
                selectedSection.classList.add('active');
                selectedSection.style.display = 'block'; // CRITICAL: Actually show the section
            }
            
            // Update nav
            document.querySelectorAll('.nav-link').forEach(n => n.classList.remove('active'));
            const selectedNav = document.getElementById(navId);
            if (selectedNav) {
                selectedNav.classList.add('active');
            }
        }

        // ===== TENANT/THEME MANAGEMENT =====
        function switchTenant(tenantId) {
            currentTenant = tenantId;
            applyTenant(tenantId);
            localStorage.setItem('current_tenant', tenantId);
        }

        function applyTenant(tenantId) {
            const config = TENANT_CONFIGS[tenantId] || TENANT_CONFIGS['default'];
            
            // Apply colors
            const root = document.documentElement;
            root.style.setProperty('--primary', config.colors.primary);
            root.style.setProperty('--primary-dark', config.colors.primaryDark);
            root.style.setProperty('--secondary', config.colors.secondary);
            root.style.setProperty('--accent', config.colors.accent);
            
            // Apply fonts
            root.style.setProperty('--heading-font', config.typography.headingFont);
            root.style.setProperty('--body-font', config.typography.bodyFont);
            root.style.setProperty('--heading-weight', config.typography.headingWeight);
            root.style.setProperty('--body-weight', config.typography.bodyWeight);
            
            // Apply branding
            document.getElementById('appName').textContent = config.branding.appName;
            document.getElementById('appTagline').textContent = config.branding.tagline;
            document.getElementById('appLogo').textContent = config.shortName;
            document.title = `${config.branding.appName} - ${config.name}`;
            
            // Apply footer
            const footerLinks = document.getElementById('footerLinks');
            footerLinks.innerHTML = config.footer.links.map(link => 
                `<a href="${link.url}">${link.text}</a>`
            ).join('');
            
            document.getElementById('footerCopyright').textContent = config.footer.copyright;
            document.getElementById('footerAdditional').textContent = config.footer.additionalText || '';
            
            // Apply contact
            document.getElementById('supportEmail').textContent = config.contact.supportEmail;
            
            // Update tenant selector
            document.getElementById('tenantSelect').value = tenantId;
        }

        // ===== FILE UPLOAD =====
        function initializeFileUpload() {
            const uploadZone = document.getElementById('uploadZone');
            const fileInput = document.getElementById('fileInput');

            uploadZone.addEventListener('click', () => fileInput.click());

            uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadZone.classList.add('drag-over');
            });

            uploadZone.addEventListener('dragleave', () => {
                uploadZone.classList.remove('drag-over');
            });

            uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadZone.classList.remove('drag-over');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });

            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFile(e.target.files[0]);
                }
            });
        }

        function handleFile(file) {
            const sizeMB = (file.size / 1024 / 1024).toFixed(2);
            
            uploadedFile = file;
            document.getElementById('fileName').textContent = `üìé ${file.name} (${formatFileSize(file.size)})`;
            document.getElementById('fileInfo').classList.remove('hidden');
            document.getElementById('continueButtonContainer').style.display = 'block';
        }

        function removeFile() {
            uploadedFile = null;
            document.getElementById('fileInfo').classList.add('hidden');
            document.getElementById('fileInput').value = '';
            document.getElementById('continueButtonContainer').style.display = 'none';
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        // ===== STEP NAVIGATION =====
        function moveToStep(step) {
            currentStep = step;
            console.log('=== moveToStep(' + step + ') called ===');
            
            // Hide all steps
            document.getElementById('uploadStep').classList.add('hidden');
            document.getElementById('detailsStep').classList.add('hidden');
            document.getElementById('processingStep').classList.add('hidden');
            document.getElementById('resultsStep').classList.add('hidden');
            
            // Update step indicators
            for (let i = 1; i <= 4; i++) {
                const stepEl = document.getElementById(`step${i}`);
                stepEl.classList.remove('active', 'completed');
                if (i < step) {
                    stepEl.classList.add('completed');
                } else if (i === step) {
                    stepEl.classList.add('active');
                }
            }
            
            // Update card header based on step
            const headerEl = document.getElementById('evaluateCardHeader');
            if (step === 4) {
                headerEl.textContent = 'üìä Speech Evaluation Results';
            } else {
                headerEl.textContent = 'üìä Evaluate a Speech';
            }
            
            // Show current step
            if (step === 1) {
                document.getElementById('uploadStep').classList.remove('hidden');
            } else if (step === 2) {
                document.getElementById('detailsStep').classList.remove('hidden');
                // Update API key field based on selected provider
                updateApiKeyPlaceholder();
                // Populate rubric selector
                populateRubricSelector();
            } else if (step === 3) {
                document.getElementById('processingStep').classList.remove('hidden');
            } else if (step === 4) {
                console.log('Showing results step');
                document.getElementById('resultsStep').classList.remove('hidden');
            }
        }

        async function populateRubricSelector() {
            const select = document.getElementById('rubricSelect');
            if (!select) return;
            
            const rubrics = await getAllRubrics();
            const classes = JSON.parse(getUserItem('classes') || '[]');
            
            // Clear existing options except the first one
            select.innerHTML = '<option value="">-- Select a Rubric --</option>';
            
            // Separate rubrics by type
            const defaultRubrics = rubrics.filter(r => r.id === 'default');
            
            // Filter unassigned rubrics (no courseId or courseIds)
            const unassignedRubrics = rubrics.filter(r => {
                if (r.id === 'default') return false;
                const hasOldCourseId = r.courseId && r.courseId !== '';
                const hasNewCourseIds = r.courseIds && Array.isArray(r.courseIds) && r.courseIds.length > 0;
                return !hasOldCourseId && !hasNewCourseIds;
            });
            
            // Add default rubric
            if (defaultRubrics.length > 0) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = 'System Default';
                defaultRubrics.forEach(rubric => {
                    const option = document.createElement('option');
                    option.value = rubric.id;
                    option.textContent = `${rubric.name} (${rubric.totalPoints} pts)`;
                    optgroup.appendChild(option);
                });
                select.appendChild(optgroup);
            }
            
            // Group rubrics by course NAME (not ID) to consolidate sections
            const rubricsByCourse = {};
            rubrics.filter(r => r.id !== 'default').forEach(rubric => {
                // Get courseIds for this rubric (handle both old and new format)
                let courseIds = [];
                if (rubric.courseIds && Array.isArray(rubric.courseIds)) {
                    courseIds = rubric.courseIds;
                } else if (rubric.courseId) {
                    courseIds = [rubric.courseId];
                }
                
                // Add rubric to each course it's assigned to
                courseIds.forEach(courseId => {
                    const course = classes.find(c => c.id === courseId);
                    if (course) {
                        // Use course name + semester + year as key
                        const courseKey = `${course.name}|${course.semester}|${course.year}`;
                        if (!rubricsByCourse[courseKey]) {
                            rubricsByCourse[courseKey] = {
                                name: course.name,
                                semester: course.semester,
                                year: course.year,
                                rubrics: []
                            };
                        }
                        // Avoid duplicates
                        if (!rubricsByCourse[courseKey].rubrics.find(r => r.id === rubric.id)) {
                            rubricsByCourse[courseKey].rubrics.push(rubric);
                        }
                    }
                });
            });
            
            // Add course-specific rubrics grouped by course name
            Object.keys(rubricsByCourse).sort().forEach(courseKey => {
                const courseGroup = rubricsByCourse[courseKey];
                
                const optgroup = document.createElement('optgroup');
                optgroup.label = `${courseGroup.name} - ${courseGroup.semester} ${courseGroup.year}`;
                
                courseGroup.rubrics.forEach(rubric => {
                    const option = document.createElement('option');
                    option.value = rubric.id;
                    option.textContent = `${rubric.name} (${rubric.totalPoints} pts)`;
                    if (rubric.speechType) {
                        option.textContent += ` - ${rubric.speechType}`;
                    }
                    optgroup.appendChild(option);
                });
                
                select.appendChild(optgroup);
            });
            
            // Add unassigned custom rubrics
            if (unassignedRubrics.length > 0) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = 'My Rubrics (No Course)';
                unassignedRubrics.forEach(rubric => {
                    const option = document.createElement('option');
                    option.value = rubric.id;
                    option.textContent = `${rubric.name} (${rubric.totalPoints} pts)`;
                    if (rubric.speechType) {
                        option.textContent += ` - ${rubric.speechType}`;
                    }
                    optgroup.appendChild(option);
                });
                select.appendChild(optgroup);
            }
            
            // Pre-select the Self-Introduction rubric if available
            const selfIntroRubric = rubrics.find(r => r.id === 'self-intro-1');
            if (selfIntroRubric) {
                select.value = selfIntroRubric.id;
            }
        }

        // ===== FORMS =====
        function initializeForms() {
            console.log('initializeForms() called');
            
            // Student form
            const studentForm = document.getElementById('studentForm');
            console.log('studentForm element:', studentForm);
            
            if (!studentForm) {
                console.error('ERROR: studentForm element not found!');
                return;
            }
            
            console.log('Adding submit event listener to studentForm...');
            studentForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                console.log('>>> FORM SUBMITTED <<<');
                
                try {
                    if (!uploadedFile) {
                        console.log('Form validation: No file uploaded');
                        alert('Please upload a speech recording first.');
                        return;
                    }
                    console.log('Form validation: File OK');

                    console.log('Form handler: Calling moveToStep(3)');
                    moveToStep(3);
                    console.log('Form handler: Calling processAndEvaluate()');
                    await processAndEvaluate();
                    console.log('Form handler: processAndEvaluate() completed');
                } catch (error) {
                    console.error('FORM HANDLER ERROR:', error);
                    alert('Form submission error: ' + error.message);
                    moveToStep(2);
                }
            });
            console.log('‚úì Submit event listener attached to studentForm');
            
            // Also add click listener to submit button for debugging
            const submitBtn = document.getElementById('submitEvaluationBtn');
            if (submitBtn) {
                submitBtn.addEventListener('click', function(e) {
                    console.log('Submit button clicked!');
                    console.log('Form validity:', studentForm.checkValidity());
                    console.log('Rubric selected:', document.getElementById('rubricSelect').value);
                    console.log('API key:', document.getElementById('apiKey').value ? 'Present' : 'Empty');
                    
                    // Check if form is valid
                    if (!studentForm.checkValidity()) {
                        console.log('Form is INVALID - browser will show validation message');
                        return;
                    }
                    
                    console.log('Form is valid, but submit event not firing - manually triggering...');
                    // Manually call the submit handler since the form submit event isn't firing
                    e.preventDefault();
                    studentForm.dispatchEvent(new Event('submit'));
                });
                console.log('‚úì Click listener attached to submit button');
            }

            // Create class form
            document.getElementById('createClassForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const newClass = {
                    id: Date.now().toString(),
                    name: document.getElementById('className').value,
                    semester: document.getElementById('classSemester').value,
                    section: document.getElementById('classSection').value,
                    year: document.getElementById('classYear').value,
                    notes: document.getElementById('classNotes').value,
                    roster: [],
                    evaluations: [],
                    createdAt: new Date().toISOString()
                };
                
                // Save to localStorage first (immediate)
                const classes = JSON.parse(getUserItem('classes') || '[]');
                classes.push(newClass);
                setUserItem('classes', JSON.stringify(classes));
                console.log('‚úì Class saved to localStorage');
                
                // Also save to Supabase (async)
                if (supabaseClient) {
                    saveCourseToSupabase(newClass).then(supabaseCourse => {
                        if (supabaseCourse) {
                            // Update with Supabase ID
                            newClass.supabaseId = supabaseCourse.id;
                            const updated = classes.find(c => c.id === newClass.id);
                            if (updated) {
                                updated.supabaseId = supabaseCourse.id;
                                setUserItem('classes', JSON.stringify(classes));
                            }
                        }
                    }).catch(err => {
                        console.log('Supabase save failed, but localStorage succeeded');
                    });
                }
                
                alert('‚úì Class created successfully!');
                document.getElementById('createClassForm').reset();
                cancelCreateClass();
                await loadClasses();
            });

            // Create rubric form
            document.getElementById('createRubricForm').addEventListener('submit', (e) => {
                e.preventDefault();
                
                try {
                    const rubricData = collectRubricData();
                    
                    // Validation
                    if (!rubricData.name) {
                        alert('Please enter a rubric name');
                        return;
                    }
                    
                    if (rubricData.totalPoints < 1) {
                        alert('Total points must be at least 1');
                        return;
                    }
                    
                    if (rubricData.categories.length === 0) {
                        alert('Please add at least one category with subcategories');
                        return;
                    }
                    
                    // Check that all categories have subcategories
                    const emptyCategories = rubricData.categories.filter(cat => cat.subcategories.length === 0);
                    if (emptyCategories.length > 0) {
                        alert('All categories must have at least one subcategory');
                        return;
                    }
                    
                    // Save using the new storage system
                    const savedRubric = saveRubric(rubricData);
                    
                    const isEditing = document.getElementById('editingRubricId').value !== '';
                    alert(isEditing ? '‚úì Rubric updated successfully!' : '‚úì Rubric created successfully!');
                    
                    document.getElementById('createRubricForm').reset();
                    cancelCreateRubric();
                    loadRubrics();
                } catch (error) {
                    console.error('Error saving rubric:', error);
                    alert('Error saving rubric: ' + error.message);
                }
            });

            // Add student form
            document.getElementById('addStudentForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const newStudent = {
                    id: Date.now().toString(),
                    firstName: document.getElementById('studentFirstName').value,
                    lastName: document.getElementById('studentLastName').value,
                    email: document.getElementById('studentEmailAdd').value,
                    studentId: document.getElementById('studentIdAdd').value,
                    addedAt: new Date().toISOString()
                };
                
                const classes = JSON.parse(getUserItem('classes') || '[]');
                const classIndex = classes.findIndex(c => c.id === currentClassId);
                
                if (classIndex !== -1) {
                    if (!classes[classIndex].roster) {
                        classes[classIndex].roster = [];
                    }
                    classes[classIndex].roster.push(newStudent);
                    setUserItem('classes', JSON.stringify(classes));
                    console.log('‚úì Student saved to localStorage');
                    
                    // Also save to Supabase if course has supabaseId
                    const course = classes[classIndex];
                    if (supabaseClient && course.supabaseId) {
                        await saveStudentsToSupabase(course.supabaseId, [newStudent]);
                    }
                    
                    alert('‚úì Student added successfully!');
                    document.getElementById('addStudentForm').reset();
                    cancelAddStudent();
                    await viewClass(currentClassId); // Refresh the view
                }
            });
        }

        // ===== SPEECH EVALUATION =====
        async function processAndEvaluate() {
            console.log('=== processAndEvaluate START ===');
            console.log('uploadedFile:', uploadedFile);
            
            // Reset correction log for new evaluation
            correctionLog = [];
            
            // Check if file is uploaded
            if (!uploadedFile) {
                console.log('FAILURE: No file uploaded');
                alert('No file uploaded. Please go back to Step 1 and upload a speech recording.');
                moveToStep(1);
                return;
            }
            console.log('‚úì File uploaded:', uploadedFile.name);
            
            // Get selected API provider
            const apiProvider = document.getElementById('apiProvider').value;
            console.log('API Provider:', apiProvider);
            
            // Get API key from form or localStorage (based on provider)
            let apiKey = document.getElementById('apiKey').value.trim();
            console.log('API key from form field:', apiKey ? '***' + apiKey.slice(-4) : '(empty)');
            
            if (!apiKey) {
                const storageKey = apiProvider === 'gemini' ? 'gemini_api_key' : 
                                  apiProvider === 'gpt4o' ? 'openai_api_key' : 
                                  'anthropic_api_key';
                const savedKey = localStorage.getItem(storageKey);
                console.log(`API key from localStorage (${storageKey}):`, savedKey ? '***' + savedKey.slice(-4) : '(empty)');
                apiKey = savedKey || '';
            }
            console.log('Final API key:', apiKey ? 'Yes (***' + apiKey.slice(-4) + ')' : 'No');
            
            const selectedRubricId = document.getElementById('rubricSelect').value;
            console.log('Selected rubric ID:', selectedRubricId);
            
            // Skip API key check for demo mode
            if (!apiKey && apiProvider !== 'demo') {
                console.log('FAILURE: No API key');
                const providerName = apiProvider === 'gemini' ? 'Google Gemini' : 
                                    apiProvider === 'gpt4o' ? 'OpenAI' :
                                    'Anthropic Claude';
                alert(`Please enter your ${providerName} API key in the form or save it in Settings.`);
                moveToStep(2);
                return;
            }
            if (apiProvider !== 'demo') {
                console.log('‚úì API key present');
            }
            
            if (!selectedRubricId) {
                console.log('FAILURE: No rubric selected');
                alert('Please select a rubric for evaluation.');
                moveToStep(2);
                return;
            }
            console.log('‚úì Rubric selected');

            const assignmentType = document.getElementById('assignmentType').value;
            const studentName = 'Student'; // Removed student name input field
            
            console.log('Student name:', studentName);
            console.log('Assignment type:', assignmentType);
            console.log('=== All validations passed, starting evaluation ===');
            
            document.getElementById('processingMessage').textContent = 
                'Analyzing speech content and delivery for ' + studentName + '...';

            try {
                // Get the selected rubric
                const selectedRubric = await getRubricById(selectedRubricId);
                if (!selectedRubric) {
                    console.log('FAILURE: Rubric not found in storage');
                    throw new Error('Selected rubric not found');
                }
                
                console.log('‚úì Using rubric:', selectedRubric.name);
                
                // Pass rubric and provider to evaluation function
                console.log('Calling evaluateSpeech...');
                const result = await evaluateSpeech(apiKey, uploadedFile, assignmentType, selectedRubric, apiProvider);
                console.log('‚úì Evaluation complete');
                evaluationResults = result;
                moveToStep(4);
                displayResults(result);
            } catch (error) {
                console.error('EVALUATION ERROR:', error);
                alert('Error evaluating speech: ' + error.message);
                moveToStep(2);
            }
        }

        // ===== DEMO MODE EVALUATION =====
        async function generateDemoEvaluation(file, assignmentType, rubric) {
            console.log('>>> Generating demo evaluation');
            updateProcessingMessage('Generating realistic demo feedback...');
            
            // Simulate processing delay
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            const metrics = calculateRubricMetrics(rubric);
            const studentName = 'Student'; // Generic name since field was removed
            const speechDate = document.getElementById('speechDate').value || new Date().toISOString().split('T')[0];
            
            // First, decide on an overall performance level (70-95%)
            const overallPercentage = 70 + (Math.random() * 25); // 70-95%
            
            // Generate scores that add up correctly
            const sections = {};
            let totalScore = 0;
            let totalMaxScore = 0;
            
            rubric.categories.forEach((category, catIndex) => {
                const categoryName = typeof category === 'string' ? category : category.name;
                const subcategories = typeof category === 'string' ? 
                    ['Introduction', 'Main Points', 'Conclusion'] : 
                    (category.subcategories || []);
                
                const categoryFeedback = [];
                let categoryScore = 0;
                let categoryMaxScore = 0;
                
                subcategories.forEach((sub, subIndex) => {
                    const subName = typeof sub === 'string' ? sub : sub.name;
                    const subPoints = typeof sub === 'string' ? 10 : (sub.points || 10);
                    
                    // Vary individual scores slightly around the overall percentage (¬±10%)
                    const variance = (Math.random() * 20) - 10; // -10% to +10%
                    const subPercentage = Math.max(60, Math.min(100, overallPercentage + variance));
                    const score = Math.round(subPoints * (subPercentage / 100));
                    
                    // Generate feedback based on score
                    const percentage = (score / subPoints) * 100;
                    let feedback;
                    let grade;
                    
                    if (percentage >= 90) {
                        feedback = `Excellent ${subName.toLowerCase()}. Demonstrates strong mastery of this area.`;
                        grade = 'A';
                    } else if (percentage >= 80) {
                        feedback = `Good ${subName.toLowerCase()}. Shows solid understanding with room for minor improvements.`;
                        grade = 'B';
                    } else if (percentage >= 70) {
                        feedback = `Adequate ${subName.toLowerCase()}. Meets basic requirements but could be enhanced.`;
                        grade = 'C';
                    } else if (percentage >= 60) {
                        feedback = `${subName} needs improvement. Consider focusing more on this area.`;
                        grade = 'D';
                    } else {
                        feedback = `${subName} needs significant improvement. Consider focusing more on this area.`;
                        grade = 'F';
                    }
                    
                    categoryFeedback.push({
                        name: subName,
                        points: score,
                        maxPoints: subPoints,
                        grade: grade,
                        feedback: feedback
                    });
                    
                    categoryScore += score;
                    categoryMaxScore += subPoints;
                });
                
                // Create overall category feedback string
                const avgPercentage = (categoryScore / categoryMaxScore) * 100;
                let overallFeedback;
                if (avgPercentage >= 90) {
                    overallFeedback = `Excellent performance in ${categoryName}. Strong demonstration of skills across all areas.`;
                } else if (avgPercentage >= 80) {
                    overallFeedback = `Good work in ${categoryName}. Solid performance with minor areas for improvement.`;
                } else if (avgPercentage >= 70) {
                    overallFeedback = `Adequate ${categoryName}. Meets basic requirements but could be strengthened.`;
                } else {
                    overallFeedback = `${categoryName} needs significant improvement. Focus on developing these skills.`;
                }
                
                sections[categoryName] = {
                    feedback: overallFeedback,
                    score: categoryScore,
                    maxScore: categoryMaxScore,
                    subcategories: categoryFeedback
                };
                
                totalScore += categoryScore;
                totalMaxScore += categoryMaxScore;
            });
            
            // Calculate final percentage from actual scores
            const finalPercentage = (totalScore / totalMaxScore) * 100;
            const letterGrade = getLetterGrade(finalPercentage, rubric.gradeScale);
            
            console.log('Demo evaluation:', {
                totalScore,
                totalMaxScore,
                percentage: finalPercentage.toFixed(1),
                letterGrade
            });
            
            // Generate realistic timeline markers
            const speechDuration = 330; // 5:30 minutes in seconds
            const timeline_markers = [];
            
            // Add 3-7 markers spread throughout speech
            const numMarkers = Math.floor(Math.random() * 5) + 3; // 3-7 markers
            const categories = rubric.categories.map(cat => 
                typeof cat === 'string' ? cat : cat.name
            );
            
            // Define realistic issues for each category
            const issueTemplates = {
                'Introduction': {
                    'positive': ['Strong attention-getter', 'Clear thesis statement', 'Excellent preview of main points'],
                    'minor': ['Attention-getter could be stronger', 'Preview slightly unclear', 'Rushed introduction'],
                    'moderate': ['Missing preview of main points', 'Weak attention-getter', 'No clear thesis']
                },
                'Organization': {
                    'positive': ['Clear transition', 'Strong signpost phrase', 'Logical flow between ideas'],
                    'minor': ['Transition could be smoother', 'Signpost needed here', 'Slight organizational gap'],
                    'moderate': ['Abrupt topic change', 'Missing transition', 'Confusing sequence']
                },
                'Content': {
                    'positive': ['Excellent supporting evidence', 'Strong example usage', 'Compelling story'],
                    'minor': ['Example could be more specific', 'Source citation needed', 'Claim needs support'],
                    'moderate': ['Lack of supporting evidence', 'Unsupported claim', 'Weak reasoning']
                },
                'Delivery': {
                    'positive': ['Great vocal variety', 'Strong emphasis here', 'Clear pronunciation'],
                    'minor': ['Vocalized pause ("um")', 'Speaking slightly fast', 'Volume a bit low'],
                    'moderate': ['Multiple filler words', 'Speaking too fast', 'Monotone delivery']
                },
                'Eye Contact': {
                    'positive': ['Great audience engagement', 'Scanning all sections', 'Natural connection with audience'],
                    'minor': ['Brief glance at notes', 'Favoring one side slightly', 'Quick look down'],
                    'moderate': ['Looking down at notes', 'Avoiding audience gaze', 'Reading from slides']
                },
                'Body Language': {
                    'positive': ['Confident posture', 'Effective gestures', 'Good use of space'],
                    'minor': ['Hands in pockets briefly', 'Slight fidgeting', 'Standing too still'],
                    'moderate': ['Distracting movements', 'Poor posture', 'Awkward gestures']
                },
                'Conclusion': {
                    'positive': ['Strong closing statement', 'Clear call to action', 'Memorable ending'],
                    'minor': ['Conclusion slightly rushed', 'Could restate thesis more clearly', 'Ending a bit abrupt'],
                    'moderate': ['No clear conclusion', 'Forgot to summarize', 'Weak ending']
                }
            };
            
            // Generate markers
            for (let i = 0; i < numMarkers; i++) {
                // Spread markers throughout speech
                const seconds = Math.floor((speechDuration / (numMarkers + 1)) * (i + 1));
                const minutes = Math.floor(seconds / 60);
                const secs = seconds % 60;
                const timestamp = `${minutes}:${secs.toString().padStart(2, '0')}`;
                
                // Pick random category from rubric
                const category = categories[Math.floor(Math.random() * categories.length)];
                
                // Determine severity (weighted toward positive/minor)
                const severityRoll = Math.random();
                let severity;
                if (severityRoll < 0.3) severity = 'positive';
                else if (severityRoll < 0.8) severity = 'minor';
                else severity = 'moderate';
                
                // Get appropriate issue template
                const categoryTemplates = issueTemplates[category] || issueTemplates['Delivery'];
                const issueList = categoryTemplates[severity] || categoryTemplates['minor'];
                const issue = issueList[Math.floor(Math.random() * issueList.length)];
                
                // Generate contextual note based on severity
                let note;
                if (severity === 'positive') {
                    const positiveNotes = [
                        'This was a strong moment in your speech. Keep up this excellent technique!',
                        'Very effective here. This really engaged the audience.',
                        'Great job with this element. Consider using this approach more often.',
                        'This demonstrated strong mastery of the technique.'
                    ];
                    note = positiveNotes[Math.floor(Math.random() * positiveNotes.length)];
                } else if (severity === 'minor') {
                    const minorNotes = [
                        'Small issue that\'s easy to fix with practice. Not a major concern.',
                        'Minor point to work on for your next speech. Otherwise looking good.',
                        'This is easily correctable. Just be mindful of it during practice.',
                        'Worth noting, but doesn\'t significantly impact your overall performance.'
                    ];
                    note = minorNotes[Math.floor(Math.random() * minorNotes.length)];
                } else {
                    const moderateNotes = [
                        'This is an area that needs attention before your next speech. Practice this specifically.',
                        'Work on improving this aspect. It impacted the effectiveness of your message.',
                        'This requires focused practice. Consider getting feedback on this element.',
                        'Important area for improvement. This affects audience comprehension.'
                    ];
                    note = moderateNotes[Math.floor(Math.random() * moderateNotes.length)];
                }
                
                timeline_markers.push({
                    timestamp: timestamp,
                    seconds: seconds,
                    category: category,
                    issue: issue,
                    severity: severity,
                    note: note
                });
            }
            
            // Sort by time
            timeline_markers.sort((a, b) => a.seconds - b.seconds);
            
            console.log('Generated timeline markers:', timeline_markers.length);
            
            // Generate overall comments
            const overallComments = finalPercentage >= 90 ? 
                "Outstanding speech overall. Demonstrates strong mastery across all evaluated areas. Continue refining these excellent skills." :
                finalPercentage >= 80 ?
                "Strong performance with solid execution in most areas. Focus on the identified improvement areas to reach the next level." :
                finalPercentage >= 70 ?
                "Adequate performance meeting basic requirements. Review the specific feedback in each category and work on identified weaknesses." :
                "Significant improvement needed. Focus on the fundamental skills highlighted in the feedback and practice consistently.";
            
            return {
                studentName: studentName,
                speechDate: speechDate,
                assignmentType: assignmentType,
                speechTime: '5:30',
                rubricUsed: rubric.name,
                sections: sections,
                totalScore: totalScore,
                maxScore: totalMaxScore,
                percentage: finalPercentage.toFixed(1),
                letterGrade: letterGrade,
                gradeScale: rubric.gradeScale,
                aiProvider: 'demo',
                transcript: '[Demo Mode - No actual transcription performed]',
                timeline_markers: timeline_markers,
                overallComments: overallComments
            };
        }
        
        function getLetterGrade(percentage, gradeScale) {
            if (!gradeScale) return 'N/A';
            
            const grades = Object.entries(gradeScale).sort((a, b) => {
                const minA = a[1].min !== undefined ? a[1].min : parseFloat(a[1].range?.split('-')[0] || 0);
                const minB = b[1].min !== undefined ? b[1].min : parseFloat(b[1].range?.split('-')[0] || 0);
                return minB - minA;
            });
            
            for (const [grade, config] of grades) {
                const min = config.min !== undefined ? config.min : parseFloat(config.range?.split('-')[0] || 0);
                if (percentage >= min) {
                    return grade;
                }
            }
            
            return 'F';
        }

        async function evaluateSpeech(apiKey, file, assignmentType, rubric, apiProvider = 'gemini') {
            console.log('>>> evaluateSpeech called');
            console.log('    API Provider:', apiProvider);
            console.log('    API key:', apiKey ? 'Present' : 'Missing');
            console.log('    File:', file ? file.name : 'Missing');
            console.log('    File size:', file ? (file.size / 1024 / 1024).toFixed(2) + ' MB' : 'N/A');
            console.log('    Assignment type:', assignmentType);
            console.log('    Rubric:', rubric ? rubric.name : 'Missing');
            
            // Check file size based on provider
            let maxSizeBytes;
            if (apiProvider === 'gemini') {
                maxSizeBytes = 100 * 1024 * 1024; // 100MB for Gemini
            } else if (apiProvider === 'gpt4o') {
                maxSizeBytes = 100 * 1024 * 1024; // 100MB for GPT-4o (generous limit)
            } else {
                maxSizeBytes = 25 * 1024 * 1024; // 25MB for Claude (due to base64 encoding)
            }
            
            if (file.size > maxSizeBytes) {
                const sizeMB = (file.size / 1024 / 1024).toFixed(2);
                const limitMB = (maxSizeBytes / 1024 / 1024).toFixed(0);
                const providerName = apiProvider === 'gemini' ? 'Gemini' : 
                                    apiProvider === 'gpt4o' ? 'GPT-4o' : 'Claude';
                throw new Error(
                    `File is ${sizeMB} MB, which exceeds the ${limitMB} MB limit for ${providerName}.\n\n` +
                    `Please compress the file or use a different format.`
                );
            }
            
            // Use the passed rubric (or fallback to default if not provided)
            if (!rubric) {
                rubric = getRubricById('default') || DEFAULT_RUBRIC;
            }
            
            const metrics = calculateRubricMetrics(rubric);
            console.log('    Metrics calculated:', metrics);
            
            // Route to demo mode if selected
            if (apiProvider === 'demo') {
                console.log('>>> Using Demo Mode - generating mock evaluation');
                return await generateDemoEvaluation(file, assignmentType, rubric);
            }
            
            // Route to the appropriate API
            if (apiProvider === 'gpt4o') {
                return await evaluateWithGPT4o(apiKey, file, assignmentType, rubric);
            } else if (apiProvider === 'gemini') {
                return await evaluateWithGemini(apiKey, file, assignmentType, rubric);
            } else {
                return await evaluateWithClaude(apiKey, file, assignmentType, rubric);
            }
        }
        
        // ===== CLAUDE API EVALUATION =====
        async function evaluateWithClaude(apiKey, file, assignmentType, rubric) {
            console.log('>>> Using Claude API (Audio Only)');
            const metrics = calculateRubricMetrics(rubric);
            
            try {
                let audioFile = file;
                
                // If file is video, extract audio automatically
                if (file.type.startsWith('video/')) {
                    console.log('>>> Video detected, extracting audio...');
                    updateProcessingMessage('Extracting audio from video...');
                    audioFile = await extractAudioFromVideo(file);
                    console.log('‚úì Audio extracted from video');
                }
                
                // Phase 2a: File Processing - Convert audio to base64
                console.log('>>> Phase 2a: Processing audio file...');
                updateProcessingMessage('Processing audio file...');
                const { base64Audio, mediaType, duration } = await processAudioFile(audioFile);
                console.log('‚úì Audio processed:', mediaType, duration);
                
                // Phase 2b: Speech Transcription
                console.log('>>> Phase 2b: Transcribing speech...');
                updateProcessingMessage('Transcribing speech...');
                const transcript = await transcribeSpeech(apiKey, base64Audio, mediaType);
                console.log('‚úì Transcription received, length:', transcript.length);
                
                if (!transcript || transcript.trim().length === 0) {
                    throw new Error('Transcription failed or returned empty. Please ensure the audio is clear and try again.');
                }
                
                // Phase 2c: AI Evaluation Against Rubric
                updateProcessingMessage('Analyzing speech against rubric...');
                const aiEvaluation = await evaluateWithClaudeAI(apiKey, transcript, rubric);
                
                // Phase 2d: Results Validation & Formatting
                updateProcessingMessage('Calculating final scores...');
                const results = formatEvaluationResults(aiEvaluation, rubric, transcript, duration);
                
                return results;
                
            } catch (error) {
                console.error('Claude evaluation error:', error);
                throw new Error(`Claude evaluation failed: ${error.message}`);
            }
        }
        
        // Extract audio from video file using Web Audio API and MediaRecorder
        async function extractAudioFromVideo(videoFile) {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                video.preload = 'metadata';
                video.muted = true;
                
                video.onloadedmetadata = async function() {
                    try {
                        // Create media element source
                        const source = audioContext.createMediaElementSource(video);
                        
                        // Create destination for recording
                        const dest = audioContext.createMediaStreamDestination();
                        source.connect(dest);
                        
                        // Set up MediaRecorder
                        const mediaRecorder = new MediaRecorder(dest.stream);
                        const chunks = [];
                        
                        mediaRecorder.ondataavailable = (e) => {
                            if (e.data.size > 0) {
                                chunks.push(e.data);
                            }
                        };
                        
                        mediaRecorder.onstop = () => {
                            const audioBlob = new Blob(chunks, { type: 'audio/webm' });
                            const audioFile = new File([audioBlob], 'extracted-audio.webm', { type: 'audio/webm' });
                            URL.revokeObjectURL(video.src);
                            resolve(audioFile);
                        };
                        
                        // Start recording and play video
                        mediaRecorder.start();
                        video.play();
                        
                        // Stop when video ends
                        video.onended = () => {
                            mediaRecorder.stop();
                            audioContext.close();
                        };
                        
                    } catch (error) {
                        URL.revokeObjectURL(video.src);
                        reject(new Error('Failed to extract audio: ' + error.message));
                    }
                };
                
                video.onerror = function() {
                    URL.revokeObjectURL(video.src);
                    reject(new Error('Failed to load video for audio extraction'));
                };
                
                video.src = URL.createObjectURL(videoFile);
            });
        }
        
        // ===== GPT-4O-MINI API EVALUATION =====
        async function evaluateWithGPT4o(apiKey, file, assignmentType, rubric) {
            console.log('>>> Using GPT-4o-mini API (Image/Frame Analysis)');
            const metrics = calculateRubricMetrics(rubric);
            
            try {
                let frameBase64;
                
                // Check if file is an image or video
                if (file.type.startsWith('image/')) {
                    // Direct image upload
                    console.log('>>> Phase 1: Processing uploaded image...');
                    updateProcessingMessage('Processing image...');
                    frameBase64 = await fileToBase64(file);
                    console.log('‚úì Image processed');
                } else {
                    // Extract frame from video
                    console.log('>>> Phase 1: Extracting frame from video...');
                    updateProcessingMessage('Extracting video frame...');
                    frameBase64 = await extractVideoFrame(file);
                    console.log('‚úì Video frame extracted');
                }
                
                // Phase 2: Send to GPT-4o for analysis
                console.log('>>> Phase 2: Analyzing with GPT-4o...');
                updateProcessingMessage('Analyzing speech delivery...');
                const gptEvaluation = await analyzeWithGPT4o(apiKey, frameBase64, rubric);
                console.log('‚úì GPT-4o analysis complete');
                
                // Phase 3: Format results
                updateProcessingMessage('Calculating final scores...');
                const duration = file.type.startsWith('image/') ? '0:00' : await getVideoDuration(file);
                const results = formatGPTResults(gptEvaluation, rubric, duration);
                
                return results;
                
            } catch (error) {
                console.error('GPT-4o evaluation error:', error);
                throw new Error(`GPT-4o evaluation failed: ${error.message}`);
            }
        }
        
        // Extract a representative frame from video
        async function extractVideoFrame(file) {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                let hasResolved = false;
                
                // Set timeout to prevent hanging
                const timeout = setTimeout(() => {
                    if (!hasResolved) {
                        URL.revokeObjectURL(video.src);
                        reject(new Error('Video loading timed out after 30 seconds. The video format may not be supported by your browser. Try converting to MP4.'));
                    }
                }, 30000);
                
                video.preload = 'metadata';
                video.muted = true;
                video.playsInline = true;
                
                video.onloadedmetadata = function() {
                    console.log('Video metadata loaded. Duration:', video.duration, 'seconds');
                    // Seek to 2 seconds in (or middle if shorter)
                    const seekTime = Math.min(2, video.duration / 2);
                    console.log('Seeking to:', seekTime, 'seconds');
                    video.currentTime = seekTime;
                };
                
                video.onseeked = function() {
                    console.log('Video seeked successfully');
                    
                    if (hasResolved) return;
                    hasResolved = true;
                    clearTimeout(timeout);
                    
                    try {
                        // Set canvas size to video size (limit to reasonable dimensions)
                        const maxWidth = 1280;
                        const maxHeight = 720;
                        let width = video.videoWidth;
                        let height = video.videoHeight;
                        
                        // Scale down if too large
                        if (width > maxWidth) {
                            height = (height * maxWidth) / width;
                            width = maxWidth;
                        }
                        if (height > maxHeight) {
                            width = (width * maxHeight) / height;
                            height = maxHeight;
                        }
                        
                        canvas.width = width;
                        canvas.height = height;
                        
                        console.log('Canvas size:', width, 'x', height);
                        
                        // Draw video frame to canvas
                        ctx.drawImage(video, 0, 0, width, height);
                        
                        // Convert to base64
                        const base64 = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];
                        console.log('Frame extracted, base64 length:', base64.length);
                        
                        // Clean up
                        URL.revokeObjectURL(video.src);
                        
                        resolve(base64);
                    } catch (error) {
                        URL.revokeObjectURL(video.src);
                        reject(new Error('Failed to extract frame: ' + error.message));
                    }
                };
                
                video.onerror = function(e) {
                    if (hasResolved) return;
                    hasResolved = true;
                    clearTimeout(timeout);
                    
                    URL.revokeObjectURL(video.src);
                    
                    let errorMsg = 'Failed to load video.';
                    if (video.error) {
                        switch (video.error.code) {
                            case 1:
                                errorMsg += ' Video loading was aborted.';
                                break;
                            case 2:
                                errorMsg += ' Network error occurred.';
                                break;
                            case 3:
                                errorMsg += ' Video codec not supported by browser. Try converting to MP4.';
                                break;
                            case 4:
                                errorMsg += ' Video format not supported. Try converting to MP4.';
                                break;
                        }
                    }
                    reject(new Error(errorMsg));
                };
                
                // Load the video
                try {
                    const url = URL.createObjectURL(file);
                    console.log('Loading video from blob URL...');
                    video.src = url;
                    video.load();
                } catch (error) {
                    hasResolved = true;
                    clearTimeout(timeout);
                    reject(new Error('Failed to create video URL: ' + error.message));
                }
            });
        }
        
        // Analyze with GPT-4o API
        async function analyzeWithGPT4o(apiKey, frameBase64, rubric) {
            const prompt = buildGPTPrompt(rubric);
            
            console.log('GPT-4o API Request Details:');
            console.log('  - API Key format check:', apiKey.startsWith('sk-') ? 'Looks valid (starts with sk-)' : 'WARNING: Does not start with sk-');
            console.log('  - API Key length:', apiKey.length);
            console.log('  - Frame base64 length:', frameBase64.length);
            
            // Validate API key format
            if (!apiKey.startsWith('sk-')) {
                throw new Error('Invalid OpenAI API key format. Key should start with "sk-". Make sure you\'re using an OpenAI API key from https://platform.openai.com/api-keys');
            }
            
            const requestBody = {
                model: 'gpt-4o-mini',
                messages: [{
                    role: 'user',
                    content: [
                        {
                            type: 'text',
                            text: prompt
                        },
                        {
                            type: 'image_url',
                            image_url: {
                                url: `data:image/jpeg;base64,${frameBase64}`
                            }
                        }
                    ]
                }],
                max_tokens: 4096
            };
            
            console.log('Calling OpenAI API...');
            
            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(requestBody)
                });
                
                console.log('GPT-4o API Response Status:', response.status);
                console.log('GPT-4o API Response OK:', response.ok);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('GPT-4o API Error Response:', errorText);
                    
                    let errorMessage;
                    try {
                        const errorData = JSON.parse(errorText);
                        errorMessage = errorData.error?.message || errorText;
                    } catch (e) {
                        errorMessage = errorText;
                    }
                    
                    throw new Error(`GPT-4o API error (${response.status}): ${errorMessage}`);
                }
                
                const data = await response.json();
                console.log('GPT-4o API Response received successfully');
                
                const responseText = data.choices?.[0]?.message?.content || '';
                
                if (!responseText) {
                    console.error('GPT-4o response structure:', JSON.stringify(data, null, 2));
                    throw new Error('GPT-4o returned empty response');
                }
                
                return parseGPTEvaluation(responseText);
            } catch (error) {
                console.error('GPT-4o API fetch error:', error);
                throw error;
            }
        }
        
        // Build prompt for GPT-4o
        function buildGPTPrompt(rubric) {
            let prompt = `You are an expert speech instructor evaluating a student's speech presentation. You are viewing a SINGLE FRAME from the middle of their speech video. Analyze this frame for nonverbal delivery cues, and infer verbal content quality based on context clues.

IMPORTANT: You only have ONE FRAME to work with, so focus on:
- What you CAN see: posture, body language, facial expression, eye direction, hand position, professional appearance
- What you can INFER: likely confidence level, engagement, preparation

RUBRIC INFORMATION:
- Assignment Type: ${rubric.speechType || 'General Speech'}
- Total Points: ${rubric.totalPoints}
- Grading Scale:
`;
            
            Object.entries(rubric.gradeScale).forEach(([grade, info]) => {
                prompt += `  ${grade} (${info.label}): ${Math.round(info.percentage * 100)}% of points\n`;
            });
            
            prompt += '\nCATEGORIES TO EVALUATE:\n';
            
            rubric.categories.forEach((category, index) => {
                prompt += `\n${index + 1}. ${category.name}\n`;
                category.subcategories.forEach((sub, subIndex) => {
                    prompt += `   ${String.fromCharCode(97 + subIndex)}. ${sub}\n`;
                });
            });
            
            prompt += `
EVALUATION INSTRUCTIONS:
1. Analyze the single frame carefully
2. For NONVERBAL categories (eye contact, gestures, body language, appearance):
   - Give specific grades based on what you observe
   - Note: "Eye contact appears direct/averted", "Posture is upright/slouched", etc.
3. For VERBAL categories (content, organization, language):
   - Make reasonable inferences based on the speaker's apparent confidence and preparation
   - Grade conservatively (B/C range) since you can't hear the actual content
4. For EACH subcategory, assign a letter grade (A, B, C, D, or F)
5. Be fair but realistic about the limitations of single-frame analysis

CRITICAL: Return your evaluation in this EXACT JSON format (no additional text before or after):
{
  "evaluations": [
    {
      "category": "Category Name",
      "feedback": "Detailed feedback based on visible cues in the frame",
      "subcategories": [
        { "name": "Subcategory Name", "grade": "A" },
        { "name": "Another Subcategory", "grade": "B" }
      ]
    }
  ],
  "overallComments": "Overall assessment noting this is based on a single frame analysis, with observations about visible delivery and inferred content quality",
  "transcript": "Note: Single frame analysis - actual speech content not available"
}

Ensure every subcategory receives a grade. Be honest about limitations while being as helpful as possible.`;

            return prompt;
        }
        
        // Parse GPT evaluation response
        function parseGPTEvaluation(responseText) {
            try {
                let jsonText = responseText.trim();
                
                // Remove markdown code blocks if present
                const codeBlockMatch = jsonText.match(/```(?:json)?\s*([\s\S]*?)```/);
                if (codeBlockMatch) {
                    jsonText = codeBlockMatch[1].trim();
                }
                
                // Try to find JSON object
                const jsonMatch = jsonText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    jsonText = jsonMatch[0];
                }
                
                const evaluation = JSON.parse(jsonText);
                
                // Validate structure
                if (!evaluation.evaluations || !Array.isArray(evaluation.evaluations)) {
                    throw new Error('Invalid evaluation format: missing evaluations array');
                }
                
                if (!evaluation.overallComments) {
                    throw new Error('Invalid evaluation format: missing overallComments');
                }
                
                return evaluation;
                
            } catch (error) {
                console.error('Failed to parse GPT evaluation:', error);
                console.error('Response text:', responseText);
                throw new Error('Failed to parse GPT evaluation response. Please try again.');
            }
        }
        
        // Format GPT results into expected structure
        function formatGPTResults(gptEvaluation, rubric, duration) {
            const metrics = calculateRubricMetrics(rubric);
            const sections = {};
            let totalScore = 0;
            
            rubric.categories.forEach((category, categoryIndex) => {
                const gptCategory = gptEvaluation.evaluations.find(
                    e => e.category === category.name
                );
                
                if (!gptCategory) {
                    console.warn(`No GPT evaluation found for category: ${category.name}`);
                    return;
                }
                
                const grades = category.subcategories.map((subName) => {
                    const gptSub = gptCategory.subcategories.find(s => s.name === subName);
                    return gptSub ? gptSub.grade : 'C';
                });
                
                const categoryScore = calculateCategoryScore(rubric, categoryIndex, grades);
                const pointsPerSub = metrics.pointsPerSubcategory;
                
                const subcategoryDetails = category.subcategories.map((subName, subIndex) => {
                    const grade = grades[subIndex];
                    const gradePercentage = rubric.gradeScale[grade]?.percentage || 0.8;
                    const points = pointsPerSub * gradePercentage;
                    
                    return {
                        name: subName,
                        grade: grade,
                        gradeLabel: rubric.gradeScale[grade]?.label || 'Developing',
                        points: parseFloat(points.toFixed(2)),
                        maxPoints: parseFloat(pointsPerSub.toFixed(2))
                    };
                });
                
                sections[category.name] = {
                    score: categoryScore.score,
                    maxScore: categoryScore.maxScore,
                    feedback: gptCategory.feedback || 'No feedback provided.',
                    subcategories: subcategoryDetails
                };
                
                totalScore += categoryScore.score;
            });
            
            const percentage = ((totalScore / rubric.totalPoints) * 100).toFixed(1);
            const letterGrade = getLetterGrade(percentage, rubric.gradeScale);
            
            return {
                studentName: 'Student',
                speechDate: document.getElementById('speechDate').value,
                assignmentType: rubric.speechType || 'General Speech',
                speechTime: duration || '0:00',
                sections: sections,
                totalScore: parseFloat(totalScore.toFixed(2)),
                maxScore: rubric.totalPoints,
                percentage: percentage,
                letterGrade: letterGrade,
                gradeScale: rubric.gradeScale,
                rubricUsed: rubric.name,
                overallComments: gptEvaluation.overallComments,
                transcript: gptEvaluation.transcript || ''
            };
        }
        
        // ===== GEMINI API EVALUATION =====
        async function evaluateWithGemini(apiKey, file, assignmentType, rubric) {
            console.log('>>> Using Gemini API (Full Video Analysis)');
            const metrics = calculateRubricMetrics(rubric);
            
            try {
                // Phase 1: Convert file to base64
                console.log('>>> Phase 1: Processing video/audio file...');
                updateProcessingMessage('Processing video file...');
                const base64Data = await fileToBase64(file);
                console.log('‚úì File converted to base64');
                
                // Phase 2: Send to Gemini for comprehensive analysis
                console.log('>>> Phase 2: Analyzing video with Gemini...');
                updateProcessingMessage('Analyzing speech content and delivery...');
                const geminiEvaluation = await analyzeWithGemini(apiKey, base64Data, file.type, rubric);
                console.log('‚úì Gemini analysis complete');
                
                // Phase 3: Format results
                updateProcessingMessage('Calculating final scores...');
                const duration = await getVideoDuration(file);
                const results = formatGeminiResults(geminiEvaluation, rubric, duration);
                
                return results;
                
            } catch (error) {
                console.error('Gemini evaluation error:', error);
                throw new Error(`Gemini evaluation failed: ${error.message}`);
            }
        }
        
        // Convert file to base64
        async function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const base64 = e.target.result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        // Get video/audio duration
        async function getVideoDuration(file) {
            return new Promise((resolve) => {
                const url = URL.createObjectURL(file);
                const media = document.createElement(file.type.startsWith('video') ? 'video' : 'audio');
                media.onloadedmetadata = function() {
                    const duration = Math.floor(media.duration);
                    const minutes = Math.floor(duration / 60);
                    const seconds = duration % 60;
                    URL.revokeObjectURL(url);
                    resolve(`${minutes}:${seconds.toString().padStart(2, '0')}`);
                };
                media.onerror = function() {
                    URL.revokeObjectURL(url);
                    resolve('0:00');
                };
                media.src = url;
            });
        }
        
        // Analyze with Gemini API
        async function analyzeWithGemini(apiKey, base64Data, mimeType, rubric) {
            const prompt = buildGeminiPrompt(rubric);
            
            console.log('Gemini API Request Details:');
            console.log('  - API Key format check:', apiKey.startsWith('AIza') ? 'Looks valid (starts with AIza)' : 'WARNING: Does not start with AIza');
            console.log('  - API Key length:', apiKey.length, '(should be around 39 characters)');
            console.log('  - MIME type:', mimeType);
            console.log('  - Base64 data length:', base64Data.length);
            console.log('  - Prompt length:', prompt.length);
            
            // Validate API key format
            if (!apiKey.startsWith('AIza')) {
                throw new Error('Invalid Gemini API key format. Key should start with "AIza". Make sure you\'re using a Gemini API key from https://aistudio.google.com/app/apikey');
            }
            
            const requestBody = {
                contents: [{
                    parts: [
                        {
                            inline_data: {
                                mime_type: mimeType,
                                data: base64Data
                            }
                        },
                        {
                            text: prompt
                        }
                    ]
                }]
            };
            
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`;
            console.log('Gemini API URL:', url.substring(0, 100) + '...');
            console.log('Request size: ~' + Math.round(JSON.stringify(requestBody).length / 1024 / 1024) + ' MB');
            
            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                console.log('Gemini API Response Status:', response.status);
                console.log('Gemini API Response OK:', response.ok);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Gemini API Error Response:', errorText);
                    
                    let errorMessage;
                    try {
                        const errorData = JSON.parse(errorText);
                        errorMessage = errorData.error?.message || errorText;
                    } catch (e) {
                        errorMessage = errorText;
                    }
                    
                    throw new Error(`Gemini API error (${response.status}): ${errorMessage}`);
                }
                
                const data = await response.json();
                console.log('Gemini API Response received successfully');
                
                const responseText = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                
                if (!responseText) {
                    console.error('Gemini response structure:', JSON.stringify(data, null, 2));
                    throw new Error('Gemini returned empty response');
                }
                
                return parseGeminiEvaluation(responseText);
            } catch (error) {
                console.error('Gemini API fetch error:', error);
                console.error('Error name:', error.name);
                console.error('Error message:', error.message);
                throw error;
            }
        }
        
        // Build prompt for Gemini
        function buildGeminiPrompt(rubric) {
            let prompt = `You are an expert speech instructor evaluating a student's speech presentation. Analyze this video recording for BOTH verbal content AND nonverbal delivery.

RUBRIC INFORMATION:
- Assignment Type: ${rubric.speechType || 'General Speech'}
- Total Points: ${rubric.totalPoints}
- Grading Scale:
`;
            
            Object.entries(rubric.gradeScale).forEach(([grade, info]) => {
                prompt += `  ${grade} (${info.label}): ${Math.round(info.percentage * 100)}% of points\n`;
            });
            
            prompt += '\nCATEGORIES TO EVALUATE:\n';
            
            rubric.categories.forEach((category, index) => {
                prompt += `\n${index + 1}. ${category.name}\n`;
                category.subcategories.forEach((sub, subIndex) => {
                    prompt += `   ${String.fromCharCode(97 + subIndex)}. ${sub}\n`;
                });
            });
            
            prompt += `
EVALUATION INSTRUCTIONS:
1. Watch the ENTIRE video carefully
2. Evaluate BOTH:
   - VERBAL: Speech content, organization, language use, clarity
   - NONVERBAL: Eye contact, gestures, body language, facial expressions, posture, movement
3. For EACH subcategory, assign a letter grade (A, B, C, D, or F)
4. Base your evaluation on evidence from the video
5. Be fair but rigorous in your assessment

For nonverbal categories (eye contact, gestures, body language):
- Observe actual behavior in the video
- Note specific examples (e.g., "maintained eye contact 80% of the time", "used descriptive hand gestures")
- Consider camera angle limitations but evaluate what is visible

CRITICAL: Return your evaluation in this EXACT JSON format (no additional text before or after):
{
  "evaluations": [
    {
      "category": "Category Name",
      "feedback": "Detailed feedback including specific observations from the video (both verbal and visual)",
      "subcategories": [
        { "name": "Subcategory Name", "grade": "A" },
        { "name": "Another Subcategory", "grade": "B" }
      ]
    }
  ],
  "overallComments": "Overall assessment referencing specific moments from the video, both verbal content and physical delivery",
  "transcript": "Brief summary of what was said (2-3 sentences)"
}

Ensure every subcategory receives a grade. Be specific in your feedback and reference actual observations from the video.`;

            return prompt;
        }
        
        // Parse Gemini evaluation response
        function parseGeminiEvaluation(responseText) {
            try {
                let jsonText = responseText.trim();
                
                // Remove markdown code blocks if present
                const codeBlockMatch = jsonText.match(/```(?:json)?\s*([\s\S]*?)```/);
                if (codeBlockMatch) {
                    jsonText = codeBlockMatch[1].trim();
                }
                
                // Try to find JSON object
                const jsonMatch = jsonText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    jsonText = jsonMatch[0];
                }
                
                const evaluation = JSON.parse(jsonText);
                
                // Validate structure
                if (!evaluation.evaluations || !Array.isArray(evaluation.evaluations)) {
                    throw new Error('Invalid evaluation format: missing evaluations array');
                }
                
                if (!evaluation.overallComments) {
                    throw new Error('Invalid evaluation format: missing overallComments');
                }
                
                return evaluation;
                
            } catch (error) {
                console.error('Failed to parse Gemini evaluation:', error);
                console.error('Response text:', responseText);
                throw new Error('Failed to parse Gemini evaluation response. Please try again.');
            }
        }
        
        // Format Gemini results into expected structure
        function formatGeminiResults(geminiEvaluation, rubric, duration) {
            const metrics = calculateRubricMetrics(rubric);
            const sections = {};
            let totalScore = 0;
            
            rubric.categories.forEach((category, categoryIndex) => {
                const geminiCategory = geminiEvaluation.evaluations.find(
                    e => e.category === category.name
                );
                
                if (!geminiCategory) {
                    console.warn(`No Gemini evaluation found for category: ${category.name}`);
                    return;
                }
                
                const grades = category.subcategories.map((subName) => {
                    const geminiSub = geminiCategory.subcategories.find(s => s.name === subName);
                    return geminiSub ? geminiSub.grade : 'C';
                });
                
                const categoryScore = calculateCategoryScore(rubric, categoryIndex, grades);
                const pointsPerSub = metrics.pointsPerSubcategory;
                
                const subcategoryDetails = category.subcategories.map((subName, subIndex) => {
                    const grade = grades[subIndex];
                    const gradePercentage = rubric.gradeScale[grade]?.percentage || 0.8;
                    const points = pointsPerSub * gradePercentage;
                    
                    return {
                        name: subName,
                        grade: grade,
                        gradeLabel: rubric.gradeScale[grade]?.label || 'Developing',
                        points: parseFloat(points.toFixed(2)),
                        maxPoints: parseFloat(pointsPerSub.toFixed(2))
                    };
                });
                
                sections[category.name] = {
                    score: categoryScore.score,
                    maxScore: categoryScore.maxScore,
                    feedback: geminiCategory.feedback || 'No feedback provided.',
                    subcategories: subcategoryDetails
                };
                
                totalScore += categoryScore.score;
            });
            
            const percentage = ((totalScore / rubric.totalPoints) * 100).toFixed(1);
            const letterGrade = getLetterGrade(percentage, rubric.gradeScale);
            
            return {
                studentName: 'Student',
                speechDate: document.getElementById('speechDate').value,
                assignmentType: rubric.speechType || 'General Speech',
                speechTime: duration || '0:00',
                sections: sections,
                totalScore: parseFloat(totalScore.toFixed(2)),
                maxScore: rubric.totalPoints,
                percentage: percentage,
                letterGrade: letterGrade,
                gradeScale: rubric.gradeScale,
                rubricUsed: rubric.name,
                overallComments: geminiEvaluation.overallComments,
                transcript: geminiEvaluation.transcript || ''
            };
        }
        
        // Helper function to update processing message
        function updateProcessingMessage(message) {
            const messageElement = document.getElementById('processingMessage');
            if (messageElement) {
                messageElement.textContent = message;
            }
        }
        
        // Phase 2a: Process audio/video file and convert to base64
        async function processAudioFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const base64Data = e.target.result.split(',')[1];
                    
                    // Determine media type
                    let mediaType = file.type;
                    
                    // Handle common audio formats
                    if (!mediaType || mediaType === '') {
                        const extension = file.name.split('.').pop().toLowerCase();
                        const typeMap = {
                            'mp3': 'audio/mpeg',
                            'wav': 'audio/wav',
                            'webm': 'audio/webm',
                            'mp4': 'audio/mp4',
                            'm4a': 'audio/mp4',
                            'ogg': 'audio/ogg'
                        };
                        mediaType = typeMap[extension] || 'audio/mpeg';
                    }
                    
                    // Estimate duration (not exact, just for display)
                    const estimatedDuration = Math.floor(file.size / 16000); // Rough estimate
                    const minutes = Math.floor(estimatedDuration / 60);
                    const seconds = estimatedDuration % 60;
                    const duration = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    
                    resolve({
                        base64Audio: base64Data,
                        mediaType: mediaType,
                        duration: duration
                    });
                };
                
                reader.onerror = function(error) {
                    reject(new Error('Failed to read audio file: ' + error));
                };
                
                reader.readAsDataURL(file);
            });
        }
        
        // Phase 2b: Transcribe speech using Claude API
        async function transcribeSpeech(apiKey, base64Audio, mediaType) {
            console.log('transcribeSpeech - API key length:', apiKey.length);
            
            // Sanitize API key - remove any non-ASCII characters
            const cleanApiKey = apiKey.replace(/[^\x00-\x7F]/g, '').trim();
            console.log('transcribeSpeech - Cleaned API key length:', cleanApiKey.length);
            
            if (cleanApiKey !== apiKey) {
                console.warn('API key contained non-ASCII characters that were removed');
            }
            
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': cleanApiKey,
                    'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                    model: 'claude-sonnet-4-20250514',
                    max_tokens: 4096,
                    messages: [
                        {
                            role: 'user',
                            content: [
                                {
                                    type: 'document',
                                    source: {
                                        type: 'base64',
                                        media_type: mediaType,
                                        data: base64Audio
                                    }
                                },
                                {
                                    type: 'text',
                                    text: 'Please transcribe this speech audio. Provide only the transcript text without any additional commentary or formatting.'
                                }
                            ]
                        }
                    ]
                })
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error?.message || `API request failed with status ${response.status}`);
            }
            
            const data = await response.json();
            const transcript = data.content[0]?.text || '';
            
            return transcript.trim();
        }
        
        // Phase 2c: Evaluate transcript against rubric using Claude API
        async function evaluateWithClaudeAI(apiKey, transcript, rubric) {
            // Build the evaluation prompt
            const prompt = buildEvaluationPrompt(transcript, rubric);
            
            // Sanitize API key - remove any non-ASCII characters
            const cleanApiKey = apiKey.replace(/[^\x00-\x7F]/g, '').trim();
            
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': cleanApiKey,
                    'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                    model: 'claude-sonnet-4-20250514',
                    max_tokens: 4096,
                    messages: [
                        {
                            role: 'user',
                            content: prompt
                        }
                    ]
                })
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error?.message || `API request failed with status ${response.status}`);
            }
            
            const data = await response.json();
            const responseText = data.content[0]?.text || '';
            
            // Parse the JSON response
            return parseAIEvaluation(responseText);
        }
        
        // Build the evaluation prompt for Claude
        function buildEvaluationPrompt(transcript, rubric) {
            let prompt = `You are an expert speech instructor grading a student's speech. Evaluate the following speech transcript against the provided rubric.

SPEECH TRANSCRIPT:
${transcript}

RUBRIC INFORMATION:
- Assignment Type: ${rubric.speechType || 'General Speech'}
- Total Points: ${rubric.totalPoints}
- Grading Scale:
`;
            
            // Add grade scale information
            Object.entries(rubric.gradeScale).forEach(([grade, info]) => {
                prompt += `  ${grade} (${info.label}): ${Math.round(info.percentage * 100)}% of points\n`;
            });
            
            prompt += '\nCATEGORIES AND SUBCATEGORIES TO EVALUATE:\n';
            
            // Add all categories and subcategories
            rubric.categories.forEach((category, index) => {
                prompt += `\n${index + 1}. ${category.name}\n`;
                category.subcategories.forEach((sub, subIndex) => {
                    prompt += `   ${String.fromCharCode(97 + subIndex)}. ${sub}\n`;
                });
            });
            
            prompt += `
TASK:
For EACH subcategory listed above, you must:
1. Assign a letter grade (A, B, C, D, or F) based on how well the speech demonstrates that specific criterion
2. Base your evaluation on evidence from the transcript
3. Be fair but rigorous in your assessment

Additionally, provide:
- Specific feedback for each CATEGORY (not subcategory) explaining the overall performance
- Overall comments on the entire speech with constructive suggestions for improvement

IMPORTANT: Return your evaluation in this EXACT JSON format (no additional text before or after):
{
  "evaluations": [
    {
      "category": "Category Name",
      "feedback": "Detailed feedback for this category based on the transcript",
      "subcategories": [
        { "name": "Subcategory Name", "grade": "A" },
        { "name": "Another Subcategory", "grade": "B" }
      ]
    }
  ],
  "overallComments": "Overall assessment of the speech with specific examples from the transcript and actionable suggestions for improvement"
}

Ensure every subcategory from the rubric receives a grade. Be specific in your feedback and reference actual content from the speech.`;

            return prompt;
        }
        
        // Parse AI evaluation response
        function parseAIEvaluation(responseText) {
            try {
                // Try to extract JSON from the response
                // Handle cases where Claude might wrap it in markdown code blocks
                let jsonText = responseText.trim();
                
                // Remove markdown code blocks if present
                const codeBlockMatch = jsonText.match(/```(?:json)?\s*([\s\S]*?)```/);
                if (codeBlockMatch) {
                    jsonText = codeBlockMatch[1].trim();
                }
                
                // Try to find JSON object
                const jsonMatch = jsonText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    jsonText = jsonMatch[0];
                }
                
                const evaluation = JSON.parse(jsonText);
                
                // Validate the structure
                if (!evaluation.evaluations || !Array.isArray(evaluation.evaluations)) {
                    throw new Error('Invalid evaluation format: missing evaluations array');
                }
                
                if (!evaluation.overallComments) {
                    throw new Error('Invalid evaluation format: missing overallComments');
                }
                
                return evaluation;
                
            } catch (error) {
                console.error('Failed to parse AI evaluation:', error);
                console.error('Response text:', responseText);
                throw new Error('Failed to parse AI evaluation response. Please try again.');
            }
        }
        
        // Phase 2d: Format evaluation results into the expected structure
        function formatEvaluationResults(aiEvaluation, rubric, transcript, duration) {
            const metrics = calculateRubricMetrics(rubric);
            const sections = {};
            let totalScore = 0;
            
            // Process each category from the AI evaluation
            rubric.categories.forEach((category, categoryIndex) => {
                // Find matching evaluation from AI response
                const aiCategory = aiEvaluation.evaluations.find(
                    e => e.category === category.name
                );
                
                if (!aiCategory) {
                    console.warn(`No AI evaluation found for category: ${category.name}`);
                    return;
                }
                
                // Build grade array for this category
                const grades = category.subcategories.map((subName) => {
                    const aiSub = aiCategory.subcategories.find(s => s.name === subName);
                    return aiSub ? aiSub.grade : 'C'; // Default to C if missing
                });
                
                // Calculate category score
                const categoryScore = calculateCategoryScore(rubric, categoryIndex, grades);
                const pointsPerSub = metrics.pointsPerSubcategory;
                
                // Build subcategory details
                const subcategoryDetails = category.subcategories.map((subName, subIndex) => {
                    const grade = grades[subIndex];
                    const gradePercentage = rubric.gradeScale[grade]?.percentage || 0.8;
                    const points = pointsPerSub * gradePercentage;
                    
                    return {
                        name: subName,
                        grade: grade,
                        gradeLabel: rubric.gradeScale[grade]?.label || 'Developing',
                        points: parseFloat(points.toFixed(2)),
                        maxPoints: parseFloat(pointsPerSub.toFixed(2))
                    };
                });
                
                sections[category.name] = {
                    score: categoryScore.score,
                    maxScore: categoryScore.maxScore,
                    feedback: aiCategory.feedback || 'No feedback provided.',
                    subcategories: subcategoryDetails
                };
                
                totalScore += categoryScore.score;
            });
            
            const percentage = ((totalScore / rubric.totalPoints) * 100).toFixed(1);
            const letterGrade = getLetterGrade(percentage, rubric.gradeScale);
            
            return {
                studentName: 'Student',
                speechDate: document.getElementById('speechDate').value,
                assignmentType: rubric.speechType || 'General Speech',
                speechTime: duration || '0:00',
                sections: sections,
                totalScore: parseFloat(totalScore.toFixed(2)),
                maxScore: rubric.totalPoints,
                percentage: percentage,
                letterGrade: letterGrade,
                gradeScale: rubric.gradeScale,
                rubricUsed: rubric.name,
                overallComments: aiEvaluation.overallComments,
                transcript: transcript // Store transcript for reference
            };
        }

        // Generate feedback based on category and grades
        function generateCategoryFeedback(categoryName, grades) {
            const avgGrade = calculateAverageGrade(grades);
            
            const feedbackMap = {
                'Content - Introduction': {
                    'A': 'Excellent opening with clear attention getter. Introduction effectively established topic relevance and purpose.',
                    'B': 'Strong opening with clear attention getter. Introduction effectively established topic relevance. Good connection to audience.',
                    'C': 'Adequate introduction present. Could improve attention-getting technique and clearer statement of purpose.',
                    'D': 'Introduction present but lacks clear attention getter or purpose statement.',
                    'F': 'Introduction needs significant improvement in capturing attention and establishing purpose.'
                },
                'Content - Organization': {
                    'A': 'Excellent organizational structure with clear pattern. Smooth transitions and perfect time management.',
                    'B': 'Clear organizational pattern evident. Transitions could be smoother. Excellent time management.',
                    'C': 'Basic organizational structure present. Transitions need improvement. Time management adequate.',
                    'D': 'Organization unclear. Transitions weak. Time management needs attention.',
                    'F': 'Lacks clear organizational pattern. Poor transitions and time management.'
                },
                'Content - Conclusion': {
                    'A': 'Excellent conclusion with memorable final thought and effective summary of main points.',
                    'B': 'Strong conclusion with good summary. Final thought could be more memorable.',
                    'C': 'Adequate conclusion present. Could strengthen summary and final thought.',
                    'D': 'Weak conclusion. Lacks clear summary or memorable ending.',
                    'F': 'No clear conclusion or summary provided.'
                },
                'Content - Assignment': {
                    'A': 'Outstanding content that fully addresses all assignment requirements. Personal stories highly engaging and philosophy exceptionally well-articulated.',
                    'B': 'Content clearly addressed assignment requirements. Personal stories were engaging and philosophy was well-articulated.',
                    'C': 'Content addresses most assignment requirements. Could develop ideas more fully.',
                    'D': 'Content partially addresses assignment. Ideas need more development.',
                    'F': 'Content does not adequately address assignment requirements.'
                },
                'Delivery - Nonverbal': {
                    'A': 'Excellent eye contact, natural gestures, and enthusiastic delivery. Highly professional appearance.',
                    'B': 'Good eye contact and gestures. Enthusiastic delivery. Some improvement needed in reducing nervous movements. Professional appearance.',
                    'C': 'Adequate eye contact and gestures. Could improve enthusiasm and reduce distracting movements.',
                    'D': 'Limited eye contact. Gestures need improvement. Lacks enthusiasm.',
                    'F': 'Poor eye contact and minimal effective gestures. Unprofessional delivery.'
                },
                'Delivery - Verbal': {
                    'A': 'Excellent vocal variety, volume, and speaking rate. Perfect use of pauses. Fully extemporaneous with no filler words.',
                    'B': 'Excellent vocal variety and appropriate volume. Good speaking rate. Mostly extemporaneous style with minimal notes. Some filler words present.',
                    'C': 'Adequate vocal delivery. Could improve variety and reduce dependence on notes. Noticeable filler words.',
                    'D': 'Limited vocal variety. Over-reliant on notes. Excessive filler words.',
                    'F': 'Poor vocal delivery. Reading from notes. Excessive filler words interfere with message.'
                }
            };
            
            return feedbackMap[categoryName]?.[avgGrade] || 'Feedback not available.';
        }

        // Calculate average grade from an array of grades
        function calculateAverageGrade(grades) {
            const gradeValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'F': 1 };
            const sum = grades.reduce((total, grade) => total + gradeValues[grade], 0);
            const avg = sum / grades.length;
            
            if (avg >= 4.5) return 'A';
            if (avg >= 3.5) return 'B';
            if (avg >= 2.5) return 'C';
            if (avg >= 1.5) return 'D';
            return 'F';
        }

        // ===== RUBRIC STORAGE & MANAGEMENT =====
        
        // Create a default "General Speech Evaluation" rubric
        const DEFAULT_RUBRIC = {
            id: 'default',
            name: "General Speech Evaluation",
            description: "Simplified evaluation for verbal and nonverbal communication",
            totalPoints: 50,
            courseId: null,
            speechType: "General",
            createdDate: new Date().toISOString(),
            gradeScale: {
                A: { label: "Professional", percentage: 1.00, range: "100-91" },
                B: { label: "Proficient", percentage: 0.90, range: "90-89" },
                C: { label: "Developing", percentage: 0.80, range: "80-71" },
                D: { label: "Unprofessional", percentage: 0.70, range: "70-61" },
                F: { label: "Unacceptable", percentage: 0.60, range: "60-0" }
            },
            categories: [
                {
                    name: "Verbal Delivery",
                    subcategories: [
                        "Vocal Volume and Clarity",
                        "Speaking Rate and Pacing",
                        "Vocal Variety and Expression",
                        "Minimal Filler Words"
                    ]
                },
                {
                    name: "Nonverbal Delivery",
                    subcategories: [
                        "Eye Contact",
                        "Gestures and Body Language",
                        "Confidence and Enthusiasm",
                        "Professional Appearance"
                    ]
                }
            ]
        };

        // Initialize rubrics in localStorage if not exists
        function initializeRubrics() {
            const existingRubrics = localStorage.getItem('speech_rubrics');
            if (!existingRubrics) {
                // Create initial rubrics array with default and self-intro
                const initialRubrics = [
                    DEFAULT_RUBRIC,
                    {
                        id: 'self-intro-1',
                        name: "Self Introduction Speech",
                        description: "Comprehensive rubric for self-introduction speeches",
                        totalPoints: 50,
                        courseId: null,
                        speechType: "Self-Introduction",
                        createdDate: new Date().toISOString(),
                        gradeScale: SELF_INTRO_RUBRIC.gradeScale,
                        categories: SELF_INTRO_RUBRIC.categories
                    }
                ];
                localStorage.setItem('speech_rubrics', JSON.stringify(initialRubrics));
            }
        }

        // Get all rubrics
        // ===== SUPABASE COURSE FUNCTIONS =====
        
        // Save course to Supabase
        async function saveCourseToSupabase(course) {
            if (!supabaseClient) {
                console.log('Supabase not available, using localStorage only');
                return null;
            }
            
            try {
                // Use current authenticated user ID
                let creatorId = currentUser?.id;
                
                if (!creatorId) {
                    console.error('No authenticated user');
                    return null;
                }
                
                const courseData = {
                    instructor_id: creatorId,
                    name: course.name,
                    code: course.section || null,
                    semester: course.semester || null,
                    year: parseInt(course.year) || null
                };
                
                // If course has Supabase ID, update it
                if (course.supabaseId) {
                    const { data, error } = await supabaseClient
                        .from('courses')
                        .update(courseData)
                        .eq('id', course.supabaseId)
                        .select();
                    
                    if (error) {
                        console.error('Failed to update course:', error);
                        return null;
                    }
                    console.log('‚úì Course updated in Supabase');
                    return data[0];
                } else {
                    const { data, error } = await supabaseClient
                        .from('courses')
                        .insert([courseData])
                        .select();
                    
                    if (error) {
                        console.error('Failed to save course:', error);
                        return null;
                    }
                    console.log('‚úì Course saved to Supabase');
                    
                    // Save students if they exist
                    if (course.roster && course.roster.length > 0) {
                        await saveStudentsToSupabase(data[0].id, course.roster);
                    }
                    
                    return data[0];
                }
            } catch (error) {
                console.error('Supabase error saving course:', error);
                return null;
            }
        }
        
        // Save students to Supabase
        async function saveStudentsToSupabase(courseId, students) {
            if (!supabaseClient || !students || students.length === 0) {
                return null;
            }
            
            try {
                const studentsData = students.map(student => ({
                    course_id: courseId,
                    student_user_id: null,
                    first_name: student.firstName || student.name?.split(' ')[0] || '',
                    last_name: student.lastName || student.name?.split(' ').slice(1).join(' ') || '',
                    email: student.email || null,
                    student_id: student.studentId || null
                }));
                
                const { data, error } = await supabaseClient
                    .from('course_students')
                    .insert(studentsData)
                    .select();
                
                if (error) {
                    console.error('Failed to save students:', error);
                    return null;
                }
                
                console.log(`‚úì ${data.length} students saved to Supabase`);
                return data;
            } catch (error) {
                console.error('Supabase error saving students:', error);
                return null;
            }
        }
        
        // Load courses from Supabase
        async function loadCoursesFromSupabase() {
            if (!supabaseClient || !currentUser) {
                console.log('Cannot load courses: No Supabase client or user');
                return null;
            }
            
            console.log('=== LOADING COURSES FROM SUPABASE ===');
            console.log('View mode:', currentViewMode);
            console.log('User tier:', userTier);
            console.log('User ID:', currentUser.id);
            console.log('Institution:', currentUser.institution_id);
            
            try {
                let query = supabaseClient
                    .from('courses')
                    .select(`
                        *,
                        course_students (
                            id,
                            first_name,
                            last_name,
                            email,
                            student_id
                        )
                    `);
                
                // Filter based on view mode
                if (currentViewMode === 'own' || userTier === 'instructor') {
                    // Instructor view: Only their own courses
                    console.log('Filtering: Own courses only (instructor_id =', currentUser.id, ')');
                    query = query.eq('instructor_id', currentUser.id);
                } else if (currentViewMode === 'institution' && isAdmin()) {
                    // Admin institution view: All courses in their institution
                    console.log('Filtering: Institution view - loading all instructors in institution');
                    
                    // Get all instructor IDs in the same institution
                    const { data: institutionInstructors, error: instError } = await supabaseClient
                        .from('user_profiles')
                        .select('id')
                        .eq('institution_id', currentUser.institution_id);
                    
                    if (instError) {
                        console.error('Error loading institution instructors:', instError);
                    } else {
                        console.log('Found', institutionInstructors?.length || 0, 'users in institution');
                    }
                    
                    if (institutionInstructors && institutionInstructors.length > 0) {
                        const instructorIds = institutionInstructors.map(i => i.id);
                        console.log('Filtering courses for instructor IDs:', instructorIds);
                        query = query.in('instructor_id', instructorIds);
                    } else {
                        console.warn('No instructors found in institution - will return 0 courses');
                    }
                } else if (currentViewMode === 'all' && isSuperAdmin()) {
                    // Super admin all view: All courses (no filter)
                    console.log('Filtering: ALL institutions (no filter - super admin)');
                } else if (currentViewMode === 'demo') {
                    // Demo mode: Don't load from Supabase
                    console.log('Demo mode: Skipping Supabase load');
                    return null;
                } else {
                    console.warn('Unknown view mode or insufficient permissions:', currentViewMode);
                }
                
                const { data: courses, error } = await query.order('created_at', { ascending: false });
                
                if (error) {
                    console.error('‚ùå Failed to load courses:', error);
                    return null;
                }
                
                console.log(`‚úÖ Loaded ${courses.length} courses from Supabase (${currentViewMode} view)`);
                
                // Log course details for debugging
                if (courses.length > 0) {
                    console.log('First course:', {
                        name: courses[0].name,
                        instructor_id: courses[0].instructor_id,
                        created_at: courses[0].created_at
                    });
                }
                
                console.log('=== COURSE LOAD COMPLETE ===');
                return courses;
            } catch (error) {
                console.error('‚ùå Supabase error loading courses:', error);
                return null;
            }
        }
        
        // ===== SUPABASE EVALUATION FUNCTIONS =====
        
        // Save evaluation to Supabase
        async function saveEvaluationToSupabase(evaluation, courseId, studentId, rubricId) {
            if (!supabaseClient || !currentUser) {
                console.log('Cannot save evaluation: no Supabase or user');
                return null;
            }
            
            try {
                const evaluationData = {
                    instructor_id: currentUser.id,
                    student_id: studentId, // course_students table ID
                    course_id: courseId,
                    rubric_id: rubricId,
                    video_url: null, // Will be added in Phase B6
                    audio_url: null,
                    transcript: evaluation.transcript || null,
                    ai_provider: evaluation.aiProvider || 'unknown',
                    evaluation_data: {
                        sections: evaluation.sections,
                        studentName: evaluation.studentName,
                        speechDate: evaluation.speechDate,
                        assignmentType: evaluation.assignmentType,
                        speechTime: evaluation.speechTime,
                        rubricUsed: evaluation.rubricUsed,
                        totalScore: evaluation.totalScore,
                        maxScore: evaluation.maxScore,
                        percentage: evaluation.percentage,
                        letterGrade: evaluation.letterGrade,
                        overallComments: evaluation.overallComments,
                        timeline_markers: evaluation.timeline_markers || [],
                        corrections: correctionLog || [],  // Include correction log
                        edited: correctionLog && correctionLog.length > 0
                    },
                    total_score: evaluation.totalScore || 0,
                    letter_grade: evaluation.letterGrade || 'N/A',
                    status: 'completed'
                };
                
                const { data, error } = await supabaseClient
                    .from('evaluations')
                    .insert([evaluationData])
                    .select();
                
                if (error) {
                    console.error('Failed to save evaluation to Supabase:', error);
                    return null;
                }
                
                console.log('‚úì Evaluation saved to Supabase');
                return data[0];
            } catch (error) {
                console.error('Supabase error saving evaluation:', error);
                return null;
            }
        }
        
        // Load evaluations from Supabase
        async function loadEvaluationsFromSupabase(courseId = null, studentId = null) {
            if (!supabaseClient || !currentUser) {
                return null;
            }
            
            try {
                let query = supabaseClient
                    .from('evaluations')
                    .select(`
                        *,
                        course:courses(id, name, code, semester, year),
                        student:course_students(id, first_name, last_name, email),
                        rubric:rubrics(id, name)
                    `)
                    .eq('instructor_id', currentUser.id)
                    .order('created_at', { ascending: false });
                
                if (courseId) {
                    query = query.eq('course_id', courseId);
                }
                
                if (studentId) {
                    query = query.eq('student_id', studentId);
                }
                
                const { data, error } = await query;
                
                if (error) {
                    console.error('Failed to load evaluations from Supabase:', error);
                    return null;
                }
                
                console.log(`‚úì Loaded ${data.length} evaluations from Supabase`);
                return data;
            } catch (error) {
                console.error('Supabase error loading evaluations:', error);
                return null;
            }
        }
        
        // ===== SUPABASE RUBRIC FUNCTIONS =====
        
        // Save rubric to Supabase
        async function saveRubricToSupabase(rubric) {
            if (!supabaseClient) {
                console.log('Supabase not available, using localStorage only');
                return null;
            }
            
            try {
                // Use current authenticated user ID
                let creatorId = currentUser?.id;
                
                if (!creatorId) {
                    console.error('No authenticated user');
                    return null;
                }
                
                // Validate UUID format
                const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
                if (!uuidRegex.test(creatorId)) {
                    console.error('Invalid UUID format for creator_id:', creatorId);
                    return null;
                }
                
                const rubricData = {
                    creator_id: creatorId, // Using authenticated user
                    name: rubric.name,
                    speech_type: rubric.speechType || null,
                    total_points: rubric.totalPoints || 0,
                    grade_scale: rubric.gradeScale,
                    categories: rubric.categories,
                    is_template: rubric.isTemplate || false
                };
                
                // If rubric has a Supabase ID, update it
                if (rubric.supabaseId) {
                    const { data, error } = await supabaseClient
                        .from('rubrics')
                        .update(rubricData)
                        .eq('id', rubric.supabaseId)
                        .select();
                    
                    if (error) {
                        console.error('Failed to update rubric in Supabase:', error);
                        return null;
                    }
                    console.log('‚úì Rubric updated in Supabase');
                    return data[0];
                } else {
                    // Insert new rubric
                    const { data, error } = await supabaseClient
                        .from('rubrics')
                        .insert([rubricData])
                        .select();
                    
                    if (error) {
                        console.error('Failed to save rubric to Supabase:', error);
                        return null;
                    }
                    console.log('‚úì Rubric saved to Supabase');
                    return data[0];
                }
            } catch (error) {
                console.error('Supabase error saving rubric:', error);
                return null;
            }
        }
        
        // Load rubrics from Supabase
        async function loadRubricsFromSupabase() {
            if (!supabaseClient) {
                return null;
            }
            
            try {
                const { data, error } = await supabaseClient
                    .from('rubrics')
                    .select('*')
                    .order('created_at', { ascending: false });
                
                if (error) {
                    console.error('Failed to load rubrics from Supabase:', error);
                    return null;
                }
                
                console.log(`‚úì Loaded ${data.length} rubrics from Supabase`);
                return data;
            } catch (error) {
                console.error('Supabase error loading rubrics:', error);
                return null;
            }
        }
        
        // Hybrid function: Get all rubrics (Supabase + localStorage)
        async function getAllRubrics() {
            // Try Supabase first
            const supabaseRubrics = await loadRubricsFromSupabase();
            
            if (supabaseRubrics && supabaseRubrics.length > 0) {
                // Convert Supabase format to app format
                return supabaseRubrics.map(sr => ({
                    id: sr.id,
                    supabaseId: sr.id,
                    name: sr.name,
                    speechType: sr.speech_type,
                    totalPoints: sr.total_points,
                    gradeScale: sr.grade_scale,
                    categories: sr.categories,
                    isTemplate: sr.is_template,
                    createdDate: sr.created_at,
                    modifiedDate: sr.updated_at
                }));
            }
            
            // Fallback to localStorage
            const rubrics = localStorage.getItem('speech_rubrics');
            return rubrics ? JSON.parse(rubrics) : [];
        }

        // Get rubrics by course
        async function getRubricsByCourse(courseId) {
            const rubrics = await getAllRubrics();
            return rubrics.filter(r => r.courseId === courseId);
        }

        // Get rubric by ID
        async function getRubricById(rubricId) {
            const rubrics = await getAllRubrics();
            return rubrics.find(r => r.id === rubricId);
        }

        // Save/update rubric (hybrid: Supabase + localStorage)
        async function saveRubric(rubric) {
            // Save to localStorage first (immediate, synchronous)
            const rubrics = localStorage.getItem('speech_rubrics');
            const localRubrics = rubrics ? JSON.parse(rubrics) : [];
            const existingIndex = localRubrics.findIndex(r => r.id === rubric.id);
            
            if (existingIndex >= 0) {
                // Update existing
                rubric.modifiedDate = new Date().toISOString();
                localRubrics[existingIndex] = rubric;
            } else {
                // Add new
                if (!rubric.id) {
                    rubric.id = 'rubric-' + Date.now();
                }
                rubric.createdDate = new Date().toISOString();
                localRubrics.push(rubric);
            }
            
            localStorage.setItem('speech_rubrics', JSON.stringify(localRubrics));
            console.log('‚úì Rubric saved to localStorage');
            
            // Also save to Supabase (async, non-blocking)
            if (supabaseClient) {
                saveRubricToSupabase(rubric).then(supabaseRubric => {
                    if (supabaseRubric) {
                        // Update the rubric with Supabase ID
                        rubric.supabaseId = supabaseRubric.id;
                        const updated = localRubrics.find(r => r.id === rubric.id);
                        if (updated) {
                            updated.supabaseId = supabaseRubric.id;
                            localStorage.setItem('speech_rubrics', JSON.stringify(localRubrics));
                        }
                    }
                }).catch(err => {
                    console.log('Supabase save failed, but localStorage succeeded');
                });
            }
            
            return rubric;
        }

        // Duplicate rubric
        async function duplicateRubric(rubricId) {
            const original = await getRubricById(rubricId);
            if (!original) return null;
            
            const duplicate = {
                ...JSON.parse(JSON.stringify(original)), // Deep copy
                id: 'rubric-' + Date.now(),
                supabaseId: undefined, // Remove supabaseId so it creates new in database
                name: original.name + " (Copy)",
                createdDate: new Date().toISOString(),
                modifiedDate: null
            };
            
            return await saveRubric(duplicate);
        }

        // Delete rubric
        async function deleteRubric(rubricId) {
            // Don't allow deleting the default rubric
            if (rubricId === 'default') {
                alert('Cannot delete the default rubric.');
                return false;
            }
            
            const rubrics = await getAllRubrics();
            const filtered = rubrics.filter(r => r.id !== rubricId);
            localStorage.setItem('speech_rubrics', JSON.stringify(filtered));
            
            // Also delete from Supabase if it has a supabase ID
            if (supabaseClient) {
                const rubricToDelete = rubrics.find(r => r.id === rubricId);
                if (rubricToDelete && rubricToDelete.supabaseId) {
                    await supabaseClient
                        .from('rubrics')
                        .delete()
                        .eq('id', rubricToDelete.supabaseId);
                }
            }
            
            return true;
        }

        // Get rubrics grouped by course
        function getRubricsGroupedByCourse() {
            const rubrics = getAllRubrics();
            const grouped = {
                'unassigned': []
            };
            
            rubrics.forEach(rubric => {
                if (!rubric.courseId) {
                    grouped['unassigned'].push(rubric);
                } else {
                    if (!grouped[rubric.courseId]) {
                        grouped[rubric.courseId] = [];
                    }
                    grouped[rubric.courseId].push(rubric);
                }
            });
            
            return grouped;
        }

        // Populate course selector in rubric form with checkboxes
        function populateCourseSelector(selectedCourseIds = []) {
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const container = document.getElementById('rubricCoursesContainer');
            
            if (!container) return;
            
            // Clear container
            container.innerHTML = '';
            
            if (classes.length === 0) {
                container.innerHTML = '<p style="color: var(--text-light); text-align: center;">No courses available. Create courses in "My Classes" first.</p>';
                return;
            }
            
            // Group courses by course name for better organization
            const courseGroups = {};
            classes.forEach(cls => {
                if (!courseGroups[cls.name]) {
                    courseGroups[cls.name] = [];
                }
                courseGroups[cls.name].push(cls);
            });
            
            // Create checkboxes grouped by course name
            Object.keys(courseGroups).sort().forEach(courseName => {
                const sections = courseGroups[courseName];
                
                // Add course name header if multiple sections exist
                if (sections.length > 1) {
                    const header = document.createElement('div');
                    header.style.cssText = 'font-weight: 600; color: var(--primary); margin-top: 0.5rem; margin-bottom: 0.25rem; font-size: 0.9rem;';
                    header.textContent = courseName;
                    container.appendChild(header);
                }
                
                // Add checkbox for each section
                sections.forEach(cls => {
                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.style.cssText = 'padding: 0.4rem; display: flex; align-items: center;';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `course_${cls.id}`;
                    checkbox.value = cls.id;
                    checkbox.className = 'course-checkbox';
                    checkbox.style.cssText = 'margin-right: 0.5rem; cursor: pointer;';
                    
                    // Check if this course is in the selected list
                    if (selectedCourseIds.includes(cls.id)) {
                        checkbox.checked = true;
                    }
                    
                    const label = document.createElement('label');
                    label.htmlFor = `course_${cls.id}`;
                    label.style.cssText = 'cursor: pointer; user-select: none;';
                    label.textContent = `${cls.name} - ${cls.semester} ${cls.year} (Section ${cls.section})`;
                    
                    checkboxDiv.appendChild(checkbox);
                    checkboxDiv.appendChild(label);
                    container.appendChild(checkboxDiv);
                });
            });
        }

        // Populate course filter dropdown in My Rubrics section
        function populateCourseFilter() {
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const filter = document.getElementById('courseFilter');
            
            if (!filter) return;
            
            // Clear existing options except "All Courses"
            filter.innerHTML = '<option value="">All Courses</option>';
            
            // Add "Unassigned" option
            filter.innerHTML += '<option value="unassigned">Unassigned (No Course)</option>';
            
            // Group classes by course name + semester + year
            const courseGroups = {};
            classes.forEach(cls => {
                const courseKey = `${cls.name}|${cls.semester}|${cls.year}`;
                if (!courseGroups[courseKey]) {
                    courseGroups[courseKey] = {
                        name: cls.name,
                        semester: cls.semester,
                        year: cls.year,
                        ids: []
                    };
                }
                courseGroups[courseKey].ids.push(cls.id);
            });
            
            // Add grouped courses to filter
            Object.keys(courseGroups).sort().forEach(courseKey => {
                const group = courseGroups[courseKey];
                const option = document.createElement('option');
                option.value = group.ids.join(','); // Store all section IDs as comma-separated
                option.textContent = `${group.name} - ${group.semester} ${group.year}`;
                filter.appendChild(option);
            });
        }

        // Filter rubrics display based on selected course
        function filterRubricsByCourse() {
            const filterValue = document.getElementById('courseFilter').value;
            
            // Initialize rubrics storage if needed
            initializeRubrics();
            
            // Get all rubrics and classes
            const allRubrics = getAllRubrics();
            const classes = JSON.parse(getUserItem('classes') || '[]');
            
            // Filter rubrics based on selection
            let filteredRubrics = allRubrics;
            
            if (filterValue === 'unassigned') {
                // Show only rubrics with no courses assigned
                filteredRubrics = allRubrics.filter(r => {
                    const hasOldCourseId = r.courseId && r.courseId !== '';
                    const hasNewCourseIds = r.courseIds && Array.isArray(r.courseIds) && r.courseIds.length > 0;
                    return !hasOldCourseId && !hasNewCourseIds;
                });
            } else if (filterValue !== '') {
                // Filter by course - filterValue contains comma-separated IDs for all sections of a course
                const courseIdsToMatch = filterValue.split(',');
                
                filteredRubrics = allRubrics.filter(rubric => {
                    // Get rubric's course IDs (handle both old and new format)
                    let rubricCourseIds = [];
                    if (rubric.courseIds && Array.isArray(rubric.courseIds)) {
                        rubricCourseIds = rubric.courseIds;
                    } else if (rubric.courseId) {
                        rubricCourseIds = [rubric.courseId];
                    }
                    
                    // Check if rubric is assigned to any of the course sections
                    return rubricCourseIds.some(id => courseIdsToMatch.includes(id));
                });
            }
            
            // Display filtered rubrics
            const list = document.getElementById('rubricsList');
            if (!list) return;
            
            if (filteredRubrics.length === 0) {
                list.innerHTML = '<p style="color: var(--text-light); text-align: center; padding: 2rem;">No rubrics found for this filter.</p>';
                return;
            }
            
            list.innerHTML = filteredRubrics.map(rubric => {
                // Get course info - handle both courseIds array and old courseId
                let courseInfo = '';
                let courseIdsToDisplay = [];
                
                if (rubric.courseIds && Array.isArray(rubric.courseIds) && rubric.courseIds.length > 0) {
                    courseIdsToDisplay = rubric.courseIds;
                } else if (rubric.courseId) {
                    courseIdsToDisplay = [rubric.courseId];
                }
                
                if (courseIdsToDisplay.length > 0) {
                    const courses = courseIdsToDisplay
                        .map(id => classes.find(c => c.id === id))
                        .filter(c => c);
                    
                    if (courses.length > 0) {
                        // Group by course name
                        const courseGroups = {};
                        courses.forEach(course => {
                            if (!courseGroups[course.name]) {
                                courseGroups[course.name] = [];
                            }
                            courseGroups[course.name].push(course);
                        });
                        
                        // Format display
                        const courseDisplays = Object.keys(courseGroups).map(courseName => {
                            const sections = courseGroups[courseName];
                            const firstCourse = sections[0];
                            const sectionNums = sections.map(s => s.section).join(', ');
                            const sectionText = sections.length > 1 ? `Sections ${sectionNums}` : `Section ${sectionNums}`;
                            return `${courseName} (${firstCourse.semester} ${firstCourse.year}) - ${sectionText}`;
                        });
                        
                        courseInfo = ` ‚Ä¢ <span style="color: var(--primary); font-weight: 500;">${courseDisplays.join(' ‚Ä¢ ')}</span>`;
                    } else if (courseIdsToDisplay.length > 0) {
                        courseInfo = ' ‚Ä¢ <span style="color: #999;">Course(s) not found</span>';
                    }
                }
                
                return `
                <div class="rubric-item">
                    <div class="rubric-info">
                        <h4>${rubric.name}</h4>
                        <p>${rubric.description || 'No description'} ‚Ä¢ ${rubric.totalPoints} points${rubric.speechType ? ' ‚Ä¢ ' + rubric.speechType : ''}${courseInfo}</p>
                    </div>
                    <div class="rubric-actions">
                        <button class="btn-small btn-view" data-rubric-id="${rubric.id}">View</button>
                        <button class="btn-small btn-edit" data-rubric-id="${rubric.id}">Edit</button>
                        <button class="btn-small btn-duplicate" data-rubric-id="${rubric.id}">Duplicate</button>
                        ${rubric.id !== 'default' ? `
                            <button class="btn-small btn-danger btn-delete" data-rubric-id="${rubric.id}">Delete</button>
                        ` : ''}
                    </div>
                </div>
            `;
            }).join('');
            
            // Re-attach event listeners to all buttons
            document.querySelectorAll('.btn-view').forEach(btn => {
                btn.addEventListener('click', () => viewRubric(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-edit').forEach(btn => {
                btn.addEventListener('click', () => editRubric(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-duplicate').forEach(btn => {
                btn.addEventListener('click', () => duplicateRubricUI(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-delete').forEach(btn => {
                btn.addEventListener('click', () => deleteRubricUI(btn.dataset.rubricId));
            });
        }


        function displayResults(results) {
            let html = '';
            
            // Show editing mode banner if editing
            if (editingEvaluationId) {
                html += `
                    <div style="background: #0066cc; color: white; padding: 1rem 1.5rem; border-radius: 0.5rem; margin-bottom: 2rem; display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong style="font-size: 1.1rem;">üìù Editing Mode</strong>
                            <p style="margin: 0.5rem 0 0 0; opacity: 0.9;">Make your changes below, then click "Save Evaluation" to update.</p>
                        </div>
                        <button onclick="cancelEdit()" style="background: white; color: #0066cc; border: none; padding: 0.5rem 1rem; border-radius: 0.25rem; cursor: pointer; font-weight: 600;">Cancel Edit</button>
                    </div>
                `;
            }
            
            html += `
                <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 2rem;">
                    <strong>Student:</strong> ${results.studentName}<br>
                    <strong>Date:</strong> ${results.speechDate}<br>
                    <strong>Assignment:</strong> ${results.assignmentType}<br>
                    <strong>Speech Time:</strong> ${results.speechTime}
                </div>
                
                <div class="score-banner">
                    <h2 style="color: white;">Final Score</h2>
                    <div class="score-value">${results.totalScore} / ${results.maxScore}</div>
                    <div class="score-percentage">${((results.totalScore / results.maxScore) * 100).toFixed(1)}%</div>
                </div>
                
                <h3 style="margin-bottom: 1rem;">Detailed Scores by Category</h3>
                <div style="display: grid; gap: 1rem; margin-bottom: 2rem;">
            `;
            
            for (const [section, data] of Object.entries(results.sections)) {
                const sectionId = section.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                html += `
                    <div style="background: var(--bg-alt); padding: 1rem; border-radius: 0.5rem; border-left: 4px solid var(--primary);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                            <strong style="text-transform: capitalize;">${section}</strong>
                            <div style="display: flex; align-items: center; gap: 0.75rem;">
                                <strong style="color: var(--primary);">${data.score} / ${data.maxScore}</strong>
                                <button onclick="editSection(\`${section.replace(/`/g, '\\`')}\`)" style="background: var(--primary); color: white; border: none; padding: 0.25rem 0.75rem; border-radius: 0.25rem; cursor: pointer; font-size: 0.85rem;">‚úèÔ∏è Edit</button>
                            </div>
                        </div>
                        <p style="color: var(--text-light); font-size: 0.9rem; margin-bottom: 0.75rem;" id="feedback-${sectionId}">${data.feedback}</p>
                `;
                
                // Show subcategory breakdown if available
                if (data.subcategories && data.subcategories.length > 0) {
                    html += `<div style="background: white; padding: 0.75rem; border-radius: 0.25rem; margin-top: 0.75rem;">
                        <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text);">Subcategory Breakdown:</div>
                    `;
                    
                    data.subcategories.forEach(sub => {
                        const gradeColor = sub.grade === 'A' ? '#28a745' : 
                                          sub.grade === 'B' ? '#5cb85c' :
                                          sub.grade === 'C' ? '#f0ad4e' :
                                          sub.grade === 'D' ? '#d9534f' : '#c9302c';
                        
                        html += `
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.4rem 0; border-bottom: 1px solid var(--border);">
                                <span style="font-size: 0.85rem; color: var(--text);">${sub.name}</span>
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <span style="background: ${gradeColor}; color: white; padding: 0.15rem 0.4rem; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600;">${sub.grade}</span>
                                    <span style="font-size: 0.85rem; color: var(--text-light);">${sub.points} / ${sub.maxPoints} pts</span>
                                </div>
                            </div>
                        `;
                    });
                    
                    html += `</div>`;
                }
                
                html += `</div>`;
            }
            
            html += `
                </div>
                
                <div style="background: #fffef7; border: 2px solid var(--accent); padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 1rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                        <h3 style="color: var(--primary); margin: 0;">Overall Comments</h3>
                        <button onclick="editOverallComments()" style="background: var(--primary); color: white; border: none; padding: 0.25rem 0.75rem; border-radius: 0.25rem; cursor: pointer; font-size: 0.85rem;">‚úèÔ∏è Edit</button>
                    </div>
                    <p id="overall-comments-text">${results.overallComments}</p>
                </div>
            `;
            
            // Add transcript section if available
            if (results.transcript && results.transcript.trim().length > 0) {
                html += `
                    <details style="background: var(--bg-alt); padding: 1rem; border-radius: 0.5rem; margin-top: 1rem;">
                        <summary style="cursor: pointer; font-weight: 600; color: var(--primary); padding: 0.5rem;">
                            üìù View Speech Transcript
                        </summary>
                        <div style="margin-top: 1rem; padding: 1rem; background: white; border-radius: 0.25rem; max-height: 300px; overflow-y: auto; font-family: monospace; font-size: 0.9rem; line-height: 1.6;">
                            ${results.transcript.replace(/\n/g, '<br>')}
                        </div>
                    </details>
                `;
            }
            
            // Add timeline markers section if available
            if (results.timeline_markers && results.timeline_markers.length > 0) {
                html += `
                    <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; margin-top: 2rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                            <h3 style="margin: 0; color: var(--primary);">‚è±Ô∏è Timeline Markers</h3>
                            <button onclick="editTimelineMarkers()" style="background: var(--primary); color: white; border: none; padding: 0.25rem 0.75rem; border-radius: 0.25rem; cursor: pointer; font-size: 0.85rem;">‚úèÔ∏è Edit Markers</button>
                        </div>
                        <p style="color: var(--text-light); margin-bottom: 1.5rem; font-size: 0.95rem;">
                            Review specific moments in your video using these timestamps. 
                            Open your video file on your device and seek to the times listed below to see exactly what was observed.
                        </p>
                        <div id="timeline-markers-content">
                `;
                
                // Group markers by category
                const markersByCategory = {};
                results.timeline_markers.forEach(marker => {
                    if (!markersByCategory[marker.category]) {
                        markersByCategory[marker.category] = [];
                    }
                    markersByCategory[marker.category].push(marker);
                });
                
                // Display each category
                Object.keys(markersByCategory).forEach(category => {
                    const markers = markersByCategory[category];
                    
                    html += `
                        <div style="margin-bottom: 1.5rem;">
                            <h4 style="margin: 0 0 0.75rem 0; color: var(--text-dark); font-size: 1.1rem; font-family: var(--body-font);">${category}</h4>
                            <div style="display: grid; gap: 0.75rem;">
                    `;
                    
                    markers.forEach(marker => {
                        // Color coding based on severity
                        const severityColors = {
                            'positive': '#10b981',   // green
                            'minor': '#f59e0b',      // orange
                            'moderate': '#f59e0b',   // orange
                            'major': '#ef4444'       // red
                        };
                        
                        const severityIcons = {
                            'positive': '‚úì',
                            'minor': '‚ö†',
                            'moderate': '‚ö†',
                            'major': '‚úï'
                        };
                        
                        const color = severityColors[marker.severity] || '#f59e0b';
                        const icon = severityIcons[marker.severity] || '‚ö†';
                        
                        html += `
                            <div style="background: white; padding: 0.75rem; border-radius: 0.25rem; border-left: 4px solid ${color}; display: flex; gap: 1rem; align-items: start;">
                                <div style="background: ${color}; color: white; min-width: 60px; height: 60px; border-radius: 0.25rem; display: flex; align-items: center; justify-content: center; flex-shrink: 0; font-size: 0.95rem; font-weight: bold; text-align: center; padding: 0.25rem;">
                                    ${marker.timestamp}
                                </div>
                                <div style="flex: 1;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.25rem;">
                                        <span style="font-size: 1.2rem;">${icon}</span>
                                        <strong style="color: var(--text-dark); font-size: 1rem;">${marker.issue}</strong>
                                    </div>
                                    <p style="margin: 0; color: var(--text-light); font-size: 0.9rem; line-height: 1.5;">
                                        ${marker.note}
                                    </p>
                                </div>
                            </div>
                        `;
                    });
                    
                    html += `
                            </div>
                        </div>
                    `;
                });
                
                html += `</div></div></div>`;
            }
            
            document.getElementById('resultsContent').innerHTML = html;
            
            // Update correction count badge if corrections exist
            if (typeof updateCorrectionCount === 'function') {
                updateCorrectionCount();
            }
        }

        // ===== EDIT FUNCTIONALITY =====
        
        let currentEditingSection = null;
        let correctionLog = [];
        
        // Edit Section Score and Feedback
        function editSection(sectionName) {
            console.log('editSection called with:', sectionName);
            if (!evaluationResults) {
                console.error('No evaluationResults available');
                return;
            }
            
            currentEditingSection = sectionName;
            const section = evaluationResults.sections[sectionName];
            
            if (!section) {
                console.error('Section not found:', sectionName);
                console.log('Available sections:', Object.keys(evaluationResults.sections));
                alert('Error: Could not find section "' + sectionName + '"');
                return;
            }
            
            console.log('Editing section:', section);
            
            document.getElementById('editSectionName').textContent = sectionName.charAt(0).toUpperCase() + sectionName.slice(1);
            document.getElementById('editSectionScore').value = section.score;
            document.getElementById('editSectionMaxScore').textContent = section.maxScore;
            document.getElementById('editSectionAIFeedback').textContent = section.feedback;
            document.getElementById('editSectionFeedback').value = section.feedback;
            document.getElementById('editSectionReason').value = '';
            document.getElementById('editSectionReason').placeholder = 'Required: Explain why you\'re making changes (helps improve AI)';
            
            // Populate subcategories if they exist
            const subcategoriesContainer = document.getElementById('editSubcategoriesContainer');
            if (section.subcategories && section.subcategories.length > 0) {
                let subHTML = '<h4 style="margin-bottom:1rem;font-size:1rem;color:var(--text-dark);">Edit Subcategories:</h4>';
                
                section.subcategories.forEach((sub, index) => {
                    const gradeColor = sub.grade === 'A' ? '#28a745' : 
                                      sub.grade === 'B' ? '#5cb85c' :
                                      sub.grade === 'C' ? '#f0ad4e' :
                                      sub.grade === 'D' ? '#d9534f' : '#c9302c';
                    
                    // Create safe IDs
                    const sectionId = sectionName.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                    
                    subHTML += `
                        <div style="background:var(--bg-alt);padding:1rem;border-radius:0.5rem;margin-bottom:1rem;border-left:4px solid ${gradeColor};">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.75rem;">
                                <strong style="font-size:0.95rem;color:var(--text-dark);">${sub.name}</strong>
                                <span style="background:${gradeColor};color:white;padding:0.25rem 0.5rem;border-radius:0.25rem;font-size:0.85rem;font-weight:600;">${sub.grade}</span>
                            </div>
                            <div style="display:flex;gap:1rem;align-items:center;">
                                <div style="flex:1;">
                                    <label style="display:block;font-size:0.85rem;font-weight:600;margin-bottom:0.25rem;">Points:</label>
                                    <div style="display:flex;gap:0.5rem;align-items:center;">
                                        <input type="number" 
                                               id="subcategory-${sectionId}-${index}-points" 
                                               value="${sub.points}" 
                                               min="0" 
                                               max="${sub.maxPoints}"
                                               onchange="updateSubcategoryGrade(\`${sectionName.replace(/`/g, '\\`')}\`, ${index})"
                                               style="width:70px;padding:0.5rem;border:2px solid #ddd;border-radius:0.25rem;font-size:0.9rem;">
                                        <span style="font-size:0.9rem;color:var(--text-light);">/ ${sub.maxPoints}</span>
                                    </div>
                                </div>
                                <div style="flex:2;">
                                    <label style="display:block;font-size:0.85rem;font-weight:600;margin-bottom:0.25rem;">Feedback (optional):</label>
                                    <textarea id="subcategory-${sectionId}-${index}-feedback" 
                                              rows="2" 
                                              style="width:100%;padding:0.5rem;border:2px solid #ddd;border-radius:0.25rem;resize:vertical;font-size:0.85rem;"
                                              placeholder="Optional subcategory feedback...">${sub.feedback || ''}</textarea>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                subcategoriesContainer.innerHTML = subHTML;
                subcategoriesContainer.style.display = 'block';
            } else {
                subcategoriesContainer.style.display = 'none';
            }
            
            document.getElementById('editSectionModal').style.display = 'flex';
            console.log('Edit modal displayed');
        }
        
        // Update subcategory grade when points change
        function updateSubcategoryGrade(sectionName, index) {
            const sectionId = sectionName.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
            const pointsInput = document.getElementById(`subcategory-${sectionId}-${index}-points`);
            const points = parseInt(pointsInput.value) || 0;
            const section = evaluationResults.sections[sectionName];
            const sub = section.subcategories[index];
            const maxPoints = sub.maxPoints;
            
            // Calculate percentage and letter grade
            const percentage = (points / maxPoints) * 100;
            let grade = 'F';
            if (percentage >= 90) grade = 'A';
            else if (percentage >= 80) grade = 'B';
            else if (percentage >= 70) grade = 'C';
            else if (percentage >= 60) grade = 'D';
            
            // Update the displayed grade badge color
            const parentDiv = pointsInput.closest('div[style*="border-left"]');
            const gradeBadge = parentDiv.querySelector('span[style*="background"]');
            
            const gradeColors = {
                'A': '#28a745',
                'B': '#5cb85c',
                'C': '#f0ad4e',
                'D': '#d9534f',
                'F': '#c9302c'
            };
            
            if (gradeBadge) {
                const color = gradeColors[grade];
                gradeBadge.style.background = color;
                gradeBadge.textContent = grade;
                parentDiv.style.borderLeftColor = color;
            }
            
            // Update total section score (sum of all subcategory points)
            let totalPoints = 0;
            section.subcategories.forEach((s, i) => {
                const input = document.getElementById(`subcategory-${sectionId}-${i}-points`);
                if (input) {
                    totalPoints += parseInt(input.value) || 0;
                }
            });
            
            document.getElementById('editSectionScore').value = totalPoints;
        }
        
        function closeEditSectionModal() {
            document.getElementById('editSectionModal').style.display = 'none';
            currentEditingSection = null;
        }
        
        function saveEditedSection() {
            if (!currentEditingSection || !evaluationResults) return;
            
            const section = evaluationResults.sections[currentEditingSection];
            const sectionId = currentEditingSection.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
            const newFeedback = document.getElementById('editSectionFeedback').value.trim();
            const reason = document.getElementById('editSectionReason').value.trim();
            
            // Check if any changes were made
            let hasChanges = false;
            
            // Check feedback change
            if (newFeedback !== section.feedback) {
                hasChanges = true;
            }
            
            // Check subcategory changes
            if (section.subcategories && section.subcategories.length > 0) {
                section.subcategories.forEach((sub, index) => {
                    const pointsInput = document.getElementById(`subcategory-${sectionId}-${index}-points`);
                    const feedbackInput = document.getElementById(`subcategory-${sectionId}-${index}-feedback`);
                    
                    if (pointsInput) {
                        const newPoints = parseInt(pointsInput.value) || 0;
                        const newSubFeedback = feedbackInput ? feedbackInput.value.trim() : '';
                        
                        if (newPoints !== sub.points || newSubFeedback !== (sub.feedback || '')) {
                            hasChanges = true;
                        }
                    }
                });
            }
            
            // If changes were made, require a reason
            if (hasChanges && !reason) {
                alert('Please provide a reason for your changes. This helps improve the AI evaluation system.');
                document.getElementById('editSectionReason').focus();
                return;
            }
            
            // Update subcategories if they exist
            if (section.subcategories && section.subcategories.length > 0) {
                section.subcategories.forEach((sub, index) => {
                    const pointsInput = document.getElementById(`subcategory-${sectionId}-${index}-points`);
                    const feedbackInput = document.getElementById(`subcategory-${sectionId}-${index}-feedback`);
                    
                    if (pointsInput) {
                        const newPoints = parseInt(pointsInput.value) || 0;
                        const newSubFeedback = feedbackInput ? feedbackInput.value.trim() : '';
                        
                        // Log correction if points changed
                        if (newPoints !== sub.points) {
                            correctionLog.push({
                                timestamp: new Date().toISOString(),
                                field: `${currentEditingSection}.${sub.name}.points`,
                                ai_value: sub.points,
                                instructor_value: newPoints,
                                reason: reason
                            });
                        }
                        
                        // Log correction if feedback changed
                        if (newSubFeedback !== (sub.feedback || '')) {
                            correctionLog.push({
                                timestamp: new Date().toISOString(),
                                field: `${currentEditingSection}.${sub.name}.feedback`,
                                ai_value: sub.feedback || '',
                                instructor_value: newSubFeedback,
                                reason: reason
                            });
                        }
                        
                        // Update subcategory
                        sub.points = newPoints;
                        sub.feedback = newSubFeedback;
                        
                        // Recalculate grade
                        const percentage = (newPoints / sub.maxPoints) * 100;
                        if (percentage >= 90) sub.grade = 'A';
                        else if (percentage >= 80) sub.grade = 'B';
                        else if (percentage >= 70) sub.grade = 'C';
                        else if (percentage >= 60) sub.grade = 'D';
                        else sub.grade = 'F';
                    }
                });
                
                // Recalculate section score from subcategories
                let newSectionScore = 0;
                section.subcategories.forEach(sub => {
                    newSectionScore += sub.points;
                });
                
                // Log if section total changed
                if (newSectionScore !== section.score) {
                    correctionLog.push({
                        timestamp: new Date().toISOString(),
                        field: `${currentEditingSection}_total_score`,
                        ai_value: section.score,
                        instructor_value: newSectionScore,
                        reason: reason
                    });
                }
                
                section.score = newSectionScore;
            }
            
            // Log correction if feedback changed
            if (newFeedback !== section.feedback) {
                correctionLog.push({
                    timestamp: new Date().toISOString(),
                    field: `${currentEditingSection}_feedback`,
                    ai_value: section.feedback,
                    instructor_value: newFeedback,
                    reason: reason
                });
            }
            
            // Update section feedback
            section.feedback = newFeedback;
            
            // Recalculate total score for entire evaluation
            let newTotal = 0;
            for (const [key, data] of Object.entries(evaluationResults.sections)) {
                newTotal += data.score;
            }
            evaluationResults.totalScore = newTotal;
            evaluationResults.percentage = ((newTotal / evaluationResults.maxScore) * 100).toFixed(1);
            
            // Update letter grade
            const percentage = (newTotal / evaluationResults.maxScore) * 100;
            evaluationResults.letterGrade = getLetterGrade(percentage, evaluationResults.gradeScale);
            
            // Re-display results
            displayResults(evaluationResults);
            
            closeEditSectionModal();
            
            // Update correction count badge
            updateCorrectionCount();
            
            showNotification('‚úì Section updated! Remember to save the evaluation.', 'success');
        }
        
        // Edit Overall Comments
        function editOverallComments() {
            if (!evaluationResults) return;
            
            document.getElementById('editCommentsAI').textContent = evaluationResults.overallComments;
            document.getElementById('editCommentsText').value = evaluationResults.overallComments;
            document.getElementById('editCommentsReason').value = '';
            
            document.getElementById('editCommentsModal').style.display = 'flex';
        }
        
        function closeEditCommentsModal() {
            document.getElementById('editCommentsModal').style.display = 'none';
        }
        
        function saveEditedComments() {
            if (!evaluationResults) return;
            
            const newComments = document.getElementById('editCommentsText').value.trim();
            const reason = document.getElementById('editCommentsReason').value.trim();
            
            if (newComments !== evaluationResults.overallComments) {
                // Require reason for changes
                if (!reason) {
                    alert('Please provide a reason for changing the comments. This helps improve the AI evaluation system.');
                    document.getElementById('editCommentsReason').focus();
                    return;
                }
                
                correctionLog.push({
                    timestamp: new Date().toISOString(),
                    field: 'overall_comments',
                    ai_value: evaluationResults.overallComments,
                    instructor_value: newComments,
                    reason: reason
                });
                
                evaluationResults.overallComments = newComments;
                
                // Update display
                document.getElementById('overall-comments-text').textContent = newComments;
                
                closeEditCommentsModal();
                
                // Update correction count badge
                updateCorrectionCount();
                
                showNotification('‚úì Comments updated! Remember to save the evaluation.', 'success');
            } else {
                closeEditCommentsModal();
            }
        }
        
        // Edit Timeline Markers
        function editTimelineMarkers() {
            if (!evaluationResults || !evaluationResults.timeline_markers) return;
            
            renderMarkersList();
            document.getElementById('editMarkersModal').style.display = 'flex';
        }
        
        function closeEditMarkersModal() {
            document.getElementById('editMarkersModal').style.display = 'none';
        }
        
        function renderMarkersList() {
            const markers = evaluationResults.timeline_markers || [];
            let html = '';
            
            markers.forEach((marker, index) => {
                const severityColors = {
                    'positive': '#10b981',
                    'minor': '#f59e0b',
                    'moderate': '#f59e0b',
                    'major': '#ef4444'
                };
                const color = severityColors[marker.severity] || '#f59e0b';
                
                html += `
                    <div style="background:var(--bg-alt);padding:1rem;border-radius:0.5rem;margin-bottom:1rem;border-left:4px solid ${color};" data-marker-index="${index}">
                        <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:1rem;">
                            <div style="flex:1;">
                                <label style="display:block;font-weight:600;font-size:0.85rem;margin-bottom:0.25rem;">Timestamp:</label>
                                <input type="text" id="marker-time-${index}" value="${marker.timestamp}" style="width:100px;padding:0.5rem;border:2px solid #ddd;border-radius:0.25rem;" placeholder="0:45">
                            </div>
                            <div style="flex:2;margin-left:1rem;">
                                <label style="display:block;font-weight:600;font-size:0.85rem;margin-bottom:0.25rem;">Category:</label>
                                <input type="text" id="marker-category-${index}" value="${marker.category}" style="width:100%;padding:0.5rem;border:2px solid #ddd;border-radius:0.25rem;">
                            </div>
                            <button onclick="deleteMarker(${index})" style="margin-left:1rem;padding:0.5rem;background:#dc3545;color:white;border:none;border-radius:0.25rem;cursor:pointer;">üóëÔ∏è</button>
                        </div>
                        <div style="margin-bottom:0.75rem;">
                            <label style="display:block;font-weight:600;font-size:0.85rem;margin-bottom:0.25rem;">Issue:</label>
                            <input type="text" id="marker-issue-${index}" value="${marker.issue}" style="width:100%;padding:0.5rem;border:2px solid #ddd;border-radius:0.25rem;">
                        </div>
                        <div style="margin-bottom:0.75rem;">
                            <label style="display:block;font-weight:600;font-size:0.85rem;margin-bottom:0.25rem;">Note:</label>
                            <textarea id="marker-note-${index}" rows="2" style="width:100%;padding:0.5rem;border:2px solid #ddd;border-radius:0.25rem;resize:vertical;">${marker.note}</textarea>
                        </div>
                        <div>
                            <label style="display:block;font-weight:600;font-size:0.85rem;margin-bottom:0.25rem;">Severity:</label>
                            <select id="marker-severity-${index}" style="padding:0.5rem;border:2px solid #ddd;border-radius:0.25rem;">
                                <option value="positive" ${marker.severity === 'positive' ? 'selected' : ''}>‚úì Positive</option>
                                <option value="minor" ${marker.severity === 'minor' ? 'selected' : ''}>‚ö† Minor</option>
                                <option value="moderate" ${marker.severity === 'moderate' ? 'selected' : ''}>‚ö† Moderate</option>
                                <option value="major" ${marker.severity === 'major' ? 'selected' : ''}>‚úï Major</option>
                            </select>
                        </div>
                    </div>
                `;
            });
            
            if (markers.length === 0) {
                html = '<p style="text-align:center;color:#999;padding:2rem;">No timeline markers yet. Click "Add New Marker" below.</p>';
            }
            
            document.getElementById('editMarkersList').innerHTML = html;
        }
        
        function deleteMarker(index) {
            if (!confirm('Delete this marker?')) return;
            
            const marker = evaluationResults.timeline_markers[index];
            
            correctionLog.push({
                timestamp: new Date().toISOString(),
                field: 'timeline_marker_removed',
                marker_index: index,
                ai_value: marker,
                reason: 'Marker removed by instructor'
            });
            
            evaluationResults.timeline_markers.splice(index, 1);
            renderMarkersList();
        }
        
        function addNewMarker() {
            if (!evaluationResults.timeline_markers) {
                evaluationResults.timeline_markers = [];
            }
            
            evaluationResults.timeline_markers.push({
                timestamp: '0:00',
                seconds: 0,
                category: 'New Category',
                issue: 'New Issue',
                severity: 'minor',
                note: 'Add your observation here...'
            });
            
            correctionLog.push({
                timestamp: new Date().toISOString(),
                field: 'timeline_marker_added',
                reason: 'Marker added by instructor'
            });
            
            renderMarkersList();
        }
        
        function saveEditedMarkers() {
            if (!evaluationResults || !evaluationResults.timeline_markers) return;
            
            // Update all markers from form inputs
            evaluationResults.timeline_markers.forEach((marker, index) => {
                const timestamp = document.getElementById(`marker-time-${index}`).value;
                const category = document.getElementById(`marker-category-${index}`).value;
                const issue = document.getElementById(`marker-issue-${index}`).value;
                const note = document.getElementById(`marker-note-${index}`).value;
                const severity = document.getElementById(`marker-severity-${index}`).value;
                
                // Convert timestamp to seconds
                const parts = timestamp.split(':');
                const seconds = parseInt(parts[0]) * 60 + parseInt(parts[1] || 0);
                
                marker.timestamp = timestamp;
                marker.seconds = seconds;
                marker.category = category;
                marker.issue = issue;
                marker.note = note;
                marker.severity = severity;
            });
            
            // Re-display results with updated markers
            displayResults(evaluationResults);
            
            closeEditMarkersModal();
            showNotification('‚úì Timeline markers updated! Remember to save the evaluation.', 'success');
        }
        
        
        // Correction History Functions
        function viewCorrectionHistory() {
            if (!correctionLog || correctionLog.length === 0) {
                alert('No corrections have been made to this evaluation yet.');
                return;
            }
            
            const content = document.getElementById('correctionHistoryContent');
            let html = `<div style="color:var(--text-light);font-size:0.9rem;margin-bottom:1rem;padding:0.75rem;background:var(--bg-alt);border-radius:0.5rem;">
                <strong>${correctionLog.length}</strong> correction${correctionLog.length !== 1 ? 's' : ''} recorded
            </div>`;
            
            // Group corrections by timestamp for better readability
            correctionLog.forEach((correction, index) => {
                const date = new Date(correction.timestamp);
                const timeStr = date.toLocaleString();
                
                // Determine field display name
                let fieldDisplay = correction.field;
                if (correction.field.includes('.')) {
                    const parts = correction.field.split('.');
                    fieldDisplay = `${parts[0]} ‚Üí ${parts[1]}`;
                    if (parts[2]) fieldDisplay += ` (${parts[2]})`;
                }
                
                html += `
                    <div style="background:white;border:1px solid var(--border);border-radius:0.5rem;padding:1rem;margin-bottom:1rem;border-left:4px solid var(--primary);">
                        <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:0.75rem;">
                            <div>
                                <strong style="color:var(--primary);font-size:0.95rem;">${fieldDisplay}</strong>
                                <div style="color:var(--text-light);font-size:0.85rem;margin-top:0.25rem;">${timeStr}</div>
                            </div>
                            <span style="background:var(--bg-alt);padding:0.25rem 0.75rem;border-radius:0.25rem;font-size:0.85rem;font-weight:600;">#${index + 1}</span>
                        </div>
                        
                        ${correction.ai_value !== undefined ? `
                            <div style="margin-bottom:0.75rem;">
                                <div style="font-size:0.85rem;font-weight:600;color:var(--text-light);margin-bottom:0.25rem;">AI Original:</div>
                                <div style="background:var(--bg-alt);padding:0.5rem;border-radius:0.25rem;font-size:0.9rem;font-family:monospace;">
                                    ${typeof correction.ai_value === 'object' ? JSON.stringify(correction.ai_value) : correction.ai_value}
                                </div>
                            </div>
                            
                            <div style="margin-bottom:0.75rem;">
                                <div style="font-size:0.85rem;font-weight:600;color:var(--primary);margin-bottom:0.25rem;">Instructor Correction:</div>
                                <div style="background:var(--success);background:rgba(40,167,69,0.1);padding:0.5rem;border-radius:0.25rem;font-size:0.9rem;border-left:3px solid var(--success);">
                                    ${typeof correction.instructor_value === 'object' ? JSON.stringify(correction.instructor_value) : correction.instructor_value}
                                </div>
                            </div>
                        ` : ''}
                        
                        <div>
                            <div style="font-size:0.85rem;font-weight:600;color:var(--text-dark);margin-bottom:0.25rem;">Reason:</div>
                            <div style="color:var(--text);font-size:0.9rem;font-style:italic;">
                                "${correction.reason}"
                            </div>
                        </div>
                    </div>
                `;
            });
            
            content.innerHTML = html;
            document.getElementById('correctionHistoryModal').style.display = 'flex';
        }
        
        function closeCorrectionHistoryModal() {
            document.getElementById('correctionHistoryModal').style.display = 'none';
        }
        
        // Update correction count badge when corrections are made
        function updateCorrectionCount() {
            const countSpan = document.getElementById('correctionCount');
            const btn = document.getElementById('viewCorrectionsBtn');
            
            if (correctionLog && correctionLog.length > 0) {
                countSpan.textContent = correctionLog.length;
                btn.style.display = 'inline-block';
            } else {
                btn.style.display = 'none';
            }
        }
        
        // Notification helper
        function showNotification(message, type = 'info') {
            const colors = {
                success: '#28a745',
                error: '#dc3545',
                info: '#17a2b8'
            };
            
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${colors[type]};
                color: white;
                padding: 1rem 1.5rem;
                border-radius: 0.5rem;
                box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                z-index: 10000;
                animation: slideIn 0.3s ease-out;
            `;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease-out';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }


        // Export evaluation as accessible HTML file
        function downloadPDF() {
            if (!evaluationResults) {
                alert('No evaluation results to download.');
                return;
            }
            
            exportEvaluationHTML(evaluationResults, evaluationResults.studentName);
        }
        
        async function exportEvaluationHTML(evaluation, studentName) {
            console.log('Exporting evaluation as accessible HTML...');
            
            // Build timeline markers HTML if they exist
            let timelineHTML = '';
            if (evaluation.timeline_markers && evaluation.timeline_markers.length > 0) {
                // Group by category
                const markersByCategory = {};
                evaluation.timeline_markers.forEach(marker => {
                    if (!markersByCategory[marker.category]) {
                        markersByCategory[marker.category] = [];
                    }
                    markersByCategory[marker.category].push(marker);
                });
                
                timelineHTML = `
            <section aria-labelledby="timeline-markers">
                <h2 id="timeline-markers">Timeline Markers</h2>
                
                <div class="instructions" role="note">
                    <h3>How to Use Timeline Markers</h3>
                    <p>Open your video file on your device and seek to the timestamps below to review specific moments from your speech. These markers highlight both strengths and areas for improvement.</p>
                </div>
                `;
                
                Object.entries(markersByCategory).forEach(([category, markers]) => {
                    timelineHTML += `
                <article aria-labelledby="${category.toLowerCase().replace(/\s+/g, '-')}-heading">
                    <h3 id="${category.toLowerCase().replace(/\s+/g, '-')}-heading">${category}</h3>
                    `;
                    
                    markers.forEach(marker => {
                        const severityClass = marker.severity || 'minor';
                        const icon = {positive: '‚úì', minor: '‚ö†', moderate: '‚ö†', major: '‚úï'}[severityClass] || '‚ö†';
                        
                        timelineHTML += `
                    <div class="marker ${severityClass}" role="article" aria-label="${severityClass === 'positive' ? 'Strength' : 'Area for improvement'} at ${marker.timestamp}">
                        <div class="marker-time" aria-label="Timestamp">${marker.timestamp}</div>
                        <div class="marker-content">
                            <h4><span aria-hidden="true">${icon}</span> ${marker.issue}</h4>
                            <p>${marker.note}</p>
                        </div>
                    </div>
                        `;
                    });
                    
                    timelineHTML += `</article>`;
                });
                
                timelineHTML += `</section>`;
            }
            
            // Create complete HTML document
            const htmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speech Evaluation - ${studentName}</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; line-height: 1.6; color: #333; max-width: 800px; margin: 0 auto; padding: 2rem; background: #f5f5f5; }
        .container { background: white; padding: 3rem; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        :focus { outline: 3px solid var(--primary); outline-offset: 2px; }
        @media (prefers-contrast: high) { body { background: white; color: black; } .container { border: 2px solid black; } }
        @media print { body { background: white; padding: 0; } .container { box-shadow: none; padding: 1rem; } .no-print { display: none !important; } .section, .marker { page-break-inside: avoid; } }
        h1 { font-size: 2rem; color: #1e293b; margin-bottom: 1.5rem; border-bottom: 3px solid var(--primary); padding-bottom: 0.5rem; }
        h2 { font-size: 1.5rem; color: #1e293b; margin: 2rem 0 1rem 0; }
        h3 { font-size: 1.25rem; color: #334155; margin: 1.5rem 0 0.75rem 0; }
        .meta-info { background: #f1f5f9; padding: 1rem; border-radius: 4px; margin-bottom: 2rem; }
        .meta-info p { margin: 0.25rem 0; }
        .score-highlight { background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%); color: white; padding: 1.5rem; border-radius: 8px; margin: 2rem 0; }
        .score-highlight h2 { color: white; margin: 0 0 0.5rem 0; }
        .section { background: #f8fafc; padding: 1.5rem; border-radius: 4px; margin-bottom: 1rem; border-left: 4px solid var(--primary); }
        .section-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; }
        .section-score { font-size: 1.25rem; font-weight: bold; color: var(--primary); }
        .marker { display: flex; gap: 1rem; background: white; padding: 1rem; border-radius: 4px; margin-bottom: 0.75rem; border-left: 3px solid; }
        .marker.positive { border-left-color: #10b981; }
        .marker.minor { border-left-color: #f59e0b; }
        .marker.moderate { border-left-color: #f59e0b; }
        .marker.major { border-left-color: #ef4444; }
        .marker-time { min-width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; border-radius: 4px; font-weight: bold; color: white; flex-shrink: 0; }
        .marker.positive .marker-time { background: #10b981; }
        .marker.minor .marker-time { background: #f59e0b; }
        .marker.moderate .marker-time { background: #f59e0b; }
        .marker.major .marker-time { background: #ef4444; }
        .marker-content h4 { margin: 0 0 0.5rem 0; color: #1e293b; }
        .marker-content p { margin: 0; color: #64748b; }
        .instructions { background: #fef3c7; border: 1px solid #f59e0b; padding: 1rem; border-radius: 4px; margin: 1rem 0; }
        .instructions h3 { margin-top: 0; color: #92400e; }
        .button { display: inline-block; background: var(--primary); color: white; padding: 0.75rem 1.5rem; border-radius: 4px; text-decoration: none; font-weight: 600; border: none; cursor: pointer; margin-right: 1rem; }
        .button:hover { background: var(--primary-dark); }
        .skip-link { position: absolute; top: -40px; left: 0; background: var(--primary); color: white; padding: 8px; z-index: 100; }
        .skip-link:focus { top: 0; }
    </style>
</head>
<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>
    <div class="container">
        <div class="no-print" style="margin-bottom: 2rem; display: flex; gap: 1rem;">
            <button onclick="window.print()" class="button">üñ®Ô∏è Print / Save as PDF</button>
            <button onclick="window.close()" class="button" style="background: #6b7280;">‚úï Close</button>
        </div>
        <main id="main-content">
            <header>
                <h1>Speech Evaluation Report</h1>
                <div class="meta-info" role="contentinfo">
                    <p><strong>Student:</strong> ${studentName}</p>
                    <p><strong>Date:</strong> ${evaluation.speechDate || new Date().toLocaleDateString()}</p>
                    <p><strong>Assignment:</strong> ${evaluation.assignmentType || 'Speech Evaluation'}</p>
                    <p><strong>Rubric:</strong> ${evaluation.rubricUsed || 'Standard'}</p>
                </div>
            </header>
            <section class="score-highlight" aria-labelledby="overall-score">
                <h2 id="overall-score">Overall Score</h2>
                <p style="font-size: 2rem; margin: 0.5rem 0;">${evaluation.totalScore}/${evaluation.maxScore} <span style="font-size: 1.5rem;">(${evaluation.percentage}%)</span></p>
                <p style="font-size: 1.5rem; margin: 0;">Grade: ${evaluation.letterGrade}</p>
            </section>
            <section aria-labelledby="section-scores">
                <h2 id="section-scores">Section Scores & Feedback</h2>
                ${Object.keys(evaluation.sections || {}).map(sectionKey => {
                    const section = evaluation.sections[sectionKey];
                    const sectionName = sectionKey.charAt(0).toUpperCase() + sectionKey.slice(1);
                    return `<article class="section"><div class="section-header"><h3>${sectionName}</h3><span class="section-score" aria-label="${sectionName} score">${section.score}/${section.maxScore}</span></div><p>${section.feedback || 'No feedback provided.'}</p></article>`;
                }).join('')}
            </section>
            ${timelineHTML}
            <footer style="margin-top: 3rem; padding-top: 2rem; border-top: 1px solid #e2e8f0; color: #64748b; font-size: 0.875rem;">
                <p>Generated by SpeechGradebook on ${new Date().toLocaleDateString()}</p>
            </footer>
        </main>
    </div>
</body>
</html>`;
            
            // Create blob and download
            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${studentName.replace(/\s+/g, '_')}_Evaluation_${evaluation.speechDate || 'report'}.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log('‚úì Accessible HTML evaluation exported');
        }
        
        window.exportEvaluationHTML = exportEvaluationHTML;

        function emailResults() {
            if (!evaluationResults) {
                alert('No evaluation results to email.');
                return;
            }
            
            // Prompt for student email
            const studentEmail = prompt('Enter student email address:');
            
            if (!studentEmail || !studentEmail.includes('@')) {
                alert('Please enter a valid email address.');
                return;
            }
            
            const subject = `Speech Evaluation Results - ${evaluationResults.assignmentType}`;
            const body = `Dear Student,\n\nYour speech evaluation results are ready.\n\nFinal Score: ${evaluationResults.totalScore} / ${evaluationResults.maxScore}\nGrade: ${evaluationResults.letterGrade || 'N/A'}\n\nPlease contact your instructor for the complete evaluation details.\n\nBest regards`;
            
            const mailtoLink = `mailto:${studentEmail}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
            window.open(mailtoLink);
        }

        function startOver() {
            uploadedFile = null;
            evaluationResults = null;
            document.getElementById('studentForm').reset();
            document.getElementById('fileInfo').classList.add('hidden');
            document.getElementById('fileInput').value = '';
            moveToStep(1);
        }

        // ===== CLASSES MANAGEMENT =====
        async function loadClasses() {
            // Try Supabase first
            const supabaseCourses = await loadCoursesFromSupabase();
            
            let classes = [];
            
            if (supabaseCourses && supabaseCourses.length > 0) {
                // Convert Supabase format to app format
                classes = supabaseCourses.map(course => ({
                    id: course.id,
                    supabaseId: course.id,
                    name: course.name,
                    semester: course.semester || 'Fall',
                    section: course.code || '001',
                    year: course.year?.toString() || '2024',
                    notes: '',
                    roster: (course.course_students || []).map(student => ({
                        supabaseId: student.id,
                        firstName: student.first_name,
                        lastName: student.last_name,
                        name: `${student.first_name} ${student.last_name}`,
                        email: student.email || '',
                        studentId: student.student_id || '',
                        evaluations: []
                    })),
                    evaluations: []
                }));
                
                // Store in user-scoped localStorage so viewClass can find them
                setUserItem('classes', JSON.stringify(classes));
                console.log('‚úì Synced Supabase classes to user-scoped localStorage');
            } else {
                // Fallback to user-scoped localStorage
                classes = JSON.parse(getUserItem('classes') || '[]');
            }
            
            // Don't initialize demo classes - start with empty slate
            
            const grid = document.getElementById('classesGrid');
            
            // Build cards asynchronously to get eval counts from Supabase
            const cardPromises = classes.map(async cls => {
                let evalCount = 0;
                
                // Get eval count from Supabase if available
                if (supabaseClient && cls.supabaseId) {
                    const supabaseEvals = await loadEvaluationsFromSupabase(cls.supabaseId);
                    if (supabaseEvals) {
                        evalCount = supabaseEvals.length;
                    }
                }
                
                // Also count localStorage evals (for backwards compatibility)
                if (cls.roster) {
                    cls.roster.forEach(student => {
                        if (student.evaluations) {
                            evalCount += student.evaluations.length;
                        }
                    });
                }
                
                return `
                <div class="class-card" data-class-id="${cls.id}">
                    <div class="class-header">${cls.name}</div>
                    <div class="class-meta">
                        ${cls.semester} ${cls.year} ‚Ä¢ Section ${cls.section}
                    </div>
                    <p style="color: var(--text-light); font-size: 0.9rem; margin-bottom: 1rem;">
                        ${cls.notes || 'No description'}
                    </p>
                    <div class="class-stats">
                        <div class="stat">
                            <div class="stat-value">${(cls.roster || []).length}</div>
                            <div class="stat-label">Students</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value">${evalCount}</div>
                            <div class="stat-label">Evaluations</div>
                        </div>
                    </div>
                </div>
                `;
            });
            
            Promise.all(cardPromises).then(cards => {
                grid.innerHTML = cards.join('');
                
                // Add click handlers
                document.querySelectorAll('.class-card').forEach(card => {
                    card.addEventListener('click', async function() {
                        const classId = this.getAttribute('data-class-id');
                        await viewClass(classId);
                    });
                });
            });
        }

        function showCreateClass() {
            document.getElementById('createClassCard').classList.remove('hidden');
        }

        function cancelCreateClass() {
            document.getElementById('createClassCard').classList.add('hidden');
            document.getElementById('createClassForm').reset();
        }

        function toggleEvalType(typeId) {
            const content = document.getElementById(typeId);
            const arrow = document.getElementById(typeId + '-arrow');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.style.transform = 'rotate(90deg)';
            } else {
                content.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
            }
        }

        
        // Sort evaluations dynamically
        // Make sortEvaluations globally accessible
        window.sortEvaluations = sortEvaluations;

        async function viewClass(classId) {
            currentClassId = classId; // Store for later use
            
            // Load classes fresh from Supabase/localStorage
            await loadClasses();
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const selectedClass = classes.find(c => c.id === classId);
            
            if (!selectedClass) {
                alert('Class not found');
                console.error('Class ID not found:', classId, 'Available IDs:', classes.map(c => c.id));
                return;
            }
            
            const roster = selectedClass.roster || [];
            
            // Gather all evaluations - from both Supabase and localStorage
            const evals = [];
            
            // Load from Supabase if available
            if (supabaseClient && selectedClass.supabaseId) {
                console.log('Loading evaluations from Supabase for course:', selectedClass.supabaseId);
                const supabaseEvals = await loadEvaluationsFromSupabase(selectedClass.supabaseId);
                console.log('Supabase evaluations result:', supabaseEvals);
                
                if (supabaseEvals && supabaseEvals.length > 0) {
                    console.log('Processing', supabaseEvals.length, 'Supabase evaluations');
                    supabaseEvals.forEach(ev => {
                        console.log('Evaluation data:', ev);
                        evals.push({
                            studentName: ev.student ? `${ev.student.first_name} ${ev.student.last_name}` : 'Unknown',
                            studentId: ev.student_id,
                            date: new Date(ev.created_at).toLocaleDateString(),
                            type: ev.evaluation_data?.assignmentType || 'Unknown',
                            totalScore: ev.total_score || 0,
                            maxScore: ev.evaluation_data?.maxScore || 100,
                            results: ev.evaluation_data
                        });
                    });
                    console.log('‚úì Added', evals.length, 'evaluations from Supabase');
                } else {
                    console.log('No evaluations found in Supabase for this course');
                }
            } else {
                console.log('Supabase not available or course has no supabaseId');
            }
            
            // Also gather from localStorage (for backwards compatibility)
            roster.forEach(student => {
                if (student.evaluations) {
                    student.evaluations.forEach(ev => {
                        // Only add if not already in evals (avoid duplicates)
                        const exists = evals.find(e => 
                            e.studentId === student.id && 
                            e.date === ev.date &&
                            e.type === ev.type
                        );
                        if (!exists) {
                            evals.push({
                                studentName: student.firstName + ' ' + student.lastName,
                                studentId: student.id,
                                date: ev.date,
                                type: ev.type,
                                totalScore: ev.results.totalScore,
                                maxScore: ev.results.maxScore,
                                results: ev.results
                            });
                        }
                    });
                }
            });
            
            // Update title
            document.getElementById('classDetailTitle').textContent = 
                `${selectedClass.name} - ${selectedClass.semester} ${selectedClass.year}`;
            
            console.log('Final evals array before display:', evals);
            console.log('Evals count:', evals.length);
            
            // Build content
            let html = `
                <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 2rem;">
                    <strong>Section:</strong> ${selectedClass.section}<br>
                    <strong>Notes:</strong> ${selectedClass.notes || 'None'}<br>
                    <strong>Students:</strong> ${roster.length}<br>
                    <strong>Evaluations:</strong> ${evals.length}
                </div>
            `;
            
            // Students section with Add button
            html += `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 2rem; margin-bottom: 1rem;">
                    <h3 style="margin: 0;">üë• Students</h3>
                    <button onclick="showAddStudent()">‚ûï Add Student</button>
                </div>
            `;
            
            if (roster.length === 0) {
                html += '<p style="color: var(--text-light);">No students yet. Click "Add Student" to get started.</p>';
            } else {
                html += '<ul style="list-style: none; padding: 0;">';
                roster.forEach(student => {
                    // Count evaluations for this student from the evals array
                    const studentEvals = evals.filter(e => e.studentId === student.id || e.studentId === student.supabaseId);
                    const evalCount = studentEvals.length;
                    
                    let evalText = '';
                    if (evalCount > 0) {
                        evalText = ` ‚Ä¢ ${evalCount} evaluation${evalCount > 1 ? 's' : ''}`;
                    }
                    
                    html += `<li style="background: var(--bg-alt); padding: 1rem; margin-bottom: 0.5rem; border-radius: 0.5rem; display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong>${student.firstName} ${student.lastName}</strong><br>
                            <span style="color: var(--text-light); font-size: 0.9rem;">${student.email || 'No email'}${evalText}</span>
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            ${evalCount > 0 ? `<button onclick="viewStudentEvals('${student.supabaseId || student.id}')" class="btn-small">View Evals</button>` : ''}
                        </div>
                    </li>`;
                });
                html += '</ul>';
            }
            
            // Show content
            document.getElementById('classDetailContent').innerHTML = html;
            
            // Switch to class detail view
            setActiveSection('classDetailSection', 'navDashboard');
        }

        // ===== RUBRICS MANAGEMENT =====
        async function loadRubrics() {
            // Initialize rubrics storage if needed
            initializeRubrics();
            
            // Populate course filter dropdown
            populateCourseFilter();
            
            // Get all rubrics from storage (now async)
            const allRubrics = await getAllRubrics();
            
            // Get all classes for course name lookup
            const classes = JSON.parse(getUserItem('classes') || '[]');
            
            const list = document.getElementById('rubricsList');
            if (!list) return; // Exit if element doesn't exist yet
            
            list.innerHTML = allRubrics.map(rubric => {
                // Get course info - handle both new courseIds array and old single courseId
                let courseInfo = '';
                let courseIdsToDisplay = [];
                
                if (rubric.courseIds && Array.isArray(rubric.courseIds) && rubric.courseIds.length > 0) {
                    courseIdsToDisplay = rubric.courseIds;
                } else if (rubric.courseId) {
                    // Backward compatibility with single courseId
                    courseIdsToDisplay = [rubric.courseId];
                }
                
                if (courseIdsToDisplay.length > 0) {
                    const courses = courseIdsToDisplay
                        .map(id => classes.find(c => c.id === id))
                        .filter(c => c); // Remove undefined (deleted courses)
                    
                    if (courses.length > 0) {
                        // Group by course name
                        const courseGroups = {};
                        courses.forEach(course => {
                            if (!courseGroups[course.name]) {
                                courseGroups[course.name] = [];
                            }
                            courseGroups[course.name].push(course);
                        });
                        
                        // Format display: "CMST 210 (Fall 2024) - Sections 001, 002"
                        const courseDisplays = Object.keys(courseGroups).map(courseName => {
                            const sections = courseGroups[courseName];
                            const firstCourse = sections[0];
                            const sectionNums = sections.map(s => s.section).join(', ');
                            const sectionText = sections.length > 1 ? `Sections ${sectionNums}` : `Section ${sectionNums}`;
                            return `${courseName} (${firstCourse.semester} ${firstCourse.year}) - ${sectionText}`;
                        });
                        
                        courseInfo = ` ‚Ä¢ <span style="color: var(--primary); font-weight: 500;">${courseDisplays.join(' ‚Ä¢ ')}</span>`;
                    } else if (courseIdsToDisplay.length > 0) {
                        courseInfo = ' ‚Ä¢ <span style="color: #999;">Course(s) not found</span>';
                    }
                }
                
                return `
                <div class="rubric-item">
                    <div class="rubric-info">
                        <h4>${rubric.name}</h4>
                        <p>${rubric.description || 'No description'} ‚Ä¢ ${rubric.totalPoints} points${rubric.speechType ? ' ‚Ä¢ ' + rubric.speechType : ''}${courseInfo}</p>
                    </div>
                    <div class="rubric-actions">
                        <button class="btn-small btn-view" data-rubric-id="${rubric.id}">View</button>
                        <button class="btn-small btn-edit" data-rubric-id="${rubric.id}">Edit</button>
                        <button class="btn-small btn-duplicate" data-rubric-id="${rubric.id}">Duplicate</button>
                        ${rubric.id !== 'default' ? `
                            <button class="btn-small btn-danger btn-delete" data-rubric-id="${rubric.id}">Delete</button>
                        ` : ''}
                    </div>
                </div>
            `;
            }).join('');
            
            // Add event listeners to all buttons
            document.querySelectorAll('.btn-view').forEach(btn => {
                btn.addEventListener('click', () => viewRubric(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-edit').forEach(btn => {
                btn.addEventListener('click', () => editRubric(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-duplicate').forEach(btn => {
                btn.addEventListener('click', () => duplicateRubricUI(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-delete').forEach(btn => {
                btn.addEventListener('click', () => {
                    console.log('Delete button clicked via event listener!');
                    deleteRubricUI(btn.dataset.rubricId);
                });
            });
        }

        function viewRubric(rubricId) {
            const rubric = getRubricById(rubricId);
            if (!rubric) return;
            
            const metrics = calculateRubricMetrics(rubric);
            const maxPointsPerSub = metrics.pointsPerSubcategory;
            
            // Get course info - handle both courseIds array and old courseId
            let courseInfo = '';
            let courseIdsToDisplay = [];
            
            if (rubric.courseIds && Array.isArray(rubric.courseIds) && rubric.courseIds.length > 0) {
                courseIdsToDisplay = rubric.courseIds;
            } else if (rubric.courseId) {
                courseIdsToDisplay = [rubric.courseId];
            }
            
            if (courseIdsToDisplay.length > 0) {
                const classes = JSON.parse(getUserItem('classes') || '[]');
                const courses = courseIdsToDisplay
                    .map(id => classes.find(c => c.id === id))
                    .filter(c => c);
                
                if (courses.length > 0) {
                    const courseDisplays = courses.map(course => 
                        `${course.name} - ${course.semester} ${course.year} (Section ${course.section})`
                    ).join('<br>');
                    courseInfo = `<strong>Course${courses.length > 1 ? 's' : ''}:</strong> ${courseDisplays}<br>`;
                }
            }
            
            let html = `
                <div style="background: white; padding: 2rem; border-radius: 0.5rem; max-width: 800px; margin: 2rem auto;">
                    <h2>${rubric.name}</h2>
                    <p style="color: var(--text-light); margin-bottom: 1rem;">${rubric.description || ''}</p>
                    <div style="background: var(--bg-alt); padding: 1rem; border-radius: 0.5rem; margin-bottom: 1.5rem;">
                        ${courseInfo}
                        <strong>Total Points:</strong> ${rubric.totalPoints}<br>
                        <strong>Total Subcategories:</strong> ${metrics.totalSubcategories}<br>
                        <strong>Maximum Points per Subcategory:</strong> ${maxPointsPerSub.toFixed(2)} (when graded as A)
                    </div>
                    <h3>Grade Scale & Points per Subcategory</h3>
                    <p style="color: var(--text-light); font-size: 0.9rem; margin-bottom: 0.5rem;">Each subcategory can earn different points based on the grade received:</p>
                    <div style="margin-bottom: 1.5rem;">
            `;
            
            for (const [grade, info] of Object.entries(rubric.gradeScale)) {
                const points = (maxPointsPerSub * info.percentage).toFixed(2);
                html += `<div style="padding: 0.5rem; border-left: 3px solid var(--primary); margin-bottom: 0.5rem; background: var(--bg-alt);">
                    <strong>${grade} - ${info.label}:</strong> ${info.percentage * 100}% ‚Üí <strong>${points} points</strong> per subcategory (Range: ${info.range})
                </div>`;
            }
            
            html += `</div><h3>Categories & Subcategories</h3>`;
            
            rubric.categories.forEach((cat, idx) => {
                const catMetrics = metrics.categoryPoints[idx];
                html += `
                    <div style="margin-bottom: 1.5rem; padding: 1rem; border: 1px solid var(--border); border-radius: 0.5rem;">
                        <h4>${cat.name} <span style="color: var(--primary);">(Max: ${catMetrics.maxPoints.toFixed(1)} points)</span></h4>
                        <p style="color: var(--text-light); font-size: 0.9rem;">${catMetrics.subcategoryCount} subcategories √ó ${maxPointsPerSub.toFixed(2)} points each (if all A's)</p>
                        <ul style="margin-top: 0.5rem;">
                            ${cat.subcategories.map(sub => `<li>${sub}</li>`).join('')}
                        </ul>
                    </div>
                `;
            });
            
            html += `<button onclick="closeModal()">Close</button></div>`;
            
            showModal(html);
        }

        function editRubric(rubricId) {
            const rubric = getRubricById(rubricId);
            if (!rubric) {
                alert('Rubric not found');
                return;
            }
            loadRubricIntoForm(rubric);
        }

        async function duplicateRubricUI(rubricId) {
            console.log('Duplicating rubric:', rubricId);
            const newRubric = await duplicateRubric(rubricId);
            if (newRubric) {
                await loadRubrics();
                alert(`‚úì Rubric duplicated: ${newRubric.name}`);
            }
        }

        async function deleteRubricUI(rubricId) {
            console.log('Delete button clicked for:', rubricId);
            const rubric = await getRubricById(rubricId);
            if (!rubric) {
                console.error('Rubric not found:', rubricId);
                return;
            }
            
            console.log('Found rubric:', rubric.name);
            
            // Use custom confirmation modal instead of native confirm
            showConfirmModal(
                'Delete Rubric',
                `Are you sure you want to delete "${rubric.name}"? This action cannot be undone.`,
                async () => {
                    // User clicked Yes/Confirm
                    console.log('User confirmed deletion via custom modal');
                    const deleteResult = await deleteRubric(rubricId);
                    console.log('deleteRubric returned:', deleteResult);
                    
                    if (deleteResult) {
                        console.log('Rubric deleted successfully');
                        await loadRubrics();
                        alert('‚úì Rubric deleted successfully');
                    } else {
                        console.error('Delete function returned false');
                    }
                },
                () => {
                    // User clicked No/Cancel
                    console.log('User cancelled deletion via custom modal');
                }
            );
        }

        // Make functions globally accessible
        window.deleteRubricUI = deleteRubricUI;
        window.duplicateRubricUI = duplicateRubricUI;
        window.viewRubric = viewRubric;
        window.editRubric = editRubric;
        window.showCreateRubric = showCreateRubric;
        window.cancelCreateRubric = cancelCreateRubric;
        window.addCategory = addCategory;
        window.removeCategory = removeCategory;
        window.addSubcategory = addSubcategory;
        window.removeSubcategory = removeSubcategory;

        // Test function to verify everything is working
        function testDeleteFunction() {
            console.log('=== TEST FUNCTION CALLED ===');
            console.log('deleteRubricUI exists?', typeof window.deleteRubricUI);
            console.log('deleteRubric exists?', typeof deleteRubric);
            console.log('getRubricById exists?', typeof getRubricById);
            
            const allRubrics = getAllRubrics();
            console.log('All rubrics:', allRubrics);
            
            if (allRubrics.length > 0) {
                const testId = allRubrics[allRubrics.length - 1].id;
                console.log('Attempting to call deleteRubricUI with ID:', testId);
                try {
                    deleteRubricUI(testId);
                } catch (e) {
                    console.error('Error calling deleteRubricUI:', e);
                }
            }
        }
        window.testDeleteFunction = testDeleteFunction;

        function showModal(content) {
            const modal = document.getElementById('saveModal');
            if (!modal) return;
            
            modal.innerHTML = `
                <div onclick="closeModal()" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 9999; display: flex; align-items: center; justify-content: center;">
                    <div onclick="event.stopPropagation()" style="background: white; border-radius: 0.5rem; max-height: 90vh; overflow-y: auto; max-width: 90vw;">
                        ${content}
                    </div>
                </div>
            `;
            modal.style.display = 'flex';
        }

        function closeModal() {
            const modal = document.getElementById('saveModal');
            if (modal) {
                modal.style.display = 'none';
                modal.innerHTML = '';
            }
        }

        function showConfirmModal(title, message, onConfirm, onCancel) {
            const modal = document.getElementById('saveModal');
            if (!modal) {
                console.error('Modal element not found');
                return;
            }
            
            modal.innerHTML = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 9999; display: flex; align-items: center; justify-content: center;">
                    <div onclick="event.stopPropagation()" style="background: white; border-radius: 0.5rem; padding: 2rem; max-width: 500px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                        <h3 style="margin-bottom: 1rem; color: var(--primary);">${title}</h3>
                        <p style="margin-bottom: 2rem; color: var(--text);">${message}</p>
                        <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                            <button id="confirmCancel" class="btn-secondary" style="padding: 0.5rem 1.5rem;">Cancel</button>
                            <button id="confirmYes" class="btn-danger" style="padding: 0.5rem 1.5rem;">Delete</button>
                        </div>
                    </div>
                </div>
            `;
            modal.style.display = 'flex';
            
            // Add event listeners
            document.getElementById('confirmYes').addEventListener('click', () => {
                closeModal();
                if (onConfirm) onConfirm();
            });
            
            document.getElementById('confirmCancel').addEventListener('click', () => {
                closeModal();
                if (onCancel) onCancel();
            });
        }

        // Make modal functions globally accessible
        window.showModal = showModal;
        window.closeModal = closeModal;
        window.showConfirmModal = showConfirmModal;

        function showCreateRubric() {
            document.getElementById('rubricFormHeader').textContent = 'Create Custom Rubric';
            document.getElementById('rubricSubmitBtn').textContent = 'Create Rubric';
            document.getElementById('editingRubricId').value = '';
            document.getElementById('createRubricForm').reset();
            
            // Populate course selector
            populateCourseSelector();
            
            // Initialize with one empty category
            document.getElementById('categoriesContainer').innerHTML = '';
            addCategory();
            
            document.getElementById('createRubricCard').classList.remove('hidden');
            document.getElementById('createRubricCard').scrollIntoView({ behavior: 'smooth' });
        }

        function cancelCreateRubric() {
            document.getElementById('createRubricCard').classList.add('hidden');
            document.getElementById('createRubricForm').reset();
            document.getElementById('categoriesContainer').innerHTML = '';
        }

        // ===== UPLOAD RUBRIC FUNCTIONS =====
        
        function showUploadRubric() {
            document.getElementById('uploadRubricForm').reset();
            document.getElementById('uploadProgress').classList.add('hidden');
            document.getElementById('uploadRubricCard').classList.remove('hidden');
            document.getElementById('uploadRubricCard').scrollIntoView({ behavior: 'smooth' });
            
            // Load saved API keys
            const savedGeminiKey = localStorage.getItem('gemini_api_key');
            const savedOpenAIKey = localStorage.getItem('openai_api_key');
            const savedClaudeKey = localStorage.getItem('anthropic_api_key');
            
            // Pre-fill API key if one is saved
            if (savedGeminiKey) {
                document.getElementById('uploadAiProvider').value = 'gemini';
                document.getElementById('uploadApiKey').value = savedGeminiKey;
            } else if (savedOpenAIKey) {
                document.getElementById('uploadAiProvider').value = 'gpt4o';
                document.getElementById('uploadApiKey').value = savedOpenAIKey;
            } else if (savedClaudeKey) {
                document.getElementById('uploadAiProvider').value = 'claude';
                document.getElementById('uploadApiKey').value = savedClaudeKey;
            }
        }
        
        function cancelUploadRubric() {
            document.getElementById('uploadRubricCard').classList.add('hidden');
            document.getElementById('uploadRubricForm').reset();
        }
        
        // Handle upload rubric form submission
        document.getElementById('uploadRubricForm')?.addEventListener('submit', async function(e) {
            e.preventDefault();
            await processUploadedRubric();
        });
        
        async function processUploadedRubric() {
            const fileInput = document.getElementById('uploadRubricFile');
            const rubricName = document.getElementById('uploadRubricName').value;
            const aiProvider = document.getElementById('uploadAiProvider').value;
            const apiKey = document.getElementById('uploadApiKey').value;
            
            if (!fileInput.files || !fileInput.files[0]) {
                alert('Please select a file to upload');
                return;
            }
            
            const file = fileInput.files[0];
            const maxSize = 10 * 1024 * 1024; // 10MB
            
            if (file.size > maxSize) {
                alert('File size exceeds 10MB limit. Please use a smaller file.');
                return;
            }
            
            // Show progress
            const progressDiv = document.getElementById('uploadProgress');
            const progressText = document.getElementById('uploadProgressText');
            const progressBar = document.getElementById('uploadProgressBar');
            progressDiv.classList.remove('hidden');
            progressText.textContent = 'Reading file...';
            progressBar.style.width = '20%';
            
            try {
                // Convert file to base64
                const base64Data = await fileToBase64(file);
                progressText.textContent = 'Analyzing rubric structure...';
                progressBar.style.width = '40%';
                
                // Extract rubric using AI
                const extractedRubric = await extractRubricWithAI(base64Data, file.type, aiProvider, apiKey);
                progressText.textContent = 'Creating rubric...';
                progressBar.style.width = '80%';
                
                if (!extractedRubric) {
                    throw new Error('Failed to extract rubric from file');
                }
                
                // Create the rubric object
                const rubric = {
                    name: rubricName,
                    speechType: extractedRubric.speechType || 'General',
                    totalPoints: extractedRubric.totalPoints || 100,
                    gradeScale: extractedRubric.gradeScale || {
                        A: { min: 90, label: 'Excellent' },
                        B: { min: 80, label: 'Good' },
                        C: { min: 70, label: 'Satisfactory' },
                        D: { min: 60, label: 'Needs Improvement' },
                        F: { min: 0, label: 'Unsatisfactory' }
                    },
                    categories: extractedRubric.categories,
                    isTemplate: false,
                    extractedFrom: file.name
                };
                
                // Save the rubric
                await saveRubric(rubric);
                
                progressText.textContent = '‚úÖ Rubric created successfully!';
                progressBar.style.width = '100%';
                
                // Reload rubrics display
                await loadRubrics();
                
                // Close form after brief delay
                setTimeout(() => {
                    cancelUploadRubric();
                    alert(`Rubric "${rubricName}" has been created successfully from ${file.name}!`);
                }, 1500);
                
            } catch (error) {
                console.error('Error processing rubric:', error);
                progressDiv.classList.add('hidden');
                alert('Failed to process rubric: ' + error.message + '\n\nPlease check:\n- Your API key is correct\n- The file contains a clear rubric structure\n- Your internet connection is working');
            }
        }
        
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    const base64 = reader.result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        async function extractRubricWithAI(base64Data, mimeType, provider, apiKey) {
            console.log('Extracting rubric with', provider);
            
            const prompt = `You are analyzing a rubric document. Extract ALL the information and return ONLY a valid JSON object (no markdown, no explanation, no preamble).

The JSON must have this exact structure:
{
  "speechType": "type of speech if mentioned, or 'General'",
  "totalPoints": total possible points as a number,
  "categories": [
    {
      "name": "Category Name",
      "subcategories": [
        {
          "name": "Subcategory Name",
          "points": point value as number,
          "description": "criteria description"
        }
      ]
    }
  ],
  "gradeScale": {
    "A": {"min": 90, "label": "Excellent"},
    "B": {"min": 80, "label": "Good"},
    "C": {"min": 70, "label": "Satisfactory"},
    "D": {"min": 60, "label": "Needs Improvement"},
    "F": {"min": 0, "label": "Unsatisfactory"}
  }
}

Extract every category, subcategory, point value, and grading criterion you can find. If the grading scale is specified in the rubric, use those values instead of the defaults shown above.

Return ONLY the JSON object, nothing else.`;

            if (provider === 'gemini') {
                return await extractWithGemini(base64Data, mimeType, prompt, apiKey);
            } else if (provider === 'gpt4o') {
                return await extractWithOpenAI(base64Data, mimeType, prompt, apiKey);
            } else if (provider === 'claude') {
                return await extractWithClaude(base64Data, mimeType, prompt, apiKey);
            }
        }
        
        async function extractWithGemini(base64Data, mimeType, prompt, apiKey) {
            // Use gemini-1.5-flash which supports both text and images
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{
                        parts: [
                            { text: prompt },
                            {
                                inline_data: {
                                    mime_type: mimeType,
                                    data: base64Data
                                }
                            }
                        ]
                    }],
                    generationConfig: {
                        temperature: 0.4,
                        topK: 32,
                        topP: 1,
                        maxOutputTokens: 2048
                    }
                })
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                console.error('Gemini API error:', errorData);
                
                // Provide helpful error message
                if (response.status === 404) {
                    throw new Error(`API key may be invalid. Please:\n1. Get a new key from https://aistudio.google.com/app/apikey\n2. Make sure it's enabled for Gemini API\n3. Try again with the new key`);
                } else if (response.status === 400) {
                    throw new Error(`Bad request: ${errorData.error?.message || 'Check your file format'}`);
                } else {
                    throw new Error(`Gemini API error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
                }
            }
            
            const data = await response.json();
            
            if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
                throw new Error('Unexpected response format from Gemini API');
            }
            
            const text = data.candidates[0].content.parts[0].text;
            
            // Clean up the response to extract JSON
            const jsonMatch = text.match(/\{[\s\S]*\}/);
            if (!jsonMatch) {
                console.error('AI Response:', text);
                throw new Error('No valid JSON found in AI response. The AI may not have recognized a rubric structure in the image.');
            }
            
            return JSON.parse(jsonMatch[0]);
        }
        
        async function extractWithOpenAI(base64Data, mimeType, prompt, apiKey) {
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: 'gpt-4o',
                    messages: [{
                        role: 'user',
                        content: [
                            { type: 'text', text: prompt },
                            {
                                type: 'image_url',
                                image_url: {
                                    url: `data:${mimeType};base64,${base64Data}`
                                }
                            }
                        ]
                    }],
                    max_tokens: 2000
                })
            });
            
            if (!response.ok) {
                throw new Error(`OpenAI API error: ${response.status}`);
            }
            
            const data = await response.json();
            const text = data.choices[0].message.content;
            
            const jsonMatch = text.match(/\{[\s\S]*\}/);
            if (!jsonMatch) {
                throw new Error('No valid JSON found in AI response');
            }
            
            return JSON.parse(jsonMatch[0]);
        }
        
        async function extractWithClaude(base64Data, mimeType, prompt, apiKey) {
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                    model: 'claude-3-5-sonnet-20241022',
                    max_tokens: 2000,
                    messages: [{
                        role: 'user',
                        content: [
                            { type: 'text', text: prompt },
                            {
                                type: 'image',
                                source: {
                                    type: 'base64',
                                    media_type: mimeType,
                                    data: base64Data
                                }
                            }
                        ]
                    }]
                })
            });
            
            if (!response.ok) {
                throw new Error(`Claude API error: ${response.status}`);
            }
            
            const data = await response.json();
            const text = data.content[0].text;
            
            const jsonMatch = text.match(/\{[\s\S]*\}/);
            if (!jsonMatch) {
                throw new Error('No valid JSON found in AI response');
            }
            
            return JSON.parse(jsonMatch[0]);
        }

        let categoryCounter = 0;

        function addCategory() {
            categoryCounter++;
            const container = document.getElementById('categoriesContainer');
            const categoryDiv = document.createElement('div');
            categoryDiv.className = 'category-item';
            categoryDiv.id = `category-${categoryCounter}`;
            categoryDiv.style.cssText = 'background: var(--bg-alt); padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem; border: 1px solid var(--border);';
            
            categoryDiv.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                    <input type="text" placeholder="Category Name (e.g., Content - Introduction)" 
                           class="category-name" style="flex: 1; margin-right: 1rem; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;" required>
                    <button type="button" onclick="removeCategory('category-${categoryCounter}')" class="btn-small btn-danger">Remove Category</button>
                </div>
                <div class="subcategories-container" id="subcategories-${categoryCounter}"></div>
                <button type="button" onclick="addSubcategory('subcategories-${categoryCounter}')" class="btn-small" style="margin-top: 0.5rem;">‚ûï Add Subcategory</button>
            `;
            
            container.appendChild(categoryDiv);
            
            // Add one default subcategory
            addSubcategory(`subcategories-${categoryCounter}`);
        }

        function removeCategory(categoryId) {
            const element = document.getElementById(categoryId);
            if (element) {
                element.remove();
            }
        }

        let subcategoryCounter = 0;

        function addSubcategory(containerId) {
            subcategoryCounter++;
            const container = document.getElementById(containerId);
            const subDiv = document.createElement('div');
            subDiv.id = `subcategory-${subcategoryCounter}`;
            subDiv.style.cssText = 'display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.5rem;';
            
            subDiv.innerHTML = `
                <span style="color: var(--text-light); font-size: 0.9rem;">‚Ä¢</span>
                <input type="text" placeholder="Subcategory (e.g., Eye Contact)" 
                       class="subcategory-name" style="flex: 1; padding: 0.4rem; border: 1px solid var(--border); border-radius: 0.25rem;" required>
                <button type="button" onclick="removeSubcategory('subcategory-${subcategoryCounter}')" class="btn-small btn-danger" style="padding: 0.25rem 0.5rem; font-size: 0.8rem;">‚úï</button>
            `;
            
            container.appendChild(subDiv);
        }

        function removeSubcategory(subId) {
            const element = document.getElementById(subId);
            if (element) {
                element.remove();
            }
        }

        function collectRubricData() {
            // Collect selected course IDs from checkboxes
            const selectedCourseIds = Array.from(document.querySelectorAll('.course-checkbox:checked'))
                .map(checkbox => checkbox.value);
            
            const rubricData = {
                id: document.getElementById('editingRubricId').value || ('rubric-' + Date.now()),
                name: document.getElementById('rubricName').value.trim(),
                description: document.getElementById('rubricDescription').value.trim(),
                totalPoints: parseInt(document.getElementById('rubricTotalPoints').value),
                speechType: document.getElementById('rubricSpeechType').value.trim() || null,
                courseIds: selectedCourseIds.length > 0 ? selectedCourseIds : [], // Array of course IDs
                gradeScale: {
                    A: {
                        label: document.getElementById('gradeA_label').value,
                        percentage: parseFloat(document.getElementById('gradeA_pct').value) / 100,
                        range: document.getElementById('gradeA_range').value
                    },
                    B: {
                        label: document.getElementById('gradeB_label').value,
                        percentage: parseFloat(document.getElementById('gradeB_pct').value) / 100,
                        range: document.getElementById('gradeB_range').value
                    },
                    C: {
                        label: document.getElementById('gradeC_label').value,
                        percentage: parseFloat(document.getElementById('gradeC_pct').value) / 100,
                        range: document.getElementById('gradeC_range').value
                    },
                    D: {
                        label: document.getElementById('gradeD_label').value,
                        percentage: parseFloat(document.getElementById('gradeD_pct').value) / 100,
                        range: document.getElementById('gradeD_range').value
                    },
                    F: {
                        label: document.getElementById('gradeF_label').value,
                        percentage: parseFloat(document.getElementById('gradeF_pct').value) / 100,
                        range: document.getElementById('gradeF_range').value
                    }
                },
                categories: []
            };

            // Collect categories and subcategories
            const categoryElements = document.querySelectorAll('.category-item');
            
            categoryElements.forEach((catEl) => {
                const categoryName = catEl.querySelector('.category-name').value.trim();
                if (!categoryName) return;

                const subcategories = [];
                const subInputs = catEl.querySelectorAll('.subcategory-name');
                
                subInputs.forEach((subInput) => {
                    const subName = subInput.value.trim();
                    if (subName) {
                        subcategories.push(subName);
                    }
                });

                if (subcategories.length > 0) {
                    rubricData.categories.push({
                        name: categoryName,
                        subcategories: subcategories
                    });
                }
            });

            return rubricData;
        }

        function loadRubricIntoForm(rubric) {
            document.getElementById('rubricFormHeader').textContent = 'Edit Rubric';
            document.getElementById('rubricSubmitBtn').textContent = 'Save Changes';
            document.getElementById('editingRubricId').value = rubric.id;
            
            // Basic info
            document.getElementById('rubricName').value = rubric.name;
            document.getElementById('rubricDescription').value = rubric.description || '';
            document.getElementById('rubricTotalPoints').value = rubric.totalPoints;
            document.getElementById('rubricSpeechType').value = rubric.speechType || '';
            
            // Populate course selector with pre-selected courses
            // Handle both old single courseId and new courseIds array for backward compatibility
            let selectedCourseIds = [];
            if (rubric.courseIds && Array.isArray(rubric.courseIds)) {
                selectedCourseIds = rubric.courseIds;
            } else if (rubric.courseId) {
                // Backward compatibility: convert old single courseId to array
                selectedCourseIds = [rubric.courseId];
            }
            populateCourseSelector(selectedCourseIds);
            
            // Grade scale
            for (const grade of ['A', 'B', 'C', 'D', 'F']) {
                const gradeData = rubric.gradeScale[grade];
                document.getElementById(`grade${grade}_label`).value = gradeData.label;
                document.getElementById(`grade${grade}_pct`).value = gradeData.percentage * 100;
                document.getElementById(`grade${grade}_range`).value = gradeData.range;
            }
            
            // Clear and rebuild categories
            document.getElementById('categoriesContainer').innerHTML = '';
            categoryCounter = 0;
            subcategoryCounter = 0;
            
            rubric.categories.forEach((category) => {
                addCategory();
                const lastCategory = document.querySelector('.category-item:last-child');
                lastCategory.querySelector('.category-name').value = category.name;
                
                // Clear default subcategory and add the actual ones
                const subContainer = lastCategory.querySelector('.subcategories-container');
                subContainer.innerHTML = '';
                
                category.subcategories.forEach((subName) => {
                    const containerId = subContainer.id;
                    addSubcategory(containerId);
                    
                    // Get all subcategory inputs in this container and set the last one
                    const allSubInputs = subContainer.querySelectorAll('.subcategory-name');
                    const lastSubInput = allSubInputs[allSubInputs.length - 1];
                    
                    if (lastSubInput) {
                        lastSubInput.value = subName;
                    }
                });
            });
            
            document.getElementById('createRubricCard').classList.remove('hidden');
            document.getElementById('createRubricCard').scrollIntoView({ behavior: 'smooth' });
        }

        // ===== STUDENT MANAGEMENT =====
        function showAddStudent() {
            document.getElementById('addStudentCard').classList.remove('hidden');
        }

        function cancelAddStudent() {
            document.getElementById('addStudentCard').classList.add('hidden');
            document.getElementById('addStudentForm').reset();
        }

        async function viewStudentEvals(studentId) {
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const cls = classes.find(c => c.id === currentClassId);
            if (!cls) return;
            
            const student = cls.roster.find(s => s.id === studentId || s.supabaseId === studentId);
            if (!student) {
                alert('Student not found.');
                return;
            }
            
            // Load evaluations from Supabase
            let allEvals = [];
            if (supabaseClient && cls.supabaseId) {
                const supabaseEvals = await loadEvaluationsFromSupabase(cls.supabaseId, student.supabaseId || studentId);
                if (supabaseEvals && supabaseEvals.length > 0) {
                    allEvals = supabaseEvals.map(ev => ({
                        date: new Date(ev.created_at).toLocaleDateString(),
                        type: ev.evaluation_data?.assignmentType || 'Unknown',
                        results: ev.evaluation_data,
                        supabaseId: ev.id
                    }));
                }
            }
            
            // Also check localStorage
            if (student.evaluations && student.evaluations.length > 0) {
                allEvals = [...allEvals, ...student.evaluations];
            }
            
            if (allEvals.length === 0) {
                alert('No evaluations found for this student.');
                return;
            }
            
            let html = `
                <div class="card">
                    <div class="card-header">${student.firstName} ${student.lastName} - Evaluations</div>
                    <div style="margin-bottom: 1rem;">
                        <button onclick="viewClass('${currentClassId}')" class="btn-secondary">‚Üê Back to Class</button>
                    </div>
                    <div style="color: var(--text-light); margin-bottom: 1rem;">Click on an evaluation to view details</div>
            `;
            
            allEvals.forEach((ev, index) => {
                const date = ev.date || 'No date';
                const type = ev.type || 'Unknown';
                const results = ev.results;
                const evalId = ev.supabaseId || ev.id;
                const percentage = (((results.totalScore || 0) / (results.maxScore || 50)) * 100).toFixed(0);
                let color = 'var(--success)';
                if (percentage < 70) color = 'var(--error)';
                else if (percentage < 80) color = 'var(--warning)';
                
                html += `
                    <div style="background: var(--bg-alt); border-radius: 0.5rem; margin-bottom: 0.75rem; border-left: 4px solid ${color}; overflow: hidden;">
                        <!-- Collapsed Header (clickable) -->
                        <div onclick="toggleEvaluation('eval-${index}')" style="padding: 1rem; cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong style="font-size: 1.1rem;">${type}</strong><br>
                                <span style="color: var(--text-light); font-size: 0.9rem;">${date}</span>
                            </div>
                            <div style="text-align: right; display: flex; align-items: center; gap: 1rem;">
                                <div>
                                    <div style="font-size: 1.3rem; font-weight: bold; color: var(--primary);">
                                        ${results.totalScore || 0}/${results.maxScore || 50}
                                    </div>
                                    <div style="font-size: 0.9rem; color: ${color}; font-weight: 600;">${percentage}% ‚Ä¢ ${results.letterGrade || 'N/A'}</div>
                                </div>
                                <span id="eval-${index}-arrow" style="font-size: 1.2rem; color: var(--text-light);">‚ñº</span>
                            </div>
                        </div>
                        
                        <!-- Expanded Details (hidden by default) -->
                        <div id="eval-${index}" class="hidden" style="padding: 0 1rem 1rem 1rem; border-top: 1px solid var(--border);">
                            <div style="padding-top: 1rem;">
                `;
                
                // Display individual sections
                if (results.sections) {
                    html += '<div style="background: white; padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem;">';
                    html += '<strong style="display: block; margin-bottom: 0.75rem;">Section Scores:</strong>';
                    
                    Object.keys(results.sections).forEach(sectionKey => {
                        const section = results.sections[sectionKey];
                        const sectionName = sectionKey.charAt(0).toUpperCase() + sectionKey.slice(1);
                        html += `
                            <div style="border-left: 3px solid var(--primary); padding-left: 1rem; margin-bottom: 1rem;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                                    <strong>${sectionName}</strong>
                                    <span style="color: var(--primary); font-weight: bold;">${section.score}/${section.maxScore}</span>
                                </div>
                                <p style="color: var(--text-light); margin: 0; font-size: 0.9rem;">${section.feedback || 'No feedback'}</p>
                            </div>
                        `;
                    });
                    
                    html += '</div>';
                }
                
                // Display timeline markers if available
                if (results.timeline_markers && results.timeline_markers.length > 0) {
                    html += `
                        <div style="background: white; padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem;">
                            <strong style="display: block; margin-bottom: 0.75rem;">‚è±Ô∏è Timeline Markers (${results.timeline_markers.length}):</strong>
                    `;
                    
                    // Group by category
                    const markersByCategory = {};
                    results.timeline_markers.forEach(marker => {
                        if (!markersByCategory[marker.category]) {
                            markersByCategory[marker.category] = [];
                        }
                        markersByCategory[marker.category].push(marker);
                    });
                    
                    Object.keys(markersByCategory).forEach(category => {
                        html += `<div style="margin-bottom: 1rem;"><strong style="color: var(--primary);">${category}:</strong><div style="margin-top: 0.5rem;">`;
                        
                        markersByCategory[category].forEach(marker => {
                            const markerColor = {positive: '#10b981', minor: '#f59e0b', moderate: '#f59e0b', major: '#ef4444'}[marker.severity] || '#f59e0b';
                            const icon = {positive: '‚úì', minor: '‚ö†', moderate: '‚ö†', major: '‚úï'}[marker.severity] || '‚ö†';
                            
                            html += `
                                <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem; padding: 0.5rem; background: var(--bg-alt); border-left: 3px solid ${markerColor}; border-radius: 0.25rem;">
                                    <span style="color: ${markerColor}; font-weight: bold; min-width: 50px;">[${marker.timestamp}]</span>
                                    <span><strong>${icon} ${marker.issue}:</strong> ${marker.note}</span>
                                </div>
                            `;
                        });
                        
                        html += `</div></div>`;
                    });
                    
                    html += '</div>';
                }
                
                // Display overall comments
                html += `
                    <div style="background: white; padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem;">
                        <strong>Overall Comments:</strong><br>
                        <p style="margin: 0.5rem 0 0 0;">${results.overallComments || 'No comments'}</p>
                    </div>
                    
                    <div style="display: flex; gap: 1rem;">
                        <button onclick="editSavedEvaluation('${evalId}', '${studentId}')" style="background: var(--primary); color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: pointer; font-weight: 600;">‚úèÔ∏è Edit Evaluation</button>
                        <button onclick="downloadSavedEvaluation('${evalId}', '${studentId}')" style="background: var(--secondary); color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: pointer; font-weight: 600;">üìÑ Download Report</button>
                    </div>
                    </div>
                    </div>
                    </div>
                `;
            });
            
            html += '</div>';
            document.getElementById('classDetailContent').innerHTML = html;
        }
        
        // Toggle evaluation expand/collapse
        function toggleEvaluation(evalId) {
            const content = document.getElementById(evalId);
            const arrow = document.getElementById(evalId + '-arrow');
            
            if (content.classList.contains('hidden')) {
                content.classList.remove('hidden');
                arrow.textContent = '‚ñ≤';
            } else {
                content.classList.add('hidden');
                arrow.textContent = '‚ñº';
            }
        }

        function deleteStudent(studentId) {
            if (!confirm('Are you sure you want to delete this student?')) return;
            
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const classIndex = classes.findIndex(c => c.id === currentClassId);
            
            if (classIndex !== -1) {
                classes[classIndex].roster = classes[classIndex].roster.filter(s => s.id !== studentId);
                setUserItem('classes', JSON.stringify(classes));
                viewClass(currentClassId); // Refresh the view
            }
        }

        // Edit saved evaluation
        let editingEvaluationId = null;
        let editingStudentId = null;
        
        async function editSavedEvaluation(evaluationId, studentId) {
            console.log('=== editSavedEvaluation START ===');
            console.log('Evaluation ID:', evaluationId);
            console.log('Student ID:', studentId);
            
            // Store IDs for later update
            editingEvaluationId = evaluationId;
            editingStudentId = studentId;
            
            // Load the evaluation from Supabase or localStorage
            let evaluation = null;
            
            if (supabaseClient && currentUser) {
                console.log('Loading from Supabase...');
                const { data, error } = await supabaseClient
                    .from('evaluations')
                    .select('*')
                    .eq('id', evaluationId)
                    .single();
                
                if (data) {
                    console.log('‚úì Loaded from Supabase');
                    evaluation = data.evaluation_data;
                } else if (error) {
                    console.error('Supabase error:', error);
                }
            }
            
            // Fallback to localStorage if not in Supabase
            if (!evaluation) {
                console.log('Trying localStorage...');
                const classes = JSON.parse(getUserItem('classes') || '[]');
                const cls = classes.find(c => c.id === currentClassId);
                if (cls) {
                    const student = cls.roster.find(s => s.id === studentId || s.supabaseId === studentId);
                    if (student && student.evaluations) {
                        const evalRecord = student.evaluations.find(e => e.id === evaluationId || e.supabaseId === evaluationId);
                        if (evalRecord) {
                            evaluation = evalRecord.results;
                            console.log('‚úì Loaded from localStorage');
                        }
                    }
                }
            }
            
            if (!evaluation) {
                console.error('Could not load evaluation!');
                alert('Could not load evaluation for editing.');
                return;
            }
            
            console.log('Evaluation loaded:', evaluation);
            
            // CRITICAL: Ensure gradeScale is present (for old evaluations that don't have it)
            if (!evaluation.gradeScale && evaluation.rubricUsed) {
                console.log('‚ö†Ô∏è gradeScale missing, attempting to fetch from rubric...');
                const allRubrics = await getAllRubrics();
                const matchingRubric = allRubrics.find(r => r.name === evaluation.rubricUsed);
                if (matchingRubric && matchingRubric.gradeScale) {
                    evaluation.gradeScale = matchingRubric.gradeScale;
                    console.log('‚úì gradeScale restored from rubric:', matchingRubric.name);
                    
                    // Recalculate letter grade with the restored gradeScale
                    const percentage = ((evaluation.totalScore / evaluation.maxScore) * 100).toFixed(1);
                    evaluation.letterGrade = getLetterGrade(percentage, evaluation.gradeScale);
                    evaluation.percentage = percentage;
                    console.log('‚úì Recalculated letterGrade:', evaluation.letterGrade);
                } else {
                    console.warn('‚ö†Ô∏è Could not find matching rubric to restore gradeScale');
                }
            }
            
            // Set the evaluation as current for editing
            evaluationResults = evaluation;
            correctionLog = evaluation.corrections || [];
            console.log('Set evaluationResults and correctionLog');
            
            // Hide all main sections
            console.log('Hiding main sections...');
            const mainSections = ['dashboardSection'];
            mainSections.forEach(id => {
                const element = document.getElementById(id);
                console.log(`  ${id}:`, element ? 'found' : 'NOT FOUND');
                if (element) {
                    element.classList.remove('active');
                    console.log(`  ${id}: hidden`);
                }
            });
            
            // Show evaluation section
            console.log('Showing evaluation section...');
            const evalSection = document.getElementById('evaluateSection');
            console.log('  evaluateSection:', evalSection ? 'found' : 'NOT FOUND');
            if (evalSection) {
                evalSection.classList.add('active');
                console.log('  evaluateSection: visible');
            }
            
            // Hide all steps within evaluation section
            console.log('Hiding other steps...');
            const steps = ['uploadStep', 'detailsStep', 'processingStep'];
            steps.forEach(id => {
                const element = document.getElementById(id);
                console.log(`  ${id}:`, element ? 'found' : 'NOT FOUND');
                if (element) {
                    element.classList.add('hidden');
                    console.log(`  ${id}: hidden`);
                }
            });
            
            // Show results step
            console.log('Showing results step...');
            const resultsStep = document.getElementById('resultsStep');
            console.log('  resultsStep:', resultsStep ? 'found' : 'NOT FOUND');
            console.log('  resultsStep classes before:', resultsStep ? resultsStep.className : 'N/A');
            if (resultsStep) {
                resultsStep.classList.remove('hidden');
                console.log('  resultsStep classes after:', resultsStep.className);
                console.log('  resultsStep: visible');
            }
            
            // Display the results for editing
            console.log('Calling displayResults...');
            displayResults(evaluation);
            console.log('displayResults complete');
            
            // Check if content was added
            const resultsContent = document.getElementById('resultsContent');
            console.log('resultsContent:', resultsContent ? 'found' : 'NOT FOUND');
            console.log('resultsContent innerHTML length:', resultsContent ? resultsContent.innerHTML.length : 0);
            
            // Show notification
            showNotification('üìù Editing Mode: Make changes and click "Save Results" to update.', 'info');
            
            // Scroll to top
            window.scrollTo(0, 0);
            
            console.log('=== editSavedEvaluation END ===');
        }
        
        // Download saved evaluation
        async function downloadSavedEvaluation(evaluationId, studentId) {
            let evaluation = null;
            
            if (supabaseClient && currentUser) {
                const { data, error } = await supabaseClient
                    .from('evaluations')
                    .select('*')
                    .eq('id', evaluationId)
                    .single();
                
                if (data) {
                    evaluation = data.evaluation_data;
                }
            }
            
            if (!evaluation) {
                const classes = JSON.parse(getUserItem('classes') || '[]');
                const cls = classes.find(c => c.id === currentClassId);
                if (cls) {
                    const student = cls.roster.find(s => s.id === studentId || s.supabaseId === studentId);
                    if (student && student.evaluations) {
                        const evalRecord = student.evaluations.find(e => e.id === evaluationId || e.supabaseId === evaluationId);
                        if (evalRecord) {
                            evaluation = evalRecord.results;
                        }
                    }
                }
            }
            
            if (!evaluation) {
                alert('Could not load evaluation for download.');
                return;
            }
            
            // Export as HTML
            const studentName = evaluation.studentName || 'Student';
            await exportEvaluationHTML(evaluation, studentName);
        }
        
        // Cancel editing mode
        function cancelEdit() {
            if (confirm('Cancel editing? Any unsaved changes will be lost.')) {
                editingEvaluationId = null;
                editingStudentId = null;
                correctionLog = [];
                
                // Return to class view
                viewClass(currentClassId);
            }
        }

        // ===== SETTINGS =====
        function loadSavedSettings() {
            // Load all three API keys
            const geminiKey = localStorage.getItem('gemini_api_key');
            const openaiKey = localStorage.getItem('openai_api_key');
            const claudeKey = localStorage.getItem('anthropic_api_key');
            
            if (geminiKey) {
                document.getElementById('savedGeminiKey').value = geminiKey;
            }
            if (openaiKey) {
                document.getElementById('savedOpenAIKey').value = openaiKey;
            }
            if (claudeKey) {
                document.getElementById('savedClaudeKey').value = claudeKey;
            }
            
            // Note: Theme settings (colors, fonts, logo) are now managed by admins
            // in the Theme Customizer, not in user settings
        }

        function saveSettings() {
            // Save all three API keys
            const geminiKey = document.getElementById('savedGeminiKey').value.trim();
            const openaiKey = document.getElementById('savedOpenAIKey').value.trim();
            const claudeKey = document.getElementById('savedClaudeKey').value.trim();
            
            if (geminiKey) {
                localStorage.setItem('gemini_api_key', geminiKey);
            }
            if (openaiKey) {
                localStorage.setItem('openai_api_key', openaiKey);
            }
            if (claudeKey) {
                localStorage.setItem('anthropic_api_key', claudeKey);
            }
            
            // Save theme settings
            const primaryColor = document.getElementById('primaryColor').value;
            const headingFont = document.getElementById('headingFont').value;
            const bodyFont = document.getElementById('bodyFont').value;
            
            localStorage.setItem('primary_color', primaryColor);
            localStorage.setItem('heading_font', headingFont);
            localStorage.setItem('body_font', bodyFont);
            
            showMessage('settingsMessage', '‚úÖ Settings saved successfully! Your API keys are now stored securely.', 'success');
        }

        function resetSettings() {
            if (!confirm('Reset all settings to defaults? This will clear all saved API keys.')) return;
            
            // Clear all API keys
            localStorage.removeItem('gemini_api_key');
            localStorage.removeItem('openai_api_key');
            localStorage.removeItem('anthropic_api_key');
            localStorage.removeItem('current_tenant');
            localStorage.removeItem('custom_logo');
            localStorage.removeItem('primary_color');
            localStorage.removeItem('heading_font');
            localStorage.removeItem('body_font');
            
            // Reset form fields
            document.getElementById('savedGeminiKey').value = '';
            document.getElementById('savedOpenAIKey').value = '';
            document.getElementById('savedClaudeKey').value = '';
            
            currentTenant = 'default';
            applyTenant('default');
            
            showMessage('settingsMessage', '‚úÖ Settings reset to defaults.', 'success');
        }

        // Note: handleLogoUpload is defined earlier in the theme customizer section
        // Old duplicate removed to prevent conflicts

        function updatePrimaryColor(color) {
            document.documentElement.style.setProperty('--primary', color);
            
            // Generate dark variant
            const darkColor = adjustColorBrightness(color, -20);
            document.documentElement.style.setProperty('--primary-dark', darkColor);
        }

        function adjustColorBrightness(hex, percent) {
            const num = parseInt(hex.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255))
                .toString(16).slice(1);
        }

        function updateFonts() {
            const headingFont = document.getElementById('headingFont').value;
            const bodyFont = document.getElementById('bodyFont').value;
            
            document.documentElement.style.setProperty('--heading-font', headingFont);
            document.documentElement.style.setProperty('--body-font', bodyFont);
        }

        // ===== UTILITIES =====
        function showMessage(elementId, message, type) {
            const el = document.getElementById(elementId);
            el.textContent = message;
                el.className = type === 'error' ? 'error-message' : 'success-message';
        }

        // ===== SAVE TO CLASS FUNCTIONS =====
        function openSaveModal() {
            // If editing, just update directly without modal
            if (editingEvaluationId) {
                updateExistingEvaluation();
                return;
            }
            
            // Otherwise show the save modal as normal
            try {
                var classes = JSON.parse(getUserItem('classes') || '[]');
                var sel = document.getElementById('saveClassSel');
                sel.innerHTML = '<option value="">-- Select Class --</option>';
                for (var i = 0; i < classes.length; i++) {
                    var opt = document.createElement('option');
                    opt.value = i;
                    opt.textContent = classes[i].name + ' - ' + classes[i].semester + ' ' + classes[i].year;
                    sel.appendChild(opt);
                }
                document.getElementById('saveModal').style.display = 'flex';
            } catch(e) {
                console.error(e);
            }
        }

        function loadSaveStudents() {
            try {
                var idx = document.getElementById('saveClassSel').value;
                var sel = document.getElementById('saveStudentSel');
                sel.innerHTML = '<option value="">-- Select Student --</option>';
                if (!idx) return;
                var classes = JSON.parse(getUserItem('classes') || '[]');
                var cls = classes[idx];
                if (cls && cls.roster) {
                    for (var i = 0; i < cls.roster.length; i++) {
                        var s = cls.roster[i];
                        var opt = document.createElement('option');
                        opt.value = i;
                        opt.textContent = s.firstName + ' ' + s.lastName;
                        sel.appendChild(opt);
                    }
                }
            } catch(e) {
                console.error(e);
            }
        }

        async function doSaveEval() {
            try {
                // Check account tier for save permission
                if (!hasResearchAccess()) {
                    const upgrade = confirm(
                        'üé≠ Demo Mode Limitation\n\n' +
                        'Evaluations cannot be saved in Demo mode.\n\n' +
                        'To save evaluations and contribute to research:\n' +
                        '‚Ä¢ Upgrade to Research Partner\n' +
                        '‚Ä¢ Full evaluation storage\n' +
                        '‚Ä¢ Correction tracking\n' +
                        '‚Ä¢ Help improve AI\n\n' +
                        'Contact speechgradebook@proton.me to upgrade.\n\n' +
                        'Click OK to copy email address.'
                    );
                    
                    if (upgrade) {
                        // Copy email to clipboard
                        navigator.clipboard.writeText('speechgradebook@proton.me').then(() => {
                            alert('Email address copied to clipboard!');
                        });
                    }
                    return;
                }
                
                // Check if we're editing an existing evaluation
                const isEditing = editingEvaluationId !== null;
                
                if (isEditing) {
                    // UPDATE existing evaluation
                    await updateExistingEvaluation();
                } else {
                    // INSERT new evaluation (original behavior)
                    var cIdx = document.getElementById('saveClassSel').value;
                    var sIdx = document.getElementById('saveStudentSel').value;
                    if (!cIdx || sIdx === '') {
                        alert('Please select both class and student');
                        return;
                    }
                    if (!evaluationResults) {
                        alert('No evaluation to save');
                        return;
                    }
                    
                    // Get class and student info
                    var classes = JSON.parse(getUserItem('classes') || '[]');
                    var classData = classes[cIdx];
                    var student = classData.roster[sIdx];
                    
                    if (!student.evaluations) {
                        student.evaluations = [];
                    }
                    
                    // Create evaluation record
                    var rec = {
                        id: Date.now().toString(),
                        date: document.getElementById('speechDate').value,
                        type: document.getElementById('assignmentType').value,
                        results: evaluationResults,
                        corrections: correctionLog,  // Include instructor corrections
                        editedAt: correctionLog.length > 0 ? new Date().toISOString() : null,
                        savedAt: new Date().toISOString()
                    };
                    
                    // Save to localStorage first (immediate)
                    student.evaluations.push(rec);
                    classes[cIdx].roster[sIdx] = student;
                    setUserItem('classes', JSON.stringify(classes));
                    console.log('‚úì Evaluation saved to localStorage');
                    
                    // Also save to Supabase if available
                    if (supabaseClient && currentUser) {
                        const rubricId = document.getElementById('rubricSelect').value;
                        
                        // Get Supabase IDs if they exist
                        const courseSupabaseId = classData.supabaseId || classData.id;
                        const studentSupabaseId = student.supabaseId || student.id;
                        
                        // Get rubric's Supabase ID
                        const rubrics = await getAllRubrics();
                        const selectedRubric = rubrics.find(r => r.id === rubricId);
                        const rubricSupabaseId = selectedRubric?.supabaseId || null;
                        
                        console.log('Attempting Supabase save with IDs:', {
                            course: courseSupabaseId,
                            student: studentSupabaseId,
                            rubric: rubricSupabaseId,
                            user: currentUser.id
                        });
                        
                        // Only save if all IDs are valid UUIDs
                        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
                        const validIds = uuidRegex.test(courseSupabaseId) && 
                                       uuidRegex.test(studentSupabaseId) && 
                                       (!rubricSupabaseId || uuidRegex.test(rubricSupabaseId));
                        
                        if (validIds) {
                            try {
                                const result = await saveEvaluationToSupabase(
                                    evaluationResults,
                                    courseSupabaseId,
                                    studentSupabaseId,
                                    rubricSupabaseId
                                );
                                
                                if (result) {
                                    console.log('‚úì Evaluation saved to Supabase with ID:', result.id);
                                } else {
                                    console.warn('‚ö†Ô∏è Supabase save returned null - check console for errors');
                                }
                            } catch (error) {
                                console.error('Error saving to Supabase:', error);
                            }
                        } else {
                            console.warn('‚ö†Ô∏è Invalid UUIDs for Supabase save:', {
                                course: courseSupabaseId,
                                student: studentSupabaseId,
                                rubric: rubricSupabaseId
                            });
                            console.log('Note: Course, student, and rubric must be created in Supabase before evaluations can be saved to database');
                        }
                    } else {
                        console.log('Supabase not available or user not logged in');
                    }
                    
                    alert('‚úì Evaluation saved for ' + student.firstName + ' ' + student.lastName);
                    closeSaveModal();
                }
            } catch(e) {
                console.error('Error saving evaluation:', e);
                alert('Error: ' + e.message);
            }
        }
        
        // Update existing evaluation
        async function updateExistingEvaluation() {
            if (!evaluationResults || !editingEvaluationId) {
                alert('No evaluation to update');
                return;
            }
            
            // Update in Supabase
            if (supabaseClient && currentUser) {
                try {
                    const { data, error } = await supabaseClient
                        .from('evaluations')
                        .update({
                            evaluation_data: {
                                sections: evaluationResults.sections,
                                studentName: evaluationResults.studentName,
                                speechDate: evaluationResults.speechDate,
                                assignmentType: evaluationResults.assignmentType,
                                speechTime: evaluationResults.speechTime,
                                rubricUsed: evaluationResults.rubricUsed,
                                totalScore: evaluationResults.totalScore,
                                maxScore: evaluationResults.maxScore,
                                percentage: evaluationResults.percentage,
                                letterGrade: evaluationResults.letterGrade,
                                gradeScale: evaluationResults.gradeScale,
                                overallComments: evaluationResults.overallComments,
                                timeline_markers: evaluationResults.timeline_markers || [],
                                corrections: correctionLog || [],
                                edited: true,
                                editedAt: new Date().toISOString()
                            },
                            total_score: evaluationResults.totalScore || 0,
                            letter_grade: evaluationResults.letterGrade || 'N/A',
                            updated_at: new Date().toISOString()
                        })
                        .eq('id', editingEvaluationId);
                    
                    if (error) {
                        console.error('Error updating evaluation:', error);
                        alert('Error updating evaluation in database: ' + error.message);
                        return;
                    }
                    
                    console.log('‚úì Evaluation updated in Supabase');
                } catch (error) {
                    console.error('Supabase error:', error);
                    alert('Error updating evaluation: ' + error.message);
                    return;
                }
            }
            
            // Also update localStorage
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const cls = classes.find(c => c.id === currentClassId);
            if (cls) {
                const student = cls.roster.find(s => s.id === editingStudentId || s.supabaseId === editingStudentId);
                if (student && student.evaluations) {
                    const evalIndex = student.evaluations.findIndex(e => 
                        e.id === editingEvaluationId || e.supabaseId === editingEvaluationId
                    );
                    if (evalIndex !== -1) {
                        student.evaluations[evalIndex].results = evaluationResults;
                        student.evaluations[evalIndex].corrections = correctionLog;
                        student.evaluations[evalIndex].editedAt = new Date().toISOString();
                        setUserItem('classes', JSON.stringify(classes));
                        console.log('‚úì Evaluation updated in localStorage');
                    }
                }
            }
            
            alert('‚úì Evaluation updated successfully!');
            
            // Clear editing state
            editingEvaluationId = null;
            editingStudentId = null;
            
            // Return to class view
            viewClass(currentClassId);
        }

        function closeSaveModal() {
            document.getElementById('saveModal').style.display = 'none';
        }
    </script>
    </div> <!-- End mainApp -->
</body>
</html>
