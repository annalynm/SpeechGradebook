<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speech Gradebook v3.0 - Supabase Edition</title>
    <link rel="icon" href="assets/logo-light-bg.png" type="image/png">
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&family=Roboto:wght@400;500;700&family=Open+Sans:wght@400;600;700&family=Georgia&family=Crimson+Pro:wght@400;600;700&family=Work+Sans:wght@400;600;700&display=swap" rel="stylesheet">
    
    <!-- Supabase JS Library -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- Lucide Icons (replaces emojis in UI) -->
    <script src="https://unpkg.com/lucide@0.460.0/dist/umd/lucide.js"></script>
    
    <style>
        /* SpeechGradebook theme (default) - dark blue. Custom themes (e.g. University of Tennessee) override via JS from institution_themes. */
        :root {
            --primary: #1e3a5f;
            --primary-dark: #142940;
            --secondary: #c8a882;
            --accent: #d4af37;
            --text: #2c3e50;
            --text-light: #6c757d;
            --bg: #fafbfc;
            --bg-alt: #f1f4f7;
            --card: #ffffff;
            --border: #e1e8ed;
            --success: #059669;
            --warning: #d97706;
            --error: #b91c1c;
            --heading-font: 'Crimson Pro', serif;
            --body-font: 'Work Sans', sans-serif;
            --heading-weight: 700;
            --body-weight: 400;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* Targeted approach: Only force normal weight on text content elements */
        /* This prevents custom fonts from appearing bold while preserving button styles */
        p, span, a:not(.button):not(.btn):not(.nav-link),
        li, td, label:not([for]), 
        .class-card, .student-card, .eval-card,
        .class-meta, .class-stats, .stat-label,
        textarea, input[type="text"], input[type="email"], input[type="password"], select {
            font-weight: 400 !important;
            font-style: normal !important;
        }
        
        /* Explicitly allow bold for semantic elements */
        h1, h2, h3, h4, h5, h6,
        strong, b, .font-bold,
        th {
            font-weight: 700 !important;
        }
        
        /* Explicitly allow italic for semantic elements */
        em, i, .font-italic {
            font-style: italic !important;
        }
        
        /* Preserve button and UI element weights (semi-bold for clarity) */
        button, .btn, .button,
        input[type="button"], input[type="submit"],
        .nav-link,
        .card-header,
        .step-label.active {
            font-weight: 600 !important;
        }
        
        body {
            font-family: var(--body-font);
            font-weight: 400; /* Always normal weight */
            font-style: normal; /* Always normal style */
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
        }
        
        h1, h2, h3, h4, h5, h6 {
            font-family: var(--heading-font);
            font-weight: 700; /* Always bold for headings */
            font-style: normal; /* Always normal style */
            color: var(--primary);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 1rem;
        }
        
        /* Header */
        header {
            font-family: var(--body-font);
            background: var(--primary-dark);
            color: white;
            padding: 1.25rem 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo-section {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .logo {
            width: 70px;
            height: 70px;
            background: #ffffff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.8rem;
            color: var(--primary);
            flex-shrink: 0; /* Prevent compression */
        }
        
        .logo img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
            border-radius: 50%;
        }
        /* Header logo circle: always pure white on account pages (no yellow/theme tint) */
        header .logo,
        header #appLogo {
            position: relative;
            background: #ffffff !important;
            background-color: #ffffff !important;
        }
        header #appLogo img {
            position: relative;
            z-index: 0;
        }
        
        .app-title h1 {
            font-family: var(--heading-font);
            font-weight: 700;
            color: white;
            font-size: 1.8rem;
            margin-bottom: 0.2rem;
        }
        
        .tagline {
            font-size: 0.9rem;
            opacity: 0.9;
        }
        
        /* Navigation */
        nav {
            font-family: var(--body-font);
            display: flex;
            gap: 1.5rem;
        }
        
        .nav-link {
            color: white;
            text-decoration: none;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            transition: background 0.3s;
        }
        
        .nav-link:hover {
            background: rgba(255,255,255,0.1);
        }
        
        .nav-link.active {
            background: rgba(255,255,255,0.2);
        }
        
        /* Main Content */
        main {
            font-family: var(--body-font);
            padding: 2rem 0;
            min-height: calc(100vh - 200px);
        }
        
        .section {
            display: none;
        }
        
        .section.active {
            display: block;
        }
        
        /* Cards */
        .card {
            background: var(--card);
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            margin-bottom: 2rem;
        }
        
        .card-header {
            font-family: var(--heading-font);
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            color: var(--primary);
            border-bottom: 2px solid var(--border);
            padding-bottom: 1rem;
        }
        
        /* Analytics tabs: affordance + responsive */
        .analytics-tablist {
            flex-wrap: nowrap;
            min-width: 0;
            -webkit-overflow-scrolling: touch;
        }
        .analytics-tab {
            padding: 0.75rem 1.5rem;
            border: none;
            background: none;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            color: var(--text-light);
            font-weight: 400;
            font-size: 1rem;
            white-space: nowrap;
            flex-shrink: 0;
            border-radius: 0.25rem 0.25rem 0 0;
            transition: background 0.2s, color 0.2s, border-color 0.2s;
        }
        .analytics-tab:hover {
            color: var(--text);
            background: rgba(0,0,0,0.03);
        }
        .analytics-tab:focus-visible {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
        }
        .analytics-tab-active {
            border-bottom-color: var(--primary);
            color: var(--primary);
            font-weight: 600;
            background: rgba(30, 58, 95, 0.06);
        }
        
        /* Instructor dashboard top-level tabs (Courses | Rubrics | Course Insights) */
        .instructor-dashboard-tablist {
            display: flex;
            gap: 0.25rem;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--border);
            padding-bottom: 0;
            flex-wrap: wrap;
        }
        .instructor-dashboard-tab {
            padding: 0.75rem 1.25rem;
            border: none;
            background: none;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
            color: var(--text-light);
            font-weight: 500;
            font-size: 1rem;
            border-radius: 0.25rem 0.25rem 0 0;
            transition: background 0.2s, color 0.2s, border-color 0.2s;
        }
        .instructor-dashboard-tab:hover {
            color: var(--text);
            background: rgba(0,0,0,0.04);
        }
        .instructor-dashboard-tab-active {
            border-bottom-color: var(--primary);
            color: var(--primary);
            font-weight: 600;
            background: rgba(30, 58, 95, 0.06);
        }

        /* Settings section tabs (General | Consent | Admin) */
        .settings-tablist {
            display: flex;
            gap: 0.25rem;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--border);
            padding-bottom: 0;
            flex-wrap: wrap;
        }
        .settings-tab {
            padding: 0.75rem 1.25rem;
            border: none;
            background: none;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
            color: var(--text-light);
            font-weight: 500;
            font-size: 1rem;
            border-radius: 0.25rem 0.25rem 0 0;
            transition: background 0.2s, color 0.2s, border-color 0.2s;
        }
        .settings-tab:hover {
            color: var(--text);
            background: rgba(0,0,0,0.04);
        }
        .settings-tab-active {
            border-bottom-color: var(--primary);
            color: var(--primary);
            font-weight: 600;
        }
        .settings-section-heading {
            font-weight: 700;
            margin-bottom: 1rem;
        }
        .settings-section-subheading {
            margin-bottom: 1rem;
            color: var(--primary);
        }

        /* Support section tabs (Getting Started | User Manual | Technical Documentation) */
        .support-tablist {
            display: flex;
            gap: 0.25rem;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--border);
            padding-bottom: 0;
            flex-wrap: wrap;
        }
        .support-tab {
            padding: 0.75rem 1.25rem;
            border: none;
            background: none;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
            color: var(--text-light);
            font-weight: 500;
            font-size: 1rem;
            border-radius: 0.25rem 0.25rem 0 0;
            transition: background 0.2s, color 0.2s, border-color 0.2s;
        }
        .support-tab:hover {
            color: var(--text);
            background: rgba(0,0,0,0.04);
        }
        .support-tab-active {
            border-bottom-color: var(--primary);
            color: var(--primary);
            font-weight: 600;
        }
        .support-tier-badge {
            display: inline-block;
            font-size: 0.75rem;
            padding: 0.2rem 0.5rem;
            border-radius: 0.25rem;
            background: var(--bg-alt);
            color: var(--text-light);
            margin-left: 0.5rem;
        }
        .support-doc-panel { display: none; }
        .support-doc-panel.active { display: block; }
        #helpSection .support-doc-panel h3,
        #helpSection .support-doc-panel h3 .icon-with-text {
            font-family: var(--heading-font);
            font-weight: 700;
            font-size: 1.25rem;
            color: var(--primary);
        }

        /* Toast for analytics success */
        .analytics-toast {
            position: fixed;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            background: var(--primary);
            color: white;
            padding: 0.75rem 1.25rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 9999;
            font-size: 0.9rem;
            animation: analyticsToastIn 0.25s ease;
        }
        .analytics-toast a { color: #fff; text-decoration: underline; }
        @keyframes analyticsToastIn {
            from { opacity: 0; transform: translateX(-50%) translateY(0.5rem); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        
        /* Theme Customizer (Settings Admin tab) */
        
        /* HTML Color Codes–style picker: 2D saturation/lightness + hue strip */
        .theme-color-picker-panel {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            box-shadow: 0 20px 60px rgba(0,0,0,0.2);
            padding: 1.25rem;
            min-width: 280px;
        }
        .theme-color-picker-panel.open { display: block; }
        .theme-color-picker-panel .picker-2d-wrap {
            position: relative;
            width: 240px;
            height: 160px;
            border-radius: 0.5rem;
            overflow: hidden;
            border: 1px solid var(--border);
            cursor: crosshair;
            touch-action: none;
        }
        .theme-color-picker-panel .picker-2d {
            width: 100%;
            height: 100%;
            background-image:
                linear-gradient(to bottom, #fff, transparent),
                linear-gradient(to top, #000, transparent),
                linear-gradient(to right, #808080, var(--picker-hue-color, #f00));
            background-size: 100% 100%;
        }
        .theme-color-picker-panel .picker-2d-marker {
            position: absolute;
            width: 14px;
            height: 14px;
            margin: -7px 0 0 -7px;
            border: 2px solid #fff;
            border-radius: 50%;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.4);
            pointer-events: none;
        }
        .theme-color-picker-panel .picker-hue-wrap {
            position: relative;
            width: 240px;
            height: 12px;
            margin-top: 0.75rem;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid var(--border);
            cursor: pointer;
            touch-action: none;
            background: linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00);
        }
        .theme-color-picker-panel .picker-hue-marker {
            position: absolute;
            top: 0;
            width: 4px;
            height: 100%;
            margin-left: -2px;
            background: #fff;
            border-radius: 2px;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.3);
            pointer-events: none;
        }
        .theme-color-picker-panel .picker-codes {
            margin-top: 0.75rem;
            display: flex;
            gap: 0.75rem;
            align-items: center;
            flex-wrap: wrap;
        }
        .theme-color-picker-panel .picker-codes label {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-light);
        }
        .theme-color-picker-panel .picker-codes input {
            padding: 0.35rem 0.5rem;
            border: 1px solid var(--border);
            border-radius: 0.25rem;
            font-size: 0.875rem;
            font-family: ui-monospace, monospace;
        }
        .theme-color-picker-panel .picker-preview {
            width: 36px;
            height: 36px;
            border-radius: 0.375rem;
            border: 1px solid var(--border);
            flex-shrink: 0;
        }
        .theme-color-picker-panel .picker-actions {
            margin-top: 1rem;
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
        }
        .theme-color-picker-panel .picker-backdrop {
            position: fixed;
            inset: 0;
            z-index: -1;
            background: rgba(0,0,0,0.35);
        }
        
        /* Upload Zone */
        .upload-zone {
            border: 3px dashed var(--border);
            border-radius: 1rem;
            padding: 3rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: var(--bg-alt);
        }
        
        .upload-zone:hover {
            border-color: var(--primary);
            background: white;
        }
        
        .upload-zone.drag-over {
            border-color: var(--primary);
            background: rgba(30, 58, 95, 0.05);
        }
        
        .upload-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
        
        .file-info {
            background: var(--success);
            color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        /* Forms */
        .form-group {
            margin-bottom: 1.5rem;
        }
        
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--text);
        }
        
        input[type="text"],
        input[type="email"],
        input[type="date"],
        input[type="number"],
        input[type="password"],
        select,
        textarea {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--border);
            border-radius: 0.5rem;
            font-size: 1rem;
            font-family: var(--body-font);
            transition: border-color 0.3s;
        }
        
        input:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        textarea {
            resize: vertical;
            min-height: 100px;
        }
        
        /* Buttons */
        button,
        .btn {
            background: var(--primary);
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-block;
            text-decoration: none;
            text-align: center;
        }
        
        button:hover,
        .btn:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .btn-secondary {
            background: var(--secondary);
        }
        
        .btn-success {
            background: var(--success);
        }
        
        .btn-danger {
            background: var(--error);
        }
        
        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
        }
        
        /* Progress Steps */
        .progress-steps {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2rem;
            position: relative;
        }
        
        .progress-steps::before {
            content: '';
            position: absolute;
            top: 25px;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--border);
            z-index: 1;
        }
        
        .step {
            flex: 1;
            text-align: center;
            position: relative;
            z-index: 2;
        }
        
        .step-circle {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--border);
            color: var(--text-light);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin: 0 auto 0.5rem;
            transition: all 0.3s;
        }
        
        .step.active .step-circle {
            background: var(--primary);
            color: white;
        }
        
        .step.completed .step-circle {
            background: var(--success);
            color: white;
        }
        
        .step-label {
            font-size: 0.9rem;
            color: var(--text-light);
        }
        
        .step.active .step-label {
            color: var(--primary);
            font-weight: 600;
        }
        
        /* Classes Grid */
        .classes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }
        
        /* Data Table Styles */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            background: var(--card);
            border-radius: 0.5rem;
            overflow: hidden;
        }
        
        .data-table thead {
            background: var(--primary);
            color: white;
        }
        
        .data-table th {
            padding: 1rem;
            text-align: left;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
        }
        
        .data-table th:hover {
            background: rgba(0, 0, 0, 0.1);
        }
        
        .data-table tbody tr {
            border-bottom: 1px solid var(--border);
            transition: background 0.2s;
        }
        
        .data-table tbody tr:hover {
            background: rgba(0, 0, 0, 0.02);
        }
        
        .data-table td {
            padding: 0.75rem 1rem;
            color: var(--text);
        }
        
        .data-table td:last-child {
            text-align: center;
        }
        
        /* Filter Controls */
        .filter-controls {
            padding: 1rem;
            background: rgba(0, 0, 0, 0.02);
            border-radius: 0.5rem;
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
        }
        
        .class-card {
            background: var(--card);
            border: 2px solid var(--border);
            border-radius: 1rem;
            padding: 1.5rem;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .class-card:hover {
            border-color: var(--primary);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }
        
        .class-header {
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 0.5rem;
        }
        
        .class-meta {
            color: var(--text-light);
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }
        
        .class-stats {
            display: flex;
            justify-content: space-between;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary);
        }
        
        .stat-label {
            font-size: 0.8rem;
            color: var(--text-light);
        }
        
        /* Rubrics */
        .rubrics-list {
            display: grid;
            gap: 1rem;
        }
        
        .rubric-item {
            background: var(--bg-alt);
            padding: 1rem;
            border-radius: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .rubric-info h4 {
            margin-bottom: 0.25rem;
        }
        
        .rubric-info p {
            font-size: 0.9rem;
            color: var(--text-light);
        }
        
        .rubric-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        /* Loading Spinner */
        .spinner {
            border: 4px solid var(--border);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 2rem auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Analytics dashboard (spec-based) */
        .dashboard-shell-title { font-size: 1.25rem; font-weight: 700; margin-bottom: 0.25rem; }
        .dashboard-shell-subtitle { font-size: 0.875rem; color: var(--text-light); margin-bottom: 1.5rem; }
        .global-filter-bar {
            display: flex; flex-direction: column; gap: 0;
            padding: 1rem 1.25rem; margin-bottom: 1.5rem;
            border: 1px solid var(--border); border-radius: 1rem; background: var(--bg-alt);
        }
        .global-filter-bar-row {
            display: flex; flex-wrap: nowrap; align-items: flex-end; gap: 1rem 1.25rem;
            overflow-x: auto; min-width: 0; padding-bottom: 0.25rem;
        }
        .global-filter-bar-row > * { flex-shrink: 0; }
        .global-filter-bar label { display: flex; flex-direction: column; gap: 0.25rem; font-size: 0.75rem; color: var(--text-light); }
        .global-filter-bar select, .global-filter-bar input[type="date"] {
            padding: 0.5rem 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; font-size: 0.875rem; min-width: 8rem;
        }
        .global-filter-bar .filter-actions { margin-left: auto; padding-left: 1rem; border-left: 1px solid var(--border); display: flex; gap: 0.5rem; align-items: center; }
        .global-filter-bar .last-updated { font-size: 0.75rem; color: var(--text-light); margin-left: 0.5rem; }
        /* Custom multi-select filter dropdowns (match Sort dropdown look) */
        .filter-dropdown { position: relative; display: flex; flex-direction: column; gap: 0.25rem; }
        .filter-dropdown .filter-dropdown-trigger {
            padding: 0.5rem 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; font-size: 0.875rem; min-width: 8rem;
            background: var(--bg); color: var(--text); text-align: left; cursor: pointer; display: flex; align-items: center; justify-content: space-between; gap: 0.5rem;
        }
        .filter-dropdown .filter-dropdown-trigger:hover { border-color: var(--primary); }
        .filter-dropdown .filter-dropdown-trigger::after { content: ''; border: 0.35rem solid transparent; border-top-color: currentColor; margin-left: auto; }
        .filter-dropdown .filter-dropdown-panel {
            display: none; position: absolute; top: 100%; left: 0; min-width: 100%; margin-top: 0.25rem;
            background: var(--bg); border: 1px solid var(--border); border-radius: 0.5rem; box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            max-height: 14rem; overflow-y: auto; z-index: 100; padding: 0.25rem 0;
        }
        .filter-dropdown.open .filter-dropdown-panel { display: block; }
        .filter-dropdown .filter-dropdown-item {
            padding: 0.5rem 0.75rem; cursor: pointer; display: flex; align-items: center; gap: 0.5rem; font-size: 0.875rem;
        }
        .filter-dropdown .filter-dropdown-item:hover { background: var(--bg-alt); }
        .filter-dropdown .filter-dropdown-item .filter-dropdown-check { width: 1rem; flex-shrink: 0; color: var(--primary); font-weight: bold; display: inline-flex; align-items: center; justify-content: center; }
        .filter-dropdown .filter-dropdown-item .filter-dropdown-check svg { width: 1rem; height: 1rem; }
        .filter-dropdown .filter-dropdown-item:not(.selected) .filter-dropdown-check { visibility: hidden; }
        /* Export preview + Evaluations table: header with sort + filter dropdown (inner flex keeps th as table-cell for column alignment) */
        #exportPreviewTable thead th .export-th-inner,
        #analyticsEvaluationsTable thead th .export-th-inner { display: flex; align-items: center; gap: 0.35rem; white-space: nowrap; }
        #exportPreviewTable thead th .export-th-sort,
        #analyticsEvaluationsTable thead th .export-th-sort { flex: 1; min-width: 0; cursor: pointer; user-select: none; }
        #exportPreviewTable thead th .export-th-filter,
        #analyticsEvaluationsTable thead th .export-th-filter {
            flex-shrink: 0; padding: 0.2rem 0.35rem; border: none; background: rgba(255,255,255,0.2); color: #fff;
            border-radius: 0.25rem; cursor: pointer; font-size: 0.7rem; line-height: 1;
        }
        #exportPreviewTable thead th .export-th-filter:hover,
        #analyticsEvaluationsTable thead th .export-th-filter:hover { background: rgba(255,255,255,0.35); }
        #exportPreviewTable thead th .export-th-filter.has-filter,
        #analyticsEvaluationsTable thead th .export-th-filter.has-filter { background: rgba(255,255,255,0.5); }
        /* Data Export tab: top bar stays on one line; ensure Export button is visible */
        #exportTabTopBar { flex-wrap: nowrap !important; white-space: nowrap !important; min-width: 0; overflow-x: auto; }
        #exportTabTopBar > * { flex-shrink: 0; }
        #analyticsExportBtn { display: inline-block !important; visibility: visible !important; min-width: 7rem; opacity: 1 !important; }
        #exportPreviewTable thead th.export-th-center .export-th-inner,
        #analyticsEvaluationsTable thead th.export-th-center .export-th-inner { justify-content: center; }
        .export-header-filter-panel {
            position: fixed; z-index: 200; background: var(--bg); border: 1px solid var(--border);
            border-radius: 0.5rem; box-shadow: 0 4px 16px rgba(0,0,0,0.2); max-height: 280px; min-width: 160px;
            overflow: hidden; display: flex; flex-direction: column;
        }
        .export-header-filter-panel .export-filter-toolbar { padding: 0.4rem 0.5rem; border-bottom: 1px solid var(--border); display: flex; gap: 0.5rem; flex-shrink: 0; font-size: 0.75rem; }
        .export-header-filter-panel .export-filter-toolbar a { color: var(--primary); cursor: pointer; text-decoration: underline; }
        .export-header-filter-panel .export-filter-list { overflow-y: auto; padding: 0.25rem 0; max-height: 220px; }
        .export-header-filter-panel .export-filter-item { display: flex; align-items: center; gap: 0.5rem; padding: 0.35rem 0.6rem; cursor: pointer; font-size: 0.8rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .export-header-filter-panel .export-filter-item:hover { background: var(--bg-alt); }
        .export-header-filter-panel .export-filter-item input { margin: 0; flex-shrink: 0; }
        .dashboard-kpi-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 1rem; margin-bottom: 1.5rem; }
        .kpi-card {
            border: 1px solid var(--border); border-radius: 1rem; padding: 1rem; background: var(--bg);
            box-shadow: 0 1px 3px rgba(0,0,0,0.06);
        }
        .kpi-card .kpi-title { font-size: 0.75rem; color: var(--text-light); margin-bottom: 0.35rem; }
        .kpi-card .kpi-value { font-size: 1.5rem; font-weight: 600; line-height: 1.2; }
        .kpi-card .kpi-subtext { font-size: 0.75rem; color: var(--text-light); margin-top: 0.25rem; }
        .kpi-card .kpi-meta { display: flex; justify-content: space-between; align-items: flex-start; gap: 0.5rem; margin-top: 0.5rem; flex-wrap: wrap; }
        .kpi-card .kpi-badge { font-size: 0.65rem; padding: 0.2rem 0.5rem; border-radius: 9999px; border: 1px solid; }
        .kpi-card .kpi-badge.ok { background: rgba(16,185,129,0.12); color: var(--success); border-color: rgba(16,185,129,0.3); }
        .kpi-card .kpi-badge.limited { background: rgba(245,158,11,0.12); color: var(--warning); border-color: rgba(245,158,11,0.3); }
        .kpi-card .kpi-badge.insufficient { background: var(--bg-alt); color: var(--text-light); border-color: var(--border); }
        .kpi-card .kpi-footer { font-size: 0.7rem; color: var(--text-light); margin-top: 0.5rem; }
        .kpi-card .kpi-footer a { color: var(--primary); text-decoration: underline; cursor: pointer; }
        .kpi-card .kpi-title:hover, .chart-card .chart-title:hover { color: var(--primary); }
        .chart-card {
            border: 1px solid var(--border); border-radius: 1rem; padding: 1rem; background: var(--bg);
            box-shadow: 0 1px 3px rgba(0,0,0,0.06); margin-bottom: 1.5rem;
            min-width: 0; overflow: hidden;
        }
        .chart-card .chart-title { font-size: 0.9375rem; font-weight: 500; margin-bottom: 0.25rem; }
        .chart-card .chart-subtitle { font-size: 0.75rem; color: var(--text-light); margin-bottom: 0.75rem; }
        .chart-card .chart-body { min-height: 180px; border: 1px dashed var(--border); border-radius: 0.75rem; background: var(--bg-alt); overflow-x: auto; padding: 0.75rem; }
        .chart-card .chart-body .data-table { width: 100%; table-layout: auto; }
        .chart-card .chart-footer { font-size: 0.7rem; color: var(--text-light); margin-top: 0.75rem; }
        .chart-card .chart-footer a { color: var(--primary); text-decoration: underline; cursor: pointer; }
        .dashboard-charts-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem; margin-bottom: 1.5rem; }
        
        /* Score Display */
        .score-banner {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            margin: 2rem 0;
        }
        
        .score-value {
            font-size: 3rem;
            font-weight: bold;
            margin: 1rem 0;
        }
        
        .score-percentage {
            font-size: 1.5rem;
            opacity: 0.9;
        }
        
        /* Footer */
        footer {
            font-family: var(--body-font);
            background: var(--primary);
            color: white;
            padding: 2rem 0;
            margin-top: 3rem;
        }
        
        .footer-content {
            text-align: center;
        }
        
        .footer-links {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-bottom: 1rem;
        }
        
        .footer-links a {
            color: white;
            text-decoration: none;
            opacity: 0.8;
            transition: opacity 0.3s;
        }
        
        .footer-links a:hover {
            opacity: 1;
        }
        
        /* Modal / Overlay */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        .modal-overlay[hidden] { display: none !important; }
        .modal-box {
            background: var(--card);
            padding: 1.75rem 2rem;
            border-radius: 1rem;
            max-width: 440px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.2);
            border: 1px solid var(--border);
        }
        .modal-box h3 {
            margin: 0 0 0.75rem 0;
            font-size: 1.25rem;
            color: var(--primary);
        }
        .modal-box p { margin: 0 0 1rem 0; color: var(--text-light); font-size: 0.9rem; line-height: 1.5; }
        .modal-box .modal-actions { margin-top: 1.25rem; }
        .info-box {
            background: var(--bg-alt);
            border-left: 4px solid var(--primary);
            padding: 1rem 1.25rem;
            border-radius: 0 0.5rem 0.5rem 0;
            margin-bottom: 1.5rem;
            font-size: 0.9rem;
            color: var(--text);
            line-height: 1.5;
        }
        .consent-toolbar {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            align-items: flex-end;
            margin-bottom: 1.5rem;
        }
        .consent-toolbar .form-group { margin-bottom: 0; }
        .consent-toolbar select {
            min-width: 240px;
            padding: 0.6rem 0.75rem;
        }
        .consent-actions {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        
        /* Utility Classes */
        .skip-link {
            position: absolute;
            top: -3rem;
            left: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--primary);
            color: white;
            text-decoration: none;
            font-weight: 600;
            z-index: 10002;
            border-radius: 0 0 0.5rem 0;
            transition: top 0.2s;
        }
        .skip-link:focus {
            top: 0;
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }
        .hidden {
            display: none !important;
        }
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        .text-center {
            text-align: center;
        }
        
        .mt-2 {
            margin-top: 2rem;
        }
        
        .mb-2 {
            margin-bottom: 2rem;
        }
        
        .alert {
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }
        
        .alert-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            nav {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .header-content {
                flex-direction: column;
                gap: 1rem;
            }
            
            .classes-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* Edit functionality animations */
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
        
        /* Auth / Login page – theme colors and logo */
        .auth-screen {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            padding: 1rem;
        }
        .auth-card {
            background: var(--card);
            padding: 2.5rem 3rem;
            border-radius: 1rem;
            max-width: 440px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.2);
            border: 2px solid var(--border);
        }
        .auth-card .auth-logo {
            width: 120px;
            height: 120px;
            margin: 0 auto 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            overflow: hidden;
            background: var(--card);
            border: 2px solid var(--border);
        }
        .auth-card .auth-logo img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
        }
        .auth-card h2 {
            font-family: var(--heading-font);
            color: var(--primary);
            margin: 0;
            font-size: 1.75rem;
        }
        .auth-card .auth-tagline {
            color: var(--text-light);
            margin: 0.35rem 0 0 0;
            font-size: 0.95rem;
        }
        .auth-card .form-group label { color: var(--text); }
        .auth-divider {
            text-align: center;
            color: var(--text-light);
            margin: 1.25rem 0;
            font-size: 0.9rem;
        }
        .auth-card .btn-demo {
            width: 100%;
            padding: 0.75rem;
            font-size: 1rem;
            background: var(--secondary);
            color: var(--text);
            border: 2px solid var(--border);
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s, border-color 0.2s;
        }
        .auth-card .btn-demo:hover {
            background: var(--accent);
            border-color: var(--primary);
            color: var(--primary-dark);
        }
        /* Full-page loading overlay until auth check completes */
        #authLoadingOverlay {
            position: fixed;
            inset: 0;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
        }
        #authLoadingOverlay.hidden { display: none; }
        #authLoadingOverlay .auth-loading-spinner {
            width: 48px;
            height: 48px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #authLoadingOverlay p { margin: 0; font-size: 1rem; font-weight: 500; }
        /* Lucide icons inline with text */
        [data-lucide] { width: 1.1em; height: 1.1em; vertical-align: -0.2em; stroke-width: 2; flex-shrink: 0; }
        .icon-with-text { display: inline-flex; align-items: center; gap: 0.35em; }
    </style>
</head>
<body>
    <!-- Loading overlay: shown until checkAuth() completes so login page doesn't flash during reload -->
    <div id="authLoadingOverlay" class="auth-loading-overlay">
        <div class="auth-loading-spinner" aria-hidden="true"></div>
        <p>Loading…</p>
    </div>
    <!-- Login/Register Screen: visible by default so we don't flash main app before checkAuth() -->
    <div id="authScreen" class="auth-screen">
        <div class="auth-card">
            <div style="text-align: center; margin-bottom: 2rem;">
                <div class="auth-logo"><img src="assets/logo-light-bg.png" alt="SpeechGradebook" /></div>
                <h2><span class="icon-with-text"><i data-lucide="graduation-cap" style="width:1.25em;height:1.25em;"></i> Speech Gradebook</span></h2>
                <p class="auth-tagline">Instructor-Informed Speech Assessment</p>
            </div>
            
            <!-- Login Form -->
            <div id="loginFormDiv">
                <form id="loginForm">
                    <div class="form-group">
                        <label for="loginEmail">Email</label>
                        <input type="email" id="loginEmail" required placeholder="you@example.com">
                    </div>
                    <div class="form-group">
                        <label for="loginPassword">Password</label>
                        <input type="password" id="loginPassword" required placeholder="••••••••">
                    </div>
                    <button type="submit" style="width: 100%; padding: 0.75rem; font-size: 1rem;"><span class="icon-with-text"><i data-lucide="log-in"></i> Login</span></button>
                </form>
                <p class="auth-divider">or</p>
                <button type="button" class="btn-demo" onclick="enterDemoMode();"><span class="icon-with-text"><i data-lucide="play"></i> Try demo</span></button>
                <p style="text-align: center; margin-top: 1.5rem; color: var(--text-light); font-size: 0.9rem;">
                    Don't have an account? <a href="#" onclick="showRegisterForm(); return false;" style="color: var(--primary); font-weight: 600;" class="icon-with-text"><i data-lucide="user-plus"></i> Create one</a>
                </p>
            </div>
            
            <!-- Register Form -->
            <div id="registerFormDiv" class="hidden">
                <h3 style="margin-bottom: 1.5rem; color: var(--text);"><span class="icon-with-text"><i data-lucide="user-plus"></i> Create your account</span></h3>
                <form id="registerForm">
                    <div class="form-group">
                        <label for="registerName">Full Name</label>
                        <input type="text" id="registerName" required placeholder="John Doe">
                    </div>
                    <div class="form-group">
                        <label for="registerEmail">Email</label>
                        <input type="email" id="registerEmail" required placeholder="you@example.com">
                    </div>
                    <div class="form-group">
                        <label for="registerPassword">Password</label>
                        <input type="password" id="registerPassword" required placeholder="••••••••" minlength="6">
                        <small style="color: var(--text-light);">At least 6 characters</small>
                    </div>
                    <button type="submit" style="width: 100%; padding: 0.75rem; font-size: 1rem;"><span class="icon-with-text"><i data-lucide="user-plus"></i> Create Account</span></button>
                </form>
                <p style="text-align: center; margin-top: 1.5rem; color: var(--text-light);">
                    Already have an account? <a href="#" onclick="showLoginForm(); return false;" style="color: var(--primary); font-weight: 600;" class="icon-with-text"><i data-lucide="log-in"></i> Login</a>
                </p>
            </div>
        </div>
    </div>

    <!-- Main App: hidden until checkAuth() confirms session -->
    <div id="mainApp" style="display: none;">
    <a href="#main-content" class="skip-link">Skip to main content</a>
    <!-- One-time instructor LLM consent (user agreement style) -->
    <div id="instructorConsentOverlay" class="modal-overlay" hidden>
        <div class="modal-box">
            <h3>Data use agreement</h3>
            <p>Your evaluation content may be used to improve the speech assessment model. This supports research and product improvement while keeping data anonymized where used for training.</p>
            <label style="display: flex; align-items: flex-start; gap: 0.5rem; cursor: pointer; margin-bottom: 1rem;">
                <input type="checkbox" id="instructorConsentCheckbox" style="margin-top: 0.2rem;">
                <span style="font-size: 0.9rem;">I agree that my evaluation content may be used for LLM training and research.</span>
            </label>
            <div class="modal-actions">
                <button type="button" id="instructorConsentSubmit" disabled class="btn">Continue</button>
            </div>
        </div>
    </div>
    <header>
        <div class="container">
            <div class="header-content">
                <div class="logo-section">
                    <div class="logo" id="appLogo" style="background-color: #ffffff;"><img src="assets/logo-dark-bg.png" alt="Speech Gradebook" style="width: 100%; height: 100%; object-fit: cover; object-position: center; border-radius: 50%;"></div>
                    <div class="app-title">
                        <h1 id="appName">Speech Gradebook</h1>
                        <div class="tagline" id="appTagline">Instructor-Informed Speech Assessment</div>
                    </div>
                </div>
                <nav>
                    <a href="#" class="nav-link" id="navEvaluate" onclick="showEvaluate(); return false;"><span class="icon-with-text"><i data-lucide="mic"></i> Evaluate Speech</span></a>
                    <a href="#" class="nav-link active" id="navDashboard" onclick="showDashboard(); return false;"><span class="icon-with-text"><i data-lucide="layout-dashboard"></i> Dashboard</span></a>
                    <a href="#" class="nav-link" id="navSettings" onclick="showSettings(); return false;"><span class="icon-with-text"><i data-lucide="settings"></i> Settings</span></a>
                    <a href="#" class="nav-link" id="navHelp" onclick="showHelp(); return false;"><span class="icon-with-text"><i data-lucide="help-circle"></i> Support</span></a>
                    
                    <a href="#" id="logoutLink" class="nav-link" onclick="logout(); return false;" aria-label="Log out">
                        <span id="userDisplay"></span> <span class="icon-with-text"><i data-lucide="log-out"></i> Logout</span>
                    </a>
                </nav>
            </div>
        </div>
    </header>

    <main id="main-content" class="container" tabindex="-1">
        <!-- Evaluate Section -->
        <section id="evaluateSection" class="section">
            <div class="card">
                <div class="card-header" id="evaluateCardHeader"><span class="icon-with-text"><i data-lucide="mic"></i> Evaluate a Speech</span></div>
                
                <div class="progress-steps">
                    <div class="step active" id="step1">
                        <div class="step-circle">1</div>
                        <div class="step-label">Upload</div>
                    </div>
                    <div class="step" id="step2">
                        <div class="step-circle">2</div>
                        <div class="step-label">Details</div>
                    </div>
                    <div class="step" id="step3">
                        <div class="step-circle">3</div>
                        <div class="step-label">Evaluate</div>
                    </div>
                    <div class="step" id="step4">
                        <div class="step-circle">4</div>
                        <div class="step-label">Results</div>
                    </div>
                </div>

                <!-- Step 1: Upload -->
                <div id="uploadStep">
                    <div class="upload-zone" id="uploadZone">
                        <div class="upload-icon"><i data-lucide="upload" style="width:3rem;height:3rem;"></i></div>
                        <h3><span class="icon-with-text"><i data-lucide="mic"></i> Upload Speech Recording</span></h3>
                        <p>Click or drag & drop your audio/video file here</p>
                        <p style="color: var(--text-light); font-size: 0.9rem; margin-top: 0.5rem;">
                            Supported: MP3, MP4, WAV, M4A, WebM<br>
                            <strong>For GPT-4o:</strong> Can also upload image/screenshot (JPG, PNG)
                        </p>
                    </div>
                    <input type="file" id="fileInput" accept="audio/*,video/*,image/*" style="display: none;">
                    <div id="fileInfo" class="file-info hidden">
                        <span id="fileName"></span>
                        <button onclick="removeFile()" class="btn-small btn-danger"><span class="icon-with-text"><i data-lucide="trash-2"></i> Remove</span></button>
                    </div>
                    <div id="continueButtonContainer" style="margin-top: 2rem; display: none;">
                        <button onclick="moveToStep(2)" id="continueToDetails"><span class="icon-with-text">Continue to Details <i data-lucide="arrow-right"></i></span></button>
                    </div>
                </div>

                <!-- Step 2: Details -->
                <div id="detailsStep" class="hidden">
                    <form id="studentForm">
                        <div class="form-group">
                            <label for="speechDate">Speech Date</label>
                            <input type="date" id="speechDate">
                        </div>
                        <div class="form-group">
                            <label for="assignmentType">Assignment Type</label>
                            <select id="assignmentType">
                                <option value="self-introduction">Self Introduction Speech</option>
                                <option value="informative">Informative Speech</option>
                                <option value="persuasive">Persuasive Speech</option>
                                <option value="demonstration">Demonstration Speech</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="rubricSelect">Evaluation Rubric *</label>
                            <select id="rubricSelect" required>
                                <option value="">-- Select a Rubric --</option>
                            </select>
                            <p style="font-size: 0.9rem; color: var(--text-light); margin-top: 0.5rem;">
                                Choose which rubric to use for evaluation. <a href="#" onclick="showDashboard(); return false;" style="color: var(--primary);">Manage rubrics</a>
                            </p>
                        </div>
                        <div class="form-group">
                            <label for="evalApiProvider">Evaluation provider</label>
                            <select id="evalApiProvider" onchange="updateEvalProviderHint()">
                                <option value="gemini">Google Gemini (recommended for training data)</option>
                                <option value="claude">Anthropic Claude</option>
                                <option value="gpt4o">OpenAI GPT-4o</option>
                                <option value="finetuned">Fine-tuned (SpeechGradebook) – your trained model</option>
                                <option value="demo">Demo (mock scores)</option>
                            </select>
                            <p style="font-size: 0.9rem; color: var(--text-light); margin-top: 0.5rem;">
                                Use an API (Gemini, Claude, GPT-4o) to evaluate videos and build training data; correct and save each evaluation. Set API keys in <a href="#" onclick="showSettings(); return false;" style="color: var(--primary);">Settings</a>. Fine-tuned uses your local server once trained.
                            </p>
                        </div>
                        <p id="localhostServerHint" style="font-size: 0.9rem; color: var(--primary); margin-top: 0.25rem; display: none;">
                            Using local server. Start it first: in a terminal, go to the SpeechGradebook folder and run <code>./run_local.sh</code> (or <code>uvicorn app:app --host 0.0.0.0 --port 8000</code>).
                        </p>
                        <div style="display: flex; gap: 1rem;">
                            <button type="button" onclick="moveToStep(1)" class="btn-secondary"><span class="icon-with-text"><i data-lucide="arrow-left"></i> Back</span></button>
                            <button type="submit" id="submitEvaluationBtn"><span class="icon-with-text">Continue to Evaluation <i data-lucide="arrow-right"></i></span></button>
                        </div>
                    </form>
                </div>

                <!-- Step 3: Processing -->
                <div id="processingStep" class="hidden text-center">
                    <div class="spinner"></div>
                    <h3><span class="icon-with-text"><i data-lucide="loader"></i> Evaluating Speech...</span></h3>
                    <p id="processingMessage">Analyzing speech content and delivery...</p>
                </div>

                <!-- Step 4: Results -->
                <div id="resultsStep" class="hidden">
                    <div id="resultsContent"></div>
                    <div style="display: flex; gap: 1rem; margin-top: 2rem; flex-wrap: wrap;">
                        <button onclick="openSaveModal()"><span class="icon-with-text"><i data-lucide="save"></i> Save Results</span></button>
                        <button onclick="downloadPDF()" class="btn-secondary"><span class="icon-with-text"><i data-lucide="file-text"></i> Download Report (HTML)</span></button>
                        <button onclick="emailResults()" class="btn-secondary"><span class="icon-with-text"><i data-lucide="mail"></i> Email Results</span></button>
                        <button onclick="viewCorrectionHistory()" class="btn-secondary" id="viewCorrectionsBtn" style="display: none;"><span class="icon-with-text"><i data-lucide="clipboard-list"></i> View Corrections (<span id="correctionCount">0</span>)</span></button>
                        <button onclick="startOver()" class="btn-secondary"><span class="icon-with-text"><i data-lucide="refresh-cw"></i> Start Over</span></button>
                    </div>
                </div>
            </div>
        </section>

        <!-- Save Modal -->
        <div id="saveModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
            <div style="background:white;padding:2rem;border-radius:1rem;max-width:500px;width:90%;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                <h3 style="margin-top:0;color:var(--primary);"><span class="icon-with-text"><i data-lucide="save"></i> Save Evaluation</span></h3>
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">Class:</label>
                    <select id="saveClassSel" onchange="loadSaveStudents()" style="width:100%;padding:0.75rem;font-size:1rem;border:2px solid #ddd;border-radius:0.5rem;">
                        <option value="">-- Select Class --</option>
                    </select>
                </div>
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">Student:</label>
                    <select id="saveStudentSel" style="width:100%;padding:0.75rem;font-size:1rem;border:2px solid #ddd;border-radius:0.5rem;">
                        <option value="">-- Select Student --</option>
                    </select>
                </div>
                <div style="display:flex;gap:1rem;justify-content:flex-end;margin-top:2rem;">
                    <button onclick="closeSaveModal()" style="padding:0.75rem 1.5rem;background:#6c757d;color:white;border:none;border-radius:0.5rem;cursor:pointer;"><span class="icon-with-text"><i data-lucide="x"></i> Cancel</span></button>
                    <button onclick="doSaveEval()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;font-weight:600;"><span class="icon-with-text"><i data-lucide="check"></i> Save</span></button>
                </div>
            </div>
        </div>

        <!-- Edit Section Modal -->
        <div id="editSectionModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
            <div style="background:white;padding:2rem;border-radius:1rem;max-width:700px;width:90%;box-shadow:0 10px 40px rgba(0,0,0,0.3);max-height:90vh;overflow-y:auto;">
                <h3 style="margin-top:0;color:var(--primary);"><span class="icon-with-text"><i data-lucide="edit-2"></i> Edit <span id="editSectionName"></span></span></h3>
                
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">Overall Section Score:</label>
                    <div style="display:flex;gap:1rem;align-items:center;">
                        <input type="number" id="editSectionScore" min="0" style="width:80px;padding:0.5rem;font-size:1rem;border:2px solid #ddd;border-radius:0.5rem;" readonly disabled>
                        <span style="font-weight:600;">/ <span id="editSectionMaxScore"></span></span>
                        <span style="color:#999;font-size:0.9rem;">(Auto-calculated from subcategories)</span>
                    </div>
                </div>
                
                <!-- Subcategories Section -->
                <div id="editSubcategoriesContainer" style="margin:1.5rem 0;">
                    <!-- Subcategories will be populated here -->
                </div>
                
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">AI Feedback:</label>
                    <div style="background:#f8f9fa;padding:1rem;border-radius:0.5rem;border-left:4px solid #6c757d;margin-bottom:1rem;">
                        <p id="editSectionAIFeedback" style="margin:0;color:#555;font-size:0.9rem;"></p>
                    </div>
                </div>
                
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">Your Feedback (optional):</label>
                    <textarea id="editSectionFeedback" rows="4" style="width:100%;padding:0.75rem;font-size:1rem;border:2px solid #ddd;border-radius:0.5rem;resize:vertical;" placeholder="Add or modify feedback for the student..."></textarea>
                </div>
                
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">Why are you making changes? (helps improve AI):</label>
                    <textarea id="editSectionReason" rows="3" style="width:100%;padding:0.75rem;font-size:1rem;border:2px solid #ddd;border-radius:0.5rem;resize:vertical;" placeholder="e.g., 'AI didn't notice student was reading from notes'"></textarea>
                </div>
                
                <div style="display:flex;gap:1rem;justify-content:flex-end;margin-top:2rem;">
                    <button onclick="closeEditSectionModal()" style="padding:0.75rem 1.5rem;background:#6c757d;color:white;border:none;border-radius:0.5rem;cursor:pointer;">Cancel</button>
                    <button onclick="saveEditedSection()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;font-weight:600;">Save Changes</button>
                </div>
            </div>
        </div>

        <!-- Edit Overall Comments Modal -->
        <div id="editCommentsModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
            <div style="background:white;padding:2rem;border-radius:1rem;max-width:600px;width:90%;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                <h3 style="margin-top:0;color:var(--primary);"><span class="icon-with-text"><i data-lucide="edit-2"></i> Edit Overall Comments</span></h3>
                
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">AI Comments:</label>
                    <div style="background:#f8f9fa;padding:1rem;border-radius:0.5rem;border-left:4px solid #6c757d;margin-bottom:1rem;">
                        <p id="editCommentsAI" style="margin:0;color:#555;font-size:0.9rem;"></p>
                    </div>
                </div>
                
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">Your Comments:</label>
                    <textarea id="editCommentsText" rows="6" style="width:100%;padding:0.75rem;font-size:1rem;border:2px solid #ddd;border-radius:0.5rem;resize:vertical;"></textarea>
                </div>
                
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">Reason for changes (optional, for AI training):</label>
                    <textarea id="editCommentsReason" rows="2" style="width:100%;padding:0.75rem;font-size:1rem;border:2px solid #ddd;border-radius:0.5rem;resize:vertical;" placeholder="What did the AI miss or get wrong?"></textarea>
                </div>
                
                <div style="display:flex;gap:1rem;justify-content:flex-end;margin-top:2rem;">
                    <button onclick="closeEditCommentsModal()" style="padding:0.75rem 1.5rem;background:#6c757d;color:white;border:none;border-radius:0.5rem;cursor:pointer;">Cancel</button>
                    <button onclick="saveEditedComments()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;font-weight:600;">Save Changes</button>
                </div>
            </div>
        </div>

        <!-- Edit Timeline Markers Modal -->
        <div id="editMarkersModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
            <div style="background:white;padding:2rem;border-radius:1rem;max-width:700px;width:90%;max-height:90vh;overflow-y:auto;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                <h3 style="margin-top:0;color:var(--primary);"><span class="icon-with-text"><i data-lucide="edit-2"></i> Edit Timeline Markers</span></h3>
                
                <div id="editMarkersList" style="margin:1.5rem 0;">
                    <!-- Markers will be populated here -->
                </div>
                
                <button onclick="addNewMarker()" style="width:100%;padding:0.75rem;background:#28a745;color:white;border:none;border-radius:0.5rem;cursor:pointer;font-weight:600;margin:1rem 0;"><span class="icon-with-text"><i data-lucide="plus"></i> Add New Marker</span></button>
                
                <div style="display:flex;gap:1rem;justify-content:flex-end;margin-top:2rem;">
                    <button onclick="closeEditMarkersModal()" style="padding:0.75rem 1.5rem;background:#6c757d;color:white;border:none;border-radius:0.5rem;cursor:pointer;">Cancel</button>
                    <button onclick="saveEditedMarkers()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;font-weight:600;">Save All Changes</button>
                </div>
            </div>
        </div>

        <!-- Correction History Modal -->
        <div id="correctionHistoryModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
            <div style="background:white;padding:2rem;border-radius:1rem;max-width:800px;width:90%;max-height:90vh;overflow-y:auto;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                <h3 style="margin-top:0;color:var(--primary);"><span class="icon-with-text"><i data-lucide="clipboard-list"></i> Instructor Corrections History</span></h3>
                <p style="color:var(--text-light);font-size:0.9rem;margin-bottom:1.5rem;">
                    This log shows all changes made to the AI's evaluation. This data helps improve future evaluations.
                </p>
                
                <div id="correctionHistoryContent" style="margin:1.5rem 0;">
                    <!-- Corrections will be populated here -->
                </div>
                
                <div style="display:flex;gap:1rem;justify-content:flex-end;margin-top:2rem;">
                    <button onclick="closeCorrectionHistoryModal()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;font-weight:600;">Close</button>
                </div>
            </div>
        </div>

        <!-- Dashboard Section (home view) -->
        <section id="dashboardSection" class="section active">
            <!-- Instructor-only: tab bar for Courses | Rubrics | Course Insights -->
            <div id="instructorDashboardTabBar" style="display: none; margin-bottom: 0;" role="tablist" aria-label="Dashboard sections">
                <button type="button" id="instructorTabBtnCourses" class="instructor-dashboard-tab instructor-dashboard-tab-active" role="tab" aria-selected="true" aria-controls="instructorTabPanelCourses"><span class="icon-with-text"><i data-lucide="book-open"></i> Courses</span></button>
                <button type="button" id="instructorTabBtnRubrics" class="instructor-dashboard-tab" role="tab" aria-selected="false" aria-controls="instructorTabPanelRubrics"><span class="icon-with-text"><i data-lucide="list-checks"></i> Rubrics</span></button>
                <button type="button" id="instructorTabBtnInsights" class="instructor-dashboard-tab" role="tab" aria-selected="false" aria-controls="instructorTabPanelInsights"><span class="icon-with-text"><i data-lucide="bar-chart-2"></i> Course Insights</span></button>
            </div>

            <!-- Courses card - at top for instructors; hidden for admin/super admin -->
            <div id="mainCoursesCard" class="card" style="margin-top: 1.5rem;" data-instructor-panel="courses">
                <div class="card-header"><span class="icon-with-text"><i data-lucide="book-open"></i> Courses</span></div>
                <!-- Course scope filter (admin and super admin only) -->
                <div id="courseScopeFilterRow" class="filter-controls" style="display: none; margin-bottom: 1.5rem; flex-wrap: wrap; gap: 1rem; align-items: flex-end;">
                    <div class="filter-group">
                        <label for="courseScopeSelect" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Show</label>
                        <select id="courseScopeSelect" onchange="onCourseScopeChange()" style="padding: 0.5rem 0.75rem; border: 2px solid var(--border); border-radius: 0.5rem; min-width: 180px;">
                            <option value="own">My Courses</option>
                            <option value="institution" id="courseScopeInstitutionOption">Department</option>
                        </select>
                    </div>
                    <div id="courseScopeInstitutionWrap" class="filter-group" style="display: none;">
                        <label for="courseScopeInstitution" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Institution</label>
                        <select id="courseScopeInstitution" onchange="onCourseScopeInstitutionChange()" style="padding: 0.5rem 0.75rem; border: 2px solid var(--border); border-radius: 0.5rem; min-width: 200px;">
                            <option value="">Select institution</option>
                        </select>
                    </div>
                    <div id="courseScopeInstructorWrap" class="filter-group" style="display: none;">
                        <label for="courseScopeInstructor" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Instructor</label>
                        <select id="courseScopeInstructor" onchange="onCourseScopeInstructorChange()" style="padding: 0.5rem 0.75rem; border: 2px solid var(--border); border-radius: 0.5rem; min-width: 200px;">
                            <option value="">All instructors</option>
                        </select>
                    </div>
                </div>
                <div style="margin-bottom: 1.5rem;">
                    <button onclick="showCreateClass()"><span class="icon-with-text"><i data-lucide="plus"></i> Create New Class</span></button>
                </div>
                <div id="classesGrid" class="classes-grid"></div>
            </div>

            <!-- Rubrics - at top for instructors; hidden for admin/super admin -->
            <div id="dashboardRubricsWrap" style="display: none; margin-top: 1.5rem;" data-instructor-panel="rubrics">
                <div class="card">
                    <div class="card-header"><span class="icon-with-text"><i data-lucide="list-checks"></i> Rubrics</span></div>
                    <div style="margin-bottom: 1rem;">
                        <label for="courseFilter" style="font-weight: 500; margin-bottom: 0.5rem; display: block;">Filter by Course:</label>
                        <select id="courseFilter" onchange="filterRubricsByCourse()" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                            <option value="">All Courses</option>
                        </select>
                    </div>
                    <div style="margin-bottom: 1.5rem; display: flex; gap: 1rem;">
                        <button onclick="showCreateRubric()"><span class="icon-with-text"><i data-lucide="plus"></i> Create Custom Rubric</span></button>
                        <button onclick="showUploadRubric()" style="background: var(--secondary);"><span class="icon-with-text"><i data-lucide="file-up"></i> Upload Rubric (PDF/Image)</span></button>
                    </div>
                    <div id="rubricsList" class="rubrics-list"></div>
                </div>
                <div id="createRubricCard" class="card hidden">
                    <div class="card-header" id="rubricFormHeader">Create Custom Rubric</div>
                    <form id="createRubricForm">
                        <input type="hidden" id="editingRubricId" value="">
                        <h4 style="margin-bottom: 1rem; color: var(--primary);">Basic Information</h4>
                        <div class="form-group">
                            <label for="rubricName">Rubric Name *</label>
                            <input type="text" id="rubricName" placeholder="e.g., Persuasive Speech" required>
                        </div>
                        <div class="form-group">
                            <label for="rubricDescription">Description</label>
                            <textarea id="rubricDescription" placeholder="Brief description of this rubric..."></textarea>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                            <div class="form-group">
                                <label for="rubricTotalPoints">Total Points *</label>
                                <input type="number" id="rubricTotalPoints" value="50" min="1" required>
                            </div>
                            <div class="form-group">
                                <label for="rubricSpeechType">Speech Type</label>
                                <input type="text" id="rubricSpeechType" placeholder="e.g., Persuasive, Informative">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Associated Courses (Optional)</label>
                            <p style="font-size: 0.9rem; color: var(--text-light); margin-bottom: 0.5rem;">Select one or more courses/sections.</p>
                            <div id="rubricCoursesContainer" style="max-height: 200px; overflow-y: auto; border: 1px solid var(--border); border-radius: 0.25rem; padding: 0.75rem; background: white;">
                                <p style="color: var(--text-light); text-align: center;">No courses available. Create courses in "My Classes" first.</p>
                            </div>
                        </div>
                        <h4 style="margin: 1.5rem 0 1rem; color: var(--primary);">Grade Scale</h4>
                        <p style="font-size: 0.9rem; color: var(--text-light); margin-bottom: 1rem;">Define what percentage of maximum points each grade represents:</p>
                        <div style="display: grid; gap: 0.5rem; margin-bottom: 1.5rem;">
                            <div style="display: grid; grid-template-columns: auto 1fr 1fr 1fr; gap: 0.5rem; align-items: center;">
                                <strong style="font-size: 0.9rem;">Grade</strong>
                                <strong style="font-size: 0.9rem;">Label</strong>
                                <strong style="font-size: 0.9rem;">Percentage</strong>
                                <strong style="font-size: 0.9rem;">Range</strong>
                            </div>
                            <div style="display: grid; grid-template-columns: auto 1fr 1fr 1fr; gap: 0.5rem; align-items: center;">
                                <span style="font-weight: 600;">A</span>
                                <input type="text" id="gradeA_label" value="Professional" style="padding: 0.4rem;">
                                <input type="number" id="gradeA_pct" value="100" min="0" max="100" style="padding: 0.4rem;">
                                <input type="text" id="gradeA_range" value="100-91" style="padding: 0.4rem;">
                            </div>
                            <div style="display: grid; grid-template-columns: auto 1fr 1fr 1fr; gap: 0.5rem; align-items: center;">
                                <span style="font-weight: 600;">B</span>
                                <input type="text" id="gradeB_label" value="Proficient" style="padding: 0.4rem;">
                                <input type="number" id="gradeB_pct" value="90" min="0" max="100" style="padding: 0.4rem;">
                                <input type="text" id="gradeB_range" value="90-81" style="padding: 0.4rem;">
                            </div>
                            <div style="display: grid; grid-template-columns: auto 1fr 1fr 1fr; gap: 0.5rem; align-items: center;">
                                <span style="font-weight: 600;">C</span>
                                <input type="text" id="gradeC_label" value="Developing" style="padding: 0.4rem;">
                                <input type="number" id="gradeC_pct" value="80" min="0" max="100" style="padding: 0.4rem;">
                                <input type="text" id="gradeC_range" value="80-71" style="padding: 0.4rem;">
                            </div>
                            <div style="display: grid; grid-template-columns: auto 1fr 1fr 1fr; gap: 0.5rem; align-items: center;">
                                <span style="font-weight: 600;">D</span>
                                <input type="text" id="gradeD_label" value="Unprofessional" style="padding: 0.4rem;">
                                <input type="number" id="gradeD_pct" value="70" min="0" max="100" style="padding: 0.4rem;">
                                <input type="text" id="gradeD_range" value="70-61" style="padding: 0.4rem;">
                            </div>
                            <div style="display: grid; grid-template-columns: auto 1fr 1fr 1fr; gap: 0.5rem; align-items: center;">
                                <span style="font-weight: 600;">F</span>
                                <input type="text" id="gradeF_label" value="Unacceptable" style="padding: 0.4rem;">
                                <input type="number" id="gradeF_pct" value="60" min="0" max="100" style="padding: 0.4rem;">
                                <input type="text" id="gradeF_range" value="60-0" style="padding: 0.4rem;">
                            </div>
                        </div>
                        <h4 style="margin: 1.5rem 0 1rem; color: var(--primary);">Categories & Subcategories</h4>
                        <div id="categoriesContainer"></div>
                        <button type="button" onclick="addCategory()" class="btn-secondary" style="margin-top: 1rem;"><span class="icon-with-text"><i data-lucide="plus"></i> Add Category</span></button>
                        <div style="display: flex; gap: 1rem; margin-top: 2rem; padding-top: 1.5rem; border-top: 2px solid var(--border);">
                            <button type="button" onclick="cancelCreateRubric()" class="btn-secondary">Cancel</button>
                            <button type="submit" id="rubricSubmitBtn">Create Rubric</button>
                        </div>
                    </form>
                </div>
            </div>

            <!-- Analytics dashboard (Course Insights for instructor; Department/Institution for admin) -->
            <div id="analyticsSection" style="margin-top: 0; margin-bottom: 2rem;" data-instructor-panel="insights">
                <div class="card">
                    <div class="card-header" id="analyticsSectionTitle"><span class="icon-with-text"><i data-lucide="bar-chart-2"></i> Course Insights</span></div>
                    <!-- Global filter bar (Overview / Course Insights) -->
                    <div id="analyticsGlobalFilterBar" class="global-filter-bar">
                        <div class="global-filter-bar-row">
                        <div class="filter-dropdown" id="filter-dropdown-course" data-select-id="analyticsGlobalCourse">
                            <label class="filter-dropdown-label" style="font-size: 0.75rem; color: var(--text-light);">Course</label>
                            <button type="button" class="filter-dropdown-trigger" id="filter-trigger-course" aria-expanded="false" aria-haspopup="listbox" aria-label="Select courses" style="min-width: 12rem;">All courses</button>
                            <div class="filter-dropdown-panel" id="filter-panel-course" role="listbox" aria-hidden="true"></div>
                            <select id="analyticsGlobalCourse" multiple aria-hidden="true" style="position:absolute;left:-9999px;width:1px;height:1px;opacity:0;"><option value="">All courses</option></select>
                        </div>
                        <div class="filter-dropdown" id="filter-dropdown-instructor" data-select-id="analyticsGlobalInstructor">
                            <label class="filter-dropdown-label" style="font-size: 0.75rem; color: var(--text-light);">Instructor</label>
                            <button type="button" class="filter-dropdown-trigger" id="filter-trigger-instructor" aria-expanded="false" aria-haspopup="listbox" aria-label="Select instructors" style="min-width: 12rem;">All instructors</button>
                            <div class="filter-dropdown-panel" id="filter-panel-instructor" role="listbox" aria-hidden="true"></div>
                            <select id="analyticsGlobalInstructor" multiple aria-hidden="true" style="position:absolute;left:-9999px;width:1px;height:1px;opacity:0;"><option value="">All instructors</option></select>
                        </div>
                        <div class="filter-date-range" style="display: flex; flex-direction: column; gap: 0.25rem;">
                            <span class="filter-dropdown-label" style="font-size: 0.75rem; color: var(--text-light);">Date range</span>
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="date" id="analyticsStartDate" aria-label="Start date" style="padding: 0.5rem 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; font-size: 0.875rem; min-width: 8rem;">
                                <span style="color: var(--text-light); font-size: 0.875rem;">to</span>
                                <input type="date" id="analyticsEndDate" aria-label="End date" style="padding: 0.5rem 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; font-size: 0.875rem; min-width: 8rem;">
                            </div>
                        </div>
                        <div class="filter-actions" style="margin-left: auto;">
                            <button type="button" id="analyticsGlobalReset" class="btn-secondary" style="padding: 0.5rem 0.75rem; font-size: 0.875rem;">Reset</button>
                            <button type="button" id="analyticsGlobalApply" class="btn" style="padding: 0.5rem 1rem; font-size: 0.875rem; background: var(--primary); color: white;">Apply</button>
                            <span id="analyticsLastUpdated" class="last-updated" style="align-self: center;"></span>
                        </div>
                        </div>
                        <div id="activeFiltersDisplay" style="display: none; flex-wrap: wrap; gap: 0.5rem; padding-top: 0.75rem; border-top: 1px solid var(--border);"></div>
                    </div>
                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1.5rem; border-bottom: 2px solid var(--border); padding-bottom: 0; flex-wrap: wrap;">
                    <div id="analyticsTablist" role="tablist" class="analytics-tablist" style="display: flex; gap: 0.5rem; overflow-x: auto; flex: 1; min-width: 0;"></div>
                </div>
                <div id="analyticsPanelsWrapper">
                <div id="analyticsOverviewTab" data-dashboard-id="overview" role="tabpanel" style="display: block;">
                    <div id="overviewDepartmentCoursesWrap" style="display: none; margin-bottom: 1.5rem;"></div>
                    <div id="overviewAllInstitutionsWrap" style="display: none; margin-bottom: 1.5rem;"></div>
                    <div id="overviewStatsContainer"><p style="color: var(--text-light);">Loading analytics…</p><div class="spinner" style="margin: 1rem auto;" aria-hidden="true"></div></div>
                    <div id="overviewActionsWrap" style="display: flex; justify-content: flex-end; gap: 0.5rem; margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--border);">
                        <button type="button" id="analyticsEditCardsBtn" class="btn-secondary" style="padding: 0.35rem 0.75rem; font-size: 0.8rem;" title="Choose which cards appear on this tab">Edit cards</button>
                        <button type="button" id="analyticsCustomizeDashboardsBtn" class="btn-secondary" style="padding: 0.35rem 0.75rem; font-size: 0.8rem;" title="Show or hide tabs, reorder, add custom dashboards">Customize tabs</button>
                    </div>
                </div>
                <div id="analyticsComparisonsTab" data-dashboard-id="comparisons" role="tabpanel" style="display: none;"><p style="color: var(--text-light);">Comparison data will appear here...</p></div>
                <div id="analyticsEvaluationsTab" data-dashboard-id="evaluations" role="tabpanel" style="display: none;"><p style="color: var(--text-light);">Evaluation list will appear here...</p></div>
                <div id="analyticsExportTab" data-dashboard-id="export" role="tabpanel" style="display: none;">
                    <div class="card" data-widget-id="export-unified" style="margin-bottom: 0;">
                        <div id="exportTabTopBar" style="padding: 0.75rem 1rem; border-bottom: 1px solid var(--border); background: var(--bg-alt); display: flex; align-items: center; gap: 1rem; flex-wrap: nowrap;">
                            <span style="font-size: 0.85rem; color: var(--text-light); flex-shrink: 0;"><span id="exportPreviewCount">0</span> evaluations</span>
                            <button type="button" id="analyticsExportBtn" onclick="exportDepartmentData()" class="btn" style="background: var(--primary); color: white; padding: 0.5rem 1rem; font-size: 0.875rem; margin-left: auto;"><span class="icon-with-text"><i data-lucide="download"></i> Export CSV</span></button>
                        </div>
                        <div style="overflow-x: auto; max-height: 500px; overflow-y: auto;">
                            <table id="exportPreviewTable" class="data-table" style="width: 100%; min-width: 560px;">
                                <thead style="position: sticky; top: 0; background: var(--primary); color: #fff; z-index: 1;">
                                    <tr>
                                        <th data-sort="date" style="text-align: left; padding: 0.75rem; color: #fff; font-weight: 600;" title="Click label to sort; click ▾ to filter"><div class="export-th-inner"><span class="export-th-sort">Date</span><button type="button" class="export-th-filter" data-sort="date" aria-label="Filter Date">▾</button></div></th>
                                        <th data-sort="student" style="text-align: left; padding: 0.75rem; color: #fff; font-weight: 600;" title="Click label to sort; click ▾ to filter"><div class="export-th-inner"><span class="export-th-sort">Student</span><button type="button" class="export-th-filter" data-sort="student" aria-label="Filter Student">▾</button></div></th>
                                        <th data-sort="course" style="text-align: left; padding: 0.75rem; color: #fff; font-weight: 600;" title="Click label to sort; click ▾ to filter"><div class="export-th-inner"><span class="export-th-sort">Course</span><button type="button" class="export-th-filter" data-sort="course" aria-label="Filter Course">▾</button></div></th>
                                        <th data-sort="instructor" style="text-align: left; padding: 0.75rem; color: #fff; font-weight: 600;" title="Click label to sort; click ▾ to filter"><div class="export-th-inner"><span class="export-th-sort">Instructor</span><button type="button" class="export-th-filter" data-sort="instructor" aria-label="Filter Instructor">▾</button></div></th>
                                        <th data-sort="score" class="export-th-center" style="text-align: center; padding: 0.75rem; color: #fff; font-weight: 600;" title="Click label to sort; click ▾ to filter"><div class="export-th-inner"><span class="export-th-sort">Score %</span><button type="button" class="export-th-filter" data-sort="score" aria-label="Filter Score">▾</button></div></th>
                                        <th data-sort="rubric" style="text-align: left; padding: 0.75rem; color: #fff; font-weight: 600;" title="Click label to sort; click ▾ to filter"><div class="export-th-inner"><span class="export-th-sort">Rubric</span><button type="button" class="export-th-filter" data-sort="rubric" aria-label="Filter Rubric">▾</button></div></th>
                                    </tr>
                                </thead>
                                <tbody id="exportPreviewTableBody">
                                    <tr>
                                        <td colspan="6" style="text-align: center; padding: 2rem; color: var(--text-light);">Load data to see preview</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p style="margin: 0; padding: 0.75rem 1rem; font-size: 0.8rem; color: var(--text-light); border-top: 1px solid var(--border);">Exports only include evaluations from students who have granted data-use consent. <a href="javascript:void(0)" onclick="exportDepartmentData(); return false;" style="color: var(--primary); font-weight: 600; text-decoration: underline;">Export CSV</a></p>
                    </div>
                </div>
                <div id="analyticsCustomPanelsContainer"></div>
                </div>
                </div>
            </div>

            <!-- Metric Definition Modal -->
            <div id="metricDefinitionModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;" role="dialog" aria-labelledby="metricDefinitionTitle" aria-modal="true" onclick="if (event.target === this) closeMetricDefinition();">
                <div style="background: var(--bg); border: 1px solid var(--border); border-radius: 1rem; padding: 2rem; max-width: 600px; width: 90%; max-height: 85vh; overflow-y: auto; box-shadow: 0 10px 40px rgba(0,0,0,0.2);" onclick="event.stopPropagation();">
                    <h3 id="metricDefinitionTitle" style="margin: 0 0 1rem 0; color: var(--primary);"></h3>
                    <div id="metricDefinitionContent" style="margin-bottom: 1.5rem; color: var(--text); line-height: 1.6;"></div>
                    <div id="metricDefinitionLinks" style="padding: 1rem; background: var(--bg-alt); border-radius: 0.5rem; margin-bottom: 1.5rem;">
                        <p style="font-weight: 600; margin: 0 0 0.5rem 0; font-size: 0.9rem;">Learn more:</p>
                        <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                            <a href="#" onclick="return false;" style="color: var(--primary); text-decoration: underline; font-size: 0.875rem;" class="icon-with-text"><i data-lucide="bar-chart-2"></i> How this is measured</a>
                            <a href="#" onclick="switchAnalyticsTab('evaluations'); closeMetricDefinition(); return false;" style="color: var(--primary); text-decoration: underline; font-size: 0.875rem;" class="icon-with-text"><i data-lucide="search"></i> View evidence in Evaluations</a>
                            <a href="#" onclick="switchAnalyticsTab('evaluations'); closeMetricDefinition(); return false;" style="color: var(--primary); text-decoration: underline; font-size: 0.875rem;" class="icon-with-text"><i data-lucide="search"></i> View in Evaluations</a>
                        </div>
                    </div>
                    <button type="button" onclick="closeMetricDefinition()" class="btn" style="width: 100%; background: var(--primary); color: white;">Close</button>
                </div>
            </div>

            <!-- Customize Dashboards modal -->
            <div id="customizeDashboardsModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;" role="dialog" aria-labelledby="customizeDashboardsTitle" aria-modal="true" onclick="if (event.target === this) closeCustomizeDashboardsModal();">
                <div style="background: var(--bg); border: 1px solid var(--border); border-radius: 1rem; padding: 1.5rem; max-width: 480px; width: 90%; max-height: 85vh; overflow-y: auto; box-shadow: 0 10px 40px rgba(0,0,0,0.2);" onclick="event.stopPropagation();">
                    <h3 id="customizeDashboardsTitle" style="margin: 0 0 0.5rem 0;">Customize tabs</h3>
                    <p style="font-size: 0.875rem; color: var(--text-light); margin-bottom: 1rem;">Choose which tabs appear in the dashboard bar: <strong>Show</strong> / <strong>Hide</strong> to toggle, <strong>↑</strong> <strong>↓</strong> to reorder. To change which cards appear on a tab, close this and click <strong>Edit cards</strong> on that tab.</p>
                    <ul id="customizeDashboardsList" style="list-style: none; margin: 0 0 1rem 0; padding: 0;"></ul>
                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                        <button type="button" id="customizeDashboardsAdd" class="btn" style="background: var(--primary); color: white;">+ Add custom tab</button>
                        <button type="button" id="customizeDashboardsClose" class="btn-secondary">Done</button>
                    </div>
                </div>
            </div>

            <!-- Edit cards (widgets per tab) modal -->
            <div id="editCardsModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10001; align-items: center; justify-content: center;" role="dialog" aria-labelledby="editCardsTitle" aria-modal="true" onclick="if (event.target === this) closeEditCardsModal();">
                <div style="background: var(--bg); border: 1px solid var(--border); border-radius: 1rem; padding: 1.5rem; max-width: 480px; width: 90%; max-height: 85vh; overflow-y: auto; box-shadow: 0 10px 40px rgba(0,0,0,0.2);" onclick="event.stopPropagation();">
                    <h3 id="editCardsTitle" style="margin: 0 0 0.5rem 0;">Edit Overview cards</h3>
                    <p style="font-size: 0.875rem; color: var(--text-light); margin-bottom: 1rem;">Choose which cards appear on this tab: <strong>Remove</strong> / <strong>Add</strong> to hide or show a card, <strong>↑</strong> <strong>↓</strong> to reorder. Changes are saved automatically.</p>
                    <ul id="editCardsWidgetList" style="list-style: none; margin: 0 0 1rem 0; padding: 0;"></ul>
                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 1rem;">
                        <button type="button" id="editCardsAddNewSection" class="btn" style="background: var(--primary); color: white; font-size: 0.875rem;">+ Add custom card</button>
                    </div>
                    <button type="button" id="editCardsClose" class="btn-secondary">Done</button>
                </div>
            </div>

            <!-- ALL INSTITUTIONS SECTION (Super Admin only) -->
            <div id="allInstitutionsSection" class="card" style="display: none; margin-top: 2rem;">
                <div class="card-header">🌐 All Institutions</div>
                
                <!-- Filter Controls -->
                <div id="superAdminFilters" class="filter-controls" style="display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 1.5rem;">
                    <div class="filter-group">
                        <label for="filterInstitution" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Institution</label>
                        <select id="filterInstitution" onchange="onInstitutionFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; min-width: 200px;">
                            <option value="">All Institutions</option>
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="filterInstructor" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Instructor</label>
                        <select id="filterInstructor" onchange="onInstructorFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; min-width: 200px;">
                            <option value="">All Instructors</option>
                            <!-- Populated dynamically based on institution -->
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="filterYear" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Year</label>
                        <select id="filterYear" onchange="onYearFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                            <option value="">All Years</option>
                            <option value="2026">2026</option>
                            <option value="2025">2025</option>
                            <option value="2024">2024</option>
                            <option value="2023">2023</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="filterSemester" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Term</label>
                        <select id="filterSemester" onchange="onSemesterFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                            <option value="">All Terms</option>
                            <option value="Spring">Spring</option>
                            <option value="Summer">Summer</option>
                            <option value="Fall">Fall</option>
                            <option value="Winter">Winter</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="filterModality" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Modality</label>
                        <select id="filterModality" onchange="onModalityFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                            <option value="">All Modalities</option>
                            <option value="in-person">In-Person</option>
                            <option value="online">Online</option>
                            <option value="hybrid">Hybrid</option>
                        </select>
                    </div>
                    
                    <div class="filter-group" style="flex-grow: 1;">
                        <label for="filterSearch" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Search</label>
                        <input type="text" id="filterSearch" oninput="onSearchFilterChange()" placeholder="Search courses..." style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; width: 100%;">
                    </div>
                    
                    <div class="filter-group" style="align-self: flex-end;">
                        <button onclick="clearAllFilters()" class="btn-secondary" style="padding: 0.5rem 1rem;">Clear Filters</button>
                    </div>
                    
                    <div class="filter-group" style="align-self: flex-end;">
                        <button onclick="testTableRenderingWithMockData()" style="padding: 0.5rem 1rem; background: #28a745; color: white; border: none; border-radius: 0.25rem; cursor: pointer;">🧪 Test Table</button>
                    </div>
                </div>
                
                <!-- Results Info -->
                <div id="filterResultsInfo" style="margin-bottom: 1rem; color: var(--text-light); font-size: 0.9rem;">
                    Select filters to view courses
                </div>
                
                <!-- Data Table -->
                <div id="coursesTableContainer" style="overflow-x: auto;">
                    <table id="coursesTable" class="data-table" style="display: none;">
                        <thead>
                            <tr>
                                <th onclick="sortTableBy('name')">Course Name</th>
                                <th onclick="sortTableBy('code')">Code</th>
                                <th onclick="sortTableBy('instructor')">Instructor</th>
                                <th onclick="sortTableBy('institution')">Institution</th>
                                <th onclick="sortTableBy('semester')">Term/Year</th>
                                <th onclick="sortTableBy('modality')">Modality</th>
                                <th onclick="sortTableBy('students')">Students</th>
                                <th onclick="sortTableBy('evaluations')">Evaluations</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="coursesTableBody">
                            <!-- Populated dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- DEPARTMENT COURSES SECTION (Admin only) -->
            <div id="departmentCoursesSection" class="card" style="display: none; margin-top: 2rem;">
                <div class="card-header">🏛️ Department Courses</div>
                
                <!-- Admin Filter Controls -->
                <div id="adminFilters" class="filter-controls" style="display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 1.5rem;">
                    <div class="filter-group">
                        <label for="adminFilterInstructor" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Instructor</label>
                        <select id="adminFilterInstructor" onchange="onAdminInstructorFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; min-width: 200px;">
                            <option value="">All Instructors</option>
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="adminFilterYear" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Year</label>
                        <select id="adminFilterYear" onchange="onAdminYearFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                            <option value="">All Years</option>
                            <option value="2026">2026</option>
                            <option value="2025">2025</option>
                            <option value="2024">2024</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="adminFilterSemester" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Term</label>
                        <select id="adminFilterSemester" onchange="onAdminSemesterFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                            <option value="">All Terms</option>
                            <option value="Spring">Spring</option>
                            <option value="Summer">Summer</option>
                            <option value="Fall">Fall</option>
                            <option value="Winter">Winter</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="adminFilterModality" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Modality</label>
                        <select id="adminFilterModality" onchange="onAdminModalityFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                            <option value="">All Modalities</option>
                            <option value="in-person">In-Person</option>
                            <option value="online">Online</option>
                            <option value="hybrid">Hybrid</option>
                        </select>
                    </div>
                    
                    <div class="filter-group" style="align-self: flex-end;">
                        <button onclick="clearAdminFilters()" class="btn-secondary" style="padding: 0.5rem 1rem;">Clear Filters</button>
                    </div>
                    
                    <div class="filter-group" style="align-self: flex-end;">
                        <button onclick="testTableRenderingWithMockData()" style="padding: 0.5rem 1rem; background: #28a745; color: white; border: none; border-radius: 0.25rem; cursor: pointer;">🧪 Test Table</button>
                    </div>
                </div>
                
                <!-- Admin Results Info -->
                <div id="adminFilterResultsInfo" style="margin-bottom: 1rem; color: var(--text-light); font-size: 0.9rem;">
                    Loading department courses...
                </div>
                
                <!-- Admin Data Table -->
                <div id="adminCoursesTableContainer" style="overflow-x: auto;">
                    <table id="adminCoursesTable" class="data-table">
                        <thead>
                            <tr>
                                <th onclick="sortAdminTableBy('name')">Course Name</th>
                                <th onclick="sortAdminTableBy('code')">Code</th>
                                <th onclick="sortAdminTableBy('instructor')">Instructor</th>
                                <th onclick="sortAdminTableBy('semester')">Term/Year</th>
                                <th onclick="sortAdminTableBy('modality')">Modality</th>
                                <th onclick="sortAdminTableBy('students')">Students</th>
                                <th onclick="sortAdminTableBy('evaluations')">Evaluations</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="adminCoursesTableBody">
                            <!-- Populated dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- INSTRUCTOR FILTERS SECTION -->
            <div id="instructorFiltersSection" class="card" style="display: none; margin-top: 2rem;">
                <div class="card-header">Filter courses</div>
                
                <!-- Instructor Filter Controls -->
                <div id="instructorFilters" class="filter-controls" style="display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 1.5rem;">
                    <div class="filter-group">
                        <label for="instructorFilterCourse" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Course Name</label>
                        <select id="instructorFilterCourse" onchange="onInstructorCourseFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; min-width: 200px;">
                            <option value="">All Courses</option>
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="instructorFilterSemester" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Term</label>
                        <select id="instructorFilterSemester" onchange="onInstructorSemesterFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                            <option value="">All Terms</option>
                            <option value="Spring">Spring</option>
                            <option value="Summer">Summer</option>
                            <option value="Fall">Fall</option>
                            <option value="Winter">Winter</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="instructorFilterYear" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Year</label>
                        <select id="instructorFilterYear" onchange="onInstructorYearFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                            <option value="">All Years</option>
                            <option value="2026">2026</option>
                            <option value="2025">2025</option>
                            <option value="2024">2024</option>
                        </select>
                    </div>
                    
                    <div class="filter-group" style="align-self: flex-end;">
                        <button onclick="clearInstructorFilters()" class="btn-secondary" style="padding: 0.5rem 1rem;">Clear Filters</button>
                    </div>
                </div>
            </div>

            <!-- Create Class Form -->
            <div id="createClassCard" class="card hidden">
                <div class="card-header">Create New Class</div>
                <form id="createClassForm">
                    <div class="form-group">
                        <label for="className">Class Name *</label>
                        <input type="text" id="className" required placeholder="e.g., CMST 210">
                    </div>
                    <div class="form-group">
                        <label for="classSemester">Term</label>
                        <select id="classSemester">
                            <option value="Spring">Spring</option>
                            <option value="Summer">Summer</option>
                            <option value="Fall" selected>Fall</option>
                            <option value="Winter">Winter</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="classSection">Section</label>
                        <input type="text" id="classSection" placeholder="e.g., 001">
                    </div>
                    <div class="form-group">
                        <label for="classYear">Year</label>
                        <input type="number" id="classYear" value="2026">
                    </div>
                    <div class="form-group">
                        <label for="classNotes">Notes</label>
                        <textarea id="classNotes" placeholder="Optional notes about this class"></textarea>
                    </div>
                    <div style="display: flex; gap: 1rem;">
                        <button type="button" onclick="cancelCreateClass()" class="btn-secondary">Cancel</button>
                        <button type="submit">Create Class</button>
                    </div>
                </form>
            </div>

            <!-- Admin panel content moved here by JS for admin/super admin -->
            <div id="dashboardAdminContainer" style="display: none; margin-top: 2rem;"></div>
        </section>

        <!-- Settings Section -->
        <section id="settingsSection" class="section">
            <div class="card">
                <div class="card-header"><span class="icon-with-text"><i data-lucide="settings"></i> Settings</span></div>
                <div class="card-body" style="padding: 1.25rem;">
                <div id="settingsTablist" role="tablist" class="settings-tablist" aria-label="Settings sections">
                    <button type="button" id="settingsTabBtnGeneral" class="settings-tab settings-tab-active" role="tab" aria-selected="true" aria-controls="settingsTabGeneral" onclick="switchSettingsTab('general')"><span class="icon-with-text"><i data-lucide="settings"></i> General</span></button>
                    <button type="button" id="settingsTabBtnConsent" class="settings-tab" role="tab" aria-selected="false" aria-controls="settingsTabConsent" onclick="switchSettingsTab('consent')"><span class="icon-with-text"><i data-lucide="clipboard-check"></i> Consent</span></button>
                    <button type="button" id="settingsTabBtnAdmin" class="settings-tab" role="tab" aria-selected="false" aria-controls="settingsTabAdmin" onclick="switchSettingsTab('admin')" style="display: none;"><span class="icon-with-text"><i data-lucide="shield"></i> Admin</span></button>
                </div>

                <!-- General: API keys, Save -->
                <div id="settingsTabGeneral" role="tabpanel" aria-labelledby="settingsTabBtnGeneral" style="display: block;">
                <div class="form-group">
                    <label for="tenantSelect">University / Theme</label>
                    <select id="tenantSelect" onchange="switchTenant(this.value)">
                        <option value="default">Generic / Default</option>
                        <option value="utk">University of Tennessee, Knoxville</option>
                    </select>
                </div>

                <div style="margin-top: 2rem;">
                    <h3 class="settings-section-heading"><span class="icon-with-text"><i data-lucide="key"></i> API Keys</span></h3>
                    <p style="font-size: 0.9rem; color: var(--text-light); margin-bottom: 1.5rem;">
                        Save your API keys here so you don't have to enter them every time. Keys are stored securely in your browser.
                    </p>

                    <div class="form-group">
                        <label for="apiProviderSelect"><strong>Select API Provider</strong></label>
                        <select id="apiProviderSelect" onchange="showApiKeyInput(this.value)" style="width: 100%; padding: 0.75rem; border: 2px solid var(--border); border-radius: 0.5rem; font-size: 1rem;">
                            <option value="">-- Choose a provider --</option>
                            <option value="finetuned">Fine-tuned Model (Local Server)</option>
                            <option value="gemini">Google Gemini (Recommended)</option>
                            <option value="openai">OpenAI GPT-4</option>
                            <option value="anthropic">Anthropic Claude</option>
                        </select>
                    </div>

                    <!-- Fine-tuned Model Server URL -->
                    <div id="apiKeyInput-finetuned" class="api-key-input-section" style="display: none;">
                        <div class="form-group">
                            <label for="savedFinetunedUrl">
                                <strong>Evaluation Server URL</strong>
                            </label>
                            <input type="text" id="savedFinetunedUrl" placeholder="http://localhost:8000" style="width: 100%; padding: 0.75rem; border: 2px solid var(--border); border-radius: 0.5rem; font-size: 1rem;">
                            <p style="font-size: 0.875rem; color: var(--text-light); margin-top: 0.5rem;">
                                <strong>Use case:</strong> Speech evaluation with Fine-tuned Mistral 7B model<br>
                                <strong>Default:</strong> http://localhost:8000<br>
                                <strong>Setup:</strong> Run your local model server before evaluating
                            </p>
                        </div>
                    </div>

                    <!-- Google Gemini -->
                    <div id="apiKeyInput-gemini" class="api-key-input-section" style="display: none;">
                        <div class="form-group">
                            <label for="savedGeminiKey">
                                <strong>Google Gemini API Key</strong>
                            </label>
                            <input type="password" id="savedGeminiKey" placeholder="AIza..." style="width: 100%; padding: 0.75rem; border: 2px solid var(--border); border-radius: 0.5rem; font-size: 1rem;">
                            <p style="font-size: 0.875rem; color: var(--text-light); margin-top: 0.5rem;">
                                <strong>Use case:</strong> Full video analysis (recommended for most evaluations)<br>
                                <strong>Get your key:</strong> <a href="https://aistudio.google.com/app/apikey" target="_blank" style="color: var(--primary); text-decoration: underline;">aistudio.google.com/app/apikey</a><br>
                                <strong>Cost:</strong> Free tier available, then pay-as-you-go
                            </p>
                        </div>
                    </div>

                    <!-- OpenAI -->
                    <div id="apiKeyInput-openai" class="api-key-input-section" style="display: none;">
                        <div class="form-group">
                            <label for="savedOpenAIKey">
                                <strong>OpenAI API Key</strong>
                            </label>
                            <input type="password" id="savedOpenAIKey" placeholder="sk-proj-..." style="width: 100%; padding: 0.75rem; border: 2px solid var(--border); border-radius: 0.5rem; font-size: 1rem;">
                            <p style="font-size: 0.875rem; color: var(--text-light); margin-top: 0.5rem;">
                                <strong>Use case:</strong> Image analysis and frame-by-frame evaluation<br>
                                <strong>Get your key:</strong> <a href="https://platform.openai.com/api-keys" target="_blank" style="color: var(--primary); text-decoration: underline;">platform.openai.com/api-keys</a><br>
                                <strong>Cost:</strong> Pay-as-you-go pricing
                            </p>
                        </div>
                    </div>

                    <!-- Anthropic Claude -->
                    <div id="apiKeyInput-anthropic" class="api-key-input-section" style="display: none;">
                        <div class="form-group">
                            <label for="savedClaudeKey">
                                <strong>Anthropic Claude API Key</strong>
                            </label>
                            <input type="password" id="savedClaudeKey" placeholder="sk-ant-..." style="width: 100%; padding: 0.75rem; border: 2px solid var(--border); border-radius: 0.5rem; font-size: 1rem;">
                            <p style="font-size: 0.875rem; color: var(--text-light); margin-top: 0.5rem;">
                                <strong>Use case:</strong> Audio transcription and text-based evaluation<br>
                                <strong>Get your key:</strong> <a href="https://console.anthropic.com/" target="_blank" style="color: var(--primary); text-decoration: underline;">console.anthropic.com</a><br>
                                <strong>Cost:</strong> Pay-as-you-go pricing
                            </p>
                        </div>
                    </div>

                    <div id="apiKeyHelperText" style="padding: 1rem; background: var(--bg-alt); border-radius: 0.5rem; border-left: 4px solid var(--primary); margin-top: 1rem; display: none;">
                        <p style="margin: 0; font-size: 0.875rem; color: var(--text);">
                            <strong><span class="icon-with-text"><i data-lucide="lightbulb" style="width:1em;height:1em;"></i> Tip:</span></strong> You can configure multiple providers and switch between them when creating evaluations.
                        </p>
                    </div>
                </div>

                <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                    <button onclick="saveSettings()"><span class="icon-with-text"><i data-lucide="save"></i> Save Settings</span></button>
                </div>

                <div id="settingsMessage" class="hidden"></div>
                </div><!-- /settingsTabGeneral -->

                <!-- Tab: Consent -->
                <div id="settingsTabConsent" role="tabpanel" aria-labelledby="settingsTabBtnConsent" style="display: none; padding-top: 1.5rem;">
                <h3 class="settings-section-heading"><span class="icon-with-text"><i data-lucide="clipboard-check"></i> Consent Management</span></h3>
                <p style="color: var(--text-light); margin-bottom: 1rem;">Generate unique consent links for students. Email each student their link; when they open it and submit, their response is saved in the database.</p>
                <div class="info-box">
                    One consent covers: grading, platform and AI improvement, research, and potential sharing or licensing of data to third parties. Students who do not consent can still be evaluated; their data stays on your device only.
                </div>
                <div class="consent-toolbar">
                    <div class="form-group">
                        <label for="consentCourseSelect">Course</label>
                        <select id="consentCourseSelect">
                            <option value="">Select a course</option>
                        </select>
                    </div>
                    <button id="consentGenerateBtn" onclick="generateConsentLinks()" class="btn">Generate links for all students</button>
                </div>
                <div id="consentLinksMessage" style="margin-bottom: 1rem; color: var(--text-light); font-size: 0.9rem;"></div>
                <div id="consentLinksContainer" class="hidden">
                    <div class="consent-actions">
                        <button type="button" onclick="copyAllConsentLinks()" class="btn-secondary btn-small">Copy all links</button>
                        <button type="button" onclick="downloadConsentCSV()" class="btn-secondary btn-small">Download CSV</button>
                    </div>
                    <div style="overflow-x: auto;">
                        <table class="data-table" id="consentLinksTable">
                            <thead>
                                <tr><th>Student</th><th>Email</th><th>Consent link</th><th>Action</th></tr>
                            </thead>
                            <tbody id="consentLinksTableBody"></tbody>
                        </table>
                    </div>
                </div>
                </div><!-- /settingsTabConsent -->

                <!-- Tab: Admin (Admin Panel, Consent, Compliance, Theme, Create institution) -->
                <div id="settingsTabAdmin" role="tabpanel" aria-labelledby="settingsTabBtnAdmin" style="display: none; padding-top: 1.5rem;">
                <!-- Create new institution (Super Admin only) -->
                <div id="createInstitutionWrap" style="display: none; margin-top: 2.5rem;">
                    <hr style="margin: 2.5rem 0; border: none; border-top: 1px solid var(--border);">
                    <h3 class="settings-section-heading"><span class="icon-with-text"><i data-lucide="building-2"></i> Create new institution</span></h3>
                    <p style="margin-bottom: 1rem; font-size: 0.9rem; color: var(--text-light);">Add a new institution so you can assign users and create themes for it.</p>
                    <div style="display: flex; gap: 1rem; align-items: flex-end; flex-wrap: wrap;">
                        <div class="form-group" style="margin-bottom: 0; flex: 1; min-width: 200px;">
                            <label for="newInstitutionName"><strong>Institution name</strong></label>
                            <input type="text" id="newInstitutionName" placeholder="e.g. State University" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem;">
                        </div>
                        <button type="button" onclick="createNewInstitution()" class="btn" style="background: var(--primary); color: white;"><span class="icon-with-text"><i data-lucide="plus"></i> Create institution</span></button>
                    </div>
                    <div id="createInstitutionStatus" style="margin-top: 1rem;"></div>
                </div>

                <!-- Theme Customizer (admins/super admins only) -->
                <div id="themeCustomizerWrap" style="display: none; margin-top: 2.5rem;">
                    <hr style="margin: 2.5rem 0; border: none; border-top: 1px solid var(--border);">
                    <h3 class="settings-section-heading"><span class="icon-with-text"><i data-lucide="palette"></i> Theme Customizer</span></h3>
                    <p style="margin-bottom: 1rem; color: var(--text-light);">Customize your institution's colors, branding, and typography. Changes apply to all users in your institution.</p>
                    <div id="themeCustomizerSection" style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem;">
                        <!-- Super Admin: select which institution's theme to edit or create -->
                        <div id="themeInstitutionRow" style="display: none; margin-bottom: 1.5rem; padding-bottom: 1.5rem; border-bottom: 1px solid var(--border);">
                            <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Institution</label>
                            <select id="themeInstitutionSelect" style="width: 100%; max-width: 400px; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                <option value="">Select institution…</option>
                            </select>
                            <p style="margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-light);">Choose an institution to edit its theme or create a new theme for new institutions.</p>
                        </div>
                        <!-- Super Admin: assign (copy) a theme from one institution to another -->
                        <div id="assignThemeWrap" style="display: none; margin-bottom: 1.5rem; padding-bottom: 1.5rem; border-bottom: 1px solid var(--border);">
                            <h4 class="settings-section-subheading"><span class="icon-with-text"><i data-lucide="copy"></i> Assign theme to institution</span></h4>
                            <p style="margin-bottom: 1rem; font-size: 0.9rem; color: var(--text-light);">Copy an existing institution's theme (colors, logo, fonts) to another institution.</p>
                            <div style="display: flex; gap: 1rem; align-items: flex-end; flex-wrap: wrap;">
                                <div class="form-group" style="margin-bottom: 0; flex: 1; min-width: 180px;">
                                    <label for="assignThemeSourceSelect" style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Copy theme from</label>
                                    <select id="assignThemeSourceSelect" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                        <option value="">Select institution…</option>
                                    </select>
                                </div>
                                <div class="form-group" style="margin-bottom: 0; flex: 1; min-width: 180px;">
                                    <label for="assignThemeTargetSelect" style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Assign to institution</label>
                                    <select id="assignThemeTargetSelect" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                        <option value="">Select institution…</option>
                                    </select>
                                </div>
                                <button type="button" id="assignThemeBtn" onclick="assignThemeToInstitution()" class="btn" style="background: var(--primary); color: white; flex-shrink: 0;"><span class="icon-with-text"><i data-lucide="copy"></i> Assign theme</span></button>
                            </div>
                            <div id="assignThemeStatus" style="margin-top: 0.75rem;"></div>
                        </div>
                        <!-- Institution Logo -->
                        <div style="margin-bottom: 2rem; padding-bottom: 2rem; border-bottom: 1px solid var(--border);">
                            <h4 class="settings-section-subheading"><span class="icon-with-text"><i data-lucide="image"></i> Institution Logo</span></h4>
                                    <div style="display: flex; gap: 2rem; align-items: center;">
                                        <div>
                                            <div id="logoPreview" style="width: 100px; height: 100px; border-radius: 50%; background: white; display: flex; align-items: center; justify-content: center; border: 2px solid var(--border); overflow: hidden;">
                                                <span id="logoPlaceholder" style="font-size: 2rem; font-weight: bold; color: var(--primary);">LOGO</span>
                                                <img id="logoPreviewImage" style="width: 100%; height: 100%; object-fit: cover; display: none;">
                                            </div>
                                        </div>
                                        <div style="flex: 1;">
                                            <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Upload Logo Image</label>
                                            <input type="file" id="institutionLogoUpload" accept="image/*" onchange="handleLogoUpload(event)" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; width: 100%;">
                                            <p style="margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-light);">Recommended: Square image, at least 200x200px. Will be displayed as a circle.</p>
                                        </div>
                                    </div>
                                </div>
                        <!-- Color Settings -->
                        <div style="margin-bottom: 2rem; padding-bottom: 2rem; border-bottom: 1px solid var(--border);">
                            <h4 class="settings-section-subheading"><span class="icon-with-text"><i data-lucide="palette"></i> Institution Colors</span></h4>
                                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem;">
                                        <div>
                                            <label style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Primary Color (Buttons)</label>
                                            <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                                                <input type="color" id="themePrimaryColor" value="#1e3a5f" style="width: 60px; height: 40px; border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;" title="Pick color">
                                                <input type="text" id="themePrimaryText" value="#1e3a5f" style="flex: 1; min-width: 6rem; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;" placeholder="#000000" maxlength="7" title="Hex code">
                                                <button type="button" onclick="openThemeColorPicker('themePrimaryColor','themePrimaryText','Primary')" style="padding: 0.35rem 0.6rem; font-size: 0.8rem; background: var(--bg-alt); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer; color: var(--primary);">Color picker…</button>
                                            </div>
                                        </div>
                                        <div>
                                            <label style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Header Background</label>
                                            <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                                                <input type="color" id="themeHeaderColor" value="#142940" style="width: 60px; height: 40px; border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;" title="Pick color">
                                                <input type="text" id="themeHeaderText" value="#142940" style="flex: 1; min-width: 6rem; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;" placeholder="#000000" maxlength="7" title="Hex code">
                                                <button type="button" onclick="openThemeColorPicker('themeHeaderColor','themeHeaderText','Header')" style="padding: 0.35rem 0.6rem; font-size: 0.8rem; background: var(--bg-alt); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer; color: var(--primary);">Color picker…</button>
                                            </div>
                                        </div>
                                        <div>
                                            <label style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Secondary Color</label>
                                            <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                                                <input type="color" id="themeSecondaryColor" value="#8b9dc3" style="width: 60px; height: 40px; border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;" title="Pick color">
                                                <input type="text" id="themeSecondaryText" value="#8b9dc3" style="flex: 1; min-width: 6rem; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;" placeholder="#000000" maxlength="7" title="Hex code">
                                                <button type="button" onclick="openThemeColorPicker('themeSecondaryColor','themeSecondaryText','Secondary')" style="padding: 0.35rem 0.6rem; font-size: 0.8rem; background: var(--bg-alt); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer; color: var(--primary);">Color picker…</button>
                                            </div>
                                        </div>
                                        <div>
                                            <label style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Primary Text</label>
                                            <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                                                <input type="color" id="themeTextColor" value="#2c3e50" style="width: 60px; height: 40px; border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;" title="Pick color">
                                                <input type="text" id="themeTextText" value="#2c3e50" style="flex: 1; min-width: 6rem; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;" placeholder="#000000" maxlength="7" title="Hex code">
                                                <button type="button" onclick="openThemeColorPicker('themeTextColor','themeTextText','Primary Text')" style="padding: 0.35rem 0.6rem; font-size: 0.8rem; background: var(--bg-alt); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer; color: var(--primary);">Color picker…</button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                        <!-- Typography Settings -->
                        <div style="margin-bottom: 2rem; padding-bottom: 2rem; border-bottom: 1px solid var(--border);">
                            <h4 class="settings-section-subheading"><span class="icon-with-text"><i data-lucide="type"></i> Typography</span></h4>
                                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin-bottom: 1.5rem;">
                                        <div>
                                            <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Heading Font</label>
                                            <select id="themeHeadingFont" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                                <option value="'Inter', -apple-system, sans-serif">Inter (Default)</option>
                                                <option value="'Crimson Pro', serif">Crimson Pro (Serif)</option>
                                                <option value="'Montserrat', sans-serif">Montserrat</option>
                                                <option value="'Roboto', sans-serif">Roboto</option>
                                                <option value="'Open Sans', sans-serif">Open Sans</option>
                                                <option value="'Lato', sans-serif">Lato</option>
                                                <option value="'Poppins', sans-serif">Poppins</option>
                                                <option value="'Raleway', sans-serif">Raleway</option>
                                                <option value="'Playfair Display', serif">Playfair Display</option>
                                                <option value="'Georgia', serif">Georgia</option>
                                            </select>
                                        </div>
                                        <div>
                                            <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Body Font</label>
                                            <select id="themeBodyFont" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                                <option value="'Inter', -apple-system, sans-serif">Inter (Default)</option>
                                                <option value="'Work Sans', sans-serif">Work Sans</option>
                                                <option value="'Roboto', sans-serif">Roboto</option>
                                                <option value="'Open Sans', sans-serif">Open Sans</option>
                                                <option value="'Lato', sans-serif">Lato</option>
                                                <option value="'Source Sans Pro', sans-serif">Source Sans Pro</option>
                                                <option value="'Noto Sans', sans-serif">Noto Sans</option>
                                                <option value="'Georgia', serif">Georgia</option>
                                                <option value="'Times New Roman', serif">Times New Roman</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div style="background: var(--bg); padding: 1.5rem; border-radius: 0.5rem; border: 2px dashed var(--border);">
                                        <h5 style="margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;"><span class="icon-with-text"><i data-lucide="package" style="width:1.1em;height:1.1em;"></i> Custom Font Packages</span></h5>
                                        <p style="font-size: 0.9rem; color: var(--text-light); margin-bottom: 1rem;">Upload your institution's official font files. Supported formats: WOFF2, WOFF, TTF, OTF</p>
                                        <div style="margin-bottom: 1rem;">
                                            <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Font Family Name</label>
                                            <input type="text" id="customFontName" placeholder="e.g., UT Volunteer" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                            <p style="font-size: 0.85rem; color: var(--text-light); margin-top: 0.25rem;">This is the display name that will appear in the font selector.</p>
                                        </div>
                                        <div style="margin-bottom: 1rem;">
                                            <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Font Files</label>
                                            <input type="file" id="customFontFiles" accept=".woff2,.woff,.ttf,.otf" multiple style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                            <p style="font-size: 0.85rem; color: var(--text-light); margin-top: 0.25rem;">Select a folder or multiple font files. The system will automatically find and use only the Regular variant.</p>
                                            <div style="margin-top: 0.75rem; padding: 0.75rem; background: #fff3cd; border: 1px solid #ffc107; border-radius: 0.25rem;">
                                                <strong style="color: #856404;"><span class="icon-with-text"><i data-lucide="info" style="width:1em;height:1em;"></i> Storage Optimization:</span></strong>
                                                <span style="color: #856404; font-size: 0.85rem;">Only the <strong>Regular</strong> (normal weight) font file will be saved to the database. All Bold, Italic, and other variants will be discarded to save storage space.</span>
                                            </div>
                                        </div>
                                        <button onclick="uploadCustomFont()" style="background: var(--secondary);"><span class="icon-with-text"><i data-lucide="upload"></i> Upload Font Package</span></button>
                                        <div id="customFontsList" style="margin-top: 1rem; display: none;">
                                            <h6 style="margin-bottom: 0.5rem; font-weight: 600;">Installed Custom Fonts:</h6>
                                            <div id="customFontsContainer" style="display: flex; flex-direction: column; gap: 0.5rem;"></div>
                                        </div>
                                    </div>
                                </div>
                                <div style="display: flex; gap: 1rem; padding-top: 2rem; border-top: 1px solid var(--border); flex-wrap: wrap;">
                                    <button type="button" onclick="createNewTheme()" style="background: var(--primary); color: white;"><span class="icon-with-text"><i data-lucide="plus"></i> Create new theme</span></button>
                                    <button onclick="previewTheme()" style="background: var(--secondary);"><span class="icon-with-text"><i data-lucide="eye"></i> Preview</span></button>
                                    <button onclick="saveInstitutionTheme()" style="background: var(--success);"><span class="icon-with-text"><i data-lucide="save"></i> Save Theme</span></button>
                                    <button onclick="resetThemeForm()" style="background: var(--error);"><span class="icon-with-text"><i data-lucide="refresh-cw"></i> Reset</span></button>
                                </div>
                                <div id="themeStatus" style="margin-top: 1rem;"></div>
                    </div>
                </div>
                
                <!-- Shared HTML Color Codes–style color picker (2D + hue + hex/RGB) -->
                <div id="themeColorPickerPanel" class="theme-color-picker-panel" role="dialog" aria-label="Color picker" aria-modal="true">
                    <div class="picker-backdrop" onclick="closeThemeColorPicker()"></div>
                    <div>
                        <p style="margin: 0 0 0.75rem; font-weight: 600; font-size: 1rem;" id="themeColorPickerTitle">Pick color</p>
                        <div class="picker-2d-wrap" id="themePicker2dWrap">
                            <div class="picker-2d" id="themePicker2d"></div>
                            <div class="picker-2d-marker" id="themePicker2dMarker"></div>
                        </div>
                        <div class="picker-hue-wrap" id="themePickerHueWrap">
                            <div class="picker-hue-marker" id="themePickerHueMarker"></div>
                        </div>
                        <div class="picker-codes">
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <div class="picker-preview" id="themePickerPreview"></div>
                                <div>
                                    <label for="themePickerHex">Hex</label>
                                    <input type="text" id="themePickerHex" value="#1e3a5f" maxlength="7" placeholder="#000000" style="width: 7rem; margin-left: 0.35rem;">
                                </div>
                            </div>
                            <div>
                                <label>RGB</label>
                                <span id="themePickerRgb" style="font-family: ui-monospace, monospace; font-size: 0.875rem; margin-left: 0.35rem;">30, 58, 95</span>
                            </div>
                        </div>
                        <div class="picker-actions">
                            <button type="button" onclick="closeThemeColorPicker()" class="btn-secondary">Cancel</button>
                            <button type="button" id="themePickerApply" class="btn" style="background: var(--primary); color: white;">Apply</button>
                        </div>
                    </div>
                </div>

                <!-- Compliance Testing (Admins and Super Admins only; visibility set in JS) -->
                <div id="complianceTestingWrap" style="display: none; margin-top: 2.5rem;">
                    <hr style="margin: 2.5rem 0; border: none; border-top: 1px solid var(--border);">
                    <div id="complianceTestingSection">
                        <h3 class="settings-section-heading"><span class="icon-with-text"><i data-lucide="lock"></i> Compliance &amp; Testing</span></h3>
                        <p style="margin-bottom: 1rem; color: var(--text-light);">
                            Verify RLS policies and audit logging for FERPA compliance. Run tests as different roles (instructor, admin, super admin) to confirm access is correct.
                        </p>
                        <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem;">
                            <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                                <button type="button" onclick="testRLSPolicies()" class="btn-secondary">Test RLS policies</button>
                                <button type="button" onclick="verifyAuditLogs()" class="btn-secondary">Check audit logs</button>
                            </div>
                            <p style="margin-top: 1rem; font-size: 0.9rem; color: var(--text-light);">
                                <strong>RLS test</strong> checks that you can see your own courses/evaluations and (as instructor) cannot see others'. <strong>Audit logs</strong> shows your recent access entries; if read is restricted, check the <code>audit_logs</code> table in Supabase Dashboard.
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Admin Panel (Admins and Super Admins only; visibility set in JS) -->
                <div id="settingsAdminPanelWrap" style="display: none; margin-top: 2.5rem;">
                    <hr style="margin: 2.5rem 0; border: none; border-top: 1px solid var(--border);">
                    <h3 class="settings-section-heading"><span class="icon-with-text"><i data-lucide="shield"></i> Admin Panel</span></h3>
                    <!-- Department Instructors Section (for Admins) -->
                    <div id="departmentInstructorsSection" style="margin-bottom: 3rem;">
                        <h4 class="settings-section-subheading"><span class="icon-with-text"><i data-lucide="users"></i> Department Instructors</span></h4>
                        <p style="margin-bottom: 1rem; color: var(--text-light);">
                            View and manage instructors in your department.
                        </p>
                        <div style="margin-bottom: 2rem; display: flex; gap: 1rem; align-items: center;">
                            <button onclick="loadDepartmentInstructors()"><span class="icon-with-text"><i data-lucide="refresh-cw"></i> Refresh Instructors</span></button>
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <label for="semesterFilter" style="font-weight: 600;">Filter by Term:</label>
                                <select id="semesterFilter" onchange="filterBySemester()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                    <option value="all">All Terms</option>
                                    <option value="Fall 2024">Fall 2024</option>
                                    <option value="Spring 2025">Spring 2025</option>
                                    <option value="Fall 2025">Fall 2025</option>
                                    <option value="Spring 2026">Spring 2026</option>
                                </select>
                            </div>
                        </div>
                        <div id="departmentInstructorsContainer">
                            <p style="color: var(--text-light);">Click "Refresh Instructors" to load your department's instructors...</p>
                        </div>
                    </div>
                    <!-- User Management Section (for Super Admins) -->
                    <div id="userManagementSection">
                        <h4 class="settings-section-subheading"><span class="icon-with-text"><i data-lucide="user-cog"></i> User Management</span></h4>
                        <p style="margin-bottom: 1rem; color: var(--text-light);">
                            Manage user account tiers and research partner access.
                        </p>
                        <div style="margin-bottom: 2rem;">
                            <button onclick="loadAllUsers()" style="margin-right: 1rem;"><span class="icon-with-text"><i data-lucide="refresh-cw"></i> Refresh Users</span></button>
                            <button onclick="showInviteForm()" style="background: var(--success);"><span class="icon-with-text"><i data-lucide="user-plus"></i> Invite Research Partner</span></button>
                        </div>
                        <div id="usersListContainer">
                            <p style="color: var(--text-light);">Click "Refresh Users" to load user list...</p>
                        </div>
                    </div>
                    <!-- Invite Form (hidden by default) -->
                    <div id="inviteFormCard" class="card hidden" style="margin-top: 2rem;">
                        <div class="card-header">Invite New Research Partner</div>
                        <form id="inviteForm" onsubmit="sendInvite(event)">
                            <div class="form-group">
                                <label for="inviteEmail">Email Address *</label>
                                <input type="email" id="inviteEmail" required placeholder="instructor@university.edu">
                            </div>
                            <div class="form-group">
                                <label for="inviteName">Name</label>
                                <input type="text" id="inviteName" placeholder="Dr. Jane Smith">
                            </div>
                            <div class="form-group">
                                <label for="inviteInstitution">Institution</label>
                                <input type="text" id="inviteInstitution" placeholder="University Name">
                            </div>
                            <div class="form-group">
                                <label>
                                    <input type="checkbox" id="inviteAutoApprove" checked>
                                    Automatically grant Research Partner access
                                </label>
                            </div>
                            <div style="display: flex; gap: 1rem;">
                                <button type="button" onclick="cancelInvite()" class="btn-secondary">Cancel</button>
                                <button type="submit">Send Invitation</button>
                            </div>
                        </form>
                    </div>
                </div>
                </div><!-- /settingsTabAdmin -->
            </div>
            </div>
        </section>

        <!-- Class Detail Section (Simple) -->
        <section id="classDetailSection" class="section">
            <div class="card">
                <div class="card-header">
                    <span id="classDetailTitle">Class Details</span>
                    <button onclick="showDashboard()"><span class="icon-with-text"><i data-lucide="arrow-left"></i> Back to Dashboard</span></button>
                </div>
                
                <div id="classDetailContent"></div>
            </div>
            
            <!-- Add Student Form -->
            <div id="addStudentCard" class="card hidden">
                <div class="card-header"><span class="icon-with-text"><i data-lucide="user-plus"></i> Add Student</span></div>
                <form id="addStudentForm">
                    <div class="form-group">
                        <label for="studentFirstName">First Name *</label>
                        <input type="text" id="studentFirstName" required>
                    </div>
                    <div class="form-group">
                        <label for="studentLastName">Last Name *</label>
                        <input type="text" id="studentLastName" required>
                    </div>
                    <div class="form-group">
                        <label for="studentEmailAdd">Email</label>
                        <input type="email" id="studentEmailAdd">
                    </div>
                    <div class="form-group">
                        <label for="studentIdAdd">Student ID (optional)</label>
                        <input type="text" id="studentIdAdd">
                    </div>
                    <div style="display: flex; gap: 1rem;">
                        <button type="button" onclick="cancelAddStudent()" class="btn-secondary"><span class="icon-with-text"><i data-lucide="x"></i> Cancel</span></button>
                        <button type="submit"><span class="icon-with-text"><i data-lucide="user-plus"></i> Add Student</span></button>
                    </div>
                </form>
            </div>
        </section>

        <!-- Upload Rubric Form -->
        <div id="uploadRubricCard" class="card hidden" style="margin-top: 2rem;">
            <div class="card-header"><span class="icon-with-text"><i data-lucide="file-up"></i> Upload Rubric from PDF or Image</span></div>
            <div style="background: #e3f2fd; padding: 1rem; border-radius: 0.5rem; margin-bottom: 1.5rem; border-left: 4px solid #2196f3;">
                <strong><span class="icon-with-text"><i data-lucide="clipboard-list" style="width:1em;height:1em;"></i> How it works:</span></strong>
                <p style="margin: 0.5rem 0 0 0;">Upload a PDF or image of your rubric, and AI will extract the categories, criteria, and point values to create a digital rubric automatically.</p>
            </div>
            
            <form id="uploadRubricForm">
                <div class="form-group">
                    <label for="uploadRubricFile">Upload Rubric File *</label>
                    <input 
                        type="file" 
                        id="uploadRubricFile" 
                        accept=".pdf,.png,.jpg,.jpeg,.webp" 
                        required
                        style="width: 100%; padding: 0.75rem; border: 2px dashed var(--border); border-radius: 0.5rem; background: var(--bg);"
                    >
                    <small style="color: var(--text-light); display: block; margin-top: 0.5rem;">
                        Supported formats: PDF, PNG, JPG, JPEG, WebP (max 10MB)
                    </small>
                </div>
                
                <div class="form-group">
                    <label for="uploadRubricName">Rubric Name *</label>
                    <input 
                        type="text" 
                        id="uploadRubricName" 
                        placeholder="e.g., Persuasive Speech Rubric" 
                        required
                    >
                </div>
                
                <div class="form-group">
                    <label for="uploadAiProvider">AI Provider for Extraction *</label>
                    <select id="uploadAiProvider" required>
                        <option value="">-- Select AI Provider --</option>
                        <option value="gemini">Google Gemini (Recommended - Free)</option>
                        <option value="gpt4o">OpenAI GPT-4o (Supports images)</option>
                        <option value="claude">Anthropic Claude (Best accuracy)</option>
                    </select>
                </div>
                
                <div class="form-group" id="uploadApiKeyGroup">
                    <label for="uploadApiKey" id="uploadApiKeyLabel">API Key *</label>
                    <input 
                        type="password" 
                        id="uploadApiKey" 
                        placeholder="Enter your API key"
                    >
                    <small style="color: var(--text-light); display: block; margin-top: 0.5rem;">
                        Your API key will be used to process the rubric. You can save it in Settings for future use.
                    </small>
                </div>
                
                <div id="uploadProgress" class="hidden" style="margin: 1.5rem 0; padding: 1rem; background: var(--bg); border-radius: 0.5rem;">
                    <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem;">
                        <div class="spinner"></div>
                        <span id="uploadProgressText">Processing rubric...</span>
                    </div>
                    <div style="background: white; height: 8px; border-radius: 4px; overflow: hidden;">
                        <div id="uploadProgressBar" style="width: 0%; height: 100%; background: var(--primary); transition: width 0.3s;"></div>
                    </div>
                </div>
                
                <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                    <button type="button" onclick="cancelUploadRubric()">Cancel</button>
                    <button type="submit" style="background: var(--primary);">🚀 Extract & Create Rubric</button>
                </div>
            </form>
        </div>

        <!-- Support Section -->
        <section id="helpSection" class="section">
            <div class="card">
                <div class="card-header"><span class="icon-with-text"><i data-lucide="help-circle"></i> Support</span></div>
                <div class="card-body" style="padding: 1.25rem;">
                    <p id="supportVersionBanner" style="margin-bottom: 1.5rem; padding: 0.75rem 1rem; background: var(--bg-alt); border-radius: 0.5rem; font-size: 0.95rem; color: var(--text-light);">
                        <strong style="color: var(--primary);">SpeechGradebook</strong> <span id="supportVersionText">v3.0</span> <span id="supportVersionLabel"></span>
                    </p>

                    <div id="supportDocTablist" role="tablist" class="support-tablist" aria-label="Support documentation">
                        <button type="button" id="supportTabBtnGettingStarted" class="support-tab support-tab-active" role="tab" aria-selected="true" aria-controls="supportPanelGettingStarted" onclick="switchSupportDocTab('getting-started')"><span class="icon-with-text"><i data-lucide="rocket"></i> Getting Started</span></button>
                        <button type="button" id="supportTabBtnUserManual" class="support-tab" role="tab" aria-selected="false" aria-controls="supportPanelUserManual" onclick="switchSupportDocTab('user-manual')"><span class="icon-with-text"><i data-lucide="book-open"></i> User Manual</span></button>
                        <button type="button" id="supportTabBtnTechnical" class="support-tab" role="tab" aria-selected="false" aria-controls="supportPanelTechnical" onclick="switchSupportDocTab('technical')"><span class="icon-with-text"><i data-lucide="file-code"></i> Technical Documentation</span></button>
                    </div>

                    <!-- Panel: Getting Started (detailed procedures) -->
                    <div id="supportPanelGettingStarted" class="support-doc-panel active" role="tabpanel" aria-labelledby="supportTabBtnGettingStarted">
                        <p style="margin-bottom: 1.5rem; color: var(--text-light);">
                            Step-by-step guides for the main areas of SpeechGradebook. Content below is relevant to your role where noted.
                        </p>

                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="mic"></i> How to Evaluate a Speech</span></h3>
                        <p style="margin-bottom: 0.5rem;">Run an AI evaluation on a student's audio or video recording.</p>
                        <ol style="margin-bottom: 1.5rem; padding-left: 1.5rem;">
                            <li style="margin-bottom: 0.5rem;">Click <strong>Evaluate Speech</strong> in the navigation.</li>
                            <li style="margin-bottom: 0.5rem;">Upload an audio or video file (MP3, MP4, WAV, M4A, WebM; for GPT-4o, image/screenshot also supported).</li>
                            <li style="margin-bottom: 0.5rem;">Select or create a course and student (or enter details). Choose a rubric.</li>
                            <li style="margin-bottom: 0.5rem;">Choose an API provider in the evaluation flow (Gemini, GPT-4o, Claude, or Fine-tuned server) and ensure the key or server URL is set in <strong>Settings</strong>.</li>
                            <li style="margin-bottom: 0.5rem;">Click <strong>Continue to Evaluation</strong> and wait for analysis.</li>
                            <li style="margin-bottom: 0.5rem;">Review results, download PDF, or email to student.</li>
                        </ol>

                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="key"></i> Getting API Keys</span></h3>
                        <p style="margin-bottom: 0.5rem;">Save provider keys or the Fine-tuned server URL in <strong>Settings → General → API Keys</strong> so you don't re-enter them each time.</p>
                        <ul style="margin-bottom: 1.5rem; padding-left: 1.5rem;">
                            <li style="margin-bottom: 0.5rem;"><strong>Google Gemini</strong> (recommended): <a href="https://aistudio.google.com/app/apikey" target="_blank" style="color: var(--primary);">aistudio.google.com/app/apikey</a></li>
                            <li style="margin-bottom: 0.5rem;"><strong>OpenAI GPT-4o</strong>: <a href="https://platform.openai.com/api-keys" target="_blank" style="color: var(--primary);">platform.openai.com/api-keys</a></li>
                            <li style="margin-bottom: 0.5rem;"><strong>Anthropic Claude</strong>: <a href="https://console.anthropic.com" target="_blank" style="color: var(--primary);">console.anthropic.com</a></li>
                            <li style="margin-bottom: 0.5rem;"><strong>Fine-tuned model</strong>: Enter your evaluation server URL (e.g. your Render or local server).</li>
                        </ul>

                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="book-open"></i> Managing Courses</span> <span class="support-tier-badge" data-tier="instructor">Instructor</span></h3>
                        <p style="margin-bottom: 0.5rem;">From the Dashboard, create and manage courses. Add students, run evaluations, and view history. Data is stored in the cloud (Supabase) for your institution.</p>
                        <ol style="margin-bottom: 1.5rem; padding-left: 1.5rem;">
                            <li style="margin-bottom: 0.5rem;">Open <strong>Dashboard</strong> and use the <strong>Courses</strong> tab.</li>
                            <li style="margin-bottom: 0.5rem;">Create a course (name, term, year, modality). Add students to the course.</li>
                            <li style="margin-bottom: 0.5rem;">Evaluations are linked to course and student; view and filter from the course or from Course Insights.</li>
                        </ol>

                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="list-checks"></i> Custom Rubrics</span> <span class="support-tier-badge" data-tier="instructor">Instructor</span></h3>
                        <p style="margin-bottom: 0.5rem;">Create rubrics tailored to your assignments. The AI scores and comments using your criteria.</p>
                        <ol style="margin-bottom: 1.5rem; padding-left: 1.5rem;">
                            <li style="margin-bottom: 0.5rem;">Dashboard → <strong>Rubrics</strong>. Create a new rubric or use an existing one.</li>
                            <li style="margin-bottom: 0.5rem;">Define categories, subcategories, and point values. Optionally upload a PDF/image and extract criteria.</li>
                            <li style="margin-bottom: 0.5rem;">Select the rubric when starting an evaluation.</li>
                        </ol>

                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="bar-chart-2"></i> Course Insights (Analytics)</span> <span class="support-tier-badge" data-tier="instructor">Instructor</span></h3>
                        <p style="margin-bottom: 1.5rem;">View overview metrics, comparisons, and evaluation lists. Export data from the Export tab. <span class="support-tier-badge" data-tier="admin">Admin</span> and <span class="support-tier-badge" data-tier="super_admin">Super Admin</span> see department- or institution-wide dashboards and filters.</p>

                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="clipboard-check"></i> Consent</span></h3>
                        <p style="margin-bottom: 1.5rem;">In <strong>Settings → Consent</strong>, generate student consent links per course. Students open the link and submit consent; evaluations for consenting students can be stored in the cloud. Instructor LLM consent is requested once at first use.</p>

                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="shield"></i> Admin &amp; Institution Management</span> <span class="support-tier-badge" data-tier="admin">Admin</span> <span class="support-tier-badge" data-tier="super_admin">Super Admin</span></h3>
                        <p style="margin-bottom: 1.5rem;">Admins see <strong>Settings → Admin</strong>: manage API keys for the institution, view all courses (with filters). Super Admins can manage institutions, themes, fonts, and global settings.</p>
                    </div>

                    <!-- Panel: User Manual (technical how-to) -->
                    <div id="supportPanelUserManual" class="support-doc-panel" role="tabpanel" aria-labelledby="supportTabBtnUserManual">
                        <p style="margin-bottom: 1.5rem; color: var(--text-light);">Technical reference for using SpeechGradebook features and workflows.</p>
                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="compass"></i> Navigation &amp; Sections</span></h3>
                        <p style="margin-bottom: 1rem;">The header shows the app name, main navigation links, and the logged-in user's <strong>name</strong> (from your profile) next to <strong>Logout</strong>. Main sections: <strong>Evaluate Speech</strong> (run evaluations), <strong>Dashboard</strong> (Courses, Rubrics, Course Insights), <strong>Settings</strong> (General, Consent, Admin if applicable), <strong>Support</strong> (this area). Visibility of Dashboard tabs and Settings tabs depends on your account tier (instructor, admin, super_admin).</p>
                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="git-branch"></i> Evaluation Flow</span></h3>
                        <p style="margin-bottom: 1rem;">Multi-step wizard: upload file → course/student/rubric → API provider → run evaluation → results. You can download a PDF report or email the student from the results step. Supported media: MP3, MP4, WAV, M4A, WebM; GPT-4o also accepts image/screenshot (JPG, PNG).</p>
                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="layout-dashboard"></i> Dashboard</span></h3>
                        <p style="margin-bottom: 1rem;"><strong>Courses:</strong> Create/edit courses, add students, see evaluations per course. <strong>Rubrics:</strong> Create and edit rubrics; use extract-from-PDF to build criteria. <strong>Course Insights:</strong> Overview, comparisons, evaluation list, and export. Admins see institution/department scope and instructor filters.</p>
                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="settings"></i> Settings</span></h3>
                        <p style="margin-bottom: 1rem;"><strong>General:</strong> Tenant/theme selector, API keys (Gemini, OpenAI, Anthropic, Fine-tuned URL). <strong>Consent:</strong> Generate student consent links; view consent status. <strong>Admin:</strong> (Admin/Super Admin only) Institution API keys, course filters, and (Super Admin) institution list, theme customizer, font packages.</p>
                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="palette"></i> Themes &amp; Branding</span></h3>
                        <p style="margin-bottom: 1rem;">Institutions can have a custom theme (colors, logo, fonts). Super Admins configure themes per institution in Settings → Admin → theme customizer. Users in an institution see that theme when selected.</p>
                    </div>

                    <!-- Panel: Technical Documentation -->
                    <div id="supportPanelTechnical" class="support-doc-panel" role="tabpanel" aria-labelledby="supportTabBtnTechnical">
                        <p style="margin-bottom: 1.5rem; color: var(--text-light);">Data management, change history, and legal information.</p>

                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="database"></i> How Data Is Managed</span></h3>
                        <p style="margin-bottom: 0.5rem;">SpeechGradebook uses <strong>Supabase</strong> for authentication and database. Data is stored per institution with row-level security (RLS):</p>
                        <ul style="margin-bottom: 1rem; padding-left: 1.5rem;">
                            <li style="margin-bottom: 0.5rem;"><strong>Instructors</strong> see only their own courses, students, rubrics, and evaluations.</li>
                            <li style="margin-bottom: 0.5rem;"><strong>Admins</strong> see data for their department/institution; they can filter by instructor and view analytics across courses.</li>
                            <li style="margin-bottom: 0.5rem;"><strong>Super Admins</strong> can manage institutions, themes, and (where configured) view cross-institution data.</li>
                            <li style="margin-bottom: 0.5rem;">Student consent is recorded in <code>consent_forms</code>; evaluations for non-consenting students are not stored in the cloud (local-only behavior when applicable).</li>
                            <li style="margin-bottom: 0.5rem;">Access to student data is logged in <strong>audit_logs</strong> for FERPA and compliance (purpose, justification, IP, user agent).</li>
                        </ul>

                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="history"></i> Change Log</span></h3>
                        <p style="margin-bottom: 0.5rem;">Recent changes to SpeechGradebook. For the full history, see <code>CHANGELOG.md</code> in the project.</p>
                        <div id="supportChangelogContent" style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-alt); border-radius: 0.5rem; font-size: 0.9rem; white-space: pre-wrap;"></div>

                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="scale"></i> Licensing &amp; Legal</span></h3>
                        <p style="margin-bottom: 0.5rem;">SpeechGradebook is provided for educational use. By using the application you agree to your institution's terms and any applicable privacy policies. Student data is processed in accordance with FERPA and your institution's data agreements. For third-party AI providers (e.g. Google, OpenAI, Anthropic), their respective terms and privacy policies apply to API usage.</p>
                        <p style="margin-bottom: 0.5rem;"><strong>Custom / fine-tuned LLM:</strong> The optional fine-tuned evaluation model is based on <strong>Mistral 7B Instruct</strong> (Apache 2.0). If you <strong>distribute</strong> the model, adapter weights, or training/serving code that includes that model, you must include the Apache 2.0 license and any required attribution (e.g. Mistral AI, and PEFT if applicable). See <code>llm_training/LICENSE</code> in the project for the Apache 2.0 text and third-party notices. Internal use only (no redistribution) does not require including the license in the app UI.</p>
                        <p style="margin-bottom: 0.5rem;">Contact your institution or the support email below for licensing and legal questions.</p>
                    </div>

                    <hr style="margin: 1.5rem 0; border: none; border-top: 1px solid var(--border);">
                    <h3 style="margin-bottom: 0.5rem;"><span class="icon-with-text"><i data-lucide="mail"></i> Contact Support</span></h3>
                    <p>
                        For questions or technical support, contact: <strong id="supportEmail"><a href="mailto:speechgradebook@proton.me">speechgradebook@proton.me</a></strong>
                    </p>
                </div>
            </div>
        </section>

    </main>

    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-links" id="footerLinks">
                    <a href="privacy.html">Privacy Policy</a>
                    <a href="terms.html">Terms of Service</a>
                </div>
                <p id="footerCopyright">© 2026 Speech Gradebook</p>
                <p id="footerAdditional" style="opacity: 0.8; font-size: 0.9rem;"></p>
            </div>
        </div>
    </footer>

    <script>
        // ===== CONFIGURATION =====
        // Note: In production, these should be loaded from environment variables or a secure endpoint
        const CONFIG = {
            SUPABASE_URL: window.SUPABASE_URL || 'https://mqhbfefylpfqsbtrshpu.supabase.co',
            SUPABASE_ANON_KEY: window.SUPABASE_ANON_KEY || 'sb_publishable_dypr7H7lUg2JGsvewz3VTQ_uov-ty72',
            DEBUG: window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1',
            appVersion: '3.0',
            appVersionLabel: 'Supabase Edition'
        };
        
        // Legacy constants for backward compatibility
        const SUPABASE_URL = CONFIG.SUPABASE_URL;
        const SUPABASE_ANON_KEY = CONFIG.SUPABASE_ANON_KEY;
        
        // ===== SECURITY UTILITIES =====
        
        /**
         * Escapes HTML special characters to prevent XSS attacks
         * @param {string} text - Text to escape
         * @returns {string} Escaped HTML-safe text
         */
        function escapeHtml(text) {
            if (text == null) return '';
            const str = String(text);
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return str.replace(/[&<>"']/g, m => map[m]);
        }
        
        /**
         * Safely sets innerHTML with escaped content
         * @param {HTMLElement|string} element - Element or element ID
         * @param {string} html - HTML content (will be escaped if needed)
         * @param {boolean} allowHtml - If true, allows HTML (use with caution)
         */
        function safeSetInnerHTML(element, html, allowHtml = false) {
            const el = typeof element === 'string' ? document.getElementById(element) : element;
            if (!el) {
                if (CONFIG.DEBUG) console.warn('Element not found for safeSetInnerHTML:', element);
                return;
            }
            el.innerHTML = allowHtml ? html : escapeHtml(String(html));
        }
        
        // ===== INPUT VALIDATION =====
        
        /**
         * Validates API key format based on provider
         * @param {string} key - API key to validate
         * @param {string} provider - Provider name ('gemini', 'gpt4o', 'claude')
         * @returns {boolean} True if format is valid
         */
        function validateApiKeyFormat(key, provider) {
            if (!key || typeof key !== 'string' || key.trim().length === 0) {
                return false;
            }
            
            const trimmedKey = key.trim();
            
            switch (provider) {
                case 'gemini':
                    return trimmedKey.startsWith('AIza') && trimmedKey.length >= 35;
                case 'gpt4o':
                case 'openai':
                    return trimmedKey.startsWith('sk-') && trimmedKey.length >= 20;
                case 'claude':
                case 'anthropic':
                    return trimmedKey.startsWith('sk-ant-') && trimmedKey.length >= 20;
                default:
                    return trimmedKey.length > 0; // Basic non-empty check
            }
        }
        
        /**
         * Validates file type for upload
         * @param {File} file - File object to validate
         * @param {string[]} allowedTypes - Array of allowed MIME types
         * @returns {object} {valid: boolean, error: string}
         */
        function validateFileType(file, allowedTypes = []) {
            if (!file) {
                return { valid: false, error: 'No file provided' };
            }
            
            if (allowedTypes.length > 0 && !allowedTypes.includes(file.type)) {
                return { 
                    valid: false, 
                    error: `File type ${file.type} not allowed. Allowed types: ${allowedTypes.join(', ')}` 
                };
            }
            
            return { valid: true };
        }
        
        /**
         * Validates file size
         * @param {File} file - File object to validate
         * @param {number} maxSizeBytes - Maximum size in bytes
         * @returns {object} {valid: boolean, error: string}
         */
        function validateFileSize(file, maxSizeBytes) {
            if (!file) {
                return { valid: false, error: 'No file provided' };
            }
            
            if (file.size > maxSizeBytes) {
                const sizeMB = (file.size / 1024 / 1024).toFixed(2);
                const limitMB = (maxSizeBytes / 1024 / 1024).toFixed(0);
                return { 
                    valid: false, 
                    error: `File size (${sizeMB} MB) exceeds limit (${limitMB} MB)` 
                };
            }
            
            return { valid: true };
        }
        
        /**
         * Validates email format
         * @param {string} email - Email to validate
         * @returns {boolean} True if valid email format
         */
        function validateEmail(email) {
            if (!email || typeof email !== 'string') return false;
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            return emailRegex.test(email.trim());
        }
        
        /**
         * Sanitizes string input (removes potentially dangerous characters)
         * @param {string} input - Input to sanitize
         * @param {number} maxLength - Maximum length (optional)
         * @returns {string} Sanitized string
         */
        function sanitizeInput(input, maxLength = null) {
            if (input == null) return '';
            let sanitized = String(input).trim();
            
            // Remove null bytes and control characters (except newlines/tabs)
            sanitized = sanitized.replace(/[\x00-\x08\x0B-\x0C\x0E-\x1F\x7F]/g, '');
            
            if (maxLength && sanitized.length > maxLength) {
                sanitized = sanitized.substring(0, maxLength);
            }
            
            return sanitized;
        }
        
        // ===== DEBUG LOGGING =====
        
        /**
         * Debug logging wrapper - only logs in development mode
         */
        const log = {
            debug: CONFIG.DEBUG ? console.log.bind(console) : () => {},
            warn: CONFIG.DEBUG ? console.warn.bind(console) : () => {},
            error: console.error.bind(console), // Always log errors
            info: CONFIG.DEBUG ? console.info.bind(console) : () => {}
        };
        
        // Initialize Supabase client
        let supabaseClient = null;
        
        try {
            if (window.supabase) {
                supabaseClient = window.supabase.createClient(CONFIG.SUPABASE_URL, CONFIG.SUPABASE_ANON_KEY);
                log.debug('✓ Supabase client initialized');
            } else {
                log.warn('⚠️ Supabase library not loaded - using localStorage fallback');
            }
        } catch (error) {
            log.error('❌ Supabase initialization failed:', error);
            log.debug('Using localStorage fallback mode');
        }
        
        // Test Supabase connection
        async function testSupabaseConnection() {
            if (!supabaseClient) {
                log.debug('Supabase not available - running in offline mode');
                return false;
            }
            
            try {
                log.debug('Testing Supabase connection...');
                const { data, error } = await supabaseClient
                    .from('organizations')
                    .select('name')
                    .limit(1);
                
                if (error) {
                    log.error('❌ Supabase connection failed:', error.message);
                    return false;
                } else {
                    log.debug('✅ Supabase connected successfully!');
                    if (data && data.length > 0) {
                        log.debug('   Organization:', data[0].name);
                    }
                    return true;
                }
            } catch (error) {
                log.error('❌ Supabase test error:', error);
                return false;
            }
        }
        
        // ===== AUTHENTICATION FUNCTIONS =====
        
        let currentUser = null;
        let userTier = 'demo'; // 'demo', 'instructor', 'admin', or 'super_admin'
        let currentViewMode = 'own'; // 'own' (default), 'institution' (admin), 'all' (super_admin), 'demo'
        let demoViewAs = 'instructor'; // 'instructor' | 'admin' — for demo mode dashboard view switcher
        let currentInstitution = null;
        let currentInstitutionTheme = null; // Store loaded theme
        let cachedDepartmentInstructors = []; // Cache for semester filtering
        let currentFilterInstitutionId = null; // Super admin: filter courses by this institution
        let currentFilterInstructorId = null;  // Admin/super admin: filter courses by this instructor when viewing institution
        
        // ===== AUDIT LOGGING FOR FERPA COMPLIANCE =====
        /**
         * Log access to student data for FERPA compliance
         * @param {string} action - 'view', 'create', 'update', 'delete', 'export', 'print'
         * @param {string} tableName - Name of table accessed
         * @param {string|null} recordId - ID of specific record (if applicable)
         * @param {string|null} studentId - ID of student whose data was accessed
         * @param {object} metadata - Additional context information
         */
        async function logAccess(action, tableName, recordId = null, studentId = null, metadata = {}) {
            if (!supabaseClient || !currentUser) {
                log.debug('Cannot log access: No Supabase client or user');
                return;
            }
            try {
                let accessPurpose = '';
                let educationalInterest = '';
                if (userTier === 'instructor') {
                    accessPurpose = 'Grading and evaluation purposes';
                    educationalInterest = 'Instructor needs access to evaluate student performance and provide feedback';
                } else if (userTier === 'admin') {
                    accessPurpose = 'Department-wide analytics and oversight';
                    educationalInterest = 'Administrator needs access for department-wide analytics and oversight';
                } else if (userTier === 'super_admin') {
                    accessPurpose = 'System administration and LLM training data preparation';
                    educationalInterest = 'System administrator needs access for system maintenance and LLM training data preparation';
                } else {
                    accessPurpose = 'Educational purposes';
                    educationalInterest = 'Access required for educational purposes';
                }
                let clientIP = null;
                try {
                    const response = await fetch('https://api.ipify.org?format=json');
                    const data = await response.json();
                    clientIP = data.ip;
                } catch (e) {
                    log.debug('Could not detect IP address');
                }
                const auditEntry = {
                    user_id: currentUser.id,
                    action: action,
                    table_name: tableName,
                    record_id: recordId,
                    student_id: studentId,
                    access_purpose: accessPurpose,
                    educational_interest_justification: educationalInterest,
                    ip_address: clientIP,
                    user_agent: navigator.userAgent,
                    metadata: metadata
                };
                const { error } = await supabaseClient
                    .from('audit_logs')
                    .insert([auditEntry]);
                if (error) {
                    log.error('Failed to log access:', error);
                } else {
                    log.debug('✓ Logged ' + action + ' access to ' + tableName);
                }
            } catch (error) {
                log.error('Error in logAccess:', error);
            }
        }
        
        // Phase 4: Test RLS policies (courses, evaluations visibility by role)
        async function testRLSPolicies() {
            if (!supabaseClient || !currentUser) {
                alert('Cannot test: Not logged in.');
                return;
            }
            const results = { canViewOwnCourses: false, canViewOwnEvaluations: false, cannotViewOtherCourses: true, cannotViewOtherEvaluations: true };
            try {
                const { data: ownCourses, error: e1 } = await supabaseClient.from('courses').select('id, name').eq('instructor_id', currentUser.id).limit(1);
                results.canViewOwnCourses = !e1 && ownCourses && ownCourses.length > 0;
                const { data: ownEvals, error: e2 } = await supabaseClient.from('evaluations').select('id').eq('instructor_id', currentUser.id).limit(1);
                // Pass if query ran without RLS error; empty result is OK (e.g. admin with no evaluations yet)
                results.canViewOwnEvaluations = !e2;
                if (userTier === 'instructor') {
                    const { data: otherCourses } = await supabaseClient.from('courses').select('id, name, instructor_id').neq('instructor_id', currentUser.id).limit(1);
                    results.cannotViewOtherCourses = !otherCourses || otherCourses.length === 0;
                    const { data: otherEvals } = await supabaseClient.from('evaluations').select('id').neq('instructor_id', currentUser.id).limit(1);
                    results.cannotViewOtherEvaluations = !otherEvals || otherEvals.length === 0;
                }
                const ok = results.canViewOwnCourses && results.canViewOwnEvaluations && results.cannotViewOtherCourses && results.cannotViewOtherEvaluations;
                console.log('RLS Policy Test Results:', results);
                alert('RLS Test Results:\n' + JSON.stringify(results, null, 2) + '\n\n' + (ok ? '✓ All checks passed.' : '⚠ Review failed checks.'));
            } catch (err) {
                log.error('Error testing RLS:', err);
                alert('Error testing RLS: ' + (err && err.message ? err.message : String(err)));
            }
        }
        
        // Phase 4: Verify audit logs (recent entries for current user; may require RLS allowing read)
        async function verifyAuditLogs() {
            if (!supabaseClient || !currentUser) {
                alert('Cannot verify: Not logged in.');
                return;
            }
            try {
                const { data, error } = await supabaseClient
                    .from('audit_logs')
                    .select('id, action, table_name, created_at')
                    .eq('user_id', currentUser.id)
                    .order('created_at', { ascending: false })
                    .limit(10);
                if (error) {
                    alert('Audit logs: Could not read (RLS may restrict read).\n\nCheck Supabase Dashboard → Table Editor → audit_logs to verify entries after you load/save evaluations.');
                    return;
                }
                const count = (data || []).length;
                const msg = count === 0
                    ? 'No recent audit entries for your user. Perform an action (e.g. load courses, view evaluations, save an evaluation) then try again.'
                    : 'Recent audit entries for you: ' + count + '\n\nLast: ' + (data[0] ? data[0].action + ' on ' + data[0].table_name + ' at ' + (data[0].created_at || '').slice(0, 19) : '—') + '\n\nFull list in browser console.';
                console.log('Recent audit_logs for current user:', data);
                alert(msg);
            } catch (err) {
                log.error('Error verifying audit logs:', err);
                alert('Error: ' + (err && err.message ? err.message : String(err)));
            }
        }
        
        // User-scoped localStorage helpers
        // These ensure each user's data is isolated
        function getUserStorageKey(key) {
            if (!currentUser || !currentUser.id) {
                return `guest_${key}`; // Fallback for non-logged-in users
            }
            return `user_${currentUser.id}_${key}`;
        }
        
        function getUserItem(key) {
            return localStorage.getItem(getUserStorageKey(key));
        }
        
        function setUserItem(key, value) {
            return localStorage.setItem(getUserStorageKey(key), value);
        }
        
        function removeUserItem(key) {
            return localStorage.removeItem(getUserStorageKey(key));
        }
        
        // Switch view mode (admin and super admin only)
        function switchViewMode(mode) {
            if (!canManageUsers()) {
                alert('Only administrators can switch views');
                return;
            }
            
            log.debug('=== SWITCHING VIEW MODE ===');
            log.debug('From:', currentViewMode);
            log.debug('To:', mode);
            log.debug('User tier:', userTier);
            log.debug('Institution:', currentInstitution?.name);
            
            currentViewMode = mode;
            
            // Save preference
            localStorage.setItem('adminViewMode', mode);
            
            log.debug('✓ View mode updated to:', currentViewMode);
            
            // Update UI based on mode
            updateViewMode();
            
            // Show notification
            const modeNames = {
                'own': 'My Courses',
                'institution': '🏛️ Institution View',
                'all': '🌐 All Institutions',
                'demo': '🎭 Demo Mode'
            };
            showNotification(`Switched to ${modeNames[mode]}`, 'success');
            
            log.debug('=== VIEW MODE SWITCH COMPLETE ===');
        }
        
        // Update UI based on current view mode
        function updateViewMode() {
            // Remove any existing mode banner
            const existingBanner = document.getElementById('viewModeBanner');
            if (existingBanner) {
                existingBanner.remove();
            }
            
            // Add mode banner for non-default views
            const header = document.querySelector('header .container');
            if (header && currentViewMode !== 'own') {
                const banner = document.createElement('div');
                banner.id = 'viewModeBanner';
                banner.style.cssText = 'background: var(--primary); color: white; padding: 0.75rem; text-align: center; font-weight: 600; border-radius: 0.5rem; margin-top: 0.5rem;';
                
                const modeInfo = {
                    'demo': '🎭 DEMO MODE - Testing functionality (localStorage only, no database)',
                    'institution': `🏛️ INSTITUTION VIEW - Viewing all courses at ${currentInstitution?.name || 'your institution'}`,
                    'all': '🌐 ALL INSTITUTIONS - System-wide view (Super Admin)'
                };
                
                banner.innerHTML = modeInfo[currentViewMode] || '';
                header.appendChild(banner);
            }
            
            // Reload data for current view
            loadClasses();
        }
        
        // ===== FILTER HANDLER FUNCTIONS (PHASE 2) =====
        
        // Super Admin Filter Handlers
        function onInstitutionFilterChange() {
            const value = document.getElementById('filterInstitution')?.value;
            log.debug('🔍 Institution filter changed:', value || 'All Institutions');
            
            // PHASE 5: Reload instructors for selected institution
            loadInstructorsForFilter(value);
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForSuperAdmin();
        }
        
        function onInstructorFilterChange() {
            const value = document.getElementById('filterInstructor')?.value;
            log.debug('🔍 Instructor filter changed:', value || 'All Instructors');
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForSuperAdmin();
        }
        
        function onYearFilterChange() {
            const value = document.getElementById('filterYear')?.value;
            log.debug('🔍 Year filter changed:', value || 'All Years');
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForSuperAdmin();
        }
        
        function onSemesterFilterChange() {
            const value = document.getElementById('filterSemester')?.value;
            log.debug('🔍 Semester filter changed:', value || 'All Semesters');
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForSuperAdmin();
        }
        
        function onModalityFilterChange() {
            const value = document.getElementById('filterModality')?.value;
            log.debug('🔍 Modality filter changed:', value || 'All Modalities');
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForSuperAdmin();
        }
        
        function onSearchFilterChange() {
            const value = document.getElementById('filterSearch')?.value;
            log.debug('🔍 Search filter changed:', value || '(empty)');
            
            // PHASE 5: Reload courses with new filter (with debounce would be better, but simple for now)
            loadFilteredCoursesForSuperAdmin();
        }
        
        function clearAllFilters() {
            log.debug('🧹 Clearing all super admin filters');
            document.getElementById('filterInstitution').value = '';
            document.getElementById('filterInstructor').value = '';
            document.getElementById('filterYear').value = '';
            document.getElementById('filterSemester').value = '';
            document.getElementById('filterModality').value = '';
            document.getElementById('filterSearch').value = '';
            
            // PHASE 5: Reset instructor dropdown and reload all instructors
            loadInstructorsForFilter('');
            
            // PHASE 5: Reload courses without filters
            loadFilteredCoursesForSuperAdmin();
        }
        
        // Admin Filter Handlers
        function onAdminInstructorFilterChange() {
            const value = document.getElementById('adminFilterInstructor')?.value;
            log.debug('🔍 Admin instructor filter changed:', value || 'All Instructors');
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForAdmin();
        }
        
        function onAdminYearFilterChange() {
            const value = document.getElementById('adminFilterYear')?.value;
            log.debug('🔍 Admin year filter changed:', value || 'All Years');
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForAdmin();
        }
        
        function onAdminSemesterFilterChange() {
            const value = document.getElementById('adminFilterSemester')?.value;
            log.debug('🔍 Admin semester filter changed:', value || 'All Semesters');
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForAdmin();
        }
        
        function onAdminModalityFilterChange() {
            const value = document.getElementById('adminFilterModality')?.value;
            log.debug('🔍 Admin modality filter changed:', value || 'All Modalities');
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForAdmin();
        }
        
        function clearAdminFilters() {
            log.debug('🧹 Clearing admin filters');
            document.getElementById('adminFilterInstructor').value = '';
            document.getElementById('adminFilterYear').value = '';
            document.getElementById('adminFilterSemester').value = '';
            document.getElementById('adminFilterModality').value = '';
            
            // PHASE 5: Reload all courses
            loadFilteredCoursesForAdmin();
        }
        
        // Instructor Filter Handlers (Phase 8: filter courses client-side)
        function getInstructorFilteredClasses() {
            const courseId = document.getElementById('instructorFilterCourse')?.value || '';
            const semester = document.getElementById('instructorFilterSemester')?.value || '';
            const year = document.getElementById('instructorFilterYear')?.value || '';
            return (_instructorCoursesAll || []).filter(cls => {
                if (courseId && cls.id !== courseId) return false;
                if (semester && (cls.semester || '') !== semester) return false;
                if (year && (cls.year || '').toString() !== year) return false;
                return true;
            });
        }
        function populateInstructorFilterDropdowns(classes) {
            const sel = document.getElementById('instructorFilterCourse');
            if (!sel) return;
            const courseId = sel.value;
            sel.innerHTML = '<option value="">All Courses</option>' + (classes || []).map(cls =>
                '<option value="' + escapeHtml(cls.id) + '">' + escapeHtml(cls.name) + '</option>'
            ).join('');
            if (courseId) sel.value = courseId;
        }
        function applyInstructorFilters() {
            const filtered = getInstructorFilteredClasses();
            if (typeof renderInstructorCoursesGrid === 'function') renderInstructorCoursesGrid(filtered);
        }
        function onInstructorCourseFilterChange() {
            log.debug('🔍 Instructor course filter changed');
            applyInstructorFilters();
        }
        function onInstructorSemesterFilterChange() {
            log.debug('🔍 Instructor semester filter changed');
            applyInstructorFilters();
        }
        function onInstructorYearFilterChange() {
            log.debug('🔍 Instructor year filter changed');
            applyInstructorFilters();
        }
        function clearInstructorFilters() {
            log.debug('🧹 Clearing instructor filters');
            document.getElementById('instructorFilterCourse').value = '';
            document.getElementById('instructorFilterSemester').value = '';
            document.getElementById('instructorFilterYear').value = '';
            applyInstructorFilters();
        }
        
        // Table Sorting (Phase 4)
        function _sortCourses(courses, column, asc) {
            const key = column === 'semester' ? ['semester', 'year'] : (column === 'students' ? 'student_count' : column === 'evaluations' ? 'evaluation_count' : column === 'instructor' ? 'instructor_name' : column === 'institution' ? 'institution_name' : column === 'name' ? 'name' : column === 'code' ? 'code' : column === 'modality' ? 'modality' : column);
            return (courses || []).slice().sort((a, b) => {
                let va, vb;
                if (Array.isArray(key)) {
                    va = (a[key[0]] || '') + ' ' + (a[key[1]] || '');
                    vb = (b[key[0]] || '') + ' ' + (b[key[1]] || '');
                } else {
                    va = a[key];
                    vb = b[key];
                }
                if (va == null) va = '';
                if (vb == null) vb = '';
                const str = String(va).localeCompare(String(vb), undefined, { numeric: true });
                return asc ? str : -str;
            });
        }
        function sortTableBy(column) {
            _superAdminSortAsc = _superAdminSortColumn === column ? !_superAdminSortAsc : true;
            _superAdminSortColumn = column;
            const sorted = _sortCourses(_superAdminCoursesCache, column, _superAdminSortAsc);
            renderSuperAdminCoursesTable(sorted);
        }
        function sortAdminTableBy(column) {
            _adminSortAsc = _adminSortColumn === column ? !_adminSortAsc : true;
            _adminSortColumn = column;
            const sorted = _sortCourses(_adminCoursesCache, column, _adminSortAsc);
            renderAdminCoursesTable(sorted);
        }
        
        // ===== TABLE RENDERING FUNCTIONS (PHASE 4) =====
        
        /**
         * Render courses in super admin table
         * @param {Array} courses - Array of course objects
         */
        function renderSuperAdminCoursesTable(courses) {
            _superAdminCoursesCache = courses || [];
            log.debug('📊 Rendering super admin table with', _superAdminCoursesCache.length, 'courses');
            
            const table = document.getElementById('coursesTable');
            const tbody = document.getElementById('coursesTableBody');
            const resultsInfo = document.getElementById('filterResultsInfo');
            
            if (!tbody || !table || !resultsInfo) {
                log.error('Table elements not found');
                return;
            }
            
            // Update results info
            if (_superAdminCoursesCache.length === 0) {
                resultsInfo.textContent = 'No courses found matching filters';
                table.style.display = 'none';
                return;
            }
            
            resultsInfo.textContent = `Showing ${_superAdminCoursesCache.length} course${_superAdminCoursesCache.length === 1 ? '' : 's'}`;
            table.style.display = 'table';
            
            // Build table rows
            tbody.innerHTML = _superAdminCoursesCache.map(course => {
                const courseName = escapeHtml(course.name || 'Untitled Course');
                const courseCode = escapeHtml(course.code || course.section || 'N/A');
                const instructorName = escapeHtml(course.instructor_name || 'Unknown');
                const institutionName = escapeHtml(course.institution_name || 'Unknown');
                const semester = escapeHtml(course.semester || 'N/A');
                const year = escapeHtml(course.year || '');
                const semesterYear = `${semester} ${year}`.trim();
                const modality = escapeHtml(course.modality || 'N/A');
                const studentCount = course.student_count || (course.roster ? course.roster.length : 0);
                const evalCount = course.evaluation_count || 0;
                const courseId = escapeHtml(String(course.id || course.supabaseId || ''));
                
                return `
                    <tr>
                        <td><strong>${courseName}</strong></td>
                        <td>${courseCode}</td>
                        <td>${instructorName}</td>
                        <td>${institutionName}</td>
                        <td>${semesterYear}</td>
                        <td>${modality}</td>
                        <td>${studentCount}</td>
                        <td>${evalCount}</td>
                        <td>
                            <button onclick="viewCourse('${courseId}')" style="padding: 0.5rem 1rem; background: var(--primary); color: white; border: none; border-radius: 0.25rem; cursor: pointer; font-size: 0.9rem;">
                                View
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');
            
            log.debug('✅ Super admin table rendered');
        }
        
        /**
         * Render courses in admin table
         * @param {Array} courses - Array of course objects
         */
        function renderAdminCoursesTable(courses) {
            _adminCoursesCache = courses || [];
            log.debug('📊 Rendering admin table with', _adminCoursesCache.length, 'courses');
            
            const table = document.getElementById('adminCoursesTable');
            const tbody = document.getElementById('adminCoursesTableBody');
            const resultsInfo = document.getElementById('adminFilterResultsInfo');
            
            if (!tbody || !table || !resultsInfo) {
                log.error('Admin table elements not found');
                return;
            }
            
            if (_adminCoursesCache.length === 0) {
                resultsInfo.textContent = 'No courses found in your department';
                tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; padding: 2rem; color: var(--text-light);">No courses found</td></tr>';
                return;
            }
            
            resultsInfo.textContent = `Showing ${_adminCoursesCache.length} course${_adminCoursesCache.length === 1 ? '' : 's'}`;
            
            tbody.innerHTML = _adminCoursesCache.map(course => {
                const courseName = escapeHtml(course.name || 'Untitled Course');
                const courseCode = escapeHtml(course.code || course.section || 'N/A');
                const instructorName = escapeHtml(course.instructor_name || 'Unknown');
                const semester = escapeHtml(course.semester || 'N/A');
                const year = escapeHtml(course.year || '');
                const semesterYear = `${semester} ${year}`.trim();
                const modality = escapeHtml(course.modality || 'N/A');
                const studentCount = course.student_count || (course.roster ? course.roster.length : 0);
                const evalCount = course.evaluation_count || 0;
                const courseId = escapeHtml(String(course.id || course.supabaseId || ''));
                
                return `
                    <tr>
                        <td><strong>${courseName}</strong></td>
                        <td>${courseCode}</td>
                        <td>${instructorName}</td>
                        <td>${semesterYear}</td>
                        <td>${modality}</td>
                        <td>${studentCount}</td>
                        <td>${evalCount}</td>
                        <td>
                            <button onclick="viewCourse('${courseId}')" style="padding: 0.5rem 1rem; background: var(--primary); color: white; border: none; border-radius: 0.25rem; cursor: pointer; font-size: 0.9rem;">
                                View
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');
            
            log.debug('✅ Admin table rendered');
        }
        
        /**
         * Test table rendering with mock data (for Phase 4 testing only)
         */
        function testTableRenderingWithMockData() {
            log.debug('🧪 Testing table rendering with mock data');
            
            const mockCourses = [
                {
                    id: '1',
                    name: 'Public Speaking 101',
                    code: 'CMST 210',
                    instructor_name: 'John Doe',
                    institution_name: 'University of Tennessee',
                    semester: 'Fall',
                    year: '2024',
                    modality: 'in-person',
                    student_count: 25,
                    evaluation_count: 12
                },
                {
                    id: '2',
                    name: 'Advanced Rhetoric',
                    code: 'CMST 340',
                    instructor_name: 'Jane Smith',
                    institution_name: 'University of Tennessee',
                    semester: 'Spring',
                    year: '2025',
                    modality: 'online',
                    student_count: 18,
                    evaluation_count: 8
                }
            ];
            
            // Test super admin table
            if (userTier === 'super_admin') {
                renderSuperAdminCoursesTable(mockCourses);
            }
            
            // Test admin table
            if (userTier === 'admin') {
                renderAdminCoursesTable(mockCourses);
            }
        }
        
        // ===== END TABLE RENDERING FUNCTIONS =====
        
        // ===== DATA LOADING FUNCTIONS (PHASE 5) =====
        
        /**
         * Load all institutions for super admin filter dropdown
         */
        async function loadInstitutionsForFilter() {
            if (!supabaseClient) return;
            
            log.debug('📊 Loading institutions for filter...');
            
            try {
                const { data: institutions, error } = await supabaseClient
                    .from('institutions')
                    .select('id, name')
                    .order('name');
                
                if (error) {
                    console.error('Error loading institutions:', error);
                    return;
                }
                
                log.debug('✅ Loaded', institutions.length, 'institutions');
                
                // Populate institution dropdown
                const institutionSelect = document.getElementById('filterInstitution');
                if (institutionSelect) {
                    const options = institutions.map(inst => 
                        `<option value="${inst.id}">${inst.name}</option>`
                    ).join('');
                    institutionSelect.innerHTML = '<option value="">All Institutions</option>' + options;
                }
            } catch (error) {
                console.error('Error in loadInstitutionsForFilter:', error);
            }
        }
        
        /**
         * Load instructors for a specific institution
         */
        async function loadInstructorsForFilter(institutionId) {
            if (!supabaseClient) return;
            
            log.debug('📊 Loading instructors for institution:', institutionId || 'All');
            
            try {
                let query = supabaseClient
                    .from('user_profiles')
                    .select('id, full_name, institution_id');
                
                // Filter by institution if specified
                if (institutionId) {
                    query = query.eq('institution_id', institutionId);
                }
                
                query = query.order('full_name');
                
                const { data: instructors, error } = await query;
                
                if (error) {
                    console.error('Error loading instructors:', error);
                    return;
                }
                
                log.debug('✅ Loaded', (instructors || []).length, 'instructors');
                
                // Populate instructor dropdown (user_profiles uses full_name)
                const instructorSelect = document.getElementById('filterInstructor');
                if (instructorSelect) {
                    const options = (instructors || []).map(inst => {
                        const name = (inst.full_name || '').trim() || 'Unknown';
                        return `<option value="${inst.id}">${name}</option>`;
                    }).join('');
                    instructorSelect.innerHTML = '<option value="">All Instructors</option>' + options;
                }
            } catch (error) {
                console.error('Error in loadInstructorsForFilter:', error);
            }
        }
        
        /**
         * Load instructors for admin (department only)
         */
        async function loadDepartmentInstructorsForFilter() {
            if (!supabaseClient || !currentUser) return;
            
            log.debug('📊 Loading department instructors...');
            
            try {
                const { data: instructors, error } = await supabaseClient
                    .from('user_profiles')
                    .select('id, full_name')
                    .eq('institution_id', currentUser.institution_id)
                    .order('full_name');
                
                if (error) {
                    console.error('Error loading department instructors:', error);
                    return;
                }
                
                log.debug('✅ Loaded', instructors.length, 'department instructors');
                
                // Populate admin instructor dropdown (user_profiles may have full_name, not first_name/last_name)
                const instructorSelect = document.getElementById('adminFilterInstructor');
                if (instructorSelect) {
                    const options = (instructors || []).map(inst => {
                        const name = (inst.full_name || '').trim() || 'Unknown';
                        return `<option value="${inst.id}">${name}</option>`;
                    }).join('');
                    instructorSelect.innerHTML = '<option value="">All Instructors</option>' + options;
                }
            } catch (error) {
                console.error('Error in loadDepartmentInstructorsForFilter:', error);
            }
        }
        
        /**
         * Course scope filter (main Courses card): populate institution dropdown for super admin
         */
        async function loadCourseScopeInstitutions() {
            if (!supabaseClient) return;
            try {
                const { data: institutions, error } = await supabaseClient
                    .from('institutions')
                    .select('id, name')
                    .order('name');
                if (error) return;
                const sel = document.getElementById('courseScopeInstitution');
                if (!sel) return;
                sel.innerHTML = '<option value="">Select institution</option>' +
                    (institutions || []).map(inst => `<option value="${inst.id}">${escapeHtml(inst.name)}</option>`).join('');
            } catch (e) {
                console.warn('loadCourseScopeInstitutions:', e);
            }
        }
        
        /**
         * Course scope filter: populate instructor dropdown (for selected institution or department)
         */
        async function loadCourseScopeInstructors(institutionId) {
            if (!supabaseClient) return;
            try {
                let query = supabaseClient.from('user_profiles').select('id, full_name');
                if (institutionId) query = query.eq('institution_id', institutionId);
                const { data: instructors, error } = await query.order('full_name');
                if (error) return;
                const sel = document.getElementById('courseScopeInstructor');
                if (!sel) return;
                sel.innerHTML = '<option value="">All instructors</option>' +
                    (instructors || []).map(inst => {
                        const name = (inst.full_name || '').trim() || 'Unknown';
                        return `<option value="${inst.id}">${escapeHtml(name)}</option>`;
                    }).join('');
            } catch (e) {
                console.warn('loadCourseScopeInstructors:', e);
            }
        }
        
        function onCourseScopeChange() {
            const scope = document.getElementById('courseScopeSelect')?.value || 'own';
            const institutionWrap = document.getElementById('courseScopeInstitutionWrap');
            const instructorWrap = document.getElementById('courseScopeInstructorWrap');
            const institutionSel = document.getElementById('courseScopeInstitution');
            const instructorSel = document.getElementById('courseScopeInstructor');
            
            currentFilterInstitutionId = null;
            currentFilterInstructorId = null;
            if (institutionSel) institutionSel.value = '';
            if (instructorSel) instructorSel.value = '';
            
            if (scope === 'own') {
                currentViewMode = 'own';
                if (institutionWrap) institutionWrap.style.display = 'none';
                if (instructorWrap) instructorWrap.style.display = 'none';
                loadClasses();
            } else {
                currentViewMode = 'institution';
                if (isSuperAdmin()) {
                    if (institutionWrap) institutionWrap.style.display = 'block';
                    if (instructorWrap) instructorWrap.style.display = 'none';
                    loadCourseScopeInstitutions();
                    loadClasses(); // clears grid until institution selected
                } else {
                    if (institutionWrap) institutionWrap.style.display = 'none';
                    if (instructorWrap) instructorWrap.style.display = 'block';
                    loadCourseScopeInstructors(currentUser?.institution_id || null);
                    loadClasses();
                }
            }
        }
        
        function onCourseScopeInstitutionChange() {
            const sel = document.getElementById('courseScopeInstitution');
            currentFilterInstitutionId = sel?.value || null;
            currentFilterInstructorId = null;
            const instructorSel = document.getElementById('courseScopeInstructor');
            if (instructorSel) instructorSel.value = '';
            const instructorWrap = document.getElementById('courseScopeInstructorWrap');
            if (instructorWrap) instructorWrap.style.display = currentFilterInstitutionId ? 'block' : 'none';
            loadCourseScopeInstructors(currentFilterInstitutionId || null);
            loadClasses();
        }
        
        function onCourseScopeInstructorChange() {
            const sel = document.getElementById('courseScopeInstructor');
            currentFilterInstructorId = sel?.value || null;
            loadClasses();
        }
        
        /**
         * Load courses with current filter settings (Super Admin)
         */
        async function loadFilteredCoursesForSuperAdmin() {
            if (!supabaseClient) return;
            
            console.log('=== LOADING FILTERED COURSES (SUPER ADMIN) ===');
            
            // Get filter values
            const institutionId = document.getElementById('filterInstitution')?.value;
            const instructorId = document.getElementById('filterInstructor')?.value;
            const year = document.getElementById('filterYear')?.value;
            const semester = document.getElementById('filterSemester')?.value;
            const modality = document.getElementById('filterModality')?.value;
            const searchTerm = document.getElementById('filterSearch')?.value;
            
            log.debug('Filters:', { institutionId, instructorId, year, semester, modality, searchTerm });
            
            try {
                // Build base query - simpler join
                let query = supabaseClient
                    .from('courses')
                    .select('*');
                
                // Apply instructor filter directly
                if (instructorId) {
                    query = query.eq('instructor_id', instructorId);
                } else if (institutionId) {
                    // If filtering by institution but no specific instructor,
                    // we need to get all instructors in that institution first
                    const { data: instInstructors } = await supabaseClient
                        .from('user_profiles')
                        .select('id')
                        .eq('institution_id', institutionId);
                    
                    if (instInstructors && instInstructors.length > 0) {
                        const instructorIds = instInstructors.map(i => i.id);
                        query = query.in('instructor_id', instructorIds);
                    } else {
                        // No instructors in this institution, return empty
                        renderSuperAdminCoursesTable([]);
                        return;
                    }
                }
                
                // Apply other filters
                if (year) {
                    query = query.eq('year', parseInt(year));
                }
                
                if (semester) {
                    query = query.eq('semester', semester);
                }
                
                if (modality) {
                    query = query.eq('modality', modality);
                }
                
                if (searchTerm) {
                    query = query.or(`name.ilike.%${searchTerm}%,code.ilike.%${searchTerm}%`);
                }
                
                query = query.order('created_at', { ascending: false });
                
                const { data: courses, error } = await query;
                
                if (error) {
                    console.error('❌ Error loading courses:', error);
                    renderSuperAdminCoursesTable([]);
                    return;
                }
                
                log.debug('✅ Loaded', courses.length, 'courses');
                
                // Now get instructor and institution names separately (requires RLS to allow super_admin to read user_profiles/institutions)
                if (courses.length > 0) {
                    const instructorIds = [...new Set(courses.map(c => c.instructor_id).filter(Boolean))];
                    let profiles = [];
                    let institutions = [];
                    
                    if (instructorIds.length > 0) {
                        const { data: profilesData, error: profilesError } = await supabaseClient
                            .from('user_profiles')
                            .select('id, full_name, institution_id')
                            .in('id', instructorIds);
                        if (profilesError) {
                            console.warn('Could not load instructor profiles for All Institutions (check RLS):', profilesError.message);
                        } else {
                            profiles = profilesData || [];
                        }
                        
                        const institutionIds = [...new Set(profiles.map(p => p.institution_id).filter(Boolean))];
                        if (institutionIds.length > 0) {
                            const { data: institutionsData, error: instError } = await supabaseClient
                                .from('institutions')
                                .select('id, name')
                                .in('id', institutionIds);
                            if (instError) {
                                console.warn('Could not load institutions (check RLS):', instError.message);
                            } else {
                                institutions = institutionsData || [];
                            }
                        }
                    }
                    
                    const institutionMap = {};
                    institutions.forEach(inst => { institutionMap[inst.id] = inst.name; });
                    
                    const profileMap = {};
                    profiles.forEach(prof => {
                        profileMap[prof.id] = {
                            name: (prof.full_name || '').trim() || 'Instructor',
                            institution_id: prof.institution_id,
                            institution_name: institutionMap[prof.institution_id] || '—'
                        };
                    });
                    
                    const transformedCourses = courses.map(course => {
                        const prof = course.instructor_id ? profileMap[course.instructor_id] : null;
                        return {
                            ...course,
                            instructor_name: prof?.name || (course.instructor_id ? 'Instructor' : '—'),
                            institution_name: prof?.institution_name || '—',
                            student_count: 0
                        };
                    });
                    
                    renderSuperAdminCoursesTable(transformedCourses);
                } else {
                    renderSuperAdminCoursesTable([]);
                }
            } catch (error) {
                console.error('❌ Error in loadFilteredCoursesForSuperAdmin:', error);
                renderSuperAdminCoursesTable([]);
            }
        }
        
        /**
         * Load courses for admin (department only)
         */
        async function loadFilteredCoursesForAdmin() {
            if (!supabaseClient || !currentUser) return;
            
            console.log('=== LOADING FILTERED COURSES (ADMIN) ===');
            
            // Get filter values
            const instructorId = document.getElementById('adminFilterInstructor')?.value;
            const year = document.getElementById('adminFilterYear')?.value;
            const semester = document.getElementById('adminFilterSemester')?.value;
            const modality = document.getElementById('adminFilterModality')?.value;
            
            log.debug('Filters:', { instructorId, year, semester, modality });
            
            try {
                // Get all users in this institution (user_profiles uses full_name)
                const { data: institutionUsers } = await supabaseClient
                    .from('user_profiles')
                    .select('id, full_name')
                    .eq('institution_id', currentUser.institution_id);
                
                const userIds = institutionUsers?.map(u => u.id) || [];
                
                // Create instructor name lookup
                const instructorMap = {};
                institutionUsers?.forEach(user => {
                    instructorMap[user.id] = (user.full_name || '').trim() || 'Unknown';
                });
                
                // Build query without joins
                let query = supabaseClient
                    .from('courses')
                    .select('*')
                    .in('instructor_id', userIds);
                
                // Apply filters
                if (instructorId) {
                    query = query.eq('instructor_id', instructorId);
                }
                
                if (year) {
                    query = query.eq('year', parseInt(year));
                }
                
                if (semester) {
                    query = query.eq('semester', semester);
                }
                
                if (modality) {
                    query = query.eq('modality', modality);
                }
                
                query = query.order('created_at', { ascending: false });
                
                const { data: courses, error } = await query;
                
                if (error) {
                    console.error('❌ Error loading courses:', error);
                    renderAdminCoursesTable([]);
                    return;
                }
                
                log.debug('✅ Loaded', courses.length, 'courses');
                
                // Transform data for table rendering
                const transformedCourses = courses.map(course => ({
                    ...course,
                    instructor_name: instructorMap[course.instructor_id] || 'Unknown',
                    student_count: 0
                }));
                
                renderAdminCoursesTable(transformedCourses);
            } catch (error) {
                console.error('❌ Error in loadFilteredCoursesForAdmin:', error);
                renderAdminCoursesTable([]);
            }
        }
        
        // ===== END DATA LOADING FUNCTIONS =====
        
        // Load user's account tier from user_profiles table
        async function loadUserTier() {
            if (!currentUser || !supabaseClient) {
                userTier = 'demo';
                resetThemeToDefault();
                routeToInterface();
                return;
            }
            
            // Start from SpeechGradebook default (dark blue); loadInstitutionalTheme will apply custom theme if institution has one
            resetThemeToDefault();
            
            try {
                // Fetch only flat columns so RLS on institutions/departments can't break the query
                const { data, error } = await supabaseClient
                    .from('user_profiles')
                    .select('account_tier, is_admin, is_super_admin, institution_id, department_id, llm_training_consent_given, full_name')
                    .eq('id', currentUser.id)
                    .single();
                
                console.log('[loadUserTier] Profile fetch:', error ? 'error ' + error.message : 'ok', 'account_tier=', data?.account_tier);
                
                if (error) {
                    console.warn('Could not load user profile:', error.message, '- Ensure user_profiles has a row for this user and RLS allows read. Falling back to demo.');
                    userTier = (currentUser.user_metadata?.account_tier || currentUser.app_metadata?.account_tier) || 'demo';
                    if (userTier === 'demo') {
                        currentUser.is_admin = false;
                        currentUser.is_super_admin = false;
                        currentInstitution = null;
                    }
                } else if (data) {
                    userTier = (data.account_tier || currentUser.user_metadata?.account_tier || currentUser.app_metadata?.account_tier) || 'demo';
                    currentUser.is_admin = data.is_admin;
                    currentUser.is_super_admin = data.is_super_admin;
                    currentUser.institution_id = data.institution_id;
                    currentUser.department_id = data.department_id;
                    currentUser.llm_training_consent_given = data.llm_training_consent_given === true;
                    currentUser.full_name = (data.full_name || '').trim() || null;
                    currentInstitution = null; // Load below if needed
                    
                    log.debug('✓ Account tier:', userTier, 
                        data.is_super_admin ? '(Super Admin)' : 
                        data.is_admin ? '(Admin)' : '(Instructor)');
                    
                    // Optionally load institution name for display (separate query so RLS on institutions is independent)
                    if (data.institution_id) {
                        const { data: inst } = await supabaseClient
                            .from('institutions')
                            .select('id, name, domain')
                            .eq('id', data.institution_id)
                            .single();
                        if (inst) currentInstitution = inst;
                    }
                    
                    // Load institutional theme if user has an institution
                    if (currentUser.institution_id) {
                        await loadInstitutionalTheme(currentUser.institution_id);
                    }
                } else {
                    console.warn('No user_profiles row for', currentUser.id, '- Set account_tier in user_profiles for this user.');
                    userTier = (currentUser.user_metadata?.account_tier || currentUser.app_metadata?.account_tier) || 'demo';
                }
            } catch (err) {
                console.error('Error loading tier:', err);
                userTier = 'demo';
            }
            
            // Route to appropriate interface (each interface handles its own UI setup)
            routeToInterface();
            
            // Remove demo banner after UI is built (in case interface added it)
            if (userTier !== 'demo') {
                removeDemoBannerIfPresent();
                setTimeout(removeDemoBannerIfPresent, 0);
                setTimeout(removeDemoBannerIfPresent, 200);
                setTimeout(removeDemoBannerIfPresent, 600);
            } else if (currentUser && supabaseClient) {
                // Retry profile fetch once in case first load failed (e.g. RLS timing)
                setTimeout(async function retryProfile() {
                    const { data, error } = await supabaseClient
                        .from('user_profiles')
                        .select('account_tier, is_admin, is_super_admin, institution_id, llm_training_consent_given, full_name')
                        .eq('id', currentUser.id)
                        .single();
                    if (!error && data && data.account_tier && data.account_tier !== 'demo') {
                        console.log('[loadUserTier] Retry got tier:', data.account_tier);
                        userTier = data.account_tier;
                        currentUser.is_admin = data.is_admin;
                        currentUser.is_super_admin = data.is_super_admin;
                        currentUser.institution_id = data.institution_id;
                        currentUser.llm_training_consent_given = data.llm_training_consent_given === true;
                        currentUser.full_name = (data.full_name || '').trim() || null;
                        if (data.institution_id) {
                            const { data: inst } = await supabaseClient.from('institutions').select('id, name').eq('id', data.institution_id).single();
                            if (inst) currentInstitution = inst;
                            await loadInstitutionalTheme(data.institution_id);
                        }
                        routeToInterface();
                        removeDemoBannerIfPresent();
                        setTimeout(removeDemoBannerIfPresent, 0);
                        setTimeout(removeDemoBannerIfPresent, 200);
                    }
                }, 800);
            }
        }
        
        function removeDemoBannerIfPresent() {
            const b = document.getElementById('demoBanner');
            if (b) { b.remove(); console.log('[loadUserTier] Removed demo banner'); }
        }
        
        // Load custom institutional theme from database (e.g. University of Tennessee).
        // If the institution has no theme row, we reset to SpeechGradebook default (dark blue).
        async function loadInstitutionalTheme(institutionId) {
            if (!supabaseClient) {
                log.warn('⚠️ No Supabase client, skipping theme load');
                resetThemeToDefault();
                return;
            }
            
            if (!institutionId) {
                log.warn('⚠️ No institution ID provided, skipping theme load');
                resetThemeToDefault();
                return;
            }
            
            log.debug('=== LOADING THEME ===');
            log.debug('Loading theme for institution_id:', institutionId);
            
            try {
                const { data, error } = await supabaseClient
                    .from('institution_themes')
                    .select('*')
                    .eq('institution_id', institutionId)
                    .single();
                
                if (error) {
                    console.warn('[loadInstitutionalTheme] No theme for institution', institutionId, '- using SpeechGradebook default.', error.message);
                    currentUser.theme = null;
                    currentInstitutionTheme = null;
                    resetThemeToDefault();
                    return;
                }
                
                if (data) {
                    // CRITICAL: Verify institution_id matches what we requested
                    if (data.institution_id !== institutionId) {
                        console.error('❌ SECURITY: Theme institution mismatch!');
                        console.error('   Requested:', institutionId);
                        console.error('   Received:', data.institution_id);
                        currentUser.theme = null;
                        currentInstitutionTheme = null;
                        return;
                    }
                    
                    currentUser.theme = data;
                    currentInstitutionTheme = data; // Store globally
                    
                    log.debug('✓ Theme loaded successfully');
                    log.debug('   Institution ID:', data.institution_id);
                    log.debug('   Primary color:', data.primary_color);
                    log.debug('   Header color:', data.header_bg_color);
                    log.debug('   Has logo:', !!data.logo_url);
                    log.debug('   Has custom fonts:', !!data.custom_fonts);
                    log.debug('   Heading font:', data.font_heading || 'default');
                    log.debug('   Body font:', data.font_body || 'default');
                    
                    // Apply theme to CSS immediately
                    console.log('[loadInstitutionalTheme] Applying theme for institution', data.institution_id);
                    applyThemeToCSS(data);
                    
                    // Apply fonts if set
                    if (data.font_heading || data.font_body) {
                        const root = document.documentElement;
                        if (data.font_heading) {
                            root.style.setProperty('--heading-font', data.font_heading);
                            log.debug('✓ Applied heading font:', data.font_heading);
                        }
                        if (data.font_body) {
                            root.style.setProperty('--body-font', data.font_body);
                            log.debug('✓ Applied body font:', data.font_body);
                        }
                    }
                    
                    // Load custom fonts if exists
                    if (data.custom_fonts) {
                        log.debug('Loading custom fonts...');
                        loadCustomFontsOnStartup(data.custom_fonts);
                    }
                    
                    log.debug('=== THEME LOAD COMPLETE ===');
                } else {
                    // No theme row for this institution - use SpeechGradebook default
                    currentUser.theme = null;
                    currentInstitutionTheme = null;
                    resetThemeToDefault();
                }
            } catch (err) {
                console.error('❌ Error loading theme:', err);
                currentUser.theme = null;
                currentInstitutionTheme = null;
                resetThemeToDefault();
            }
        }
        
        // Load custom fonts on startup (for all users)
        function loadCustomFontsOnStartup(customFontsData) {
            if (!customFontsData) return;
            
            let fonts = [];
            try {
                fonts = typeof customFontsData === 'string' ? JSON.parse(customFontsData) : customFontsData;
            } catch (e) {
                console.error('Error parsing custom fonts:', e);
                return;
            }
            
            if (!Array.isArray(fonts) || fonts.length === 0) return;
            
            // Inject font-face CSS for each font
            fonts.forEach(font => {
                injectFontFace(font);
            });
            
            log.debug('✓ Loaded', fonts.length, 'custom font(s)');
        }
        
        // SpeechGradebook theme (default) - dark blue, matches :root. Used when user has no institution
        // or institution has no theme row. Header uses same color as footer (solid #1e3a5f).
        function resetThemeToDefault() {
            const root = document.documentElement;
            root.style.setProperty('--primary', '#1e3a5f');
            root.style.setProperty('--primary-dark', '#142940');
            root.style.setProperty('--secondary', '#c8a882');
            root.style.setProperty('--accent', '#d4af37');
            root.style.setProperty('--text', '#2c3e50');
            root.style.setProperty('--text-light', '#6c757d');
            root.style.setProperty('--bg', '#fafbfc');
            root.style.setProperty('--bg-alt', '#f1f4f7');
            root.style.setProperty('--card', '#ffffff');
            root.style.setProperty('--border', '#e1e8ed');
            root.style.setProperty('--success', '#059669');
            root.style.setProperty('--warning', '#d97706');
            root.style.setProperty('--error', '#b91c1c');
            root.style.setProperty('--heading-font', "'Crimson Pro', serif");
            root.style.setProperty('--body-font', "'Work Sans', sans-serif");
            const header = document.querySelector('header');
            if (header) {
                header.style.background = '#142940';
                header.style.backgroundImage = 'none';
                header.style.color = 'white';
                header.querySelectorAll('h1, .subtitle, #logoutLink, .nav-link').forEach(el => { if (el) el.style.color = ''; });
            }
            const logo = document.getElementById('appLogo');
            if (logo) { logo.innerHTML = '<img src="assets/logo-dark-bg.png" alt="Speech Gradebook" style="width: 100%; height: 100%; object-fit: cover; object-position: center; border-radius: 50%;">'; logo.style.backgroundColor = '#ffffff'; }
            const appTaglineEl = document.getElementById('appTagline');
            if (appTaglineEl) appTaglineEl.textContent = 'Instructor-Informed Speech Assessment';
            currentInstitutionTheme = null;
            if (typeof currentUser !== 'undefined' && currentUser) currentUser.theme = null;
            log.debug('Theme reset to SpeechGradebook default');
        }
        
        // Apply custom institutional theme to CSS (e.g. University of Tennessee).
        // Only called when institution_themes has a row for this institution.
        function applyThemeToCSS(theme) {
            if (!theme) return;
            
            const root = document.documentElement;
            
            log.debug('🎨 Applying custom institutional theme...');
            
            // Apply colors to CSS variables
            if (theme.primary_color) {
                root.style.setProperty('--primary', theme.primary_color);
                root.style.setProperty('--primary-dark', theme.primary_color); // Use same color, no gradient
            }
            if (theme.secondary_color) root.style.setProperty('--secondary', theme.secondary_color);
            
            // Apply extended theme colors if available
            if (theme.bg_primary) root.style.setProperty('--bg', theme.bg_primary);
            if (theme.bg_secondary) root.style.setProperty('--bg-alt', theme.bg_secondary);
            if (theme.bg_tertiary) {
                root.style.setProperty('--bg-elevated', theme.bg_tertiary);
                root.style.setProperty('--card', theme.bg_tertiary); // Also update card background
            }
            
            if (theme.text_primary) {
                root.style.setProperty('--text', theme.text_primary);
            }
            if (theme.text_secondary) {
                root.style.setProperty('--text-light', theme.text_secondary);
            }
            if (theme.border_color) root.style.setProperty('--border', theme.border_color);
            
            if (theme.accent_color) root.style.setProperty('--success', theme.accent_color);
            if (theme.warning_color) root.style.setProperty('--warning', theme.warning_color);
            if (theme.error_color) root.style.setProperty('--error', theme.error_color);
            
            // Apply font family if specified (use for both heading and body for consistency)
            if (theme.font_family) {
                root.style.setProperty('--font-family', theme.font_family);
                root.style.setProperty('--body-font', theme.font_family);
                root.style.setProperty('--heading-font', theme.font_family);
            }
            
            // Apply header background - use solid color instead of gradient
            const header = document.querySelector('header');
            if (header && theme.header_bg_color) {
                header.style.background = theme.header_bg_color; // Solid color
                header.style.backgroundImage = 'none'; // Remove gradient
                
                // Set header text color (white for dark backgrounds, dark for light)
                const headerColor = theme.header_bg_color;
                // Simple brightness check: if background is dark, use white text
                if (headerColor) {
                    const isDark = headerColor.toLowerCase() === '#4b4b4b' || 
                                   headerColor.toLowerCase() === '#061e29' ||
                                   headerColor.toLowerCase() === '#0f172a' ||
                                   parseInt(headerColor.replace('#', ''), 16) < 0x808080;
                    
                    const textColor = isDark ? 'white' : '#4B4B4B';
                    header.style.color = textColor;
                    
                    // Also update heading text colors
                    const h1 = header.querySelector('h1');
                    const subtitle = header.querySelector('.subtitle');
                    const logoutLink = document.getElementById('logoutLink');
                    const navLinks = header.querySelectorAll('.nav-link');
                    
                    if (h1) h1.style.color = textColor;
                    if (subtitle) subtitle.style.color = textColor;
                    if (logoutLink) logoutLink.style.color = textColor;
                    
                    // Update all nav links
                    navLinks.forEach(link => {
                        link.style.color = textColor;
                    });
                }
            }
            
            // Update logo based on institution
            updateInstitutionLogo();
            
            // Log what was applied
            log.debug('✓ Theme applied successfully');
            log.debug('  - Primary:', theme.primary_color);
            log.debug('  - Background:', theme.bg_primary);
            console.log('  - Text:', theme.text_primary);
            console.log('  - Mode:', theme.is_dark_mode ? 'Dark' : 'Light');
        }
        
        // Update logo based on institution
        async function updateInstitutionLogo() {
            const logo = document.getElementById('appLogo');
            if (!logo) {
                console.error('❌ Logo element not found');
                return;
            }
            
            console.log('🔄 Updating institution logo...');
            console.log('Current user institution:', currentUser?.institution_id);
            console.log('Current theme institution:', currentInstitutionTheme?.institution_id);
            
            // CRITICAL: Only use theme if it matches current user's institution
            // This prevents theme bleeding across institutions
            if (currentInstitutionTheme && 
                currentUser && 
                currentUser.institution_id &&
                currentInstitutionTheme.institution_id === currentUser.institution_id) {
                
                console.log('✓ Institution match verified - theme belongs to this user');
                
                // Check if institution has a custom logo in theme
                if (currentInstitutionTheme.logo_url) {
                    console.log('✓ Custom logo URL found:', currentInstitutionTheme.logo_url.substring(0, 50) + '...');
                    
                    // Use custom logo image
                    try {
                        logo.style.backgroundColor = '#ffffff';
                        logo.innerHTML = `<img src="${currentInstitutionTheme.logo_url}" 
                                              style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;" 
                                              onerror="console.error('Logo image failed to load'); this.style.display='none';"
                                              onload="console.log('✓ Logo image loaded successfully');">`;
                        console.log('✓ Logo HTML updated with custom image');
                        return;
                    } catch (error) {
                        console.error('Error setting logo image:', error);
                    }
                }
            } else if (currentInstitutionTheme && currentUser && currentInstitutionTheme.institution_id !== currentUser.institution_id) {
                console.warn('⚠️ Institution mismatch detected! Theme will not be applied.');
                console.warn('  User institution:', currentUser.institution_id);
                console.warn('  Theme institution:', currentInstitutionTheme.institution_id);
            } else {
                console.log('No custom logo URL in theme or no theme loaded');
            }
            
            // Fallback: Speech Gradebook logo image (no custom institution logo)
            logo.innerHTML = '<img src="assets/logo-dark-bg.png" alt="Speech Gradebook" style="width: 100%; height: 100%; object-fit: cover; object-position: center; border-radius: 50%;">';
            logo.style.backgroundColor = '#ffffff';
            console.log('✓ Logo updated with default Speech Gradebook image');
        }
        
        // Route user to appropriate interface based on their tier
        function routeToInterface() {
            console.log('🎯 Routing to interface for tier:', userTier);
            
            // Determine interface type based on account tier
            let interfaceType = 'demo'; // default
            
            if (userTier === 'super_admin') {
                interfaceType = 'super_admin';
            } else if (userTier === 'admin') {
                interfaceType = 'admin';
            } else if (userTier === 'instructor') {
                interfaceType = 'instructor';
            } else if (userTier === 'demo') {
                interfaceType = 'demo';
            }
            
            console.log('✓ Interface type:', interfaceType);
            
            // Initialize the appropriate interface
            initializeInterface(interfaceType);
        }
        
        // Move admin section content into dashboard (admin/super admin only); run once
        function moveAdminPanelIntoDashboard() {
            const container = document.getElementById('dashboardAdminContainer');
            const adminSection = document.getElementById('adminSection');
            if (!container || !adminSection || container.children.length > 0) return;
            while (adminSection.firstChild) container.appendChild(adminSection.firstChild);
            adminSection.style.display = 'none';
        }
        
        // Move Department Courses and All Institutions into Analytics Overview tab (admin/super admin)
        function moveCoursesSectionsIntoOverview() {
            const deptWrap = document.getElementById('overviewDepartmentCoursesWrap');
            const allWrap = document.getElementById('overviewAllInstitutionsWrap');
            const deptSection = document.getElementById('departmentCoursesSection');
            const allSection = document.getElementById('allInstitutionsSection');
            if (deptWrap && deptSection && deptSection.parentNode !== deptWrap) deptWrap.appendChild(deptSection);
            if (allWrap && allSection && allSection.parentNode !== allWrap) allWrap.appendChild(allSection);
        }
        
        // Initialize interface based on user type
        function initializeInterface(interfaceType) {
            console.log('🚀 Initializing interface:', interfaceType);
            
            // CRITICAL: Hide ALL sections first to prevent flashing wrong interface
            document.querySelectorAll('.section').forEach(section => {
                section.style.display = 'none';
            });
            
            // Courses card: show for instructor/demo, hide for admin/super admin
            const mainCoursesCard = document.getElementById('mainCoursesCard');
            if (mainCoursesCard) {
                mainCoursesCard.style.display = (interfaceType === 'admin' || interfaceType === 'super_admin') ? 'none' : '';
            }
            
            console.log('✓ Previous interface cleared');
            
            switch(interfaceType) {
                case 'super_admin':
                    initializeSuperAdminInterface();
                    break;
                case 'admin':
                    initializeAdminInterface();
                    break;
                case 'instructor':
                    initializeInstructorInterface();
                    break;
                case 'demo':
                    initializeDemoInterface();
                    break;
                default:
                    console.warn('Unknown interface type:', interfaceType);
                    initializeDemoInterface();
            }
        }
        
        // Initialize Super Admin interface
        function initializeSuperAdminInterface() {
            console.log('🌐 Setting up Super Admin interface');
            
            // Super admin: default to My Courses; scope filter in main Courses card
            currentViewMode = 'own';
            currentFilterInstitutionId = null;
            currentFilterInstructorId = null;
            const scopeFilterRow = document.getElementById('courseScopeFilterRow');
            if (scopeFilterRow) {
                scopeFilterRow.style.display = 'flex';
                const opt = document.getElementById('courseScopeInstitutionOption');
                if (opt) opt.textContent = 'Institution';
            }
            loadCourseScopeInstitutions();
            updateViewMode();
            moveCoursesSectionsIntoOverview();
            const dashboardAdmin = document.getElementById('dashboardAdminContainer');
            if (dashboardAdmin) dashboardAdmin.style.display = 'none';

            const createInstitutionWrap = document.getElementById('createInstitutionWrap');
            if (createInstitutionWrap) createInstitutionWrap.style.display = 'block';
            const themeCustomizerWrap = document.getElementById('themeCustomizerWrap');
            if (themeCustomizerWrap) themeCustomizerWrap.style.display = '';
            const themeInstitutionRow = document.getElementById('themeInstitutionRow');
            if (themeInstitutionRow) themeInstitutionRow.style.display = 'block';
            const assignThemeWrap = document.getElementById('assignThemeWrap');
            if (assignThemeWrap) assignThemeWrap.style.display = 'block';
            loadInstitutionsForThemeCustomizer();
            const themeInstitutionSelect = document.getElementById('themeInstitutionSelect');
            if (themeInstitutionSelect) themeInstitutionSelect.removeEventListener('change', onThemeInstitutionChange);
            if (themeInstitutionSelect) themeInstitutionSelect.addEventListener('change', onThemeInstitutionChange);
            const complianceTestingWrap = document.getElementById('complianceTestingWrap');
            if (complianceTestingWrap) complianceTestingWrap.style.display = '';
            
            const instructorTabBar = document.getElementById('instructorDashboardTabBar');
            if (instructorTabBar) instructorTabBar.style.display = 'none';
            const rubricsWrap = document.getElementById('dashboardRubricsWrap');
            if (rubricsWrap) rubricsWrap.style.display = 'none';
            
            const overviewAllWrap = document.getElementById('overviewAllInstitutionsWrap');
            const overviewDeptWrap = document.getElementById('overviewDepartmentCoursesWrap');
            if (overviewAllWrap) overviewAllWrap.style.display = 'block';
            if (overviewDeptWrap) overviewDeptWrap.style.display = 'none';
            
            const instructorFiltersSection = document.getElementById('instructorFiltersSection');
            if (instructorFiltersSection) instructorFiltersSection.style.display = 'none';
            
            // Hide department section, show user management (super admins manage all users)
            const deptSection = document.getElementById('departmentInstructorsSection');
            const userMgmtSection = document.getElementById('userManagementSection');
            if (deptSection) deptSection.style.display = 'none';
            if (userMgmtSection) userMgmtSection.style.display = 'block';
            
            // Remove any demo banners (unless in demo mode)
            if (currentViewMode !== 'demo') {
                const demoBanner = document.getElementById('demoBanner');
                if (demoBanner) demoBanner.remove();
            }
            
            console.log('✓ Super Admin interface ready');
            console.log('  - View:', currentViewMode);
            console.log('  - Can manage:', 'All institutions and users');
            
            // PHASE 5: Load filter dropdowns and All Institutions course table
            loadInstitutionsForFilter();
            loadInstructorsForFilter(''); // Load all instructors initially
            loadFilteredCoursesForSuperAdmin(); // Populate All Institutions table on first load
            
            // CRITICAL: Always start at dashboard after login; showDashboard() loads analytics automatically
            if (typeof showDashboard === 'function') showDashboard();
        }
        
        // Initialize Admin interface
        function initializeAdminInterface() {
            console.log('🏛️ Setting up Admin interface');
            
            // Admin: default to My Courses; scope filter in main Courses card
            currentViewMode = 'own';
            currentFilterInstitutionId = null;
            currentFilterInstructorId = null;
            const scopeFilterRow = document.getElementById('courseScopeFilterRow');
            if (scopeFilterRow) {
                scopeFilterRow.style.display = 'flex';
                const opt = document.getElementById('courseScopeInstitutionOption');
                if (opt) opt.textContent = 'Department';
            }
            updateViewMode();
            moveCoursesSectionsIntoOverview();
            const dashboardAdmin = document.getElementById('dashboardAdminContainer');
            if (dashboardAdmin) dashboardAdmin.style.display = 'none';

            const createInstitutionWrap = document.getElementById('createInstitutionWrap');
            if (createInstitutionWrap) createInstitutionWrap.style.display = 'none';
            const themeCustomizerWrap = document.getElementById('themeCustomizerWrap');
            if (themeCustomizerWrap) themeCustomizerWrap.style.display = '';
            const assignThemeWrap = document.getElementById('assignThemeWrap');
            if (assignThemeWrap) assignThemeWrap.style.display = 'none';
            const complianceTestingWrap = document.getElementById('complianceTestingWrap');
            if (complianceTestingWrap) complianceTestingWrap.style.display = '';

            const instructorTabBar = document.getElementById('instructorDashboardTabBar');
            if (instructorTabBar) instructorTabBar.style.display = 'none';
            const rubricsWrap = document.getElementById('dashboardRubricsWrap');
            if (rubricsWrap) rubricsWrap.style.display = 'none';

            const overviewDeptWrap = document.getElementById('overviewDepartmentCoursesWrap');
            const overviewAllWrap = document.getElementById('overviewAllInstitutionsWrap');
            if (overviewDeptWrap) overviewDeptWrap.style.display = 'block';
            if (overviewAllWrap) overviewAllWrap.style.display = 'none';

            const instructorFiltersSection = document.getElementById('instructorFiltersSection');
            if (instructorFiltersSection) instructorFiltersSection.style.display = 'none';

            // Show department section, hide user management (admins manage department, not all users)
            const deptSection = document.getElementById('departmentInstructorsSection');
            const userMgmtSection = document.getElementById('userManagementSection');
            if (deptSection) deptSection.style.display = 'block';
            if (userMgmtSection) userMgmtSection.style.display = 'none';
            
            // Remove any demo banners (unless in demo mode)
            if (currentViewMode !== 'demo') {
                const demoBanner = document.getElementById('demoBanner');
                if (demoBanner) demoBanner.remove();
            }
            
            console.log('✓ Admin interface ready');
            console.log('  - Theme:', currentInstitution?.name || 'Default');
            console.log('  - View:', currentViewMode);
            console.log('  - Can manage:', 'Department instructors');
            
            // PHASE 5: Load filter dropdowns and courses
            loadDepartmentInstructorsForFilter();
            loadFilteredCoursesForAdmin(); // Load all department courses by default
            
            // CRITICAL: Always start at dashboard after login; showDashboard() loads analytics automatically
            if (typeof showDashboard === 'function') showDashboard();
        }
        
        // Initialize Instructor interface
        function initializeInstructorInterface() {
            console.log('👤 Setting up Instructor interface');
            
            // CRITICAL: Hide admin panel container so instructor never sees admin content
            const dashboardAdmin = document.getElementById('dashboardAdminContainer');
            if (dashboardAdmin) {
                dashboardAdmin.style.display = 'none';
                dashboardAdmin.innerHTML = '';
                console.log('  ✓ Dashboard admin container hidden');
            }
            const createInstitutionWrap = document.getElementById('createInstitutionWrap');
            if (createInstitutionWrap) createInstitutionWrap.style.display = 'none';
            const themeCustomizerWrap = document.getElementById('themeCustomizerWrap');
            if (themeCustomizerWrap) themeCustomizerWrap.style.display = 'none';
            const complianceTestingWrap = document.getElementById('complianceTestingWrap');
            if (complianceTestingWrap) complianceTestingWrap.style.display = 'none';
            
            // Instructors always see their own courses
            currentViewMode = 'own';
            
            // Filter courses section removed from instructor dashboard (replaced by Courses | Rubrics | Course Insights tabs)
            const overviewDeptWrap = document.getElementById('overviewDepartmentCoursesWrap');
            const overviewAllWrap = document.getElementById('overviewAllInstitutionsWrap');
            if (overviewDeptWrap) overviewDeptWrap.style.display = 'none';
            if (overviewAllWrap) overviewAllWrap.style.display = 'none';
            
            // CRITICAL: Remove view mode banner (from previous admin session)
            const viewBanner = document.getElementById('viewModeBanner');
            if (viewBanner) {
                viewBanner.remove();
                console.log('  ✓ View mode banner removed');
            }
            
            // Remove any demo banners
            const demoBanner = document.getElementById('demoBanner');
            if (demoBanner) {
                demoBanner.remove();
                console.log('  ✓ Demo banner removed');
            }
            
            // CRITICAL: Set view mode to 'own' (instructor sees only their courses)
            // This prevents institution banner from showing
            currentViewMode = 'own';
            
            // Instructor dashboard: show tab bar (Courses | Rubrics | Course Insights) and default to Courses tab
            const instructorTabBar = document.getElementById('instructorDashboardTabBar');
            if (instructorTabBar) instructorTabBar.style.display = 'block';
            if (typeof switchInstructorDashboardTab === 'function') switchInstructorDashboardTab('courses');
            
            // Show Filter courses section for instructors (Phase 8)
            const instructorFiltersSection = document.getElementById('instructorFiltersSection');
            if (instructorFiltersSection) instructorFiltersSection.style.display = 'block';
            
            console.log('✓ Instructor interface ready');
            console.log('  - Theme:', currentInstitution?.name || 'Default');
            console.log('  - View: Own courses only');
            
            // CRITICAL: Always start at dashboard after login; showDashboard() loads analytics automatically
            if (typeof showDashboard === 'function') showDashboard();
        }
        
        // Initialize Demo interface
        function initializeDemoInterface() {
            console.log('🎭 Setting up Demo interface');
            
            const createInstitutionWrap = document.getElementById('createInstitutionWrap');
            if (createInstitutionWrap) createInstitutionWrap.style.display = 'none';
            const themeCustomizerWrap = document.getElementById('themeCustomizerWrap');
            if (themeCustomizerWrap) themeCustomizerWrap.style.display = 'none';
            
            // Set view mode to demo
            currentViewMode = 'demo';
            
            // Show demo banner with View as: Instructor | Admin switcher
            if (typeof updateTierUI === 'function') updateTierUI();
            console.log('  ✓ Demo banner with view switcher shown');
            
            var instructorTabBar = document.getElementById('instructorDashboardTabBar');
            if (instructorTabBar) instructorTabBar.style.display = (typeof demoViewAs !== 'undefined' && demoViewAs === 'admin') ? 'none' : 'block';
            if (typeof demoViewAs !== 'undefined' && demoViewAs === 'instructor' && typeof switchInstructorDashboardTab === 'function') switchInstructorDashboardTab('courses');
            if (typeof demoViewAs !== 'undefined' && demoViewAs === 'admin') {
                var mainCard = document.getElementById('mainCoursesCard');
                var rubricsWrap = document.getElementById('dashboardRubricsWrap');
                var analyticsSec = document.getElementById('analyticsSection');
                if (mainCard) mainCard.style.display = 'none';
                if (rubricsWrap) rubricsWrap.style.display = 'none';
                if (analyticsSec) analyticsSec.style.display = 'block';
            }
            
            console.log('✓ Demo interface ready');
            console.log('  - Storage: localStorage only');
            console.log('  - Features: Full evaluation features for testing');
            
            // CRITICAL: Always start at dashboard after login; showDashboard() loads analytics automatically
            if (typeof showDashboard === 'function') showDashboard();
        }
        
        // Update UI elements based on account tier
        function updateTierUI() {
            const isDemoMode = userTier === 'demo' || currentViewMode === 'demo';
            
            // Remove old banners
            const oldDemoBanner = document.getElementById('demoBanner');
            if (oldDemoBanner) oldDemoBanner.remove();
            
            if (isDemoMode && currentViewMode === 'demo') {
                const header = document.querySelector('header .container');
                let banner = document.getElementById('demoBanner');
                if (header && !banner) {
                    banner = document.createElement('div');
                    banner.id = 'demoBanner';
                    header.appendChild(banner);
                }
                if (banner) {
                    banner.style.cssText = 'background: #d4af37; color: var(--primary-dark); padding: 0.5rem 1rem; border-radius: 0.25rem; margin-top: 0.5rem; display: flex; align-items: center; justify-content: center; gap: 1rem; flex-wrap: wrap; border: 1px solid rgba(0,0,0,0.15);';
                    banner.innerHTML = '<span style="font-weight: 600; display: inline-flex; align-items: center; gap: 0.35rem;"><i data-lucide="theater" style="width:1.1em;height:1.1em;"></i> Demo Mode</span><span style="font-size: 0.9rem;">Data stored in localStorage only (not saved to database)</span><span style="display: inline-flex; align-items: center; gap: 0.5rem;"><label style="font-size: 0.875rem; font-weight: 600;">View as:</label><button type="button" id="demoViewInstructor" class="btn-secondary" style="padding: 0.25rem 0.75rem; font-size: 0.8rem; background: rgba(0,0,0,0.12); color: var(--primary-dark); border-color: rgba(0,0,0,0.2);"><span class="icon-with-text"><i data-lucide="user" style="width:1em;height:1em;"></i> Instructor</span></button><button type="button" id="demoViewAdmin" class="btn-secondary" style="padding: 0.25rem 0.75rem; font-size: 0.8rem; background: rgba(0,0,0,0.12); color: var(--primary-dark); border-color: rgba(0,0,0,0.2);"><span class="icon-with-text"><i data-lucide="shield" style="width:1em;height:1em;"></i> Admin</span></button></span>';
                    if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: banner });
                    var instrBtn = document.getElementById('demoViewInstructor');
                    var adminBtn = document.getElementById('demoViewAdmin');
                    if (instrBtn) instrBtn.onclick = function() { setDemoViewAs('instructor'); };
                    if (adminBtn) adminBtn.onclick = function() { setDemoViewAs('admin'); };
                    updateDemoViewButtons();
                }
            }
        }
        function setDemoViewAs(view) {
            if (typeof demoViewAs !== 'undefined') demoViewAs = view;
            if (typeof updateDemoViewButtons === 'function') updateDemoViewButtons();
            if (typeof updateAnalyticsUIForRole === 'function') updateAnalyticsUIForRole();
            var instructorTabBar = document.getElementById('instructorDashboardTabBar');
            if (instructorTabBar) instructorTabBar.style.display = view === 'instructor' ? 'block' : 'none';
            if (view === 'instructor') {
                if (typeof switchInstructorDashboardTab === 'function') switchInstructorDashboardTab('courses');
            } else {
                var mainCard = document.getElementById('mainCoursesCard');
                var rubricsWrap = document.getElementById('dashboardRubricsWrap');
                var analyticsSec = document.getElementById('analyticsSection');
                if (mainCard) mainCard.style.display = 'none';
                if (rubricsWrap) rubricsWrap.style.display = 'none';
                if (analyticsSec) analyticsSec.style.display = 'block';
            }
            if (typeof loadDemoAnalytics === 'function') loadDemoAnalytics(view);
        }
        function updateDemoViewButtons() {
            var instrBtn = document.getElementById('demoViewInstructor');
            var adminBtn = document.getElementById('demoViewAdmin');
            var active = typeof demoViewAs !== 'undefined' ? demoViewAs : 'instructor';
            if (instrBtn) { instrBtn.style.background = active === 'instructor' ? 'var(--primary-dark)' : 'rgba(0,0,0,0.12)'; instrBtn.style.color = active === 'instructor' ? 'white' : 'var(--primary-dark)'; instrBtn.style.borderColor = active === 'instructor' ? 'var(--primary-dark)' : 'rgba(0,0,0,0.2)'; }
            if (adminBtn) { adminBtn.style.background = active === 'admin' ? 'var(--primary-dark)' : 'rgba(0,0,0,0.12)'; adminBtn.style.color = active === 'admin' ? 'white' : 'var(--primary-dark)'; adminBtn.style.borderColor = active === 'admin' ? 'var(--primary-dark)' : 'rgba(0,0,0,0.2)'; }
        }
        
        // Show information about upgrading to research partner
        function showUpgradeInfo() {
            alert('To become a Research Partner with full features:\n\n' +
                  '• Full evaluation storage\n' +
                  '• Correction tracking for AI improvement\n' +
                  '• Contribute to research\n\n' +
                  'Contact: speechgradebook@proton.me');
        }
        
        // Check if user has research partner access (can save to database)
        function hasResearchAccess() {
            // Demo users can't save to database
            if (userTier === 'demo') {
                return false;
            }
            // All other tiers can save
            return ['instructor', 'admin', 'super_admin'].includes(userTier);
        }
        
        // Check if user is admin (institution admin)
        // Check if user is admin (institution admin, not super admin)
        function isAdmin() {
            return currentUser?.is_admin === true && userTier === 'admin';
        }
        
        // Check if user is super admin
        function isSuperAdmin() {
            return currentUser?.is_super_admin === true && userTier === 'super_admin';
        }
        
        // Check if user can manage other users (admin OR super admin)
        function canManageUsers() {
            return isAdmin() || isSuperAdmin();
        }
        
        // Check if user can view institution-wide data (admin OR super admin)
        function canViewInstitutionData() {
            return isAdmin() || isSuperAdmin();
        }
        
        // Check if user has any admin privileges (used for UI elements)
        function hasAdminAccess() {
            return currentUser?.is_admin === true || currentUser?.is_super_admin === true;
        }
        
        // Check if user is logged in
        async function checkAuth() {
            if (!supabaseClient) {
                console.log('Supabase not available - skipping auth');
                showMainApp();
                return;
            }
            
            const { data: { session } } = await supabaseClient.auth.getSession();
            
            if (session) {
                currentUser = session.user;
                console.log('✓ Logged in as:', currentUser.email);
                
                // Load user's account tier
                await loadUserTier();
                
                showMainApp();
                maybeShowInstructorLLMConsent();
            } else {
                console.log('Not logged in - showing auth screen');
                showAuthScreen();
                if (window.location.hash === '#register') showRegisterForm();
            }
        }
        
        function showAuthScreen() {
            var loadingEl = document.getElementById('authLoadingOverlay');
            if (loadingEl) loadingEl.classList.add('hidden');
            // Always reset theme so login page looks consistent (no leftover institution theme)
            resetThemeToDefault();
            document.getElementById('authScreen').classList.remove('hidden');
            document.getElementById('mainApp').style.display = 'none';
        }
        
        function enterDemoMode() {
            currentUser = null;
            userTier = 'demo';
            currentViewMode = 'demo';
            currentInstitution = null;
            currentInstitutionTheme = null;
            window.institutionLogoData = null;
            resetThemeToDefault();
            showMainApp();
            routeToInterface();
        }
        
        function showMainApp() {
            var loadingEl = document.getElementById('authLoadingOverlay');
            if (loadingEl) loadingEl.classList.add('hidden');
            document.getElementById('authScreen').classList.add('hidden');
            const mainApp = document.getElementById('mainApp');
            if (mainApp) mainApp.style.display = 'block';
            
            const userDisplayEl = document.getElementById('userDisplay');
            if (userDisplayEl) {
                const displayName = currentUser
                    ? (currentUser.full_name || currentUser.user_metadata?.full_name || currentUser.email)
                    : 'Demo';
                userDisplayEl.textContent = displayName;
            }
            
            // Remove demo banner when user is not in demo mode; repeat a few times in case UI adds it later
            if (userTier !== 'demo') {
                if (typeof removeDemoBannerIfPresent === 'function') removeDemoBannerIfPresent();
                setTimeout(function() { if (typeof removeDemoBannerIfPresent === 'function') removeDemoBannerIfPresent(); }, 100);
                setTimeout(function() { if (typeof removeDemoBannerIfPresent === 'function') removeDemoBannerIfPresent(); }, 400);
            }
        }

        // One-time instructor LLM consent (user-agreement style)
        function maybeShowInstructorLLMConsent() {
            if (!currentUser || !supabaseClient || userTier === 'demo') return;
            if (currentUser.llm_training_consent_given === true) return;
            // Anyone who can create evaluations (instructor, admin, super_admin) sees the agreement
            var overlay = document.getElementById('instructorConsentOverlay');
            var checkbox = document.getElementById('instructorConsentCheckbox');
            var submitBtn = document.getElementById('instructorConsentSubmit');
            if (!overlay || !checkbox || !submitBtn) return;
            overlay.hidden = false;
            checkbox.checked = false;
            submitBtn.disabled = true;
            checkbox.onchange = function() { submitBtn.disabled = !checkbox.checked; };
            submitBtn.onclick = function() {
                if (!checkbox.checked) return;
                submitBtn.disabled = true;
                supabaseClient.from('user_profiles')
                    .update({
                        llm_training_consent_given: true,
                        llm_training_consent_given_at: new Date().toISOString()
                    })
                    .eq('id', currentUser.id)
                    .then(function(res) {
                        if (res.error) {
                            console.warn('Could not save instructor consent:', res.error);
                            submitBtn.disabled = false;
                            return;
                        }
                        currentUser.llm_training_consent_given = true;
                        overlay.hidden = true;
                        if (typeof removeDemoBannerIfPresent === 'function') removeDemoBannerIfPresent();
                    })
                    .catch(function(err) {
                        console.warn('Instructor consent update failed:', err);
                        submitBtn.disabled = false;
                    });
            };
        }
        
        function showLoginForm() {
            document.getElementById('loginFormDiv').classList.remove('hidden');
            document.getElementById('registerFormDiv').classList.add('hidden');
        }
        
        function showRegisterForm() {
            document.getElementById('loginFormDiv').classList.add('hidden');
            document.getElementById('registerFormDiv').classList.remove('hidden');
        }
        
        // Login
        async function login(email, password) {
            try {
                console.log('=== LOGGING IN ===');
                
                // CRITICAL: Clear previous user state FIRST
                currentUser = null;
                userTier = 'demo';
                currentViewMode = 'own';
                currentInstitution = null;
                currentInstitutionTheme = null;
                window.institutionLogoData = null;
                window.pendingCustomFonts = null;
                cachedDepartmentInstructors = [];
                resetThemeToDefault(); // So previous user's theme doesn't stick
                
                console.log('✓ Previous state cleared');
                
                const { data, error } = await supabaseClient.auth.signInWithPassword({
                    email: email,
                    password: password
                });
                
                if (error) {
                    alert('Login failed: ' + error.message);
                    return false;
                }
                
                currentUser = data.user;
                console.log('✓ Login successful:', email);
                
                // Load new user's profile and theme
                await checkAuth();
                
                // Reload data for this user
                await loadClasses();
                await loadRubrics();
                
                return true;
            } catch (error) {
                console.error('Login error:', error);
                alert('Login failed: ' + error.message);
                return false;
            }
        }
        
        // Register
        async function register(name, email, password) {
            try {
                // Check if user was invited
                let invitedTier = 'demo';
                let invitation = null;
                
                if (supabaseClient) {
                    try {
                        const { data: invites, error: inviteError } = await supabaseClient
                            .from('invitations')
                            .select('*')
                            .eq('email', email)
                            .eq('status', 'pending')
                            .gt('expires_at', new Date().toISOString())
                            .order('created_at', { ascending: false })
                            .limit(1);
                        
                        if (!inviteError && invites && invites.length > 0) {
                            invitation = invites[0];
                            invitedTier = invitation.account_tier || 'research_partner';
                            console.log('✓ Found valid invitation for', email, '- will upgrade to', invitedTier);
                        }
                    } catch (err) {
                        console.log('Could not check invitations:', err);
                    }
                }
                
                // First create the auth user
                const { data: authData, error: authError } = await supabaseClient.auth.signUp({
                    email: email,
                    password: password
                });
                
                if (authError) {
                    alert('Registration failed: ' + authError.message);
                    return false;
                }
                
                if (!authData.user) {
                    alert('Registration failed: No user data returned');
                    return false;
                }
                
                // Split name into first and last
                const nameParts = name.trim().split(' ');
                const firstName = nameParts[0] || '';
                const lastName = nameParts.slice(1).join(' ') || '';
                
                // Create user record in users table (legacy)
                const { data: userData, error: userError } = await supabaseClient
                    .from('users')
                    .insert([{
                        id: authData.user.id,
                        email: email,
                        password_hash: 'managed_by_supabase_auth',
                        role: 'instructor',
                        account_type: 'individual',
                        status: 'active',
                        first_name: firstName,
                        last_name: lastName
                    }])
                    .select();
                
                if (userError) {
                    console.error('Failed to create user record:', userError);
                }
                
                // Update user_profile with invited tier
                if (supabaseClient && invitation) {
                    try {
                        // The trigger should have created the profile, now update it
                        const { error: profileError } = await supabaseClient
                            .from('user_profiles')
                            .update({
                                account_tier: invitedTier,
                                full_name: name,
                                institution: invitation.institution
                            })
                            .eq('id', authData.user.id);
                        
                        if (profileError) {
                            console.error('Could not upgrade account:', profileError);
                        } else {
                            console.log('✓ Account upgraded to', invitedTier);
                            
                            // Mark invitation as accepted
                            await supabaseClient
                                .from('invitations')
                                .update({
                                    status: 'accepted',
                                    accepted_at: new Date().toISOString()
                                })
                                .eq('id', invitation.id);
                        }
                    } catch (err) {
                        console.error('Error upgrading account:', err);
                    }
                }
                
                console.log('✓ User record created:', userData);
                
                if (invitation) {
                    alert('✓ Account created successfully!\n\nYou have been upgraded to Research Partner with full access.\n\nYou can now login.');
                } else {
                    alert('✓ Account created successfully! You can now login.');
                }
                
                showLoginForm();
                return true;
            } catch (error) {
                console.error('Registration error:', error);
                alert('Registration failed: ' + error.message);
                return false;
            }
        }
        
        // Logout
        async function logout() {
            console.log('=== LOGGING OUT ===');
            
            // Sign out from Supabase
            if (supabaseClient) {
                await supabaseClient.auth.signOut();
            }
            
            // Clear ALL global state
            currentUser = null;
            userTier = 'demo';
            currentViewMode = 'own';
            currentInstitution = null;
            currentInstitutionTheme = null;
            
            // Clear window variables
            window.institutionLogoData = null;
            window.pendingCustomFonts = null;
            
            // Clear any cached data
            cachedDepartmentInstructors = [];
            
            // CRITICAL: Clear login form
            const loginEmail = document.getElementById('loginEmail');
            const loginPassword = document.getElementById('loginPassword');
            if (loginEmail) loginEmail.value = '';
            if (loginPassword) loginPassword.value = '';
            
            // Remove all banners
            const viewBanner = document.getElementById('viewModeBanner');
            if (viewBanner) viewBanner.remove();
            const demoBanner = document.getElementById('demoBanner');
            if (demoBanner) demoBanner.remove();
            
            // Reset theme to stylesheet default (same as login page) so next login is consistent
            resetThemeToDefault();
            
            // Hide all sections
            document.querySelectorAll('.section').forEach(section => {
                section.style.display = 'none';
            });
            
            console.log('✓ State cleared');
            console.log('✓ Login form cleared');
            console.log('✓ Banners removed');
            console.log('✓ Theme reset to defaults');
            console.log('✓ Logged out');
            
            // Show login screen
            showAuthScreen();
        }
        
        // Handle login form
        document.getElementById('loginForm')?.addEventListener('submit', async (e) => {
            e.preventDefault();
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;
            await login(email, password);
        });
        
        // Handle register form
        document.getElementById('registerForm')?.addEventListener('submit', async (e) => {
            e.preventDefault();
            const name = document.getElementById('registerName').value;
            const email = document.getElementById('registerEmail').value;
            const password = document.getElementById('registerPassword').value;
            await register(name, email, password);
        });
        
        // ===== TENANT CONFIGURATION =====
        const TENANT_CONFIGS = {
            'utk': {
                name: 'University of Tennessee, Knoxville',
                shortName: 'UTK',
                domain: 'utk.edu',
                branding: {
                    appName: 'Speech Gradebook',
                    tagline: 'Instructor-Informed Speech Assessment'
                },
                colors: {
                    primary: '#FF8200',
                    primaryDark: '#D66D00',
                    secondary: '#58595B',
                    accent: '#FF8200'
                },
                typography: {
                    headingFont: "'Montserrat', sans-serif",
                    bodyFont: "'Georgia', serif",
                    headingWeight: '600',
                    bodyWeight: '400'
                },
                contact: {
                    supportEmail: 'speecheval-support@utk.edu'
                },
                footer: {
                    links: [
                        { text: 'Privacy Policy', url: 'https://www.utk.edu/aboutut/privacy/' },
                        { text: 'Accessibility', url: 'https://dae.utk.edu/eoa/ada/' },
                        { text: 'Title IX', url: 'https://titleix.utk.edu/' },
                        { text: 'IT Help', url: 'https://oit.utk.edu/help' }
                    ],
                    copyright: '© 2026 Speech Gradebook',
                    additionalText: 'The flagship campus of the University of Tennessee System'
                }
            },
            'default': {
                name: 'Speech Gradebook',
                shortName: 'SG',
                domain: null,
                branding: {
                    appName: 'Speech Gradebook',
                    tagline: 'Instructor-Informed Speech Assessment'
                },
                colors: {
                    primary: '#1e3a5f',
                    primaryDark: '#142940',
                    secondary: '#c8a882',
                    accent: '#d4af37'
                },
                typography: {
                    headingFont: "'Crimson Pro', serif",
                    bodyFont: "'Work Sans', sans-serif",
                    headingWeight: '700',
                    bodyWeight: '400'
                },
                contact: {
                    supportEmail: 'speechgradebook@proton.me'
                },
                footer: {
                    links: [
                        { text: 'Privacy Policy', url: 'privacy.html' },
                        { text: 'Terms of Service', url: 'terms.html' }
                    ],
                    copyright: '© 2026 Speech Gradebook',
                    additionalText: null
                }
            }
        };

        // ===== GLOBAL STATE =====
        console.log('🚀 Speech Gradebook JavaScript Loading...');
        let currentTenant = 'default';
        let uploadedFile = null;
        let evaluationResults = null;
        let currentStep = 1;
        let _instructorCoursesAll = []; // Full list for instructor filter (Phase 8)
        let _superAdminCoursesCache = [];
        let _adminCoursesCache = [];
        let _superAdminSortColumn = '';
        let _superAdminSortAsc = true;
        let _adminSortColumn = '';
        let _adminSortAsc = true;
        console.log('✓ Global variables initialized');
        
        // (API key placeholder removed – app always uses Fine-tuned model; URL from Settings or default)
        function updateApiKeyPlaceholder() {
            const el = document.getElementById('apiProvider');
            if (!el) return;
        }

        // ===== RUBRIC SYSTEM =====
        // Define the Self-Introduction Speech Rubric
        const SELF_INTRO_RUBRIC = {
            name: "Self Introduction Speech",
            totalPoints: 50,
            gradeScale: {
                A: { label: "Professional", percentage: 1.00, range: "100-91" },
                B: { label: "Proficient", percentage: 0.90, range: "90-89" },
                C: { label: "Developing", percentage: 0.80, range: "80-71" },
                D: { label: "Unprofessional", percentage: 0.70, range: "70-61" },
                F: { label: "Unacceptable", percentage: 0.60, range: "60-0" }
            },
            categories: [
                {
                    name: "Content - Introduction",
                    subcategories: [
                        "Capture Attention",
                        "Relevance to Audience",
                        "Introduction of Topic/Purpose"
                    ]
                },
                {
                    name: "Content - Organization",
                    subcategories: [
                        "Pattern",
                        "Connectives",
                        "Within Time Limits"
                    ]
                },
                {
                    name: "Content - Conclusion",
                    subcategories: [
                        "Recap/Summary",
                        "Memorable Final Thought"
                    ]
                },
                {
                    name: "Content - Assignment",
                    subcategories: [
                        "Your passion(s)",
                        "Career Goals",
                        "Philosophy",
                        "Clear Development of Ideas"
                    ]
                },
                {
                    name: "Delivery - Nonverbal",
                    subcategories: [
                        "Eye Contact",
                        "Gestures/Bodily Movements",
                        "Desire to Communicate/Enthusiasm",
                        "Professionalism"
                    ]
                },
                {
                    name: "Delivery - Verbal",
                    subcategories: [
                        "Vocal volume/variety/tone",
                        "Speaking Rate/Effective Use of Pauses",
                        "Extemporaneous style - use of notes",
                        "Use of vocalized pauses/fillers (ums, uhs, like...)"
                    ]
                }
            ]
        };

        // Calculate rubric metrics
        function calculateRubricMetrics(rubric) {
            const totalSubcategories = rubric.categories.reduce(
                (sum, cat) => sum + cat.subcategories.length, 
                0
            );
            const pointsPerSubcategory = rubric.totalPoints / totalSubcategories;
            
            return {
                totalSubcategories,
                pointsPerSubcategory,
                categoryPoints: rubric.categories.map(cat => ({
                    name: cat.name,
                    maxPoints: cat.subcategories.length * pointsPerSubcategory,
                    subcategoryCount: cat.subcategories.length
                }))
            };
        }

        // Calculate score for a category based on grade selections
        function calculateCategoryScore(rubric, categoryIndex, gradeSelections) {
            const metrics = calculateRubricMetrics(rubric);
            const category = rubric.categories[categoryIndex];
            const pointsPerSub = metrics.pointsPerSubcategory;
            
            let totalScore = 0;
            gradeSelections.forEach(grade => {
                const gradePercentage = rubric.gradeScale[grade].percentage;
                totalScore += pointsPerSub * gradePercentage;
            });
            
            return {
                score: parseFloat(totalScore.toFixed(2)),
                maxScore: parseFloat((category.subcategories.length * pointsPerSub).toFixed(2))
            };
        }
        let currentClassId = null;

        // ===== INITIALIZATION =====
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('📄 DOM Content Loaded');
            
            // Test Supabase connection
            testSupabaseConnection();
            
            // Check authentication status (loading overlay hides when this completes)
            await checkAuth();
            
            // Set default tenant
            currentTenant = 'default';
            applyTenant(currentTenant);
            console.log('✓ Tenant applied');
            
            // Initialize file upload
            initializeFileUpload();
            console.log('✓ File upload initialized');
            
            // Initialize form handlers
            initializeForms();
            console.log('✓ Forms initialized');
            
            // Load saved data
            await loadClasses();
            await loadRubrics();
            loadSavedSettings();
            console.log('✓ Data loaded');
            
            // Set current date
            document.getElementById('speechDate').valueAsDate = new Date();
            
            // Analytics tablist: arrow-key navigation (uses current dashboard config)
            const analyticsTablist = document.getElementById('analyticsTablist');
            if (analyticsTablist) {
                analyticsTablist.addEventListener('keydown', function(e) {
                    const config = typeof getDashboardConfig === 'function' ? getDashboardConfig() : [];
                    const tabIds = config.map(d => 'tab_' + d.id);
                    const target = e.target;
                    if (!target || !tabIds.includes(target.id)) return;
                    let idx = tabIds.indexOf(target.id);
                    if (e.key === 'ArrowLeft' && idx > 0) {
                        e.preventDefault();
                        switchAnalyticsTab(config[idx - 1].id);
                    } else if (e.key === 'ArrowRight' && idx < tabIds.length - 1) {
                        e.preventDefault();
                        switchAnalyticsTab(config[idx + 1].id);
                    }
                });
            }
            var analyticsGlobalApply = document.getElementById('analyticsGlobalApply');
            if (analyticsGlobalApply) analyticsGlobalApply.addEventListener('click', function() { if (typeof loadEnhancedAnalytics === 'function') loadEnhancedAnalytics(); });
            var analyticsGlobalReset = document.getElementById('analyticsGlobalReset');
            if (analyticsGlobalReset) analyticsGlobalReset.addEventListener('click', function() {
                // Reset date range
                var startEl = document.getElementById('analyticsStartDate');
                var endEl = document.getElementById('analyticsEndDate');
                if (startEl) startEl.value = '';
                if (endEl) endEl.value = '';
                
                // Reset all multi-select filters
                var globalCourse = document.getElementById('analyticsGlobalCourse');
                var globalInstructor = document.getElementById('analyticsGlobalInstructor');
                
                if (globalCourse) {
                    Array.from(globalCourse.options).forEach(opt => opt.selected = false);
                }
                if (globalInstructor) {
                    Array.from(globalInstructor.options).forEach(opt => opt.selected = false);
                }
                
                // Reset single-select filters
                var courseFilter = document.getElementById('analyticsCourseFilter');
                var instFilter = document.getElementById('analyticsInstructorFilter');
                var searchEl = document.getElementById('analyticsSearch');
                var scoreBandEl = document.getElementById('analyticsScoreBand');
                
                if (courseFilter) courseFilter.value = 'all';
                if (instFilter) instFilter.value = 'all';
                if (searchEl) searchEl.value = '';
                if (scoreBandEl) scoreBandEl.value = 'all';
                
                // Update active filters display and dropdown trigger labels
                if (typeof updateActiveFiltersDisplay === 'function') updateActiveFiltersDisplay();
                if (typeof FILTER_DROPDOWN_KEYS !== 'undefined' && typeof updateFilterDropdownTrigger === 'function') {
                    FILTER_DROPDOWN_KEYS.forEach(function(m) { updateFilterDropdownTrigger(m.key); });
                }
                
                // Reload data
                if (typeof loadEnhancedAnalytics === 'function') loadEnhancedAnalytics();
            });
            if (typeof renderDashboardTabs === 'function') renderDashboardTabs();
            if (typeof initFilterDropdownBehavior === 'function') initFilterDropdownBehavior();
            var editCardsBtn = document.getElementById('analyticsEditCardsBtn');
            if (editCardsBtn) editCardsBtn.addEventListener('click', function() { if (typeof openEditCardsModal === 'function' && typeof currentAnalyticsTabId !== 'undefined') openEditCardsModal(currentAnalyticsTabId); });
            var customizeBtn = document.getElementById('analyticsCustomizeDashboardsBtn');
            if (customizeBtn) customizeBtn.addEventListener('click', function() { if (typeof openCustomizeDashboardsModal === 'function') openCustomizeDashboardsModal(); });
            var customizeClose = document.getElementById('customizeDashboardsClose');
            if (customizeClose) customizeClose.addEventListener('click', function() { if (typeof closeCustomizeDashboardsModal === 'function') closeCustomizeDashboardsModal(); });
            var customizeAdd = document.getElementById('customizeDashboardsAdd');
            if (customizeAdd) customizeAdd.addEventListener('click', function() { if (typeof addDashboard === 'function') addDashboard(); });
            var editCardsClose = document.getElementById('editCardsClose');
            if (editCardsClose) editCardsClose.addEventListener('click', function() { if (typeof closeEditCardsModal === 'function') closeEditCardsModal(); });
            var instructorTabCourses = document.getElementById('instructorTabBtnCourses');
            var instructorTabRubrics = document.getElementById('instructorTabBtnRubrics');
            var instructorTabInsights = document.getElementById('instructorTabBtnInsights');
            if (instructorTabCourses) instructorTabCourses.addEventListener('click', function() { if (typeof switchInstructorDashboardTab === 'function') switchInstructorDashboardTab('courses'); });
            if (instructorTabRubrics) instructorTabRubrics.addEventListener('click', function() { if (typeof switchInstructorDashboardTab === 'function') switchInstructorDashboardTab('rubrics'); });
            if (instructorTabInsights) instructorTabInsights.addEventListener('click', function() { if (typeof switchInstructorDashboardTab === 'function') switchInstructorDashboardTab('insights'); });
            
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons();
            console.log('✓ Application fully initialized and ready');
        });

        // ===== NAVIGATION =====
        function showEvaluate() {
            setActiveSection('evaluateSection', 'navEvaluate');
        }

        function switchInstructorDashboardTab(tabId) {
            var panels = document.querySelectorAll('[data-instructor-panel]');
            panels.forEach(function(el) {
                el.style.display = el.getAttribute('data-instructor-panel') === tabId ? (el.id === 'mainCoursesCard' ? 'block' : 'block') : 'none';
            });
            var tabIds = ['courses', 'rubrics', 'insights'];
            tabIds.forEach(function(id) {
                var btn = document.getElementById('instructorTabBtn' + id.charAt(0).toUpperCase() + id.slice(1));
                if (btn) {
                    var active = id === tabId;
                    btn.classList.toggle('instructor-dashboard-tab-active', active);
                    btn.setAttribute('aria-selected', active ? 'true' : 'false');
                }
            });
        }

        function showDashboard() {
            setActiveSection('dashboardSection', 'navDashboard');
            loadClasses();
            if (typeof loadRubrics === 'function') loadRubrics();
            if (typeof updateAnalyticsUIForRole === 'function') updateAnalyticsUIForRole();
            if (typeof prefillAnalyticsDateRange === 'function') prefillAnalyticsDateRange();
            if (typeof renderDashboardTabs === 'function') renderDashboardTabs();
            var config = typeof getDashboardConfig === 'function' ? getDashboardConfig() : [];
            var firstVisible = config.filter(function(d) { return d.visible !== false; })[0];
            if (typeof switchAnalyticsTab === 'function') switchAnalyticsTab(firstVisible ? firstVisible.id : 'overview');
            const canLoadAnalytics = (typeof userTier !== 'undefined' && userTier === 'instructor') || (typeof isAdmin === 'function' && isAdmin() && typeof currentUser !== 'undefined' && currentUser && currentUser.department_id) || (typeof isSuperAdmin === 'function' && isSuperAdmin());
            if (userTier === 'demo' && typeof loadDemoAnalytics === 'function') {
                loadDemoAnalytics(typeof demoViewAs !== 'undefined' ? demoViewAs : 'instructor');
            } else if (canLoadAnalytics && typeof loadEnhancedAnalytics === 'function') {
                loadEnhancedAnalytics();
            } else {
                const statsContainer = document.getElementById('overviewStatsContainer');
                if (statsContainer) {
                    statsContainer.innerHTML = '<div style="text-align: center; padding: 2rem 1.5rem; color: var(--text-light);"><p style="font-size: 1.5rem; margin-bottom: 0.5rem;"><i data-lucide="bar-chart-2" style="width:2rem;height:2rem;display:inline-block;"></i></p><p style="font-weight: 600; margin-bottom: 0.25rem; color: var(--text);">Analytics</p><p style="font-size: 0.9rem;">Analytics are available for instructors and department heads. Sign in with an eligible account to see evaluation insights here.</p></div>';
                    if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statsContainer });
                }
            }
        }

        function switchSettingsTab(tabId) {
            var generalBtn = document.getElementById('settingsTabBtnGeneral');
            var consentBtn = document.getElementById('settingsTabBtnConsent');
            var adminBtn = document.getElementById('settingsTabBtnAdmin');
            var generalPanel = document.getElementById('settingsTabGeneral');
            var consentPanel = document.getElementById('settingsTabConsent');
            var adminPanel = document.getElementById('settingsTabAdmin');
            if (!generalPanel || !consentPanel || !adminPanel) return;
            generalPanel.style.display = tabId === 'general' ? 'block' : 'none';
            consentPanel.style.display = tabId === 'consent' ? 'block' : 'none';
            adminPanel.style.display = tabId === 'admin' ? 'block' : 'none';
            if (generalBtn) { generalBtn.classList.toggle('settings-tab-active', tabId === 'general'); generalBtn.setAttribute('aria-selected', tabId === 'general' ? 'true' : 'false'); }
            if (consentBtn) { consentBtn.classList.toggle('settings-tab-active', tabId === 'consent'); consentBtn.setAttribute('aria-selected', tabId === 'consent' ? 'true' : 'false'); }
            if (adminBtn) { adminBtn.classList.toggle('settings-tab-active', tabId === 'admin'); adminBtn.setAttribute('aria-selected', tabId === 'admin' ? 'true' : 'false'); }
            if (tabId === 'admin' && typeof canManageUsers === 'function' && canManageUsers() && typeof loadCurrentThemeToForm === 'function') loadCurrentThemeToForm();
        }

        function showSettings(openTab) {
            setActiveSection('settingsSection', 'navSettings');
            loadCoursesForConsentDropdown();
            if (typeof loadApiKeySettings === 'function') loadApiKeySettings();
            var adminTabBtn = document.getElementById('settingsTabBtnAdmin');
            if (adminTabBtn) adminTabBtn.style.display = (typeof canManageUsers === 'function' && canManageUsers()) ? '' : 'none';
            var tab = (openTab === 'admin' || openTab === 'consent') ? openTab : 'general';
            if (typeof switchSettingsTab === 'function') switchSettingsTab(tab);
        }

        function showHelp() {
            setActiveSection('helpSection', 'navHelp');
            refreshSupportContent();
        }

        function switchSupportDocTab(tabId) {
            const panels = ['supportPanelGettingStarted', 'supportPanelUserManual', 'supportPanelTechnical'];
            const buttons = ['supportTabBtnGettingStarted', 'supportTabBtnUserManual', 'supportTabBtnTechnical'];
            panels.forEach(id => {
                const el = document.getElementById(id);
                if (el) { el.classList.toggle('active', id === 'supportPanel' + tabId.split('-').map(s => s.charAt(0).toUpperCase() + s.slice(1)).join('')); }
            });
            buttons.forEach((id, i) => {
                const key = ['getting-started', 'user-manual', 'technical'][i];
                const el = document.getElementById(id);
                if (el) { el.classList.toggle('support-tab-active', key === tabId); el.setAttribute('aria-selected', key === tabId ? 'true' : 'false'); }
            });
            if (tabId === 'technical') populateSupportChangelog();
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: document.getElementById('helpSection') });
        }

        function refreshSupportContent() {
            const v = (typeof CONFIG !== 'undefined' && CONFIG.appVersion) ? CONFIG.appVersion : '3.0';
            const label = (typeof CONFIG !== 'undefined' && CONFIG.appVersionLabel) ? ' ' + CONFIG.appVersionLabel : ' (Supabase Edition)';
            const versionEl = document.getElementById('supportVersionText');
            const labelEl = document.getElementById('supportVersionLabel');
            if (versionEl) versionEl.textContent = 'v' + v;
            if (labelEl) labelEl.textContent = label;
            const tier = typeof userTier !== 'undefined' ? userTier : 'demo';
            document.querySelectorAll('.support-tier-badge').forEach(badge => {
                const t = badge.getAttribute('data-tier');
                const show = t === tier || (tier === 'super_admin' && (t === 'admin' || t === 'instructor')) || (tier === 'admin' && t === 'instructor');
                badge.style.display = show ? 'inline-block' : 'none';
            });
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: document.getElementById('helpSection') });
        }

        function populateSupportChangelog() {
            const el = document.getElementById('supportChangelogContent');
            if (!el) return;
            const log = typeof SUPPORT_CHANGELOG !== 'undefined' ? SUPPORT_CHANGELOG : 'See CHANGELOG.md in the project for the full change history.';
            el.textContent = log;
        }

        // Recent changelog text for Support → Technical Documentation (full history in CHANGELOG.md)
        const SUPPORT_CHANGELOG = `v3.0 (Supabase Edition)
• Support section restructured: version at top, Getting Started, User Manual, Technical Documentation
• Documentation tailored by user tier (instructor, admin, super_admin)
• Data management, Change Log, and Licensing/Legal in Technical Documentation

Earlier:
• Supabase backend: courses, evaluations, rubrics, consent, audit logs, RLS
• Multi-provider evaluation: Gemini, GPT-4o, Claude, Fine-tuned server
• Institution themes, custom fonts, consent links, Course Insights / analytics
• FERPA-oriented audit logging and consent flows`;

        // Consent: store last generated links for copy/download
        let lastConsentLinks = [];

        function showConsent() {
            // Consent management is in Settings (Consent tab)
            showSettings('consent');
        }

        async function loadCoursesForConsentDropdown() {
            const sel = document.getElementById('consentCourseSelect');
            if (!sel || !supabaseClient || !currentUser) return;
            try {
                let query = supabaseClient.from('courses').select('id, name').order('name');
                if (userTier === 'instructor') {
                    query = query.eq('instructor_id', currentUser.id);
                } else if (userTier === 'admin' && currentUser.institution_id) {
                    const { data: instInstructors } = await supabaseClient
                        .from('user_profiles')
                        .select('id')
                        .eq('institution_id', currentUser.institution_id);
                    const ids = (instInstructors || []).map(i => i.id);
                    if (ids.length) query = query.in('instructor_id', ids);
                    else { sel.innerHTML = '<option value="">-- No courses --</option>'; return; }
                }
                const { data: courses, error } = await query;
                if (error) throw error;
                sel.innerHTML = '<option value="">-- Select a course --</option>' +
                    (courses || []).map(c => `<option value="${c.id}">${escapeHtml(c.name)}</option>`).join('');
            } catch (e) {
                console.error('loadCoursesForConsentDropdown:', e);
                document.getElementById('consentLinksMessage').textContent = 'Could not load courses.';
            }
        }

        async function generateConsentLinks() {
            const courseId = document.getElementById('consentCourseSelect')?.value;
            const consentType = 'data_collection'; // Single catch-all consent (matches DB allowed values; covers grading, platform improvement, research)
            const msgEl = document.getElementById('consentLinksMessage');
            const container = document.getElementById('consentLinksContainer');
            const btn = document.getElementById('consentGenerateBtn');
            if (!courseId || !supabaseClient || !currentUser) {
                if (msgEl) msgEl.textContent = 'Please select a course and sign in.';
                return;
            }
            msgEl.textContent = 'Generating links…';
            if (container) container.classList.add('hidden');
            if (btn) btn.disabled = true;
            try {
                const { data: students, error: studErr } = await supabaseClient
                    .from('course_students')
                    .select('id, first_name, last_name, email')
                    .eq('course_id', courseId);
                if (studErr) throw studErr;
                if (!students || students.length === 0) {
                    msgEl.textContent = 'No students in this course.';
                    return;
                }
                // Include all consent_requests for this course/type (completed or not) so we reuse tokens and never INSERT duplicate (student_id, course_id, consent_type)
                const { data: existing } = await supabaseClient
                    .from('consent_requests')
                    .select('student_id, token')
                    .eq('course_id', courseId)
                    .eq('consent_type', consentType);
                const tokenByStudent = {};
                (existing || []).forEach(r => { tokenByStudent[r.student_id] = r.token; });
                var path = (window.location.pathname || '/').replace(/\/index\.html$/i, '') || '/';
                if (!path.endsWith('/')) path += '/';
                const baseUrl = window.location.origin + path + 'consent.html';
                const links = [];
                for (const s of students) {
                    let token = tokenByStudent[s.id];
                    if (!token) {
                        const { data: inserted, error: insErr } = await supabaseClient
                            .from('consent_requests')
                            .insert({
                                student_id: s.id,
                                course_id: courseId,
                                consent_type: consentType,
                                created_by: currentUser.id
                            })
                            .select('token')
                            .single();
                        if (insErr) {
                            console.error('Insert consent_request:', insErr);
                            continue;
                        }
                        token = inserted?.token;
                    }
                    if (!token) continue;
                    const name = [s.first_name, s.last_name].filter(Boolean).join(' ').trim() || 'Student';
                    const link = baseUrl + '?token=' + token;
                    links.push({ name, email: s.email || '', link });
                }
                lastConsentLinks = links;
                renderConsentLinksTable(links);
                msgEl.textContent = links.length + ' link(s) ready. Copy or download, then email each student their link.';
                if (container) container.classList.remove('hidden');
            } catch (e) {
                console.error('generateConsentLinks:', e);
                msgEl.textContent = 'Error: ' + (e.message || 'Could not generate links.');
            } finally {
                if (btn) btn.disabled = false;
            }
        }

        function renderConsentLinksTable(links) {
            const tbody = document.getElementById('consentLinksTableBody');
            if (!tbody) return;
            tbody.innerHTML = links.map((row, i) => {
                const linkEsc = escapeHtml(row.link);
                const nameEsc = escapeHtml(row.name);
                const emailEsc = escapeHtml(row.email);
                return `<tr>
                    <td>${nameEsc}</td>
                    <td>${emailEsc}</td>
                    <td><a href="${linkEsc}" target="_blank" rel="noopener">${linkEsc}</a></td>
                    <td><button type="button" class="copy-consent-link" data-link="${escapeHtml(row.link)}" style="padding:0.25rem 0.5rem;">Copy</button></td>
                </tr>`;
            }).join('');
            tbody.querySelectorAll('.copy-consent-link').forEach(btn => {
                btn.addEventListener('click', function() {
                    const link = this.getAttribute('data-link');
                    if (link) navigator.clipboard.writeText(link).then(() => { this.textContent = 'Copied!'; setTimeout(() => { this.textContent = 'Copy'; }, 1500); });
                });
            });
        }

        function copyAllConsentLinks() {
            if (!lastConsentLinks.length) return;
            const text = lastConsentLinks.map(r => r.name + ' – ' + r.link).join('\n');
            navigator.clipboard.writeText(text).then(() => {
                const msg = document.getElementById('consentLinksMessage');
                if (msg) msg.textContent = 'All links copied to clipboard.';
            }).catch(() => alert('Copy failed.'));
        }

        function downloadConsentCSV() {
            if (!lastConsentLinks.length) return;
            const header = 'Name,Email,Consent link\n';
            const rows = lastConsentLinks.map(r => {
                const name = '"' + (r.name || '').replace(/"/g, '""') + '"';
                const email = '"' + (r.email || '').replace(/"/g, '""') + '"';
                const link = '"' + (r.link || '').replace(/"/g, '""') + '"';
                return [name, email, link].join(',');
            }).join('\n');
            const blob = new Blob([header + rows], { type: 'text/csv;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'consent-links.csv';
            a.click();
            URL.revokeObjectURL(a.href);
        }

        function showAdmin() {
            // Admin panel is in Settings
            if (!canManageUsers()) {
                alert('Access denied. Admin privileges required.');
                return;
            }
            showSettings();
        }
        
        // Super Admin: load institutions into theme customizer dropdown
        async function loadInstitutionsForThemeCustomizer() {
            if (!supabaseClient || !isSuperAdmin()) return;
            const sel = document.getElementById('themeInstitutionSelect');
            if (!sel) return;
            try {
                const { data: institutions, error } = await supabaseClient
                    .from('institutions')
                    .select('id, name')
                    .order('name');
                if (error) throw error;
                const list = institutions || [];
                const opts = list.map(inst => `<option value="${inst.id}">${escapeHtml(inst.name)}</option>`).join('');
                sel.innerHTML = '<option value="">Select institution…</option>' + opts;
                loadInstitutionsForAssignTheme(list);
            } catch (e) {
                console.warn('loadInstitutionsForThemeCustomizer:', e);
            }
        }

        // Super Admin: populate Assign theme source/target dropdowns
        function loadInstitutionsForAssignTheme(institutions) {
            if (!isSuperAdmin()) return;
            const src = document.getElementById('assignThemeSourceSelect');
            const tgt = document.getElementById('assignThemeTargetSelect');
            if (!src || !tgt) return;
            const list = Array.isArray(institutions) ? institutions : [];
            const opts = list.map(inst => `<option value="${inst.id}">${escapeHtml(inst.name)}</option>`).join('');
            src.innerHTML = '<option value="">Select institution…</option>' + opts;
            tgt.innerHTML = '<option value="">Select institution…</option>' + opts;
        }

        // Super Admin: copy one institution's theme to another
        async function assignThemeToInstitution() {
            if (!isSuperAdmin()) {
                alert('Only Super Admins can assign themes to institutions.');
                return;
            }
            const statusEl = document.getElementById('assignThemeStatus');
            const sourceId = document.getElementById('assignThemeSourceSelect')?.value;
            const targetId = document.getElementById('assignThemeTargetSelect')?.value;
            if (!sourceId || !targetId) {
                if (statusEl) statusEl.innerHTML = '<p style="color: var(--error); font-size: 0.9rem;">Select both "Copy theme from" and "Assign to institution".</p>';
                return;
            }
            if (sourceId === targetId) {
                if (statusEl) statusEl.innerHTML = '<p style="color: var(--error); font-size: 0.9rem;">Source and target must be different institutions.</p>';
                return;
            }
            if (!supabaseClient) {
                if (statusEl) statusEl.innerHTML = '<p style="color: var(--error); font-size: 0.9rem;">Not connected to database.</p>';
                return;
            }
            if (statusEl) statusEl.innerHTML = '<p style="color: var(--text-light); font-size: 0.9rem;">Copying theme…</p>';
            try {
                const { data: sourceTheme, error: fetchErr } = await supabaseClient
                    .from('institution_themes')
                    .select('*')
                    .eq('institution_id', sourceId)
                    .maybeSingle();
                if (fetchErr) throw fetchErr;
                if (!sourceTheme) {
                    if (statusEl) statusEl.innerHTML = '<p style="color: var(--warning); font-size: 0.9rem;">The source institution has no theme to copy. Edit and save a theme for it first.</p>';
                    return;
                }
                // Exclude id so target row gets new PK on insert; exclude institution_id/created_at/updated_at (we set target id and updated_at)
                const { id, institution_id, created_at, updated_at, ...themeFields } = sourceTheme;
                const payload = {
                    institution_id: targetId,
                    ...themeFields,
                    updated_at: new Date().toISOString()
                };
                const { data: saved, error: upsertErr } = await supabaseClient
                    .from('institution_themes')
                    .upsert(payload, { onConflict: 'institution_id' })
                    .select();
                if (upsertErr) throw upsertErr;
                if (statusEl) statusEl.innerHTML = '<p style="color: var(--success); font-size: 0.9rem;"><span class="icon-with-text"><i data-lucide="check-circle" style="width:1em;height:1em;"></i> Theme assigned successfully. The target institution now uses the copied theme.</span></p>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statusEl });
                loadInstitutionsForThemeCustomizer();
            } catch (err) {
                console.error('assignThemeToInstitution:', err);
                if (statusEl) statusEl.innerHTML = '<p style="color: var(--error); font-size: 0.9rem;"><span class="icon-with-text"><i data-lucide="x-circle" style="width:1em;height:1em;"></i> ' + escapeHtml(err.message || 'Failed to assign theme.') + '</span></p>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statusEl });
            }
        }
        
        function onThemeInstitutionChange() {
            loadCurrentThemeToForm();
        }
        
        // Super Admin: create a new institution
        async function createNewInstitution() {
            if (!isSuperAdmin()) {
                alert('Only Super Admins can create institutions.');
                return;
            }
            const nameInput = document.getElementById('newInstitutionName');
            const statusEl = document.getElementById('createInstitutionStatus');
            const name = (nameInput && nameInput.value) ? nameInput.value.trim() : '';
            if (!name) {
                if (statusEl) statusEl.innerHTML = '<p style="color: var(--error); padding: 0.75rem; background: #fee2e2; border-radius: 0.5rem;">Enter an institution name.</p>';
                return;
            }
            if (!supabaseClient) {
                if (statusEl) statusEl.innerHTML = '<p style="color: var(--error); padding: 0.75rem; background: #fee2e2; border-radius: 0.5rem;">Not connected to database.</p>';
                return;
            }
            if (statusEl) statusEl.innerHTML = '<p style="color: var(--text-light); padding: 0.75rem;">Creating…</p>';
            try {
                const { data, error } = await supabaseClient
                    .from('institutions')
                    .insert({ name: name })
                    .select('id, name')
                    .single();
                if (error) throw error;
                if (nameInput) nameInput.value = '';
                if (statusEl) statusEl.innerHTML = '<p style="color: var(--success); padding: 0.75rem; background: #d1fae5; border-radius: 0.5rem; border-left: 4px solid var(--success);"><span class="icon-with-text"><i data-lucide="check-circle" style="width:1.1em;height:1.1em;"></i> Institution created: ' + escapeHtml(data.name) + '. You can now assign users and create a theme for it.</span></p>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statusEl });
                loadInstitutionsForThemeCustomizer();
                loadInstitutionsForFilter();
                if (typeof loadCourseScopeInstitutions === 'function') loadCourseScopeInstitutions();
            } catch (err) {
                console.error('createNewInstitution:', err);
                if (statusEl) statusEl.innerHTML = '<p style="color: var(--error); padding: 0.75rem; background: #fee2e2; border-radius: 0.5rem; border-left: 4px solid var(--error);"><span class="icon-with-text"><i data-lucide="x-circle" style="width:1.1em;height:1.1em;"></i> ' + escapeHtml(err.message || 'Failed to create institution.') + ' Run the RLS migration to allow Super Admins to insert institutions.</span></p>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statusEl });
            }
        }
        
        // Set theme form inputs to SpeechGradebook default (for creating new themes)
        function setThemeFormToDefaults() {
            const defaults = {
                primary: '#1e3a5f',
                header: '#142940',
                secondary: '#8b9dc3',
                text: '#2c3e50',
                textLight: '#6c757d',
                fontHeading: "'Crimson Pro', serif",
                fontBody: "'Work Sans', sans-serif"
            };
            const primaryEl = document.getElementById('themePrimaryColor');
            const primaryText = document.getElementById('themePrimaryText');
            if (primaryEl) primaryEl.value = defaults.primary;
            if (primaryText) primaryText.value = defaults.primary;
            const headerEl = document.getElementById('themeHeaderColor');
            const headerText = document.getElementById('themeHeaderText');
            if (headerEl) headerEl.value = defaults.header;
            if (headerText) headerText.value = defaults.header;
            const secEl = document.getElementById('themeSecondaryColor');
            const secText = document.getElementById('themeSecondaryText');
            if (secEl) secEl.value = defaults.secondary;
            if (secText) secText.value = defaults.secondary;
            const textEl = document.getElementById('themeTextColor');
            const textText = document.getElementById('themeTextText');
            if (textEl) textEl.value = defaults.text;
            if (textText) textText.value = defaults.text;
            const headingFont = document.getElementById('themeHeadingFont');
            const bodyFont = document.getElementById('themeBodyFont');
            if (headingFont) headingFont.value = defaults.fontHeading;
            if (bodyFont) bodyFont.value = defaults.fontBody;
            window.institutionLogoData = null;
            const logoImg = document.getElementById('logoPreviewImage');
            const logoPlaceholder = document.getElementById('logoPlaceholder');
            if (logoImg) { logoImg.src = ''; logoImg.style.display = 'none'; }
            if (logoPlaceholder) logoPlaceholder.style.display = 'block';
            const customList = document.getElementById('customFontsList');
            if (customList) customList.style.display = 'none';
            const container = document.getElementById('customFontsContainer');
            if (container) container.innerHTML = '';
            if (typeof syncColorInputs === 'function') syncColorInputs();
        }
        
        function getThemeFormInstitutionId() {
            if (isSuperAdmin()) {
                const sel = document.getElementById('themeInstitutionSelect');
                if (sel && sel.value) return sel.value;
                return null;
            }
            return currentUser?.institution_id || null;
        }
        
        // Load current institution theme into form
        async function loadCurrentThemeToForm() {
            const institutionId = getThemeFormInstitutionId();
            if (!institutionId && !isSuperAdmin()) {
                if (!currentUser || !currentUser.institution_id) {
                    console.warn('⚠️ Cannot load theme form: No user or institution');
                    return;
                }
            }
            if (isSuperAdmin() && !institutionId) {
                setThemeFormToDefaults();
                return;
            }
            const targetInstitutionId = institutionId || currentUser.institution_id;
            console.log('Loading theme form for institution:', targetInstitutionId);
            
            try {
                const { data: theme, error } = await supabaseClient
                    .from('institution_themes')
                    .select('*')
                    .eq('institution_id', targetInstitutionId)
                    .maybeSingle();
                
                if (error) {
                    console.error('Error loading theme form:', error);
                    if (isSuperAdmin()) setThemeFormToDefaults();
                    return;
                }
                
                if (theme) {
                    if (!isSuperAdmin() && theme.institution_id !== currentUser.institution_id) {
                        console.error('❌ SECURITY VIOLATION: Theme institution mismatch!');
                        alert('Security error: You do not have permission to edit this theme.');
                        return;
                    }
                    
                    console.log('✓ Loading theme form with data from institution:', theme.institution_id);
                    
                    document.getElementById('themePrimaryColor').value = theme.primary_color || '#1e3a5f';
                    document.getElementById('themePrimaryText').value = theme.primary_color || '#1e3a5f';
                    document.getElementById('themeHeaderColor').value = theme.header_bg_color || '#142940';
                    document.getElementById('themeHeaderText').value = theme.header_bg_color || '#142940';
                    document.getElementById('themeSecondaryColor').value = theme.secondary_color || '#8b9dc3';
                    document.getElementById('themeSecondaryText').value = theme.secondary_color || '#8b9dc3';
                    document.getElementById('themeTextColor').value = theme.text_primary || '#2c3e50';
                    document.getElementById('themeTextText').value = theme.text_primary || '#2c3e50';
                    
                    if (theme.font_heading) {
                        document.getElementById('themeHeadingFont').value = theme.font_heading;
                    }
                    if (theme.font_body) {
                        document.getElementById('themeBodyFont').value = theme.font_body;
                    }
                    
                    if (theme.logo_url) {
                        const logoImg = document.getElementById('logoPreviewImage');
                        const logoPlaceholder = document.getElementById('logoPlaceholder');
                        if (logoImg && logoPlaceholder) {
                            logoImg.src = theme.logo_url;
                            logoImg.style.display = 'block';
                            logoPlaceholder.style.display = 'none';
                            window.institutionLogoData = theme.logo_url;
                            console.log('✓ Logo loaded from database');
                        }
                    } else {
                        // Only clear preview; do NOT set institutionLogoData = null here, so a
                        // newly uploaded logo (not yet saved) is not lost when switching tabs or reloading form.
                        const logoImg = document.getElementById('logoPreviewImage');
                        const logoPlaceholder = document.getElementById('logoPlaceholder');
                        if (logoImg) { logoImg.src = ''; logoImg.style.display = 'none'; }
                        if (logoPlaceholder) logoPlaceholder.style.display = 'block';
                    }
                    
                    if (theme.custom_fonts) {
                        console.log('✓ Loading custom fonts into form');
                        loadCustomFonts(theme.custom_fonts);
                    } else {
                        const customList = document.getElementById('customFontsList');
                        if (customList) customList.style.display = 'none';
                        const container = document.getElementById('customFontsContainer');
                        if (container) container.innerHTML = '';
                    }
                    
                    syncColorInputs();
                    console.log('✓ Theme form loaded successfully');
                } else {
                    console.log('ℹ️ No theme for this institution; showing defaults for new theme.');
                    setThemeFormToDefaults();
                }
            } catch (err) {
                console.error('Error loading theme form:', err);
                if (isSuperAdmin()) setThemeFormToDefaults();
            }
        }
        
        // Load and display custom fonts
        function loadCustomFonts(customFontsData) {
            if (!customFontsData) return;
            
            let fonts = [];
            try {
                fonts = typeof customFontsData === 'string' ? JSON.parse(customFontsData) : customFontsData;
            } catch (e) {
                console.error('Error parsing custom fonts:', e);
                return;
            }
            
            if (!Array.isArray(fonts) || fonts.length === 0) return;
            
            const container = document.getElementById('customFontsContainer');
            const list = document.getElementById('customFontsList');
            
            if (!container || !list) return;
            
            // Show the list
            list.style.display = 'block';
            
            // Clear existing
            container.innerHTML = '';
            
            // Add each font
            fonts.forEach((font, index) => {
                // Inject font-face
                injectFontFace(font);
                
                // Add to selectors
                addFontToSelectors(font.name, font.family);
                
                // Display in list
                const fontItem = document.createElement('div');
                fontItem.style.cssText = 'padding: 0.75rem; background: var(--bg); border: 1px solid var(--border); border-radius: 0.25rem; display: flex; justify-content: space-between; align-items: center;';
                fontItem.innerHTML = `
                    <span style="font-family: ${font.family}, sans-serif; font-weight: 600;">${font.name}</span>
                    <button onclick="removeCustomFont(${index})" style="padding: 0.25rem 0.5rem; font-size: 0.85rem; background: var(--error);">
                        🗑️ Remove
                    </button>
                `;
                container.appendChild(fontItem);
            });
        }
        
        // Inject @font-face CSS - ONLY Regular weight to prevent auto-matching
        function injectFontFace(font) {
            const styleId = `custom-font-${font.family.replace(/[^a-zA-Z0-9]/g, '-')}`;
            
            // Check if already injected
            if (document.getElementById(styleId)) return;
            
            // CRITICAL: Only use Regular (400) Normal style variant
            // This prevents browser from auto-applying bold/italic variants
            const regularFile = font.files.find(f => f.weight === '400' && f.style === 'normal');
            
            if (!regularFile) {
                console.warn(`No Regular variant found for ${font.family}, using first file`);
                // Fallback to first file but force it as Regular
                const fallbackFile = font.files[0];
                if (!fallbackFile) return;
                
                const style = document.createElement('style');
                style.id = styleId;
                style.textContent = `
                    @font-face {
                        font-family: '${font.family}';
                        src: url('${fallbackFile.data}') format('${fallbackFile.format}');
                        font-weight: 400;
                        font-style: normal;
                        font-display: swap;
                    }
                `;
                document.head.appendChild(style);
                console.log(`✓ Injected font-face for ${font.family} (forced as Regular)`);
                return;
            }
            
            // Inject ONLY the Regular variant
            const style = document.createElement('style');
            style.id = styleId;
            style.textContent = `
                @font-face {
                    font-family: '${font.family}';
                    src: url('${regularFile.data}') format('${regularFile.format}');
                    font-weight: 400;
                    font-style: normal;
                    font-display: swap;
                }
            `;
            
            document.head.appendChild(style);
            console.log(`✓ Injected font-face for ${font.family} (Regular only - ${font.files.length} total variants ignored to prevent auto-matching)`);
        }
        
        // Add font to selectors
        function addFontToSelectors(name, family) {
            const headingSelect = document.getElementById('themeHeadingFont');
            const bodySelect = document.getElementById('themeBodyFont');
            
            if (!headingSelect || !bodySelect) return;
            
            const value = `'${family}', sans-serif`;
            
            // Check if already exists
            const existsInHeading = Array.from(headingSelect.options).some(opt => opt.value === value);
            const existsInBody = Array.from(bodySelect.options).some(opt => opt.value === value);
            
            if (!existsInHeading) {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = `${name} (Custom)`;
                headingSelect.appendChild(option);
            }
            
            if (!existsInBody) {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = `${name} (Custom)`;
                bodySelect.appendChild(option);
            }
        }
        
        // Upload custom font
        async function uploadCustomFont() {
            const nameInput = document.getElementById('customFontName');
            const filesInput = document.getElementById('customFontFiles');
            
            // Check which input has files
            const files = filesInput.files;
            
            if (!nameInput.value.trim()) {
                alert('Please enter a font family name.');
                return;
            }
            
            if (!files || files.length === 0) {
                alert('Please select font files or a folder containing fonts.');
                return;
            }
            
            const fontName = nameInput.value.trim();
            const fontFamily = fontName.replace(/[^a-zA-Z0-9 ]/g, '');
            
            const statusDiv = document.getElementById('themeStatus');
            statusDiv.innerHTML = '<p style="color: var(--text-light);">Processing font files...</p>';
            
            try {
                let regularFile = null;
                let processedCount = 0;
                
                // Find ONLY the Regular variant - discard all others to save storage
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    
                    // Skip non-font files
                    if (!file.name.match(/\.(woff2|woff|ttf|otf)$/i)) {
                        console.log('Skipping non-font file:', file.name);
                        continue;
                    }
                    
                    processedCount++;
                    
                    // Detect if this is the Regular variant
                    const fileName = file.name.toLowerCase();
                    const isRegular = (fileName.includes('regular') || fileName.includes('normal')) && 
                                     !fileName.includes('italic') && 
                                     !fileName.includes('oblique');
                    
                    // If no explicit "Regular" found, use first non-bold, non-italic file as fallback
                    const isFallbackRegular = !fileName.includes('bold') && 
                                             !fileName.includes('italic') && 
                                             !fileName.includes('black') && 
                                             !fileName.includes('heavy') && 
                                             !fileName.includes('light') && 
                                             !fileName.includes('thin') && 
                                             !fileName.includes('medium') &&
                                             !fileName.includes('semi') &&
                                             !fileName.includes('extra');
                    
                    if (isRegular || (isFallbackRegular && !regularFile)) {
                        // Validate size (max 2MB)
                        if (file.size > 2 * 1024 * 1024) {
                            console.warn(`${file.name} is too large (max 2MB), skipping.`);
                            continue;
                        }
                        
                        // Determine format
                        const format = file.name.toLowerCase().endsWith('.woff2') ? 'woff2' :
                                      file.name.toLowerCase().endsWith('.woff') ? 'woff' :
                                      file.name.toLowerCase().endsWith('.ttf') ? 'truetype' :
                                      file.name.toLowerCase().endsWith('.otf') ? 'opentype' : 'woff';
                        
                        // Read as base64
                        const base64 = await readFileAsBase64(file);
                        
                        regularFile = {
                            name: file.name,
                            format: format,
                            data: base64,
                            weight: '400',
                            style: 'normal'
                        };
                        
                        console.log(`✓ Found Regular variant: ${file.name}`);
                        break; // Stop after finding Regular
                    } else {
                        console.log(`Skipping non-Regular variant: ${file.name} (not needed, saves storage)`);
                    }
                }
                
                if (!regularFile) {
                    throw new Error('No Regular (normal weight) font file found. Please include a Regular or Normal weight variant in your font package.');
                }
                
                // Create font package with ONLY Regular variant
                const fontPackage = {
                    name: fontName,
                    family: fontFamily,
                    files: [regularFile] // ONLY ONE FILE - saves storage!
                };
                
                // Get existing custom fonts
                let customFonts = [];
                if (currentInstitutionTheme && currentInstitutionTheme.custom_fonts) {
                    try {
                        customFonts = typeof currentInstitutionTheme.custom_fonts === 'string' 
                            ? JSON.parse(currentInstitutionTheme.custom_fonts)
                            : currentInstitutionTheme.custom_fonts;
                    } catch (e) {
                        customFonts = [];
                    }
                }
                
                // Add new font
                customFonts.push(fontPackage);
                
                // Temporarily store (will be saved with theme)
                window.pendingCustomFonts = customFonts;
                
                // Display the font
                loadCustomFonts(customFonts);
                
                // Clear inputs
                nameInput.value = '';
                filesInput.value = '';
                
                const discardedCount = processedCount - 1;
                
                statusDiv.innerHTML = 
                    '<p style="color: var(--success); padding: 1rem; background: #d1fae5; border-radius: 0.5rem;"><span class="icon-with-text"><i data-lucide="check-circle" style="width:1.25em;height:1.25em;"></i> Font "' + escapeHtml(fontName) + '" uploaded!</span><br>' +
                    '<span style="font-size: 0.9rem; color: var(--text-light); margin-top: 0.5rem; display: block;">' +
                    'Stored: 1 file (Regular variant, ' + (regularFile.data.length / 1024).toFixed(1) + 'KB)<br>' +
                    (discardedCount > 0 ? 'Discarded: ' + discardedCount + ' file' + (discardedCount !== 1 ? 's' : '') + ' (Bold, Italic, etc. - not needed, saves storage)<br>' : '') +
                    'Click "Save Theme" to apply permanently.</span></p>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statusDiv });
                
            } catch (error) {
                console.error('Error uploading font:', error);
                statusDiv.innerHTML = 
                    '<p style="color: var(--error); padding: 1rem; background: #fee; border-radius: 0.5rem;"><span class="icon-with-text"><i data-lucide="x-circle" style="width:1.25em;height:1.25em;"></i> Error uploading font: ' + escapeHtml(error.message) + '</span></p>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statusDiv });
            }
        }
        
        // Read file as base64
        function readFileAsBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        // Remove custom font
        function removeCustomFont(index) {
            if (!confirm('Remove this custom font?')) return;
            
            let customFonts = window.pendingCustomFonts || [];
            customFonts.splice(index, 1);
            window.pendingCustomFonts = customFonts;
            
            loadCustomFonts(customFonts);
            
            document.getElementById('themeStatus').innerHTML = 
                '<p style="color: var(--text-light);">Font removed. Click "Save Theme" to apply changes.</p>';
        }
        
        // Handle logo upload for institution
        function handleLogoUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Validate file type
            if (!file.type.startsWith('image/')) {
                alert('Please upload an image file.');
                return;
            }
            
            // Validate file size (max 5MB)
            if (file.size > 5 * 1024 * 1024) {
                alert('Image must be less than 5MB.');
                return;
            }
            
            // Preview the image
            const reader = new FileReader();
            reader.onload = function(e) {
                const logoImg = document.getElementById('logoPreviewImage');
                const logoPlaceholder = document.getElementById('logoPlaceholder');
                
                if (logoImg && logoPlaceholder) {
                    logoImg.src = e.target.result;
                    logoImg.style.display = 'block';
                    logoPlaceholder.style.display = 'none';
                    
                    // Store base64 for saving
                    window.institutionLogoData = e.target.result;
                    
                    console.log('✓ Logo preview loaded');
                }
            };
            reader.onerror = function(error) {
                console.error('Error reading logo file:', error);
                alert('Error loading logo preview. Please try again.');
            };
            reader.readAsDataURL(file);
        }
        
        // --- HTML Color Codes–style picker: Hex/HSL conversion and panel ---
        function hexToRgb(hex) {
            const h = (hex || '').replace(/^#/, '');
            if (!/^[0-9A-Fa-f]{6}$/.test(h) && !/^[0-9A-Fa-f]{3}$/.test(h)) return { r: 0, g: 0, b: 0 };
            const expand = h.length === 3 ? h.split('').map(c => c + c).join('') : h;
            return {
                r: parseInt(expand.slice(0, 2), 16),
                g: parseInt(expand.slice(2, 4), 16),
                b: parseInt(expand.slice(4, 6), 16)
            };
        }
        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, Math.round(x))).toString(16).padStart(2, '0')).join('').toUpperCase();
        }
        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    default: h = ((r - g) / d + 4) / 6; break;
                }
            }
            return { h: Math.round(h * 360), s: Math.round(s * 100), l: Math.round(l * 100) };
        }
        function hslToRgb(h, s, l) {
            h /= 360; s /= 100; l /= 100;
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return { r: r * 255, g: g * 255, b: b * 255 };
        }
        function hue2rgb(p, q, t) {
            if (t < 0) t += 1; if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        }
        function hexToHsl(hex) {
            const rgb = hexToRgb(hex);
            return rgbToHsl(rgb.r, rgb.g, rgb.b);
        }
        function hslToHex(h, s, l) {
            const rgb = hslToRgb(h, s, l);
            return rgbToHex(rgb.r, rgb.g, rgb.b);
        }
        
        let themePickerState = { h: 0, s: 0, l: 50 };
        let themePickerTarget = { pickerId: null, textId: null };
        
        function updateThemePickerUI() {
            const panel = document.getElementById('themeColorPickerPanel');
            const marker2d = document.getElementById('themePicker2dMarker');
            const markerHue = document.getElementById('themePickerHueMarker');
            const wrap2d = document.getElementById('themePicker2dWrap');
            const hexInput = document.getElementById('themePickerHex');
            const rgbSpan = document.getElementById('themePickerRgb');
            const preview = document.getElementById('themePickerPreview');
            if (!panel || !marker2d || !markerHue || !wrap2d) return;
            const { h, s, l } = themePickerState;
            const hex = hslToHex(h, s, l);
            const rgb = hexToRgb(hex);
            panel.style.setProperty('--picker-hue-color', 'hsl(' + h + ', 100%, 50%)');
            marker2d.style.left = (s) + '%';
            marker2d.style.top = (100 - l) + '%';
            markerHue.style.left = (h / 360 * 100) + '%';
            if (hexInput) hexInput.value = hex;
            if (rgbSpan) rgbSpan.textContent = rgb.r + ', ' + rgb.g + ', ' + rgb.b;
            if (preview) preview.style.backgroundColor = hex;
        }
        
        function setThemePickerFromHSL(h, s, l) {
            themePickerState = { h: Math.round(h), s: Math.round(s), l: Math.round(l) };
            updateThemePickerUI();
        }
        
        function openThemeColorPicker(pickerId, textId, label) {
            const pickerEl = document.getElementById(pickerId);
            const textEl = document.getElementById(textId);
            const hex = (textEl && textEl.value.trim()) || (pickerEl && pickerEl.value) || '#1e3a5f';
            const normalized = normalizeHex(hex);
            themePickerTarget = { pickerId: pickerId, textId: textId };
            const hsl = hexToHsl(normalized);
            themePickerState = { h: hsl.h, s: hsl.s, l: hsl.l };
            const panel = document.getElementById('themeColorPickerPanel');
            const titleEl = document.getElementById('themeColorPickerTitle');
            if (titleEl) titleEl.textContent = label + ' — Color picker';
            if (panel) {
                panel.classList.add('open');
                updateThemePickerUI();
            }
            const wrap2d = document.getElementById('themePicker2dWrap');
            const hueWrap = document.getElementById('themePickerHueWrap');
            const hexInput = document.getElementById('themePickerHex');
            function on2d(ev) {
                const rect = wrap2d.getBoundingClientRect();
                const x = (ev.clientX - rect.left) / rect.width;
                const y = (ev.clientY - rect.top) / rect.height;
                const s = Math.max(0, Math.min(100, x * 100));
                const l = Math.max(0, Math.min(100, (1 - y) * 100));
                setThemePickerFromHSL(themePickerState.h, s, l);
            }
            function onHue(ev) {
                const rect = hueWrap.getBoundingClientRect();
                const x = (ev.clientX - rect.left) / rect.width;
                const h = Math.max(0, Math.min(360, x * 360));
                setThemePickerFromHSL(h, themePickerState.s, themePickerState.l);
            }
            function drag(ev) {
                ev.preventDefault();
                if (ev.target.closest('.picker-2d-wrap')) on2d(ev);
                else if (ev.target.closest('.picker-hue-wrap')) onHue(ev);
            }
            function up() {
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('mouseup', up);
            }
            if (wrap2d) {
                wrap2d.onmousedown = function(ev) { ev.preventDefault(); on2d(ev); document.addEventListener('mousemove', drag); document.addEventListener('mouseup', up); };
            }
            if (hueWrap) {
                hueWrap.onmousedown = function(ev) { ev.preventDefault(); onHue(ev); document.addEventListener('mousemove', drag); document.addEventListener('mouseup', up); };
            }
            if (hexInput) {
                hexInput.oninput = function() {
                    const val = hexInput.value.trim();
                    if (/^#[0-9A-Fa-f]{6}$/i.test(val) || /^[0-9A-Fa-f]{6}$/i.test(val)) {
                        const hex = val.startsWith('#') ? val : '#' + val;
                        const hsl = hexToHsl(hex);
                        setThemePickerFromHSL(hsl.h, hsl.s, hsl.l);
                    }
                };
            }
            document.getElementById('themePickerApply').onclick = function() {
                const hex = hslToHex(themePickerState.h, themePickerState.s, themePickerState.l);
                const picker = document.getElementById(themePickerTarget.pickerId);
                const text = document.getElementById(themePickerTarget.textId);
                if (picker) picker.value = hex;
                if (text) text.value = hex;
                closeThemeColorPicker();
            };
            window._themePickerEscape = function(e) {
                if (e.key === 'Escape') {
                    closeThemeColorPicker();
                    document.removeEventListener('keydown', window._themePickerEscape);
                }
            };
            document.addEventListener('keydown', window._themePickerEscape);
        }
        
        function closeThemeColorPicker() {
            const panel = document.getElementById('themeColorPickerPanel');
            if (panel) panel.classList.remove('open');
            document.removeEventListener('keydown', window._themePickerEscape);
        }
        
        // Normalize hex for display (# + 6 chars, uppercase)
        function normalizeHex(hex) {
            const h = (hex || '').replace(/^#/, '').trim();
            if (/^[0-9A-Fa-f]{6}$/.test(h)) return '#' + h.toUpperCase();
            if (/^[0-9A-Fa-f]{3}$/.test(h)) return '#' + h.split('').map(c => c + c).join('').toUpperCase();
            return hex || '#000000';
        }
        
        // Sync color picker with text input
        function syncColorInputs() {
            const pairs = [
                ['themePrimaryColor', 'themePrimaryText'],
                ['themeHeaderColor', 'themeHeaderText'],
                ['themeSecondaryColor', 'themeSecondaryText'],
                ['themeTextColor', 'themeTextText']
            ];
            
            pairs.forEach(([pickerId, textId]) => {
                const picker = document.getElementById(pickerId);
                const text = document.getElementById(textId);
                
                if (picker && text) {
                    picker.addEventListener('input', () => {
                        text.value = picker.value.toUpperCase();
                    });
                    
                    text.addEventListener('input', () => {
                        const val = text.value.trim();
                        if (/^#[0-9A-F]{6}$/i.test(val)) {
                            picker.value = val;
                        }
                    });
                }
            });
        }
        
        // Preview theme (temporary, doesn't save)
        function previewTheme() {
            const theme = {
                primary_color: document.getElementById('themePrimaryColor').value,
                header_bg_color: document.getElementById('themeHeaderColor').value,
                secondary_color: document.getElementById('themeSecondaryColor').value,
                text_primary: document.getElementById('themeTextColor').value,
                font_heading: document.getElementById('themeHeadingFont').value,
                font_body: document.getElementById('themeBodyFont').value
            };
            
            applyThemeToCSS(theme);
            
            // Apply fonts
            const root = document.documentElement;
            if (theme.font_heading) {
                root.style.setProperty('--heading-font', theme.font_heading);
            }
            if (theme.font_body) {
                root.style.setProperty('--body-font', theme.font_body);
            }
            
            // Preview logo if uploaded
            if (window.institutionLogoData) {
                const appLogo = document.getElementById('appLogo');
                if (appLogo) {
                    appLogo.style.backgroundColor = '#ffffff';
                    appLogo.innerHTML = `<img src="${window.institutionLogoData}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;">`;
                }
            }
            
            var statusEl = document.getElementById('themeStatus');
            statusEl.innerHTML = '<p style="color: var(--success); padding: 1rem; background: var(--bg-alt); border-radius: 0.5rem;"><span class="icon-with-text"><i data-lucide="eye" style="width:1.1em;height:1.1em;"></i> Preview applied! Click "Save Theme" to make permanent.</span></p>';
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statusEl });
        }
        
        // Save theme to database
        async function saveInstitutionTheme() {
            const targetInstitutionId = getThemeFormInstitutionId();
            if (!supabaseClient || !currentUser) {
                alert('Error: Not connected to database.');
                return;
            }
            if (!targetInstitutionId) {
                alert(isSuperAdmin() ? 'Please select an institution first.' : 'No institution assigned.');
                return;
            }
            
            const statusDiv = document.getElementById('themeStatus');
            statusDiv.innerHTML = '<p style="color: var(--text-light);">Saving theme...</p>';
            
            console.log('=== SAVING THEME ===');
            console.log('Target institution:', targetInstitutionId);
            console.log('User tier:', userTier);
            
            try {
                const themeData = {
                    primary_color: document.getElementById('themePrimaryColor').value,
                    header_bg_color: document.getElementById('themeHeaderColor').value,
                    secondary_color: document.getElementById('themeSecondaryColor').value,
                    text_primary: document.getElementById('themeTextColor').value,
                    text_secondary: document.getElementById('themeTextColor').value,
                    font_heading: document.getElementById('themeHeadingFont').value,
                    font_body: document.getElementById('themeBodyFont').value,
                    updated_at: new Date().toISOString()
                };
                
                if (window.institutionLogoData) {
                    themeData.logo_url = window.institutionLogoData;
                    console.log('✓ Logo data prepared for save');
                    console.log('  Logo size:', (themeData.logo_url.length / 1024).toFixed(1) + 'KB');
                } else {
                    console.log('ℹ️ No new logo data to save (keeping existing if any)');
                }
                
                if (window.pendingCustomFonts && window.pendingCustomFonts.length > 0) {
                    themeData.custom_fonts = window.pendingCustomFonts;
                    console.log('✓ Custom fonts prepared for save:', window.pendingCustomFonts.length, 'font(s)');
                    console.log('  Font data size:', JSON.stringify(window.pendingCustomFonts).length, 'characters');
                } else {
                    console.log('ℹ️ No custom fonts to save (keeping existing if any)');
                }
                
                console.log('Saving theme to institution_id:', targetInstitutionId);
                
                const { data, error } = await supabaseClient
                    .from('institution_themes')
                    .upsert({
                        institution_id: targetInstitutionId,
                        ...themeData
                    }, {
                        onConflict: 'institution_id'
                    })
                    .select();
                
                if (error) {
                    console.error('❌ Save failed:', error);
                    throw error;
                }
                
                if (!data || data.length === 0) {
                    console.error('❌ No data returned from upsert');
                    throw new Error('No data returned from save operation');
                }
                
                const savedTheme = data[0];
                console.log('✓ Theme saved to database');
                console.log('  Saved to institution_id:', savedTheme.institution_id);
                console.log('  Has logo:', !!savedTheme.logo_url);
                console.log('  Has custom fonts:', !!savedTheme.custom_fonts);
                
                const isForCurrentInstitution = currentUser.institution_id && savedTheme.institution_id === currentUser.institution_id;
                if (isForCurrentInstitution) {
                    currentInstitutionTheme = savedTheme;
                    currentUser.theme = savedTheme;
                    console.log('✓ Global theme variable updated');
                    applyThemeToCSS(savedTheme);
                    const root = document.documentElement;
                    if (savedTheme.font_heading) {
                        root.style.setProperty('--heading-font', savedTheme.font_heading);
                        console.log('✓ Applied heading font:', savedTheme.font_heading);
                    }
                    if (savedTheme.font_body) {
                        root.style.setProperty('--body-font', savedTheme.font_body);
                        console.log('✓ Applied body font:', savedTheme.font_body);
                    }
                    if (savedTheme.custom_fonts) {
                        console.log('Loading custom fonts from saved data...');
                        loadCustomFontsOnStartup(savedTheme.custom_fonts);
                    }
                    if (window.institutionLogoData) {
                        console.log('Updating logo display...');
                        await updateInstitutionLogo();
                    }
                } else {
                    console.log('Theme saved for another institution; not applying to current session.');
                }
                
                statusDiv.innerHTML = 
                    '<p style="color: var(--success); padding: 1rem; background: #d1fae5; border-radius: 0.5rem; border-left: 4px solid var(--success);"><span class="icon-with-text"><i data-lucide="check-circle" style="width:1.25em;height:1.25em;"></i> Theme saved successfully! ' + (isForCurrentInstitution ? 'All users in your institution will see these colors, fonts, and logo on next login.' : 'Users in that institution will see this theme on next login.') + '</span></p>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statusDiv });
                
                console.log('=== THEME SAVE COMPLETE ===');
                
                // Clear pending fonts (they're now saved)
                window.pendingCustomFonts = null;
                
            } catch (error) {
                console.error('Error saving theme:', error);
                statusDiv.innerHTML = 
                    '<p style="color: var(--error); padding: 1rem; background: #fee; border-radius: 0.5rem; border-left: 4px solid var(--error);"><span class="icon-with-text"><i data-lucide="x-circle" style="width:1.25em;height:1.25em;"></i> Error saving theme: ' + escapeHtml(error.message) + '</span></p>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statusDiv });
            }
        }
        
        // Create new theme: reset form to defaults; Super Admin must then select an institution and Save
        function createNewTheme() {
            setThemeFormToDefaults();
            window.pendingCustomFonts = null;
            window.institutionLogoData = null;
            document.getElementById('institutionLogoUpload').value = '';
            document.getElementById('customFontName').value = '';
            document.getElementById('customFontFiles').value = '';
            const logoImg = document.getElementById('logoPreviewImage');
            const logoPlaceholder = document.getElementById('logoPlaceholder');
            if (logoImg) { logoImg.src = ''; logoImg.style.display = 'none'; }
            if (logoPlaceholder) logoPlaceholder.style.display = 'block';
            const statusDiv = document.getElementById('themeStatus');
            if (isSuperAdmin()) {
                const sel = document.getElementById('themeInstitutionSelect');
                if (sel) sel.value = '';
                if (statusDiv) statusDiv.innerHTML = 
                    '<p style="color: var(--primary); padding: 1rem; background: var(--bg-alt); border-radius: 0.5rem; border-left: 4px solid var(--primary);">Select an institution above, customize colors and fonts, then click <strong>Save Theme</strong> to create a new theme for that institution.</p>';
            } else {
                if (statusDiv) statusDiv.innerHTML = 
                    '<p style="color: var(--text-light); padding: 1rem; background: var(--bg-alt); border-radius: 0.5rem;">Form reset to default palette. Edit as needed and click <strong>Save Theme</strong> to update your institution\'s theme.</p>';
            }
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statusDiv });
        }
        
        // Reset theme form to current saved values
        function resetThemeForm() {
            loadCurrentThemeToForm(); // This will reload logo from database
            window.pendingCustomFonts = null;
            document.getElementById('institutionLogoUpload').value = '';
            document.getElementById('customFontName').value = '';
            document.getElementById('customFontFiles').value = '';
            document.getElementById('themeStatus').innerHTML = 
                '<p style="color: var(--text-light);">Reset to saved theme.</p>';
        }
        
        // Load department instructors (for admins)
        async function loadDepartmentInstructors() {
            if (!supabaseClient || !isAdmin()) return;
            
            if (!currentUser.department_id) {
                var instContainer = document.getElementById('departmentInstructorsContainer');
                instContainer.innerHTML = '<p style="color: var(--warning);"><span class="icon-with-text"><i data-lucide="alert-triangle" style="width:1.1em;height:1.1em;"></i> You are not assigned to a department.</span></p>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: instContainer });
                return;
            }
            
            try {
                const { data: instructors, error } = await supabaseClient
                    .from('user_profiles')
                    .select(`
                        id,
                        email,
                        full_name,
                        account_tier,
                        is_research_partner,
                        created_at,
                        departments (
                            name
                        )
                    `)
                    .eq('department_id', currentUser.department_id)
                    .eq('account_tier', 'instructor')
                    .order('email', { ascending: true });
                
                if (error) throw error;
                
                // Load course info for each instructor (for semester filtering)
                const instructorsWithCourses = await Promise.all(instructors.map(async (instructor) => {
                    const { data: courses } = await supabaseClient
                        .from('courses')
                        .select('id, name, semester, year')
                        .eq('instructor_id', instructor.id);
                    
                    return {
                        ...instructor,
                        courses: courses || []
                    };
                }));
                
                // Cache the full data
                cachedDepartmentInstructors = instructorsWithCourses;
                
                // Display all instructors initially
                displayDepartmentInstructors(instructorsWithCourses);
                
            } catch (error) {
                console.error('Error loading instructors:', error);
                document.getElementById('departmentInstructorsContainer').innerHTML = 
                    '<p style="color: var(--error);">Error loading instructors. Please try again.</p>';
            }
        }
        
        // Display department instructors (used by load and filter)
        function displayDepartmentInstructors(instructors) {
            const container = document.getElementById('departmentInstructorsContainer');
            
            if (!instructors || instructors.length === 0) {
                container.innerHTML = '<p style="color: var(--text-light);">No instructors found matching the filter.</p>';
                return;
            }
            
            // Build instructors list HTML
            let html = `
                <div style="background: var(--bg); border: 1px solid var(--border); border-radius: 0.5rem; overflow: hidden;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead style="background: var(--bg-alt);">
                            <tr>
                                <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Instructor</th>
                                <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Email</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Courses</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Research Partner</th>
                                <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            instructors.forEach(instructor => {
                const researchBadge = instructor.is_research_partner
                    ? '<span style="color: var(--success); font-size: 1.25rem;"><i data-lucide="check" style="width:1.25rem;height:1.25rem;"></i></span>'
                    : '<span style="color: var(--text-light);">—</span>';
                
                const courseCount = instructor.courses?.length || 0;
                
                html += `
                    <tr style="border-bottom: 1px solid var(--border);">
                        <td style="padding: 0.75rem;">${instructor.full_name || '—'}</td>
                        <td style="padding: 0.75rem; color: var(--text-light);">${instructor.email}</td>
                        <td style="padding: 0.75rem; text-align: center;">${courseCount}</td>
                        <td style="padding: 0.75rem; text-align: center;">${researchBadge}</td>
                        <td style="padding: 0.75rem;">
                            <button onclick="viewInstructorCourses('${instructor.id}', '${instructor.email}')" 
                                    style="padding: 0.25rem 0.75rem; font-size: 0.875rem; margin-right: 0.5rem;"><span class="icon-with-text"><i data-lucide="book-open" style="width:1em;height:1em;"></i> View Courses</span></button>
                            <button onclick="viewInstructorDetails('${instructor.id}', '${instructor.email}')" 
                                    style="padding: 0.25rem 0.75rem; font-size: 0.875rem;"><span class="icon-with-text"><i data-lucide="user" style="width:1em;height:1em;"></i> Details</span></button>
                        </td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
                <p style="margin-top: 1rem; color: var(--text-light); font-size: 0.875rem;">
                    Showing ${instructors.length} instructor${instructors.length !== 1 ? 's' : ''}
                </p>
            `;
            
            container.innerHTML = html;
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: container });
            console.log('✓ Displayed', instructors.length, 'instructors');
        }
        
        // Filter instructors by semester
        function filterBySemester() {
            const filter = document.getElementById('semesterFilter').value;
            console.log('🔍 Filtering by semester:', filter);
            
            if (filter === 'all') {
                // Show all instructors
                displayDepartmentInstructors(cachedDepartmentInstructors);
                return;
            }
            
            // Filter instructors who have courses in the selected semester
            const filtered = cachedDepartmentInstructors.filter(instructor => {
                return instructor.courses.some(course => {
                    const courseSemester = course.semester && course.year 
                        ? `${course.semester} ${course.year}`
                        : '';
                    return courseSemester === filter;
                });
            });
            
            displayDepartmentInstructors(filtered);
        }
        
        // Enhanced analytics data cache
        let analyticsData = {
            evaluations: [],
            instructors: [],
            courses: [],
            filtered: []
        };
        
        // User-customizable dashboards (add, remove, rename, hide, reorder)
        const DEFAULT_DASHBOARD_CONFIG = [
            { id: 'overview', name: 'Overview', type: 'builtin', visible: true },
            { id: 'comparisons', name: 'Comparisons', type: 'builtin', visible: true },
            { id: 'evaluations', name: 'Evaluations', type: 'builtin', visible: true },
            { id: 'export', name: 'Data Export', type: 'builtin', visible: false }
        ];
        // Instructor: hide Comparisons and Data Export tabs (Overview and Evaluations only - Export CSV is in Evaluations tab)
        const DEFAULT_DASHBOARD_CONFIG_INSTRUCTOR = [
            { id: 'overview', name: 'Overview', type: 'builtin', visible: true },
            { id: 'comparisons', name: 'Comparisons', type: 'builtin', visible: false },
            { id: 'evaluations', name: 'Evaluations', type: 'builtin', visible: true },
            { id: 'export', name: 'Data Export', type: 'builtin', visible: false }
        ];
        const BUILTIN_PANEL_IDS = { overview: 'analyticsOverviewTab', comparisons: 'analyticsComparisonsTab', evaluations: 'analyticsEvaluationsTab', export: 'analyticsExportTab' };
        const DEFAULT_OVERVIEW_WIDGETS = [
            { id: 'kpi-row', label: 'KPI cards', visible: true, order: 0 },
            { id: 'chart-outcome', label: 'Outcome attainment by outcome', visible: true, order: 1 },
            { id: 'chart-modality', label: 'Modality comparison', visible: true, order: 2 },
            { id: 'chart-course', label: 'Course comparisons', visible: true, order: 3 },
            { id: 'chart-section', label: 'Section variability map', visible: true, order: 4 },
            { id: 'chart-accreditation', label: 'Accreditation-ready summary', visible: true, order: 5 },
            { id: 'chart-modality-report', label: 'Modality report', visible: true, order: 6 },
            { id: 'chart-norming', label: 'Norming summary', visible: true, order: 7 }
        ];
        // Admin/Super Admin: fewer overview cards by default (key metrics only)
        const DEFAULT_OVERVIEW_WIDGETS_ADMIN = [
            { id: 'kpi-row', label: 'KPI cards', visible: true, order: 0 },
            { id: 'chart-outcome', label: 'Outcome attainment by outcome', visible: true, order: 1 },
            { id: 'chart-course', label: 'Course comparisons', visible: true, order: 2 },
            { id: 'chart-accreditation', label: 'Accreditation-ready summary', visible: true, order: 3 }
        ];
        const DEFAULT_TAB_WIDGETS = {
            comparisons: [
                { id: 'card-course', label: 'By course', visible: true, order: 0 },
                { id: 'card-instructor', label: 'By instructor', visible: true, order: 1 }
            ],
            evaluations: [
                { id: 'card-table', label: 'Evaluations table', visible: true, order: 0 }
            ],
            export: [
                { id: 'export-unified', label: 'Data export', visible: true, order: 0 }
            ]
        };
        
        function getDashboardConfig() {
            // One-time migration: apply tier-specific defaults to existing users
            const migratedKey = 'dashboard_config_migrated_v2';
            if (typeof getUserItem === 'function' && getUserItem(migratedKey) !== '1') {
                if (typeof setUserItem === 'function') {
                    setUserItem(migratedKey, '1');
                    const isInstructorOnly = (typeof userTier !== 'undefined' && userTier === 'instructor') || (typeof userTier !== 'undefined' && userTier === 'demo' && typeof demoViewAs !== 'undefined' && demoViewAs === 'instructor');
                    const defaultConfig = JSON.parse(JSON.stringify(isInstructorOnly ? DEFAULT_DASHBOARD_CONFIG_INSTRUCTOR : DEFAULT_DASHBOARD_CONFIG));
                    setUserItem('dashboard_config', JSON.stringify(defaultConfig));
                    return defaultConfig;
                }
            }
            try {
                const raw = typeof getUserItem === 'function' ? getUserItem('dashboard_config') : null;
                if (raw) {
                    const parsed = JSON.parse(raw);
                    if (Array.isArray(parsed) && parsed.length) {
                        parsed.forEach(function(d, i) {
                            if (d.visible === undefined) d.visible = true;
                            if (d.type === 'custom' && d.visible === undefined) d.visible = true;
                            if (d.id === 'evaluations' && d.name === 'All Evaluations') d.name = 'Evaluations';
                        });
                        return parsed;
                    }
                }
            } catch (e) {}
            // Tier-specific defaults: instructor sees Overview, Evaluations, Data Export only; Admin/Super Admin see all tabs
            const isInstructorOnly = (typeof userTier !== 'undefined' && userTier === 'instructor') || (typeof userTier !== 'undefined' && userTier === 'demo' && typeof demoViewAs !== 'undefined' && demoViewAs === 'instructor');
            return JSON.parse(JSON.stringify(isInstructorOnly ? DEFAULT_DASHBOARD_CONFIG_INSTRUCTOR : DEFAULT_DASHBOARD_CONFIG));
        }
        function setDashboardConfig(config) {
            if (typeof setUserItem !== 'function') return;
            setUserItem('dashboard_config', JSON.stringify(config));
        }
        function getPanelIdForDashboard(dashboardId) {
            if (BUILTIN_PANEL_IDS[dashboardId]) return BUILTIN_PANEL_IDS[dashboardId];
            return 'analyticsPanel_' + dashboardId;
        }
        
        function renderDashboardTabs() {
            const config = getDashboardConfig();
            const visibleConfig = config.filter(function(d) { return d.visible !== false; });
            const tablist = document.getElementById('analyticsTablist');
            const wrapper = document.getElementById('analyticsPanelsWrapper');
            const customContainer = document.getElementById('analyticsCustomPanelsContainer');
            if (!tablist || !wrapper || !customContainer) return;
            
            tablist.innerHTML = '';
            tablist.setAttribute('aria-label', 'Analytics dashboards');
            
            visibleConfig.forEach(function(d, index) {
                const tabId = 'tab_' + d.id;
                const panelId = getPanelIdForDashboard(d.id);
                const isFirst = index === 0;
                const btn = document.createElement('button');
                btn.id = tabId;
                btn.setAttribute('role', 'tab');
                btn.setAttribute('aria-selected', isFirst ? 'true' : 'false');
                btn.setAttribute('aria-controls', panelId);
                btn.setAttribute('tabindex', isFirst ? 0 : -1);
                btn.className = 'analytics-tab' + (isFirst ? ' analytics-tab-active' : '');
                btn.textContent = d.name;
                btn.onclick = function() { switchAnalyticsTab(d.id); };
                tablist.appendChild(btn);
                
                if (d.type === 'custom') {
                    let panel = document.getElementById(panelId);
                    if (!panel) {
                        panel = document.createElement('div');
                        panel.id = panelId;
                        panel.setAttribute('role', 'tabpanel');
                        panel.setAttribute('aria-labelledby', tabId);
                        panel.setAttribute('data-dashboard-id', d.id);
                        panel.style.display = 'none';
                        panel.innerHTML = '<div class="chart-card"><div class="chart-title">' + escapeHtml(d.name) + '</div><div class="chart-subtitle">Custom dashboard. Add widgets from Overview or use other tabs for data.</div><div class="chart-body" style="min-height:120px;"><p style="color: var(--text-light); padding: 1rem;">This dashboard is empty. Use the Overview tab for key metrics and charts.</p></div></div>';
                        customContainer.appendChild(panel);
                    }
                }
            });
            var customIds = config.filter(d => d.type === 'custom').map(d => d.id);
            customContainer.querySelectorAll('[id^="analyticsPanel_"]').forEach(panel => {
                var did = panel.id.replace('analyticsPanel_', '');
                if (did && !customIds.includes(did)) panel.remove();
            });
            
            var firstVisibleId = visibleConfig.length ? visibleConfig[0].id : null;
            wrapper.querySelectorAll('[data-dashboard-id]').forEach(function(el) {
                var did = el.getAttribute('data-dashboard-id');
                var inConfig = config.some(function(d) { return d.id === did; });
                var isVisible = config.find(function(d) { return d.id === did; });
                isVisible = isVisible && isVisible.visible !== false;
                el.style.display = inConfig && isVisible ? (did === firstVisibleId ? 'block' : 'none') : 'none';
            });
            customContainer.querySelectorAll('[id^="analyticsPanel_"]').forEach(function(panel) {
                var did = panel.id.replace('analyticsPanel_', '');
                var d = config.find(function(c) { return c.id === did; });
                var show = d && d.visible !== false && did === firstVisibleId;
                panel.style.display = show ? 'block' : 'none';
            });
        }
        
        var currentAnalyticsTabId = 'overview';
        function switchAnalyticsTab(dashboardId) {
            currentAnalyticsTabId = dashboardId;
            const config = getDashboardConfig();
            const panelId = getPanelIdForDashboard(dashboardId);
            const panel = document.getElementById(panelId);
            if (!panel) return;
            
            const wrapper = document.getElementById('analyticsPanelsWrapper');
            if (wrapper) {
                wrapper.querySelectorAll('[data-dashboard-id]').forEach(el => { el.style.display = 'none'; });
                const customContainer = document.getElementById('analyticsCustomPanelsContainer');
                if (customContainer) customContainer.querySelectorAll('[id^="analyticsPanel_"]').forEach(el => { el.style.display = 'none'; });
            }
            panel.style.display = 'block';
            
            config.forEach((d, i) => {
                const tab = document.getElementById('tab_' + d.id);
                if (tab) {
                    const selected = d.id === dashboardId;
                    tab.setAttribute('aria-selected', selected ? 'true' : 'false');
                    tab.setAttribute('tabindex', selected ? 0 : -1);
                    tab.classList.toggle('analytics-tab-active', selected);
                    if (selected) tab.focus({ preventScroll: true });
                }
            });
            
            if (dashboardId === 'overview') {
                if (typeof isSuperAdmin === 'function' && isSuperAdmin() && typeof loadFilteredCoursesForSuperAdmin === 'function') loadFilteredCoursesForSuperAdmin();
                else if (typeof isAdmin === 'function' && isAdmin() && typeof loadFilteredCoursesForAdmin === 'function') loadFilteredCoursesForAdmin();
            }
            if (dashboardId === 'export' && typeof applyExportTabWidgets === 'function') applyExportTabWidgets();
        }
        
        function openCustomizeDashboardsModal() {
            const modal = document.getElementById('customizeDashboardsModal');
            const list = document.getElementById('customizeDashboardsList');
            if (!modal || !list) return;
            const config = getDashboardConfig();
            list.innerHTML = config.map(function(d, idx) {
                var isCustom = d.type === 'custom';
                var safeId = String(d.id).replace(/'/g, "\\'");
                var visible = d.visible !== false;
                return '<li style="display: flex; align-items: center; gap: 0.35rem; padding: 0.5rem 0; border-bottom: 1px solid var(--border); flex-wrap: wrap;">' +
                    '<span style="flex: 1; min-width: 6rem;">' + escapeHtml(d.name) + (visible ? '' : ' <span style="font-size: 0.7rem; color: var(--text-light);">(hidden)</span>') + '</span>' +
                    '<button type="button" class="btn-secondary" style="padding: 0.2rem 0.4rem; font-size: 0.75rem;" onclick="renameDashboard(\'' + safeId + '\')">Rename</button>' +
                    '<button type="button" class="btn-secondary" style="padding: 0.2rem 0.4rem; font-size: 0.75rem;" onclick="toggleDashboardVisible(\'' + safeId + '\')">' + (visible ? 'Hide' : 'Show') + '</button>' +
                    '<button type="button" class="btn-secondary" style="padding: 0.2rem 0.35rem; font-size: 0.75rem;" onclick="moveDashboard(\'' + safeId + '\', \'up\')" title="Move left">↑</button>' +
                    '<button type="button" class="btn-secondary" style="padding: 0.2rem 0.35rem; font-size: 0.75rem;" onclick="moveDashboard(\'' + safeId + '\', \'down\')" title="Move right">↓</button>' +
                    (['overview', 'comparisons', 'evaluations', 'export'].indexOf(d.id) >= 0 ? ' <button type="button" class="btn-secondary" style="padding: 0.2rem 0.4rem; font-size: 0.75rem;" onclick="openEditCardsModal(\'' + safeId + '\')">Edit cards</button>' : '') +
                    (isCustom ? '<button type="button" class="btn-secondary" style="padding: 0.25rem 0.5rem; font-size: 0.8rem; color: var(--error);" onclick="removeDashboard(\'' + safeId + '\')">Remove</button>' : '') +
                    '</li>';
            }).join('');
            modal.style.display = 'flex';
        }
        function openEditCardsModal(tabId) {
            tabId = tabId || 'overview';
            editCardsModalTabId = tabId;
            var m = document.getElementById('editCardsModal');
            if (!m) return;
            var list = document.getElementById('editCardsWidgetList');
            var titleEl = document.getElementById('editCardsTitle');
            if (!list) return;
            if (typeof ensureTabWidgets === 'function') ensureTabWidgets(tabId);
            var widgets = getTabWidgets(tabId);
            var tabNames = { overview: 'Overview', comparisons: 'Comparisons', evaluations: 'Evaluations', export: 'Data Export' };
            if (titleEl) titleEl.textContent = 'Edit ' + (tabNames[tabId] || tabId) + ' cards';
            var safeTabId = String(tabId).replace(/'/g, "\\'");
            list.innerHTML = widgets.map(function(w) {
                var safeId = String(w.id).replace(/'/g, "\\'");
                var isCustom = w.custom === true || String(w.id).indexOf('custom_') === 0;
                var deleteBtn = isCustom ? '<button type="button" class="btn-secondary" style="padding: 0.2rem 0.4rem; font-size: 0.75rem; color: var(--error);" onclick="deleteTabWidget(\'' + safeTabId + '\', \'' + safeId + '\')">Delete</button>' : '';
                return '<li style="display: flex; align-items: center; gap: 0.35rem; padding: 0.4rem 0; border-bottom: 1px solid var(--border); flex-wrap: wrap;">' +
                    '<span style="flex: 1; min-width: 8rem;">' + escapeHtml(w.label) + (w.visible !== false ? '' : ' <span style="font-size: 0.7rem; color: var(--text-light);">(removed)</span>') + '</span>' +
                    '<button type="button" class="btn-secondary" style="padding: 0.2rem 0.4rem; font-size: 0.75rem;" onclick="toggleTabWidgetVisible(\'' + safeTabId + '\', \'' + safeId + '\')">' + (w.visible !== false ? 'Remove' : 'Add') + '</button>' +
                    '<button type="button" class="btn-secondary" style="padding: 0.2rem 0.35rem; font-size: 0.75rem;" onclick="moveTabWidget(\'' + safeTabId + '\', \'' + safeId + '\', \'up\')">↑</button>' +
                    '<button type="button" class="btn-secondary" style="padding: 0.2rem 0.35rem; font-size: 0.75rem;" onclick="moveTabWidget(\'' + safeTabId + '\', \'' + safeId + '\', \'down\')">↓</button>' +
                    deleteBtn + '</li>';
            }).join('');
            var addBtn = document.getElementById('editCardsAddNewSection');
            if (addBtn) { addBtn.onclick = function() { addNewSection(editCardsModalTabId); }; addBtn.style.display = ''; }
            m.style.display = 'flex';
        }
        function closeEditCardsModal() {
            var m = document.getElementById('editCardsModal');
            if (m) m.style.display = 'none';
        }
        function closeCustomizeDashboardsModal() {
            const modal = document.getElementById('customizeDashboardsModal');
            if (modal) modal.style.display = 'none';
        }
        function applyExportTabWidgets() {
            var container = document.getElementById('analyticsExportTab');
            if (!container) return;
            var widgets = (typeof getTabWidgets === 'function' ? getTabWidgets('export') : []).filter(function(w) { return w.visible !== false; }).sort(function(a, b) { return (a.order || 0) - (b.order || 0); });
            if (!widgets.length) widgets = (DEFAULT_TAB_WIDGETS.export || []).filter(function(w) { return w.visible !== false; }).sort(function(a, b) { return a.order - b.order; });
            var orderedIds = widgets.map(function(w) { return w.id; });
            var cards = container.querySelectorAll('[data-widget-id]');
            cards.forEach(function(card) {
                var id = card.getAttribute('data-widget-id');
                if (orderedIds.indexOf(id) >= 0) { card.style.display = ''; } else { card.style.display = 'none'; }
            });
            widgets.forEach(function(w) {
                var el = container.querySelector('[data-widget-id="' + w.id + '"]');
                if (!el && (w.custom || String(w.id).indexOf('custom_') === 0)) {
                    el = document.createElement('div');
                    el.className = 'card';
                    el.setAttribute('data-widget-id', w.id);
                    el.style.marginTop = '1.25rem';
                    el.style.marginBottom = '0';
                    el.innerHTML = '<div class="card-header">' + (typeof escapeHtml === 'function' ? escapeHtml(w.label || 'Custom section') : (w.label || 'Custom section')) + '</div><div style="padding:1rem;color:var(--text-light);font-size:0.9rem;">Custom section. Use Edit cards to remove or reorder.</div>';
                }
                if (el) container.appendChild(el);
            });
        }
        function addDashboard() {
            const name = prompt('Name for the new dashboard:', 'My dashboard');
            if (name == null || !name.trim()) return;
            const config = getDashboardConfig();
            const id = 'custom_' + Date.now();
            config.push({ id: id, name: name.trim(), type: 'custom', visible: true });
            setDashboardConfig(config);
            renderDashboardTabs();
            switchAnalyticsTab(id);
            openCustomizeDashboardsModal();
            if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Dashboard added.');
        }
        function removeDashboard(dashboardId) {
            const config = getDashboardConfig();
            const d = config.find(c => c.id === dashboardId);
            if (!d || d.type !== 'custom') return;
            if (!confirm('Remove the dashboard "' + d.name + '"?')) return;
            const next = config.filter(c => c.id !== dashboardId);
            setDashboardConfig(next);
            renderDashboardTabs();
            const visible = next.filter(function(d) { return d.visible !== false; });
            if (visible.length && typeof switchAnalyticsTab === 'function') switchAnalyticsTab(visible[0].id);
            openCustomizeDashboardsModal();
            if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Dashboard removed.');
        }
        function renameDashboard(dashboardId) {
            const config = getDashboardConfig();
            const d = config.find(c => c.id === dashboardId);
            if (!d) return;
            const name = prompt('New name:', d.name);
            if (name == null || !name.trim()) return;
            d.name = name.trim();
            setDashboardConfig(config);
            renderDashboardTabs();
            openCustomizeDashboardsModal();
            if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Dashboard renamed.');
        }
        function toggleDashboardVisible(dashboardId) {
            var config = getDashboardConfig();
            var d = config.find(function(c) { return c.id === dashboardId; });
            if (!d) return;
            d.visible = !d.visible;
            setDashboardConfig(config);
            renderDashboardTabs();
            var visible = config.filter(function(x) { return x.visible !== false; });
            if (visible.length && typeof switchAnalyticsTab === 'function') switchAnalyticsTab(visible[0].id);
            openCustomizeDashboardsModal();
            if (typeof showAnalyticsToast === 'function') showAnalyticsToast(d.visible ? 'Tab shown.' : 'Tab hidden. Re-add from Customize.');
        }
        function moveDashboard(dashboardId, direction) {
            var config = getDashboardConfig();
            var idx = config.findIndex(function(c) { return c.id === dashboardId; });
            if (idx < 0) return;
            var next = idx + (direction === 'up' ? -1 : 1);
            if (next < 0 || next >= config.length) return;
            var t = config[idx]; config[idx] = config[next]; config[next] = t;
            setDashboardConfig(config);
            renderDashboardTabs();
            openCustomizeDashboardsModal();
            if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Order updated.');
        }
        function getTabWidgets(dashboardId) {
            var config = getDashboardConfig();
            var d = config.find(function(x) { return x.id === dashboardId; });
            if (dashboardId === 'overview') {
                if (d && d.widgets && d.widgets.length) return d.widgets.slice();
                var isAdminView = (typeof userTier !== 'undefined' && userTier === 'demo' && typeof demoViewAs !== 'undefined' && demoViewAs === 'admin') || (typeof isAdmin === 'function' && isAdmin() && typeof currentUser !== 'undefined' && currentUser && currentUser.department_id) || (typeof isSuperAdmin === 'function' && isSuperAdmin());
                return JSON.parse(JSON.stringify(isAdminView ? DEFAULT_OVERVIEW_WIDGETS_ADMIN : DEFAULT_OVERVIEW_WIDGETS));
            }
            if (d && d.widgets && d.widgets.length) return d.widgets.slice();
            var def = DEFAULT_TAB_WIDGETS[dashboardId];
            return def ? JSON.parse(JSON.stringify(def)) : [];
        }
        function getOverviewWidgets() { return getTabWidgets('overview'); }
        function ensureTabWidgets(dashboardId) {
            var config = getDashboardConfig();
            var d = config.find(function(x) { return x.id === dashboardId; });
            var def = dashboardId === 'overview' ? getTabWidgets('overview') : (DEFAULT_TAB_WIDGETS[dashboardId] ? JSON.parse(JSON.stringify(DEFAULT_TAB_WIDGETS[dashboardId])) : []);
            if (!def.length) return;
            if (!d) { config.push({ id: dashboardId, name: dashboardId, type: 'builtin', visible: true, widgets: JSON.parse(JSON.stringify(def)) }); setDashboardConfig(config); return; }
            if (!d.widgets || !d.widgets.length) { d.widgets = JSON.parse(JSON.stringify(def)); setDashboardConfig(config); }
        }
        function ensureOverviewWidgets() { ensureTabWidgets('overview'); }
        function setTabWidgets(dashboardId, widgets) {
            var config = getDashboardConfig();
            var d = config.find(function(x) { return x.id === dashboardId; });
            if (d) d.widgets = widgets;
            else config.push({ id: dashboardId, name: dashboardId, type: 'builtin', visible: true, widgets: widgets });
            setDashboardConfig(config);
            if (dashboardId === 'overview' && typeof renderOverviewTab === 'function') renderOverviewTab();
            if (dashboardId === 'comparisons' && typeof renderComparisonsTab === 'function') renderComparisonsTab();
            if (dashboardId === 'evaluations' && typeof renderEvaluationsTab === 'function') renderEvaluationsTab();
            if (dashboardId === 'export' && typeof applyExportTabWidgets === 'function') applyExportTabWidgets();
            var editModal = document.getElementById('editCardsModal');
            if (editModal && editModal.style.display === 'flex') openEditCardsModal(editCardsModalTabId);
        }
        var editCardsModalTabId = 'overview';
        function setOverviewWidgets(widgets) { setTabWidgets('overview', widgets); }
        function toggleTabWidgetVisible(dashboardId, widgetId) {
            var widgets = getTabWidgets(dashboardId);
            var w = widgets.find(function(x) { return x.id === widgetId; });
            if (!w) return;
            w.visible = !w.visible;
            setTabWidgets(dashboardId, widgets);
            if (typeof showAnalyticsToast === 'function') showAnalyticsToast(w.visible ? 'Card shown.' : 'Card hidden. Re-add from Customize.');
        }
        function moveTabWidget(dashboardId, widgetId, direction) {
            var widgets = getTabWidgets(dashboardId);
            var idx = widgets.findIndex(function(x) { return x.id === widgetId; });
            if (idx < 0) return;
            var next = idx + (direction === 'up' ? -1 : 1);
            if (next < 0 || next >= widgets.length) return;
            var t = widgets[idx]; widgets[idx] = widgets[next]; widgets[next] = t;
            for (var i = 0; i < widgets.length; i++) widgets[i].order = i;
            setTabWidgets(dashboardId, widgets);
            if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Order updated.');
        }
        function toggleOverviewWidgetVisible(widgetId) { toggleTabWidgetVisible('overview', widgetId); }
        function moveOverviewWidget(widgetId, direction) { moveTabWidget('overview', widgetId, direction); }
        function addNewSection(tabId) {
            var name = prompt('Name for the new section:', 'My section');
            if (name == null || !name.trim()) return;
            var dataQuery = prompt('What data to show? (e.g. by course, by instructor, by modality, by student). Leave blank for a searchable list.', '');
            if (dataQuery === null) return;
            var widgets = getTabWidgets(tabId);
            var newWidget = { id: 'custom_' + Date.now(), label: name.trim(), visible: true, order: widgets.length, custom: true, dataQuery: (dataQuery && dataQuery.trim()) ? dataQuery.trim() : '' };
            widgets.push(newWidget);
            setTabWidgets(tabId, widgets);
            openEditCardsModal(tabId);
            if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Section added. Use search on the card or Edit query to change data.');
        }
        function updateTabWidgetDataQuery(dashboardId, widgetId, dataQuery) {
            var widgets = getTabWidgets(dashboardId);
            var w = widgets.find(function(x) { return x.id === widgetId; });
            if (!w || (!w.custom && String(widgetId).indexOf('custom_') !== 0)) return;
            w.dataQuery = dataQuery == null ? '' : String(dataQuery).trim();
            setTabWidgets(dashboardId, widgets);
            if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Data query updated.');
        }
        function deleteTabWidget(dashboardId, widgetId) {
            var widgets = getTabWidgets(dashboardId);
            var w = widgets.find(function(x) { return x.id === widgetId; });
            if (!w || (!w.custom && String(widgetId).indexOf('custom_') !== 0)) return;
            if (!confirm('Delete the section "' + (w.label || widgetId) + '"?')) return;
            var next = widgets.filter(function(x) { return x.id !== widgetId; });
            for (var i = 0; i < next.length; i++) next[i].order = i;
            setTabWidgets(dashboardId, next);
            openEditCardsModal(dashboardId);
            if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Section deleted.');
        }
        
        // Filter custom card rows by search input (client-side)
        function filterCustomCardBySearch(inputEl) {
            var card = inputEl && inputEl.closest ? inputEl.closest('.chart-card') : null;
            if (!card) return;
            var content = card.querySelector('[data-custom-card-content]');
            if (!content) return;
            var term = (inputEl.value || '').toLowerCase();
            var rows = content.querySelectorAll('tr[data-searchable], .custom-card-row');
            if (!rows.length) rows = content.querySelectorAll('tbody tr');
            rows.forEach(function(r) {
                var text = (r.textContent || '').toLowerCase();
                r.style.display = term === '' || text.indexOf(term) >= 0 ? '' : 'none';
            });
        }
        
        // Build custom card body HTML from widget.dataQuery and evals (with search input)
        function renderCustomCardBody(widget, evals) {
            var q = (widget.dataQuery || '').toLowerCase();
            var instructors = (typeof analyticsData !== 'undefined' && analyticsData.instructors) ? analyticsData.instructors : [];
            var searchHtml = '<div style="margin-bottom:0.75rem;"><input type="text" class="custom-card-search" placeholder="Search in this card..." style="width:100%;padding:0.5rem 0.75rem;border:1px solid var(--border);border-radius:0.5rem;font-size:0.9rem;" oninput="filterCustomCardBySearch(this)" aria-label="Search"></div>';
            if (!evals || !evals.length) return searchHtml + '<div data-custom-card-content><p style="color:var(--text-light);padding:1rem;">No data. Load analytics and set a data query (e.g. by course, by instructor) in Edit cards.</p></div>';
            function pct(e) { var p = typeof getOverallScorePct === 'function' ? getOverallScorePct(e) : null; return p != null ? p.toFixed(1) : '—'; }
            var rows = [];
            if (q.indexOf('course') >= 0) {
                var courseStats = {};
                evals.forEach(function(e) {
                    var cid = e.course_id; var name = (e.courses && e.courses.name) || 'Unknown';
                    if (!courseStats[cid]) courseStats[cid] = { name: name, pcts: [] };
                    var p = pct(e); if (p !== '—') courseStats[cid].pcts.push(parseFloat(p));
                });
                rows = Object.keys(courseStats).map(function(cid) {
                    var c = courseStats[cid]; var avg = c.pcts.length ? (c.pcts.reduce(function(a,b){return a+b;},0)/c.pcts.length).toFixed(1) : '—';
                    return { cells: [c.name, c.pcts.length, avg + '%'], text: c.name + ' ' + c.pcts.length + ' ' + avg };
                });
                var tableHtml = '<table class="data-table" style="width:100%;font-size:0.9rem;"><thead><tr><th style="text-align:left;">Course</th><th style="text-align:center;">N</th><th style="text-align:center;">Avg %</th></tr></thead><tbody>' + rows.map(function(r) { return '<tr data-searchable="true"><td>' + escapeHtml(r.cells[0]) + '</td><td style="text-align:center;">' + r.cells[1] + '</td><td style="text-align:center;">' + r.cells[2] + '</td></tr>'; }).join('') + '</tbody></table>';
                return searchHtml + '<div data-custom-card-content>' + tableHtml + '</div>';
            }
            if (q.indexOf('instructor') >= 0) {
                var instStats = {};
                evals.forEach(function(e) {
                    var id = e.instructor_id;
                    if (!instStats[id]) instStats[id] = { name: '', pcts: [] };
                    var inst = instructors.find(function(i){ return i.id === id; });
                    if (inst) instStats[id].name = inst.full_name || inst.email || 'Unknown';
                    var p = pct(e); if (p !== '—') instStats[id].pcts.push(parseFloat(p));
                });
                rows = Object.keys(instStats).map(function(id) {
                    var c = instStats[id]; var avg = c.pcts.length ? (c.pcts.reduce(function(a,b){return a+b;},0)/c.pcts.length).toFixed(1) : '—';
                    return { cells: [c.name || 'Unknown', c.pcts.length, avg + '%'], text: (c.name||'') + ' ' + c.pcts.length + ' ' + avg };
                });
                var tableHtml2 = '<table class="data-table" style="width:100%;font-size:0.9rem;"><thead><tr><th style="text-align:left;">Instructor</th><th style="text-align:center;">N</th><th style="text-align:center;">Avg %</th></tr></thead><tbody>' + rows.map(function(r) { return '<tr data-searchable="true"><td>' + escapeHtml(r.cells[0]) + '</td><td style="text-align:center;">' + r.cells[1] + '</td><td style="text-align:center;">' + r.cells[2] + '</td></tr>'; }).join('') + '</tbody></table>';
                return searchHtml + '<div data-custom-card-content>' + tableHtml2 + '</div>';
            }
            if (q.indexOf('modality') >= 0) {
                var byMod = {};
                evals.forEach(function(e) {
                    var mod = (e.courses && e.courses.modality) ? e.courses.modality : 'unknown';
                    if (!byMod[mod]) byMod[mod] = { n: 0, pcts: [] };
                    byMod[mod].n++;
                    var p = pct(e); if (p !== '—') byMod[mod].pcts.push(parseFloat(p));
                });
                rows = Object.keys(byMod).map(function(mod) {
                    var o = byMod[mod]; var avg = o.pcts.length ? (o.pcts.reduce(function(a,b){return a+b;},0)/o.pcts.length).toFixed(1) : '—';
                    return { cells: [mod.charAt(0).toUpperCase() + mod.slice(1), o.n, avg + '%'], text: mod + ' ' + o.n + ' ' + avg };
                });
                var tableHtml3 = '<table class="data-table" style="width:100%;font-size:0.9rem;"><thead><tr><th style="text-align:left;">Modality</th><th style="text-align:center;">N</th><th style="text-align:center;">Avg %</th></tr></thead><tbody>' + rows.map(function(r) { return '<tr data-searchable="true"><td>' + escapeHtml(r.cells[0]) + '</td><td style="text-align:center;">' + r.cells[1] + '</td><td style="text-align:center;">' + r.cells[2] + '</td></tr>'; }).join('') + '</tbody></table>';
                return searchHtml + '<div data-custom-card-content>' + tableHtml3 + '</div>';
            }
            if (q.indexOf('student') >= 0) {
                rows = evals.slice(0, 100).map(function(e) {
                    var name = e.course_students ? (e.course_students.first_name + ' ' + e.course_students.last_name) : 'Unknown';
                    var courseName = (e.courses && e.courses.name) || 'Unknown';
                    var score = pct(e);
                    return { cells: [name, courseName, score + '%'], text: name + ' ' + courseName + ' ' + score };
                });
                var tableHtml4 = '<table class="data-table" style="width:100%;font-size:0.9rem;"><thead><tr><th style="text-align:left;">Student</th><th style="text-align:left;">Course</th><th style="text-align:center;">Score %</th></tr></thead><tbody>' + rows.map(function(r) { return '<tr data-searchable="true"><td>' + escapeHtml(r.cells[0]) + '</td><td>' + escapeHtml(r.cells[1]) + '</td><td style="text-align:center;">' + r.cells[2] + '</td></tr>'; }).join('') + '</tbody></table>' + (evals.length > 100 ? '<p style="font-size:0.8rem;color:var(--text-light);margin-top:0.5rem;">Showing first 100. Use search to narrow.</p>' : '');
                return searchHtml + '<div data-custom-card-content>' + tableHtml4 + '</div>';
            }
            return searchHtml + '<div data-custom-card-content><p style="color:var(--text-light);padding:1rem;">Set data query in Edit cards: e.g. <strong>by course</strong>, <strong>by instructor</strong>, <strong>by modality</strong>, or <strong>by student</strong>.</p></div>';
        }
        
        // Switch analytics tabs (ARIA + classes) - legacy alias
        function switchAnalyticsTabByName(tabName) { switchAnalyticsTab(tabName); }
        
        // Toast helper for analytics success
        function showAnalyticsToast(message, durationMs) {
            durationMs = durationMs || 4000;
            const existing = document.getElementById('analyticsToast');
            if (existing) existing.remove();
            const el = document.createElement('div');
            el.id = 'analyticsToast';
            el.className = 'analytics-toast';
            el.setAttribute('role', 'status');
            el.innerHTML = message;
            document.body.appendChild(el);
            setTimeout(() => { if (el.parentNode) el.remove(); }, durationMs);
        }
        
        // Prefill analytics date range from localStorage
        function prefillAnalyticsDateRange() {
            const startEl = document.getElementById('analyticsStartDate');
            const endEl = document.getElementById('analyticsEndDate');
            if (startEl && !startEl.value && localStorage.getItem('analyticsStartDate')) startEl.value = localStorage.getItem('analyticsStartDate');
            if (endEl && !endEl.value && localStorage.getItem('analyticsEndDate')) endEl.value = localStorage.getItem('analyticsEndDate');
        }
        
        // Load enhanced analytics
        async function loadEnhancedAnalytics() {
            if (!supabaseClient || !currentUser) {
                const statsContainer = document.getElementById('overviewStatsContainer');
                if (statsContainer) statsContainer.innerHTML = '<div style="text-align: center; padding: 2rem 1.5rem; color: var(--text-light);"><p style="font-weight: 600; color: var(--text);">Sign in to load analytics</p><p style="font-size: 0.9rem;">Analytics are available for instructors and department heads.</p></div>';
                return;
            }
            const isSuperAdminView = typeof isSuperAdmin === 'function' && isSuperAdmin();
            const isAdminView = isAdmin() && currentUser.department_id;
            
            if (isSuperAdminView) {
                // Platform-level analytics for SpeechGradebook managers
            } else if (isAdminView) {
                // Department head: load department-wide data
            } else if (userTier === 'instructor') {
                // Instructor: load own data only
            } else {
                alert('Analytics require an instructor or admin account with a department.');
                return;
            }
            
            const btnLoad = document.getElementById('btnLoadAnalytics');
            const originalBtnHtml = btnLoad ? btnLoad.innerHTML : '';
            if (btnLoad) {
                btnLoad.disabled = true;
                btnLoad.innerHTML = '<span style="display:inline-block;width:1rem;height:1rem;border:2px solid rgba(255,255,255,0.4);border-top-color:#fff;border-radius:50%;animation:spin 0.6s linear infinite;vertical-align:middle;margin-right:0.5rem;"></span> Loading...';
            }
            
            prefillAnalyticsDateRange();
            const startDate = document.getElementById('analyticsStartDate')?.value || '';
            const endDate = document.getElementById('analyticsEndDate')?.value || '';
            
            function clearLoading() {
                if (btnLoad) {
                    btnLoad.disabled = false;
                    btnLoad.innerHTML = originalBtnHtml;
                }
            }
            
            function setAnalyticsLoading(show) {
                const statsContainer = document.getElementById('overviewStatsContainer');
                if (!statsContainer) return;
                if (show) {
                    statsContainer.innerHTML = '<p style="color: var(--text-light); margin-bottom: 0.5rem;">Loading analytics…</p><div class="spinner" style="width: 40px; height: 40px; margin: 1rem auto;" aria-hidden="true"></div>';
                }
            }
            setAnalyticsLoading(true);
            try {
                console.log('📊 Loading analytics...', isSuperAdminView ? '(platform)' : isAdminView ? '(department)' : '(my courses)');
                
                let instructors, evaluations;
                
                if (isSuperAdminView) {
                    // Platform stats for Super Admin (SpeechGradebook managers)
                    const [rInst, rUsers, rCourses, rEvals, rConsent, rInstList, rEvalsList] = await Promise.all([
                        supabaseClient.from('institutions').select('*', { count: 'exact', head: true }),
                        supabaseClient.from('user_profiles').select('*', { count: 'exact', head: true }),
                        supabaseClient.from('courses').select('*', { count: 'exact', head: true }),
                        supabaseClient.from('evaluations').select('*', { count: 'exact', head: true }),
                        supabaseClient.from('consent_forms').select('id, consent_given'),
                        supabaseClient.from('institutions').select('id, name').order('name'),
                        supabaseClient.from('evaluations').select('id, course_id').limit(10000)
                    ]);
                    const institutionsCountVal = rInst.count ?? 0;
                    const usersCountVal = rUsers.count ?? 0;
                    const coursesCountVal = rCourses.count ?? 0;
                    const evaluationsCountVal = rEvals.count ?? 0;
                    const consentList = rConsent.data || [];
                    const consentGivenVal = consentList.filter(x => x.consent_given === true).length;
                    const consentTotalVal = consentList.length;
                    const instMap = {};
                    (rInstList.data || []).forEach(i => { instMap[i.id] = i.name; });
                    const rCoursesList = await supabaseClient.from('courses').select('id, instructor_id');
                    const rUp = await supabaseClient.from('user_profiles').select('id, institution_id');
                    const upMap = {};
                    (rUp.data || []).forEach(u => { upMap[u.id] = u.institution_id; });
                    const courseToInst = {};
                    (rCoursesList.data || []).forEach(c => { courseToInst[c.id] = upMap[c.instructor_id]; });
                    const byInst = {};
                    (rEvalsList.data || []).forEach(e => {
                        const instId = courseToInst[e.course_id];
                        if (!instId) return;
                        if (!byInst[instId]) byInst[instId] = { name: instMap[instId] || 'Unknown', evaluations: 0, courses: new Set(), users: new Set() };
                        byInst[instId].evaluations++;
                        byInst[instId].courses.add(e.course_id);
                    });
                    const byInstitutionVal = Object.entries(byInst).map(([id, o]) => ({
                        id,
                        name: o.name,
                        evaluations: o.evaluations,
                        courses: o.courses.size,
                        instructors: 0
                    })).sort((a, b) => b.evaluations - a.evaluations);
                    analyticsData.evaluations = [];
                    analyticsData.filtered = [];
                    analyticsData.instructors = [];
                    analyticsData.courses = [];
                    analyticsData.superAdminPlatform = {
                        institutionsCount: institutionsCountVal,
                        usersCount: usersCountVal,
                        coursesCount: coursesCountVal,
                        evaluationsCount: evaluationsCountVal,
                        consentGiven: consentGivenVal,
                        consentTotal: consentTotalVal,
                        byInstitution: byInstitutionVal
                    };
                    updateAnalyticsUIForRole();
                    renderOverviewTab();
                    renderComparisonsTab();
                    renderEvaluationsTab();
                    if (typeof renderExportPreview === 'function') renderExportPreview();
                    if (typeof currentAnalyticsTabId !== 'undefined' && currentAnalyticsTabId) {
                        if (typeof switchAnalyticsTab === 'function') switchAnalyticsTab(currentAnalyticsTabId);
                    } else {
                        if (typeof switchAnalyticsTab === 'function') switchAnalyticsTab('overview');
                    }
                    if (typeof setAnalyticsLastUpdated === 'function') setAnalyticsLastUpdated();
                    if (typeof loadFilteredCoursesForSuperAdmin === 'function') loadFilteredCoursesForSuperAdmin();
                    console.log('✓ Platform analytics loaded:', analyticsData.superAdminPlatform);
                    clearLoading();
                    return;
                }
                
                if (isAdminView) {
                    const { data: instData, error: instError } = await supabaseClient
                        .from('user_profiles')
                        .select('id, email, full_name')
                        .eq('department_id', currentUser.department_id)
                        .eq('account_tier', 'instructor');
                    if (instError) throw instError;
                    instructors = instData || [];
                    const instructorIds = instructors.map(i => i.id);
                    if (instructorIds.length === 0) {
                        const statsContainer = document.getElementById('overviewStatsContainer');
                        if (statsContainer) {
                        statsContainer.innerHTML = '<div style="text-align: center; padding: 2rem 1.5rem; color: var(--text-light);"><p style="font-size: 1.5rem; margin-bottom: 0.5rem;"><i data-lucide="users" style="width:2rem;height:2rem;display:inline-block;"></i></p><p style="font-weight: 600; margin-bottom: 0.25rem; color: var(--text);">No instructors in your department</p><p style="font-size: 0.9rem;">Add instructors to your department to see analytics here.</p></div>';
                        if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statsContainer });
                    }
                        clearLoading();
                        return;
                    }
                    let query = supabaseClient.from('evaluations').select(`
                        id, instructor_id, course_id, student_id, rubric_id, created_at, evaluation_data,
                        courses!fk_evaluations_course (id, name, semester, year),
                        course_students!fk_evaluations_student (first_name, last_name)
                    `).in('instructor_id', instructorIds);
                    if (startDate) query = query.gte('created_at', startDate);
                    if (endDate) query = query.lte('created_at', endDate + 'T23:59:59');
                    const { data: evData, error: evalError } = await query;
                    if (evalError) throw evalError;
                    evaluations = evData || [];
                    if (evaluations.length > 0) {
                        await logAccess('view', 'evaluations', null, null, { evaluation_count: evaluations.length, purpose: 'department_analytics' });
                    }
                } else {
                    instructors = [{ id: currentUser.id, email: currentUser.email || '', full_name: currentUser.full_name || currentUser.email || 'Me' }];
                    let query = supabaseClient.from('evaluations').select(`
                        id, instructor_id, course_id, student_id, rubric_id, created_at, evaluation_data,
                        courses!fk_evaluations_course (id, name, semester, year),
                        course_students!fk_evaluations_student (first_name, last_name)
                    `).eq('instructor_id', currentUser.id);
                    if (startDate) query = query.gte('created_at', startDate);
                    if (endDate) query = query.lte('created_at', endDate + 'T23:59:59');
                    const { data: evData, error: evalError } = await query;
                    if (evalError) throw evalError;
                    evaluations = evData || [];
                }
                
                const uniqueCourses = evaluations
                    .filter((e, i, arr) => arr.findIndex(x => x.course_id === e.course_id) === i)
                    .map(e => e.courses)
                    .filter(c => c);
                
                analyticsData.evaluations = evaluations;
                analyticsData.instructors = instructors;
                analyticsData.courses = uniqueCourses;
                analyticsData.filtered = evaluations;
                
                if (startDate) try { localStorage.setItem('analyticsStartDate', startDate); } catch (e) {}
                if (endDate) try { localStorage.setItem('analyticsEndDate', endDate); } catch (e) {}
                
                updateAnalyticsUIForRole();
                populateAnalyticsFilters();
                populateFocusCategoryDropdown();
                filterAnalytics();
                
                analyticsEvaluationsPage = 0;
                renderOverviewTab();
                renderComparisonsTab();
                renderEvaluationsTab();
                if (typeof renderExportPreview === 'function') renderExportPreview();
                
                // Stay on current tab instead of forcing switch to overview
                if (typeof currentAnalyticsTabId !== 'undefined' && currentAnalyticsTabId) {
                    if (typeof switchAnalyticsTab === 'function') switchAnalyticsTab(currentAnalyticsTabId);
                } else {
                    if (typeof switchAnalyticsTab === 'function') switchAnalyticsTab('overview');
                }
                if (typeof setAnalyticsLastUpdated === 'function') setAnalyticsLastUpdated();
                
                console.log('✓ Analytics loaded:', { evaluations: evaluations.length, instructors: instructors.length, courses: uniqueCourses.length });
            } catch (error) {
                console.error('Error loading analytics:', error);
                const statsContainer = document.getElementById('overviewStatsContainer');
                if (statsContainer) {
                statsContainer.innerHTML = '<div style="text-align: center; padding: 2rem 1.5rem;"><p style="font-size: 1.5rem; margin-bottom: 0.5rem;"><i data-lucide="alert-triangle" style="width:2rem;height:2rem;display:inline-block;color:var(--error);"></i></p><p style="font-weight: 600; margin-bottom: 0.25rem; color: var(--error);">Error loading analytics</p><p style="font-size: 0.9rem; color: var(--text-light); margin-bottom: 1rem;">Please try again.</p><button type="button" onclick="loadEnhancedAnalytics()" class="btn" style="background: var(--primary); color: white;"><span class="icon-with-text"><i data-lucide="refresh-cw"></i> Try again</span></button></div>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statsContainer });
            }
                showAnalyticsToast('Error loading analytics. Please try again.', 5000);
            }
            clearLoading();
        }
        
        // Demo mode: load fake analytics so dashboard renders (Instructor or Admin view)
        function loadDemoAnalytics(viewAs) {
            if (typeof analyticsData === 'undefined') return;
            var instructors, courses, evaluations;
            var baseDate = new Date();
            baseDate.setMonth(baseDate.getMonth() - 2);
            function iso(d) { return d.toISOString().slice(0, 10) + 'T12:00:00Z'; }
            function mockEvalData(scorePct) {
                var s = Math.max(0, Math.min(100, scorePct));
                return { sections: { Content: { score: s * 0.4, maxScore: 40, subcategories: [{ name: 'Organization', points: s * 0.15, maxPoints: 15 }, { name: 'Delivery', points: s * 0.25, maxPoints: 25 }] }, Delivery: { score: s * 0.3, maxScore: 30, subcategories: [{ name: 'Eye contact', points: s * 0.15, maxPoints: 15 }] } } };
            }
            if (viewAs === 'admin') {
                instructors = [{ id: 'demo-i1', email: 'jane@example.edu', full_name: 'Jane Smith' }, { id: 'demo-i2', email: 'bob@example.edu', full_name: 'Bob Jones' }, { id: 'demo-i3', email: 'alex@example.edu', full_name: 'Alex Lee' }];
                courses = [{ id: 'demo-c1', name: 'COMM 101', semester: 'Fall', year: '2025', modality: 'in-person' }, { id: 'demo-c2', name: 'COMM 205', semester: 'Fall', year: '2025', modality: 'online' }, { id: 'demo-c3', name: 'SPCH 110', semester: 'Spring', year: '2025', modality: 'hybrid' }];
                evaluations = [];
                [72, 85, 91, 68, 78, 88, 65, 82, 90, 74, 79, 86, 70, 84, 92].forEach(function(pct, i) {
                    var inst = instructors[i % 3]; var course = courses[i % 3];
                    evaluations.push({ id: 'demo-e' + i, instructor_id: inst.id, course_id: course.id, student_id: 'demo-s' + i, rubric_id: 'default', created_at: iso(new Date(baseDate.getTime() + i * 86400000 * 3)), evaluation_data: mockEvalData(pct), courses: course, course_students: { first_name: 'Student', last_name: String(i + 1) } });
                });
            } else {
                instructors = [{ id: 'demo-me', email: 'instructor@example.edu', full_name: 'Demo Instructor' }];
                courses = [{ id: 'demo-c1', name: 'COMM 101', semester: 'Fall', year: '2025', modality: 'in-person' }, { id: 'demo-c2', name: 'COMM 205', semester: 'Fall', year: '2025', modality: 'online' }];
                evaluations = [];
                [75, 82, 88, 70, 79, 85, 68, 80, 90, 73, 78, 86].forEach(function(pct, i) {
                    var course = courses[i % 2];
                    evaluations.push({ id: 'demo-e' + i, instructor_id: 'demo-me', course_id: course.id, student_id: 'demo-s' + i, rubric_id: 'default', created_at: iso(new Date(baseDate.getTime() + i * 86400000 * 4)), evaluation_data: mockEvalData(pct), courses: course, course_students: { first_name: 'Student', last_name: String(i + 1) } });
                });
            }
            analyticsData.evaluations = evaluations;
            analyticsData.instructors = instructors;
            analyticsData.courses = courses;
            analyticsData.filtered = evaluations;
            if (typeof updateAnalyticsUIForRole === 'function') updateAnalyticsUIForRole();
            if (typeof populateAnalyticsFilters === 'function') populateAnalyticsFilters();
            if (typeof populateFocusCategoryDropdown === 'function') populateFocusCategoryDropdown();
            if (typeof filterAnalytics === 'function') filterAnalytics();
            if (typeof renderOverviewTab === 'function') renderOverviewTab();
            if (typeof renderComparisonsTab === 'function') renderComparisonsTab();
            if (typeof renderEvaluationsTab === 'function') renderEvaluationsTab();
            if (typeof switchAnalyticsTab === 'function') switchAnalyticsTab('overview');
            if (typeof setAnalyticsLastUpdated === 'function') setAnalyticsLastUpdated();
            // Demo data loaded (no toast needed)
        }
        
        function updateAnalyticsUIForRole() {
            const isAdminView = (userTier === 'demo' && typeof demoViewAs !== 'undefined' && demoViewAs === 'admin') || (typeof isAdmin === 'function' && isAdmin() && currentUser);
            const isSuperAdminView = typeof isSuperAdmin === 'function' && isSuperAdmin();
            const titleEl = document.getElementById('analyticsSectionTitle');
            const exportBtn = document.getElementById('analyticsExportBtn');
            if (titleEl) {
                if (isSuperAdminView) titleEl.innerHTML = '<span class="icon-with-text"><i data-lucide="bar-chart-2"></i> Platform Analytics</span>';
                else if (isAdminView) titleEl.innerHTML = '<span class="icon-with-text"><i data-lucide="bar-chart-2"></i> Department Outcomes & Teaching Insights</span>';
                else titleEl.innerHTML = '<span class="icon-with-text"><i data-lucide="bar-chart-2"></i> Course Insights</span>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: titleEl });
            }
            if (exportBtn) exportBtn.style.display = (isAdminView || isSuperAdminView) ? '' : 'none';
        }
        
        // Metric definitions database
        const METRIC_DEFINITIONS = {
            'overall-performance': {
                title: 'Overall Performance',
                definition: 'The average score across all evaluations in the selected date range and filters. This represents the mean percentage score calculated from all rubric dimensions.',
                measurement: 'Calculated by averaging the overall percentage scores from each evaluation. Each evaluation\'s score is computed by taking the weighted average of all rubric categories and subcategories.',
                limitations: 'This metric provides a high-level view but may mask variation across different rubric dimensions. Use the detailed charts below to understand performance by specific categories.'
            },
            'top-strength': {
                title: 'Top Strength',
                definition: 'The rubric dimension or category where students scored highest on average. This identifies the area of strongest performance across all evaluations.',
                measurement: 'Determined by calculating the average percentage score for each rubric dimension across all evaluations, then identifying the dimension with the highest average.',
                limitations: 'Represents aggregate performance and may not reflect individual student variation. Some dimensions may have fewer data points than others.'
            },
            'top-opportunity': {
                title: 'Top Opportunity',
                definition: 'The rubric dimension or category where students scored lowest on average. This identifies the area with the greatest potential for improvement and targeted instruction.',
                measurement: 'Determined by calculating the average percentage score for each rubric dimension across all evaluations, then identifying the dimension with the lowest average.',
                limitations: 'Represents aggregate performance. Consider reviewing individual evaluations to understand specific patterns and student needs.'
            },
            'completion': {
                title: 'Completion',
                definition: 'The total number of evaluations completed in the selected date range and filter criteria. This indicates the volume of assessment data available for analysis.',
                measurement: 'Simple count of all evaluation records that match the current filters (date range, course, term, instructor).',
                limitations: 'Does not reflect evaluation quality or depth. A higher number provides more reliable aggregate statistics.'
            },
            'total-evaluations': {
                title: 'Total Evaluations',
                definition: 'The total number of evaluations completed in the selected date range and filter criteria. This indicates the volume of assessment data available for analysis.',
                measurement: 'Simple count of all evaluation records that match the current filters (date range, course, term, instructor).',
                limitations: 'Does not reflect evaluation quality or depth. A higher number provides more reliable aggregate statistics.'
            },
            'outcome-attainment': {
                title: 'Outcome Attainment',
                definition: 'The percentage of evaluations where students met the threshold (≥60%) across all rubric dimensions. This is a key indicator for accreditation and program assessment.',
                measurement: 'For each evaluation, determines if the overall score is 60% or higher. The percentage represents the proportion of evaluations meeting this threshold.',
                limitations: 'The 60% threshold is a standard benchmark but may not reflect your institution\'s specific standards. Adjust interpretation based on your program goals.'
            },
            'across-section-variability': {
                title: 'Across-section Variability',
                definition: 'Measures consistency in student performance across different course sections. Lower variability suggests more consistent instruction and assessment.',
                measurement: 'Calculated using standard deviation of mean scores across different sections or instructors. Requires multiple sections for meaningful analysis.',
                limitations: 'High variability may reflect differences in student populations, not just instructional quality. Use for calibration, not ranking.'
            },
            'modality-gap': {
                title: 'Modality Gap',
                definition: 'The difference in average performance between online and in-person course sections. Helps identify if modality affects student outcomes.',
                measurement: 'Compares mean scores between courses tagged as "online" vs "in-person" in course settings. Requires course modality data.',
                limitations: 'Differences may reflect student self-selection, not modality effects. Requires sufficient sample size (n≥5) per modality.'
            },
            'calibration-signals': {
                title: 'Calibration Signals',
                definition: 'Indicates consistency in evaluation scoring over time. "Stable" means no significant drift detected; changes may suggest need for rater recalibration.',
                measurement: 'Monitors score distributions over time using statistical process control methods. Flags significant shifts in mean or variance.',
                limitations: 'For professional development only. Not intended for punitive evaluation of instructors.'
            },
            'completion-rate': {
                title: 'Completion Rate',
                definition: 'Total number of completed evaluations. Higher completion rates provide more robust data for analysis and decision-making.',
                measurement: 'Count of all evaluation records in the system matching current filters.',
                limitations: 'Quantity does not equal quality. Ensure evaluations are completed thoughtfully and thoroughly.'
            },
            'access-quality-flags': {
                title: 'Access / Quality Flags',
                definition: 'Indicators of potential data quality issues or access concerns, such as missing consent, incomplete evaluations, or data anomalies.',
                measurement: 'Automated checks for missing required fields, outlier scores, or consent-related restrictions.',
                limitations: 'Flags require human review. Not all flagged items indicate actual problems.'
            },
            'outcome-attainment-by-outcome': {
                title: 'Outcome attainment by outcome',
                definition: 'Shows the percentage of students meeting the threshold (≥60%) for each individual rubric dimension. Helps identify which learning outcomes are being met consistently.',
                measurement: 'For each rubric dimension, calculates the percentage of evaluations where that dimension scored 60% or higher.',
                limitations: 'Dimensions with fewer evaluations may show more variability. Consider sample size when interpreting results.'
            },
            'modality-comparison': {
                title: 'Modality comparison',
                definition: 'Compares student performance across different course delivery modalities (online, in-person, hybrid). Helps assess if delivery method impacts outcomes.',
                measurement: 'Aggregates scores by course modality setting. Suppresses cells with n<5 to protect privacy.',
                limitations: 'Modality must be set in course settings. Differences may reflect student populations, not just delivery method.'
            },
            'course-comparisons': {
                title: 'Course comparisons',
                definition: 'Shows average performance across different courses. Useful for identifying courses that may need additional support or represent best practices.',
                measurement: 'Calculates mean score for each course across all evaluations in that course.',
                limitations: 'Courses may have different rubrics, student populations, or difficulty levels. Use for exploration, not ranking.'
            },
            'section-variability-map': {
                title: 'Section variability map',
                definition: 'Displays mean scores and standard deviations for each rubric dimension across all sections. Helps identify where consistency is strong or where calibration may be needed.',
                measurement: 'For each dimension, calculates mean and standard deviation across all evaluations. Higher SD indicates more variability.',
                limitations: 'Use for professional development and calibration, not for punitive instructor comparison.'
            },
            'accreditation-ready-summary': {
                title: 'Accreditation-ready summary',
                definition: 'Provides a high-level summary of outcome attainment suitable for accreditation reports. Shows percentage meeting threshold with export options.',
                measurement: 'Calculates overall percentage of evaluations meeting the 60% threshold, formatted for external reporting.',
                limitations: 'Represents aggregate data only. Accreditation bodies may require additional context and disaggregation.'
            },
            'modality-report': {
                title: 'Modality report',
                definition: 'Detailed comparison of performance across course modalities with sample sizes and suppression thresholds applied for privacy.',
                measurement: 'Tabulates mean scores and sample sizes by modality. Suppresses cells with n<5.',
                limitations: 'Requires modality data in course settings. Small samples may not be representative.'
            },
            'norming-summary': {
                title: 'Norming summary',
                definition: 'Calibration and norming indicators showing whether scoring is stable over time. Helps ensure consistent standards across evaluators.',
                measurement: 'Monitors score distributions for significant shifts using statistical process control methods.',
                limitations: 'For calibration and professional development only. Does not assess evaluator quality.'
            },
            'opi-distribution': {
                title: 'OPI Distribution',
                definition: 'Overall Performance Index distribution showing the spread of scores across all evaluations. Helps visualize whether most students are meeting expectations.',
                measurement: 'Displays the distribution of overall percentage scores, typically shown as a histogram or summary statistics.',
                limitations: 'Aggregate view may mask important subgroup differences. Review by course or dimension for deeper insights.'
            },
            'students-needing-targeted-feedback': {
                title: 'Students Needing Targeted Feedback',
                definition: 'Identifies students who may benefit from additional support based on evaluation scores. Typically includes students scoring below 60%.',
                measurement: 'Filters evaluations to show those with overall scores below the threshold, allowing instructors to follow up.',
                limitations: 'Low scores may reflect various factors. Review individual evaluations for context before intervening.'
            }
        };
        
        function showMetricDefinition(slug, title) {
            const modal = document.getElementById('metricDefinitionModal');
            const titleEl = document.getElementById('metricDefinitionTitle');
            const contentEl = document.getElementById('metricDefinitionContent');
            
            if (!modal || !titleEl || !contentEl) return;
            
            const def = METRIC_DEFINITIONS[slug];
            
            if (def) {
                titleEl.textContent = def.title;
                contentEl.innerHTML = `
                    <div style="margin-bottom: 1rem;">
                        <h4 style="margin: 0 0 0.5rem 0; font-size: 0.95rem; color: var(--primary);">Definition</h4>
                        <p style="margin: 0; font-size: 0.9rem;">${def.definition}</p>
                    </div>
                    <div style="margin-bottom: 1rem;">
                        <h4 style="margin: 0 0 0.5rem 0; font-size: 0.95rem; color: var(--primary);">How it's measured</h4>
                        <p style="margin: 0; font-size: 0.9rem;">${def.measurement}</p>
                    </div>
                    <div>
                        <h4 style="margin: 0 0 0.5rem 0; font-size: 0.95rem; color: var(--primary);">Limitations & context</h4>
                        <p style="margin: 0; font-size: 0.9rem;">${def.limitations}</p>
                    </div>
                `;
            } else {
                titleEl.textContent = title;
                contentEl.innerHTML = `
                    <p style="margin: 0; font-size: 0.9rem; color: var(--text-light);">
                        Detailed information about this metric is being developed. 
                        For now, you can explore the data in the Evaluations tab or export to CSV for further analysis.
                    </p>
                `;
            }
            
            modal.style.display = 'flex';
        }
        
        function closeMetricDefinition() {
            const modal = document.getElementById('metricDefinitionModal');
            if (modal) modal.style.display = 'none';
        }
        
        function populateFocusCategoryDropdown() {
            const sel = document.getElementById('analyticsFocusCategory');
            if (!sel) return;
            const evals = analyticsData.evaluations || [];
            const categories = new Set();
            evals.forEach(e => {
                let d = e.evaluation_data;
                if (typeof d === 'string') try { d = JSON.parse(d); } catch (e) { return; }
                if (d?.sections && typeof d.sections === 'object') {
                    Object.keys(d.sections).forEach(k => categories.add(k));
                    Object.values(d.sections).forEach(s => {
                        (s.subcategories || s.feedback || []).forEach(item => { if (item.name) categories.add(item.name); });
                    });
                }
            });
            sel.innerHTML = '<option value="">All categories</option>' + Array.from(categories).sort().map(c => `<option value="${escapeHtml(c)}">${escapeHtml(c)}</option>`).join('');
        }
        
        function applyInsightFilters() {
            filterAnalytics();
        }
        
        // Filter dropdown key -> select id and default label
        var FILTER_DROPDOWN_KEYS = [
            { key: 'course', selectId: 'analyticsGlobalCourse', allLabel: 'All courses' },
            { key: 'instructor', selectId: 'analyticsGlobalInstructor', allLabel: 'All instructors' }
        ];
        
        function updateFilterDropdownTrigger(filterKey) {
            var meta = FILTER_DROPDOWN_KEYS.find(function(m) { return m.key === filterKey; });
            if (!meta) return;
            var sel = document.getElementById(meta.selectId);
            var trigger = document.getElementById('filter-trigger-' + filterKey);
            if (!sel || !trigger) return;
            var selected = getMultiSelectValues(sel);
            var labels = [];
            for (var i = 0; i < sel.options.length; i++) {
                var opt = sel.options[i];
                if (opt.value && selected.indexOf(opt.value) !== -1) labels.push(opt.text);
            }
            if (labels.length === 0) {
                trigger.textContent = meta.allLabel;
            } else if (labels.length <= 3) {
                trigger.textContent = labels.join(', ');
            } else {
                trigger.textContent = labels.length + ' selected';
            }
            var panel = document.getElementById('filter-panel-' + filterKey);
            if (panel) {
                panel.querySelectorAll('.filter-dropdown-item').forEach(function(item) {
                    var val = item.getAttribute('data-value');
                    item.classList.toggle('selected', selected.indexOf(val) !== -1);
                });
            }
        }
        
        function buildFilterDropdownPanel(filterKey) {
            var meta = FILTER_DROPDOWN_KEYS.find(function(m) { return m.key === filterKey; });
            if (!meta) return;
            var sel = document.getElementById(meta.selectId);
            var panel = document.getElementById('filter-panel-' + filterKey);
            if (!sel || !panel) return;
            var options = [];
            for (var i = 0; i < sel.options.length; i++) {
                var opt = sel.options[i];
                if (opt.value) options.push({ value: opt.value, text: opt.text });
            }
            panel.innerHTML = options.map(function(o) {
                return '<div class="filter-dropdown-item" data-value="' + escapeHtml(o.value) + '" role="option" tabindex="0">' +
                    '<span class="filter-dropdown-check" aria-hidden="true"><i data-lucide="check"></i></span>' +
                    '<span>' + escapeHtml(o.text) + '</span></div>';
            }).join('');
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: panel });
        }
        
        function initFilterDropdownBehavior() {
            if (window._filterDropdownBehaviorInited) return;
            window._filterDropdownBehaviorInited = true;
            document.addEventListener('click', function(e) {
                var open = document.querySelector('.filter-dropdown.open');
                if (open && !open.contains(e.target)) {
                    open.classList.remove('open');
                    var trigger = open.querySelector('.filter-dropdown-trigger');
                    if (trigger) trigger.setAttribute('aria-expanded', 'false');
                }
            });
            FILTER_DROPDOWN_KEYS.forEach(function(meta) {
                var key = meta.key;
                var wrapper = document.getElementById('filter-dropdown-' + key);
                var trigger = document.getElementById('filter-trigger-' + key);
                var panel = document.getElementById('filter-panel-' + key);
                if (!wrapper || !trigger || !panel) return;
                trigger.addEventListener('click', function(ev) {
                    ev.stopPropagation();
                    var isOpen = wrapper.classList.toggle('open');
                    trigger.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
                    panel.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
                    if (isOpen) {
                        document.querySelectorAll('.filter-dropdown.open').forEach(function(d) {
                            if (d !== wrapper) {
                                d.classList.remove('open');
                                var t = d.querySelector('.filter-dropdown-trigger');
                                if (t) t.setAttribute('aria-expanded', 'false');
                            }
                        });
                    }
                });
                panel.addEventListener('click', function(ev) {
                    var item = ev.target.closest('.filter-dropdown-item');
                    if (!item) return;
                    ev.preventDefault();
                    var value = item.getAttribute('data-value');
                    var sel = document.getElementById(meta.selectId);
                    if (!sel) return;
                    var opt = Array.from(sel.options).find(function(o) { return o.value === value; });
                    if (opt) {
                        opt.selected = !opt.selected;
                        item.classList.toggle('selected', opt.selected);
                        updateFilterDropdownTrigger(key);
                        if (typeof applyGlobalFilters === 'function') applyGlobalFilters();
                    }
                });
            });
        }
        
        // Populate filter dropdowns (hidden selects + custom dropdown panels)
        function populateAnalyticsFilters() {
            // Populate instructors
            const instFilter = document.getElementById('analyticsInstructorFilter');
            const globalInstructor = document.getElementById('analyticsGlobalInstructor');
            const instructorOptions = (analyticsData.instructors || [])
                .map(inst => `<option value="${inst.id}">${escapeHtml((inst.full_name || '').trim() || 'Instructor')}</option>`).join('');
            if (instFilter) instFilter.innerHTML = '<option value="all">All Instructors</option>' + instructorOptions;
            if (globalInstructor) globalInstructor.innerHTML = '<option value="">All instructors</option>' + instructorOptions;
            
            // Populate courses
            const courseFilter = document.getElementById('analyticsCourseFilter');
            const globalCourse = document.getElementById('analyticsGlobalCourse');
            const courseOptions = (analyticsData.courses || [])
                .map(c => `<option value="${c.id}">${escapeHtml(c.name || '')}</option>`).join('');
            if (courseFilter) courseFilter.innerHTML = '<option value="all">All courses</option>' + courseOptions;
            if (globalCourse) globalCourse.innerHTML = '<option value="">All courses</option>' + courseOptions;
            
            // Build custom dropdown panels and sync trigger text
            FILTER_DROPDOWN_KEYS.forEach(function(m) {
                buildFilterDropdownPanel(m.key);
                updateFilterDropdownTrigger(m.key);
            });
            initFilterDropdownBehavior();
        }
        
        // Apply global filters (concurrent multi-category filtering)
        function applyGlobalFilters() {
            updateActiveFiltersDisplay();
            filterAnalytics();
        }
        
        // Get selected values from multi-select
        function getMultiSelectValues(selectElement) {
            if (!selectElement) return [];
            const selected = Array.from(selectElement.selectedOptions)
                .map(opt => opt.value)
                .filter(val => val !== '');
            return selected;
        }
        
        // Clear one global filter by type and value (used by active-filter badge buttons; no closure serialization)
        function clearGlobalFilter(type, value) {
            const selectIds = {
                course: 'analyticsGlobalCourse',
                instructor: 'analyticsGlobalInstructor'
            };
            if (type === 'date') {
                var startEl = document.getElementById('analyticsStartDate');
                var endEl = document.getElementById('analyticsEndDate');
                if (startEl) startEl.value = '';
                if (endEl) endEl.value = '';
                if (typeof loadEnhancedAnalytics === 'function') loadEnhancedAnalytics();
                return;
            }
            var id = selectIds[type];
            var sel = id ? document.getElementById(id) : null;
            if (!sel) return;
            var opt = Array.from(sel.options).find(function(o) { return o.value === value; });
            if (opt) opt.selected = false;
            if (typeof applyGlobalFilters === 'function') applyGlobalFilters();
        }
        
        // Called from badge button onclick; reads data-filter-* from parent span
        function clearGlobalFilterFromNode(btn) {
            var span = btn && btn.closest ? btn.closest('span[data-filter-type]') : null;
            if (!span) return;
            var type = span.getAttribute('data-filter-type');
            var value = span.getAttribute('data-filter-value') || '';
            clearGlobalFilter(type, value);
            if (typeof updateFilterDropdownTrigger === 'function') updateFilterDropdownTrigger(type);
            if (typeof updateActiveFiltersDisplay === 'function') updateActiveFiltersDisplay();
        }
        
        // Update active filters display with removable badges
        function updateActiveFiltersDisplay() {
            const display = document.getElementById('activeFiltersDisplay');
            if (!display) return;
            
            const filters = [];
            
            // Check each multi-select filter
            const courses = getMultiSelectValues(document.getElementById('analyticsGlobalCourse'));
            const instructors = getMultiSelectValues(document.getElementById('analyticsGlobalInstructor'));
            const startDate = document.getElementById('analyticsStartDate')?.value;
            const endDate = document.getElementById('analyticsEndDate')?.value;
            
            if (courses.length > 0) {
                const courseEl = document.getElementById('analyticsGlobalCourse');
                courses.forEach(crs => {
                    const option = Array.from(courseEl.options).find(opt => opt.value === crs);
                    if (option) filters.push({ type: 'course', value: crs, label: 'Course: ' + option.text });
                });
            }
            
            if (instructors.length > 0) {
                const instEl = document.getElementById('analyticsGlobalInstructor');
                instructors.forEach(inst => {
                    const option = Array.from(instEl.options).find(opt => opt.value === inst);
                    if (option) filters.push({ type: 'instructor', value: inst, label: 'Instructor: ' + option.text });
                });
            }
            
            if (startDate || endDate) {
                const dateLabel = startDate && endDate ? `Date: ${startDate} to ${endDate}` : startDate ? `Date: from ${startDate}` : `Date: until ${endDate}`;
                filters.push({ type: 'date', value: '', label: dateLabel });
            }
            
            if (filters.length === 0) {
                display.style.display = 'none';
                return;
            }
            
            display.style.display = 'flex';
            display.innerHTML = '<span style="font-size: 0.75rem; font-weight: 600; color: var(--text-light); align-self: center;">Active filters:</span>' +
                filters.map(f => {
                    const typeAttr = escapeHtml(f.type);
                    const valueAttr = escapeHtml(f.value || '');
                    return `<span style="display: inline-flex; align-items: center; gap: 0.35rem; padding: 0.25rem 0.5rem; background: var(--primary); color: white; border-radius: 9999px; font-size: 0.75rem;" data-filter-type="${typeAttr}" data-filter-value="${valueAttr}">
                        ${escapeHtml(f.label)}
                        <button type="button" onclick="clearGlobalFilterFromNode(this)" style="background: none; border: none; color: white; cursor: pointer; padding: 0; width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; border-radius: 50%; font-weight: bold;" title="Remove filter">×</button>
                    </span>`;
                }).join('');
        }
        function setAnalyticsLastUpdated() {
            const el = document.getElementById('analyticsLastUpdated');
            if (el) el.textContent = 'Last updated: ' + (new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }));
        }
        
        function getOverallScorePct(eval) {
            let d = eval.evaluation_data;
            if (typeof d === 'string') try { d = JSON.parse(d); } catch (e) { return null; }
            if (!d?.sections || typeof d.sections !== 'object') return null;
            const pcts = [];
            Object.values(d.sections).forEach(section => {
                if (section.score != null && section.maxScore) pcts.push((parseFloat(section.score) / parseFloat(section.maxScore)) * 100);
                (section.subcategories || section.feedback || []).forEach(item => {
                    if (item.points != null && item.maxPoints) pcts.push((parseFloat(item.points) / parseFloat(item.maxPoints)) * 100);
                });
            });
            return pcts.length ? pcts.reduce((a, b) => a + b, 0) / pcts.length : null;
        }
        
        // Filter analytics data (concurrent multi-select filtering)
        function filterAnalytics() {
            // Get all multi-select filter values
            const courseIds = getMultiSelectValues(document.getElementById('analyticsGlobalCourse'));
            const instructorIds = getMultiSelectValues(document.getElementById('analyticsGlobalInstructor'));
            
            // Get single-select filters from Export tab
            const instSel = document.getElementById('analyticsInstructorFilter');
            const courseSel = document.getElementById('analyticsCourseFilter');
            const searchEl = document.getElementById('analyticsSearch');
            const scoreBandEl = document.getElementById('analyticsScoreBand');
            
            let filtered = analyticsData.evaluations || [];
            
            // Filter by course (multi-select OR logic)
            if (courseIds.length > 0) {
                filtered = filtered.filter(e => courseIds.includes(e.course_id));
            } else if (courseSel && courseSel.value !== 'all') {
                // Fallback to single-select from Export tab
                filtered = filtered.filter(e => e.course_id === courseSel.value);
            }
            
            // Filter by instructor (multi-select OR logic)
            if (instructorIds.length > 0) {
                filtered = filtered.filter(e => instructorIds.includes(e.instructor_id));
            } else if (instSel && instSel.value !== 'all') {
                // Fallback to single-select from Export tab
                filtered = filtered.filter(e => e.instructor_id === instSel.value);
            }
            
            // Filter by search term
            const searchTerm = (searchEl && searchEl.value || '').toLowerCase();
            if (searchTerm) {
                filtered = filtered.filter(e => {
                    const studentName = e.course_students ? `${e.course_students.first_name} ${e.course_students.last_name}`.toLowerCase() : '';
                    const courseName = e.courses?.name?.toLowerCase() || '';
                    return studentName.includes(searchTerm) || courseName.includes(searchTerm);
                });
            }
            
            // Filter by score band
            const scoreBand = scoreBandEl ? scoreBandEl.value : 'all';
            if (scoreBand !== 'all') {
                filtered = filtered.filter(e => {
                    const pct = getOverallScorePct(e);
                    if (pct == null) return scoreBand === 'all';
                    if (scoreBand === 'at-risk') return pct < 60;
                    if (scoreBand === 'strong') return pct >= 80;
                    return true;
                });
            }
            
            analyticsData.filtered = filtered;
            analyticsEvaluationsPage = 0;
            renderOverviewTab();
            renderComparisonsTab();
            renderEvaluationsTab();
            if (typeof renderExportPreview === 'function') renderExportPreview();
        }
        
        // Search evaluations (delegate to filterAnalytics so search + score band + filters stay in sync)
        function searchEvaluations() {
            filterAnalytics();
        }
        
        // Render Overview Tab (stats only; Department/All Institutions courses are in wrappers above)
        function renderOverviewTab() {
            const container = document.getElementById('overviewStatsContainer');
            if (!container) return;
            
            // Super Admin: platform-level analytics (same design as admin/instructor boards)
            const platform = analyticsData.superAdminPlatform;
            if (typeof isSuperAdmin === 'function' && isSuperAdmin() && platform) {
                const consentPct = platform.consentTotal > 0 ? Math.round((platform.consentGiven / platform.consentTotal) * 100) : 0;
                function kpiCard(title, value, subtext, status) {
                    const statusClass = (status === 'Limited' || status === 'Insufficient N') ? (status === 'Insufficient N' ? 'insufficient' : 'limited') : 'ok';
                    return '<div class="kpi-card" style="display: flex; flex-direction: column; min-height: 120px;"><div class="kpi-title">' + escapeHtml(title) + '</div><div class="kpi-value">' + escapeHtml(String(value)) + '</div>' + (subtext ? '<div class="kpi-subtext">' + escapeHtml(subtext) + '</div>' : '') + '<div style="flex: 1;"></div><div class="kpi-meta" style="margin-top: auto;">' + (status ? '<span class="kpi-badge ' + statusClass + '">' + escapeHtml(status) + '</span>' : '') + '</div></div>';
                }
                function chartCard(title, subtitle, bodyContent) {
                    return '<div class="chart-card"><div class="chart-title">' + escapeHtml(title) + '</div>' + (subtitle ? '<div class="chart-subtitle">' + escapeHtml(subtitle) + '</div>' : '') + '<div class="chart-body" style="min-height: 180px;">' + (bodyContent || '') + '</div></div>';
                }
                let html = '<div class="dashboard-kpi-grid">';
                html += kpiCard('Institutions', platform.institutionsCount, 'active institutions', '');
                html += kpiCard('Users', platform.usersCount, 'accounts', '');
                html += kpiCard('Courses', platform.coursesCount, 'total courses', '');
                html += kpiCard('Evaluations', platform.evaluationsCount, 'total completed', '');
                html += kpiCard('Consent rate', platform.consentTotal > 0 ? consentPct + '%' : '—', platform.consentTotal > 0 ? platform.consentGiven + ' of ' + platform.consentTotal + ' responses' : 'no consent data', '');
                html += '</div>';
                const byInst = platform.byInstitution || [];
                const tableBody = byInst.length ? '<table class="data-table" style="width:100%; font-size:0.9rem;"><thead><tr><th style="text-align:left;">Institution</th><th style="text-align:center;">Evaluations</th><th style="text-align:center;">Courses</th></tr></thead><tbody>' + byInst.map(r => '<tr><td>' + escapeHtml(r.name) + '</td><td style="text-align:center;">' + r.evaluations + '</td><td style="text-align:center;">' + (r.courses || 0) + '</td></tr>').join('') + '</tbody></table>' : '<p style="color: var(--text-light); padding: 1rem;">No evaluation data by institution yet.</p>';
                html += '<div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">';
                html += chartCard('Evaluations by institution', 'Usage breakdown across institutions.', tableBody);
                html += '</div>';
                html += '<div style="background: var(--bg-alt); padding: 0.75rem 1rem; border-radius: 0.5rem; border-left: 4px solid var(--primary); margin-top: 1rem;"><p style="margin: 0; color: var(--text); font-size: 0.85rem;"><strong>Tip:</strong> Use the <strong>All Institutions</strong> table below to filter courses. Use <strong>Evaluations</strong> and <strong>Data Export</strong> tabs for detailed data.</p></div>';
                container.innerHTML = html;
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: container });
                return;
            }
            
            const evals = analyticsData.filtered;
            if (evals.length === 0) {
                const isFiltered = analyticsData.evaluations && analyticsData.evaluations.length > 0;
                container.innerHTML = isFiltered
                    ? '<div style="text-align: center; padding: 2rem 1.5rem; color: var(--text-light);"><p style="font-size: 1.5rem; margin-bottom: 0.5rem;"><i data-lucide="search" style="width:2rem;height:2rem;display:inline-block;"></i></p><p style="font-weight: 600; margin-bottom: 0.25rem; color: var(--text);">No evaluations match your filters</p><p style="font-size: 0.9rem; margin-bottom: 1rem;">Try broadening the date range or clearing filters above.</p></div>'
                    : '<div style="text-align: center; padding: 2rem 1.5rem; color: var(--text-light);"><p style="font-size: 1.5rem; margin-bottom: 0.5rem;"><i data-lucide="bar-chart-2" style="width:2rem;height:2rem;display:inline-block;"></i></p><p style="font-weight: 600; margin-bottom: 0.25rem; color: var(--text);">No evaluation data yet</p><p style="font-size: 0.9rem; margin-bottom: 1rem;">Set a date range in the filter bar above and click Apply to load analytics.</p><button type="button" onclick="document.getElementById(\'analyticsGlobalApply\') && document.getElementById(\'analyticsGlobalApply\').click()" class="btn" style="background: var(--primary); color: white;">Apply</button></div>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: container });
                return;
            }
            
            const uniqueStudents = new Set(evals.map(e => e.student_id)).size;
            const uniqueCourses = new Set(evals.map(e => e.course_id)).size;
            const uniqueInstructorIds = new Set(evals.map(e => e.instructor_id));
            const isFiltered = analyticsData.filtered.length !== analyticsData.evaluations.length;
            const isAdminView = (typeof userTier !== 'undefined' && userTier === 'demo' && typeof demoViewAs !== 'undefined' && demoViewAs === 'admin') || (typeof isAdmin === 'function' && isAdmin() && typeof currentUser !== 'undefined' && currentUser && currentUser.department_id);
            
            const byInstructor = [];
            uniqueInstructorIds.forEach(instId => {
                const inst = analyticsData.instructors.find(i => i.id === instId);
                const count = evals.filter(e => e.instructor_id === instId).length;
                byInstructor.push({ name: inst?.full_name || inst?.email || 'Unknown', count });
            });
            byInstructor.sort((a, b) => b.count - a.count);
            
            const byMonth = {};
            evals.forEach(e => {
                const key = (e.created_at || '').slice(0, 7);
                if (key) byMonth[key] = (byMonth[key] || 0) + 1;
            });
            const volumeRows = Object.entries(byMonth).sort((a, b) => b[0].localeCompare(a[0])).slice(0, 12);
            
            let high = 0, medium = 0, low = 0;
            const pctList = [];
            evals.forEach(e => {
                const pct = getOverallScorePct(e);
                if (pct != null) { pctList.push(pct); if (pct >= 80) high++; else if (pct >= 60) medium++; else low++; }
            });
            const totalScored = high + medium + low;
            const outcomeAttainmentPct = totalScored ? Math.round(((high + medium) / totalScored) * 100) : 0;
            const avgPct = pctList.length ? (pctList.reduce((a, b) => a + b, 0) / pctList.length).toFixed(1) : '—';
            
            const categoryAvgs = {};
            evals.forEach(e => {
                let d = e.evaluation_data;
                if (typeof d === 'string') try { d = JSON.parse(d); } catch (e) { return; }
                if (!d?.sections || typeof d.sections !== 'object') return;
                Object.entries(d.sections).forEach(([name, section]) => {
                    if (!categoryAvgs[name]) categoryAvgs[name] = [];
                    if (section.score != null && section.maxScore) categoryAvgs[name].push((parseFloat(section.score) / parseFloat(section.maxScore)) * 100);
                    (section.subcategories || section.feedback || []).forEach(item => {
                        if (item.name && item.points != null && item.maxPoints) {
                            if (!categoryAvgs[item.name]) categoryAvgs[item.name] = [];
                            categoryAvgs[item.name].push((parseFloat(item.points) / parseFloat(item.maxPoints)) * 100);
                        }
                    });
                });
            });
            const focusAreasAll = Object.entries(categoryAvgs)
                .map(([name, arr]) => ({ name, avg: arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : 0 }))
                .filter(c => c.avg > 0)
                .sort((a, b) => a.avg - b.avg);
            const focusAreas = focusAreasAll.slice(0, 3);
            const topOpportunity = focusAreas[0];
            const topStrength = focusAreasAll.length ? focusAreasAll[focusAreasAll.length - 1] : null;
            
            function kpiCard(title, value, subtext, delta, status) {
                const statusClass = status === 'Limited' ? 'limited' : status === 'Insufficient N' ? 'insufficient' : 'ok';
                const titleSlug = title.toLowerCase().replace(/[^a-z0-9]+/g, '-');
                return `<div class="kpi-card" style="display: flex; flex-direction: column; min-height: 120px;">
                    <div class="kpi-title" style="cursor: pointer; text-decoration: underline; text-decoration-style: dotted;" onclick="showMetricDefinition('${titleSlug}', '${escapeHtml(title).replace(/'/g, '\\\'')}')" title="Click for definition">${escapeHtml(title)}</div>
                    <div class="kpi-value">${escapeHtml(String(value))}</div>
                    ${subtext ? `<div class="kpi-subtext">${escapeHtml(subtext)}</div>` : ''}
                    <div style="flex: 1;"></div>
                    <div class="kpi-meta" style="margin-top: auto;">${status ? `<span class="kpi-badge ${statusClass}">${escapeHtml(status)}</span>` : ''}${delta ? `<span>${escapeHtml(delta)}</span>` : ''}</div>
                </div>`;
            }
            function chartCard(title, subtitle, height, bodyContent) {
                var h = height || 180;
                var body = bodyContent != null ? '<div class="chart-body" style="min-height:' + h + 'px;">' + bodyContent + '</div>' : '<div class="chart-body" style="min-height:' + h + 'px;"></div>';
                const titleSlug = title.toLowerCase().replace(/[^a-z0-9]+/g, '-');
                return '<div class="chart-card"><div class="chart-title" style="cursor: pointer; text-decoration: underline; text-decoration-style: dotted;" onclick="showMetricDefinition(\'' + titleSlug + '\', \'' + escapeHtml(title).replace(/'/g, '\\\'') + '\')" title="Click for definition">' + escapeHtml(title) + '</div>' + (subtitle ? '<div class="chart-subtitle">' + escapeHtml(subtitle) + '</div>' : '') + body + '</div>';
            }
            
            // Per-outcome % meeting threshold (60%): for each rubric dimension, count evals where that dimension's score >= 60%
            var outcomeByCategory = focusAreasAll.map(function(c) {
                var arr = categoryAvgs[c.name];
                if (!arr || !arr.length) return { name: c.name, pct: 0 };
                var meeting = arr.filter(function(p) { return p >= 60; }).length;
                return { name: c.name, pct: evals.length ? Math.round((meeting / evals.length) * 100) : 0 };
            }).sort(function(a, b) { return b.pct - a.pct; });
            var courseStats = {};
            evals.forEach(function(e) {
                var cid = e.course_id; var name = (e.courses && e.courses.name) || 'Unknown';
                if (!courseStats[cid]) courseStats[cid] = { name: name, pcts: [] };
                var p = getOverallScorePct(e); if (p != null) courseStats[cid].pcts.push(p);
            });
            var courseRows = Object.keys(courseStats).map(function(cid) {
                var c = courseStats[cid]; var avg = c.pcts.length ? (c.pcts.reduce(function(a, b) { return a + b; }, 0) / c.pcts.length).toFixed(1) : '—';
                return { name: c.name, avg: avg, n: c.pcts.length };
            }).sort(function(a, b) { return parseFloat(b.avg) - parseFloat(a.avg); });
            // Section variability: mean and SD per dimension (hover/title for N)
            function stdDev(arr) {
                if (!arr || arr.length < 2) return 0;
                var mean = arr.reduce(function(a, b) { return a + b; }, 0) / arr.length;
                var sq = arr.reduce(function(s, x) { return s + (x - mean) * (x - mean); }, 0);
                return Math.sqrt(sq / (arr.length - 1));
            }
            var sectionVariabilityRows = focusAreasAll.map(function(c) {
                var arr = categoryAvgs[c.name] || [];
                var sd = arr.length ? stdDev(arr).toFixed(1) : '—';
                return { name: c.name, mean: c.avg.toFixed(1), sd: sd, n: arr.length };
            });
            // Modality: aggregate by course modality (in-person / online / hybrid)
            var byModality = {};
            evals.forEach(function(e) {
                var mod = (e.courses && e.courses.modality) ? e.courses.modality : 'unknown';
                if (!byModality[mod]) byModality[mod] = { n: 0, pcts: [] };
                byModality[mod].n++;
                var p = getOverallScorePct(e); if (p != null) byModality[mod].pcts.push(p);
            });
            var modalityRows = Object.keys(byModality).map(function(mod) {
                var o = byModality[mod];
                var avg = o.pcts.length ? (o.pcts.reduce(function(a, b) { return a + b; }, 0) / o.pcts.length).toFixed(1) : '—';
                return { modality: mod, n: o.n, avg: avg };
            }).sort(function(a, b) { return b.n - a.n; });
            function barRow(label, pct) { var w = Math.min(100, Math.max(0, pct)); var color = w >= 80 ? 'var(--success)' : w >= 60 ? 'var(--warning)' : 'var(--error)'; return '<div style="margin-bottom:0.5rem;"><div style="display:flex;justify-content:space-between;font-size:0.85rem;margin-bottom:0.2rem;"><span>' + escapeHtml(label) + '</span><span>' + pct + '%</span></div><div style="height:8px;background:var(--bg-alt);border-radius:4px;overflow:hidden;"><div style="height:100%;width:' + w + '%;background:' + color + ';border-radius:4px;"></div></div></div>'; }
            var outcomeBody = outcomeByCategory.length ? outcomeByCategory.map(function(r) { return barRow(r.name, r.pct); }).join('') : '<p style="color:var(--text-light);padding:1rem;">No category data.</p>';
            var suppressN = 5;
            var modalityBody = modalityRows.length ? modalityRows.map(function(r) {
                var show = r.n >= suppressN;
                var pctVal = (typeof r.avg === 'string' && r.avg !== '—') ? parseFloat(r.avg) : (typeof r.avg === 'number' ? r.avg : null);
                var pctNum = (pctVal != null && !isNaN(pctVal)) ? Math.round(pctVal) : 0;
                return show ? barRow(r.modality.charAt(0).toUpperCase() + r.modality.slice(1) + ' (n=' + r.n + ')', pctNum) : '<div style="margin-bottom:0.5rem;font-size:0.85rem;color:var(--text-light);">' + escapeHtml(r.modality.charAt(0).toUpperCase() + r.modality.slice(1)) + ': <em>Suppressed (n&lt;' + suppressN + ')</em></div>';
            }).join('') : '<p style="color:var(--text-light);padding:1rem;">Add course modality to see comparison. Use Data Export to load data.</p>';
            var courseBody = courseRows.length ? '<table class="data-table" style="width:100%;font-size:0.9rem;"><thead><tr><th style="text-align:left;">Course</th><th style="text-align:center;">N</th><th style="text-align:center;">Avg %</th></tr></thead><tbody>' + courseRows.map(function(r) { return '<tr><td>' + escapeHtml(r.name) + '</td><td style="text-align:center;">' + r.n + '</td><td style="text-align:center;">' + r.avg + '%</td></tr>'; }).join('') + '</tbody></table>' : '<p style="color:var(--text-light);padding:1rem;">No course data.</p>';
            var sectionBody = sectionVariabilityRows.length ? '<table class="data-table" style="width:100%;font-size:0.9rem;"><thead><tr><th style="text-align:left;">Dimension</th><th style="text-align:center;">Mean %</th><th style="text-align:center;">SD</th><th>N</th></tr></thead><tbody>' + sectionVariabilityRows.map(function(r) { return '<tr title="N=' + r.n + '"><td>' + escapeHtml(r.name) + '</td><td style="text-align:center;">' + r.mean + '%</td><td style="text-align:center;">' + r.sd + '</td><td>' + r.n + '</td></tr>'; }).join('') + '</tbody></table>' : '<p style="color:var(--text-light);padding:1rem;">No section data.</p>';
            var accreditationBody = '<p style="font-size:0.875rem;margin-bottom:0.75rem;">' + (totalScored ? outcomeAttainmentPct + '% of evaluations met threshold (≥60%) across selected courses/terms.' : 'No outcome data yet.') + '</p><p style="font-size:0.8rem;color:var(--text-light);">Export outcomes report with definitions appendix from the <strong>Data Export</strong> tab (CSV).</p>';
            var modalityReportBody = modalityRows.length ? '<table class="data-table" style="width:100%;font-size:0.9rem;"><thead><tr><th style="text-align:left;">Modality</th><th style="text-align:center;">N</th><th style="text-align:center;">Avg %</th></tr></thead><tbody>' + modalityRows.filter(function(r) { return r.n >= suppressN; }).map(function(r) { return '<tr><td>' + escapeHtml(r.modality.charAt(0).toUpperCase() + r.modality.slice(1)) + '</td><td style="text-align:center;">' + r.n + '</td><td style="text-align:center;">' + r.avg + '%</td></tr>'; }).join('') + '</tbody></table>' + (modalityRows.some(function(r) { return r.n < suppressN; }) ? '<p style="font-size:0.75rem;color:var(--text-light);margin-top:0.5rem;">Cells with n&lt;' + suppressN + ' suppressed.</p>' : '') : '<p style="font-size:0.875rem;color:var(--text-light);">Add course modality to compare online vs in-person. Suppression applied for n&lt;' + suppressN + '.</p>';
            var normingBody = '<p style="font-size:0.875rem;margin-bottom:0.5rem;">Calibration: <strong>Stable</strong>. No drift detected in the selected period.</p><p style="font-size:0.8rem;color:var(--text-light);">Use for rater alignment only; not for punitive ranking.</p>';
            
            let html = '';
            
            if (isAdminView) {
                var blocks = {};
                blocks['kpi-row'] = kpiCard('Outcome Attainment', totalScored ? outcomeAttainmentPct + '%' : '—', 'meeting threshold', '', totalScored ? 'OK' : 'Insufficient N') + kpiCard('Across-section Variability', byInstructor.length > 1 ? '—' : '—', '', '', 'OK') + kpiCard('Modality Gap', '—', 'online vs in-person', '', 'Limited') + kpiCard('Calibration Signals', 'Stable', 'alignment indicator', '', 'OK') + kpiCard('Total Evaluations', evals.length, '') + kpiCard('Access / Quality Flags', '—', '', '', 'Limited');
                blocks['chart-outcome'] = chartCard('Outcome attainment by outcome', '% meeting threshold across selected courses/terms.', 260, outcomeBody);
                blocks['chart-modality'] = chartCard('Modality comparison', 'Distribution comparison by modality (suppressed below thresholds).', 260, modalityBody);
                blocks['chart-course'] = chartCard('Course comparisons', 'OPI distributions across course types.', 260, courseBody);
                blocks['chart-section'] = chartCard('Section variability map', 'Sections × rubric dimensions (mean; hover for N/SD).', 260, sectionBody);
                blocks['chart-accreditation'] = chartCard('Accreditation-ready summary', 'Export outcomes report with definitions appendix.', 150, accreditationBody);
                blocks['chart-modality-report'] = chartCard('Modality report', 'Compare online vs in-person patterns with suppression thresholds.', 150, modalityReportBody);
                blocks['chart-norming'] = chartCard('Norming summary', 'Calibration signals and drift checks (carefully framed).', 150, normingBody);
                var overviewWidgets = (typeof getOverviewWidgets === 'function' ? getOverviewWidgets() : []).filter(function(w) { return w.visible !== false; }).sort(function(a, b) { return (a.order || 0) - (b.order || 0); });
                if (!overviewWidgets.length) overviewWidgets = DEFAULT_OVERVIEW_WIDGETS.filter(function(w) { return w.visible !== false; }).sort(function(a, b) { return a.order - b.order; });
                var kpiDone = false;
                var chartParts = [];
                overviewWidgets.forEach(function(w) {
                    if (w.id === 'kpi-row' && blocks['kpi-row']) { html += '<div class="dashboard-kpi-grid">' + blocks['kpi-row'] + '</div>'; kpiDone = true; }
                    else if (blocks[w.id]) chartParts.push(blocks[w.id]);
                    else if (w.custom === true || String(w.id).indexOf('custom_') === 0) chartParts.push(chartCard(w.label || 'Custom section', (w.dataQuery ? 'Data: ' + w.dataQuery : 'Set data query in Edit cards (e.g. by course, by instructor).'), 200, typeof renderCustomCardBody === 'function' ? renderCustomCardBody(w, evals) : '<p style="color:var(--text-light);padding:1rem;">Use Edit cards to set a data query.</p>'));
                });
                if (chartParts.length) html += '<div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">' + chartParts.join('') + '</div>';
            } else {
                // Instructor: minimal default — 4 KPIs, 2 key charts, link to Evaluations
                html += '<div class="dashboard-kpi-grid">';
                html += kpiCard('Overall Performance', avgPct !== '—' ? avgPct + '%' : '—', 'avg score', '', totalScored ? 'OK' : 'Insufficient N');
                html += kpiCard('Top Strength', topStrength ? escapeHtml(topStrength.name) : '—', '', '', 'OK');
                html += kpiCard('Top Opportunity', topOpportunity ? escapeHtml(topOpportunity.name) : '—', '', '', 'Limited');
                html += kpiCard('Total Evaluations', evals.length, '');
                html += '</div>';
                html += '<div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">';
                html += chartCard('OPI Distribution', 'Score spread and outcomes by dimension.', 260);
                html += '<div class="chart-card"><div class="chart-title">Students Needing Targeted Feedback</div><div class="chart-subtitle">View student timeline or evidence from Evaluations.</div><div style="padding:0.5rem 0;"><a href="#" onclick="switchAnalyticsTab(\'evaluations\'); return false;" class="btn" style="background: var(--primary); color: white; font-size: 0.875rem;">View Evaluations</a></div><div class="chart-footer"><a href="#" onclick="return false;">Definitions &amp; limitations</a></div></div>';
                html += '</div>';
            }
            html += '<div style="background: var(--bg-alt); padding: 0.75rem 1rem; border-radius: 0.5rem; border-left: 4px solid var(--primary); margin-top: 1rem;"><p style="margin: 0; color: var(--text); font-size: 0.85rem;"><strong>Tip:</strong> Set date range above and click <strong>Apply</strong> to refresh. Use <strong>Evaluations</strong> to search and open records; <strong>Data Export</strong> to export CSV.</p></div>';
            
            container.innerHTML = html;
        }
        
        // Render Rubrics Tab - Rubric dropdown + structure + category analysis
        async function renderRubricsTab() {
            const container = document.getElementById('analyticsRubricsTab');
            if (!container) return;
            
            const savedSelection = document.getElementById('analyticsRubricSelect')?.value || '';
            const allRubrics = typeof getAllRubrics === 'function' ? await getAllRubrics() : [];
            const evalsAll = analyticsData.filtered || [];
            
            const rubricOptions = allRubrics.length ? allRubrics.map(r => `<option value="${escapeHtml(String(r.id))}">${escapeHtml(r.name || 'Unnamed')}</option>`).join('') : '';
            const dropdownHtml = `
                <div class="card" style="margin-bottom: 1.5rem;">
                    <div class="card-header" style="margin-bottom: 0;">Select rubric</div>
                    <div style="padding: 1rem;">
                        <label for="analyticsRubricSelect" style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Rubric</label>
                        <select id="analyticsRubricSelect" onchange="renderRubricsTab()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; font-size: 0.9rem; min-width: 14rem;">
                            <option value="">All rubrics (combined)</option>
                            ${rubricOptions}
                        </select>
                        <p style="margin-top: 0.5rem; font-size: 0.85rem; color: var(--text-light);">View the rubric structure and performance analysis for the selected rubric.</p>
                    </div>
                </div>`;
            
            if (evalsAll.length === 0) {
                container.innerHTML = dropdownHtml + `
                    <div class="card" style="text-align: center; padding: 3rem 1.5rem; color: var(--text-light); max-width: 28rem; margin: 0 auto;">
                        <p style="font-size: 2rem; margin-bottom: 0.5rem;"><i data-lucide="clipboard-list" style="width:2rem;height:2rem;display:inline-block;"></i></p>
                        <p style="font-weight: 600; margin-bottom: 0.25rem; color: var(--text);">No evaluation data</p>
                        <p style="font-size: 0.9rem; margin-bottom: 1.25rem;">Load analytics to see rubric performance.</p>
                        <button type="button" onclick="switchAnalyticsTab('evaluations')" class="btn" style="background: var(--primary); color: white;">Load data</button>
                    </div>`;
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: container });
                const sel = document.getElementById('analyticsRubricSelect');
                if (sel && savedSelection) sel.value = savedSelection;
                return;
            }
            
            const selectedRubricId = savedSelection || document.getElementById('analyticsRubricSelect')?.value || '';
            const evals = selectedRubricId ? evalsAll.filter(e => (e.rubric_id || e.rubric?.id) == selectedRubricId) : evalsAll;
            const selectedRubric = selectedRubricId && typeof getRubricById === 'function' ? await getRubricById(selectedRubricId) : null;
            
            let structureHtml = '';
            if (selectedRubric && selectedRubric.categories && selectedRubric.categories.length) {
                structureHtml = `
                <div class="card" style="margin-bottom: 1.5rem;">
                    <div class="card-header" style="margin-bottom: 0;">Rubric structure — ${escapeHtml(selectedRubric.name || 'Unnamed')}</div>
                    <div style="padding: 1rem;">
                        <p style="color: var(--text-light); font-size: 0.9rem; margin-bottom: 1rem;">${selectedRubric.totalPoints || 0} points total${selectedRubric.speechType ? ' • ' + escapeHtml(selectedRubric.speechType) : ''}</p>
                        <ul style="margin: 0; padding-left: 1.25rem;">
                            ${(selectedRubric.categories || []).map(cat => {
                                const c = typeof cat === 'object' && cat !== null ? cat : { name: String(cat), subcategories: [] };
                                const subs = (c.subcategories || c.feedback || []).map(s => typeof s === 'object' && s !== null ? `<li style="margin-left: 1rem; font-size: 0.9rem;">${escapeHtml(s.name || '')} ${s.maxPoints != null ? `(${s.points != null ? s.points : 0}/${s.maxPoints})` : ''}</li>` : '').join('');
                                return `<li style="margin-bottom: 0.35rem;"><strong>${escapeHtml(c.name || '')}</strong>${c.maxScore != null ? ` — ${c.score != null ? c.score : 0}/${c.maxScore} pts` : ''}${subs ? `<ul style="margin: 0.25rem 0 0 0;">${subs}</ul>` : ''}</li>`;
                            }).join('')}
                        </ul>
                    </div>
                </div>`;
            } else if (selectedRubricId && !selectedRubric) {
                structureHtml = '<p style="color: var(--text-light); font-size: 0.9rem; margin-bottom: 1rem;">Rubric structure not found for selected rubric.</p>';
            }
            
            const categoryStats = {};
            evals.forEach(eval => {
                let evalData = eval.evaluation_data;
                if (typeof evalData === 'string') { try { evalData = JSON.parse(evalData); } catch (e) { return; } }
                if (!evalData || !evalData.sections || typeof evalData.sections !== 'object') return;
                Object.entries(evalData.sections).forEach(([sectionName, section]) => {
                    if (!categoryStats[sectionName]) categoryStats[sectionName] = { name: sectionName, percentages: [], total: 0, count: 0 };
                    if (section.score != null && section.maxScore) {
                        const pct = (parseFloat(section.score) / parseFloat(section.maxScore)) * 100;
                        categoryStats[sectionName].percentages.push(pct);
                        categoryStats[sectionName].total += pct;
                        categoryStats[sectionName].count++;
                    }
                    (section.subcategories || section.feedback || []).forEach(item => {
                        if (!item || !item.name) return;
                        if (!categoryStats[item.name]) categoryStats[item.name] = { name: item.name, percentages: [], total: 0, count: 0 };
                        if (item.points != null && item.maxPoints) {
                            const pct = (parseFloat(item.points) / parseFloat(item.maxPoints)) * 100;
                            categoryStats[item.name].percentages.push(pct);
                            categoryStats[item.name].total += pct;
                            categoryStats[item.name].count++;
                        }
                    });
                });
            });
            
            let categories = Object.values(categoryStats).map(cat => ({
                ...cat,
                average: cat.count > 0 ? (cat.total / cat.count).toFixed(1) : 0,
                min: cat.percentages.length ? Math.min(...cat.percentages).toFixed(1) : 0,
                max: cat.percentages.length ? Math.max(...cat.percentages).toFixed(1) : 0
            })).sort((a, b) => parseFloat(b.average) - parseFloat(a.average));
            const focusCat = document.getElementById('analyticsFocusCategory')?.value;
            if (focusCat) categories = categories.filter(c => c.name === focusCat);
            
            let tableHtml = '';
            if (categories.length) {
                tableHtml = `
                <div class="card" style="margin-bottom: 1.5rem;">
                    <div class="card-header">Performance analysis${selectedRubricId ? ' — ' + escapeHtml(selectedRubric?.name || 'Selected rubric') : ' (all rubrics)'}</div>
                    <div style="padding: 1rem;">
                        <p style="color: var(--text-light); margin: 0 0 1rem 0; font-size: 0.9rem;">
                            Normalized averages (0–100%) across ${evals.length} evaluation${evals.length !== 1 ? 's' : ''}.
                        </p>
                        <div style="overflow-x: auto;">
                            <table class="data-table" style="width: 100%; min-width: 480px;">
                                <thead><tr><th style="text-align: left;">Category</th><th style="text-align: center;">Avg %</th><th style="text-align: center;">Min</th><th style="text-align: center;">Max</th><th style="text-align: center;">Count</th><th style="text-align: left;">Distribution</th></tr></thead>
                                <tbody>
                                    ${categories.map(cat => {
                                        const avgPct = parseFloat(cat.average);
                                        const barColor = avgPct >= 80 ? 'var(--success)' : avgPct >= 60 ? 'var(--warning)' : 'var(--error)';
                                        const barWidth = Math.min(100, Math.max(0, avgPct));
                                        return `<tr><td><strong>${escapeHtml(cat.name)}</strong></td><td style="text-align: center; font-weight: 600; color: ${barColor};">${cat.average}%</td><td style="text-align: center; color: var(--text-light); font-size: 0.9rem;">${cat.min}%</td><td style="text-align: center; color: var(--text-light); font-size: 0.9rem;">${cat.max}%</td><td style="text-align: center;">${cat.count}</td><td><div style="background: var(--bg-alt); height: 18px; border-radius: 9px; overflow: hidden; max-width: 160px;"><div style="background: ${barColor}; width: ${barWidth}%; height: 100%;"></div></div></td></tr>`;
                                    }).join('')}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>`;
            } else if (evals.length > 0) {
                tableHtml = '<p style="color: var(--text-light); font-size: 0.9rem;">No category scores in evaluations for this selection.</p>';
            }
            
            container.innerHTML = dropdownHtml + structureHtml + tableHtml;
            const sel = document.getElementById('analyticsRubricSelect');
            if (sel && (savedSelection || selectedRubricId)) sel.value = selectedRubricId || savedSelection;
        }
        
        // Render Comparisons Tab - Course and instructor comparisons
        function renderComparisonsTab() {
            const evals = analyticsData.filtered;
            const container = document.getElementById('analyticsComparisonsTab');
            
            if (evals.length === 0) {
                container.innerHTML = `
                    <div class="card" style="text-align: center; padding: 3rem 1.5rem; color: var(--text-light); max-width: 28rem; margin: 0 auto;">
                        <p style="font-size: 2rem; margin-bottom: 0.5rem;">📈</p>
                        <p style="font-weight: 600; margin-bottom: 0.25rem; color: var(--text);">No comparison data</p>
                        <p style="font-size: 0.9rem; margin-bottom: 1.25rem;">Load analytics to compare courses and instructors.</p>
                        <button type="button" onclick="switchAnalyticsTab('evaluations')" class="btn" style="background: var(--primary); color: white;">Load data</button>
                    </div>`;
                return;
            }
            
            function avgPctForEvals(evaluations) {
                let all = [];
                evaluations.forEach(e => {
                    let d = e.evaluation_data;
                    if (typeof d === 'string') try { d = JSON.parse(d); } catch (err) { return; }
                    if (!d?.sections || typeof d.sections !== 'object') return;
                    Object.values(d.sections).forEach(section => {
                        if (section.score != null && section.maxScore) all.push((parseFloat(section.score) / parseFloat(section.maxScore)) * 100);
                        (section.subcategories || section.feedback || []).forEach(item => {
                            if (item.points != null && item.maxPoints) all.push((parseFloat(item.points) / parseFloat(item.maxPoints)) * 100);
                        });
                    });
                });
                return all.length ? (all.reduce((a, b) => a + b, 0) / all.length).toFixed(1) : 0;
            }
            
            // By course
            const courseStats = {};
            evals.forEach(eval => {
                const courseId = eval.course_id;
                if (!courseStats[courseId]) {
                    courseStats[courseId] = {
                        name: eval.courses?.name || 'Unknown',
                        semester: eval.courses?.semester && eval.courses?.year ? `${eval.courses.semester} ${eval.courses.year}` : '—',
                        evaluations: []
                    };
                }
                courseStats[courseId].evaluations.push(eval);
            });
            const courseComparisons = Object.values(courseStats).map(c => ({
                ...c,
                count: c.evaluations.length,
                average: parseFloat(avgPctForEvals(c.evaluations))
            })).sort((a, b) => b.average - a.average);
            
            // By instructor
            const instStats = {};
            evals.forEach(eval => {
                const id = eval.instructor_id;
                if (!instStats[id]) instStats[id] = { evaluations: [] };
                instStats[id].evaluations.push(eval);
            });
            const instComparisons = Object.entries(instStats).map(([id, o]) => {
                const inst = analyticsData.instructors.find(i => i.id === id);
                return {
                    name: inst?.full_name || inst?.email || 'Unknown',
                    count: o.evaluations.length,
                    average: parseFloat(avgPctForEvals(o.evaluations))
                };
            }).sort((a, b) => b.average - a.average);
            
            var byCourseHtml = `
                <div class="card" data-widget-id="card-course" style="margin-bottom: 2rem;">
                    <div class="card-header">By course</div>
                    <div style="padding: 1rem;">
                        <p style="color: var(--text-light); margin: 0 0 1rem 0; font-size: 0.9rem;">Normalized average score (0–100%) per course.</p>
                        <div style="overflow-x: auto;">
                            <table class="data-table" style="width: 100%; min-width: 420px;">
                                <thead><tr><th style="text-align: left;">Course</th><th style="text-align: left;">Term</th><th style="text-align: center;">Evaluations</th><th style="text-align: center;">Avg %</th><th style="text-align: left;">Performance</th></tr></thead>
                                <tbody>
            `;
            courseComparisons.forEach(course => {
                const barColor = course.average >= 80 ? 'var(--success)' : course.average >= 60 ? 'var(--warning)' : 'var(--error)';
                const barWidth = Math.min(100, Math.max(0, course.average));
                byCourseHtml += `<tr>
                    <td><strong>${escapeHtml(course.name)}</strong></td>
                    <td style="color: var(--text-light); font-size: 0.9rem;">${escapeHtml(course.semester)}</td>
                    <td style="text-align: center;">${course.count}</td>
                    <td style="text-align: center; font-weight: 600; color: ${barColor};">${course.average}%</td>
                    <td><div style="background: var(--bg-alt); height: 18px; border-radius: 9px; overflow: hidden; max-width: 140px;"><div style="background: ${barColor}; width: ${barWidth}%; height: 100%;"></div></div></td>
                </tr>`;
            });
            byCourseHtml += `</tbody></table></div></div></div>`;
            var byInstructorHtml = `
                <div class="card" data-widget-id="card-instructor">
                    <div class="card-header">By instructor</div>
                    <div style="padding: 1rem;">
                        <p style="color: var(--text-light); margin: 0 0 1rem 0; font-size: 0.9rem;">Normalized average score (0–100%) per instructor.</p>
                        <div style="overflow-x: auto;">
                            <table class="data-table" style="width: 100%; min-width: 360px;">
                                <thead><tr><th style="text-align: left;">Instructor</th><th style="text-align: center;">Evaluations</th><th style="text-align: center;">Avg %</th><th style="text-align: left;">Performance</th></tr></thead>
                                <tbody>
            `;
            instComparisons.forEach(inst => {
                const barColor = inst.average >= 80 ? 'var(--success)' : inst.average >= 60 ? 'var(--warning)' : 'var(--error)';
                const barWidth = Math.min(100, Math.max(0, inst.average));
                byInstructorHtml += `<tr>
                    <td><strong>${escapeHtml(inst.name)}</strong></td>
                    <td style="text-align: center;">${inst.count}</td>
                    <td style="text-align: center; font-weight: 600; color: ${barColor};">${inst.average}%</td>
                    <td><div style="background: var(--bg-alt); height: 18px; border-radius: 9px; overflow: hidden; max-width: 140px;"><div style="background: ${barColor}; width: ${barWidth}%; height: 100%;"></div></div></td>
                </tr>`;
            });
            byInstructorHtml += `</tbody></table></div></div></div>`;
            function customCardHtml(w) {
                return '<div class="card" data-widget-id="' + escapeHtml(w.id) + '"><div class="card-header">' + escapeHtml(w.label || 'Custom section') + '</div><div style="padding:1rem;color:var(--text-light);font-size:0.9rem;">Custom section. Use Edit cards to remove or reorder.</div></div>';
            }
            var blocks = { 'card-course': byCourseHtml, 'card-instructor': byInstructorHtml };
            var tabWidgets = (typeof getTabWidgets === 'function' ? getTabWidgets('comparisons') : []).filter(function(w) { return w.visible !== false; }).sort(function(a, b) { return (a.order || 0) - (b.order || 0); });
            if (!tabWidgets.length) tabWidgets = (DEFAULT_TAB_WIDGETS.comparisons || []).filter(function(w) { return w.visible !== false; }).sort(function(a, b) { return a.order - b.order; });
            var html = tabWidgets.map(function(w) { return blocks[w.id] || (w.custom || String(w.id).indexOf('custom_') === 0 ? customCardHtml(w) : ''); }).filter(Boolean).join('');
            container.innerHTML = html || '<p style="color: var(--text-light); padding: 1rem;">No cards visible. Use Customize → Edit cards to show cards.</p>';
        }
        
        // Render Evaluations Tab - Searchable list with drill-down
        const ANALYTICS_EVALS_PAGE_SIZE = 50;
        let analyticsEvaluationsPage = 0;
        
        // Export preview sort state (Excel-style column header sort)
        var exportPreviewSortColumn = 'date';
        var exportPreviewSortDir = 'desc';
        var EXPORT_PREVIEW_HEADER_LABELS = { date: 'Date', student: 'Student', course: 'Course', instructor: 'Instructor', score: 'Score %', rubric: 'Rubric' };
        // Column filter state: each key is column id, value is array of selected display values (empty = no filter)
        var exportPreviewColumnFilters = { date: [], student: [], course: [], instructor: [], score: [], rubric: [] };
        var exportHeaderFilterPanelOpen = null;
        
        function sortExportPreviewBy(column) {
            if (column === exportPreviewSortColumn) {
                exportPreviewSortDir = exportPreviewSortDir === 'asc' ? 'desc' : 'asc';
            } else {
                exportPreviewSortColumn = column;
                exportPreviewSortDir = 'asc';
            }
            renderExportPreview();
        }
        
        function getExportPreviewSortValue(e, column) {
            switch (column) {
                case 'date': return e.created_at ? new Date(e.created_at).getTime() : 0;
                case 'student': return (e.course_students ? (e.course_students.first_name || '') + ' ' + (e.course_students.last_name || '') : '').toLowerCase();
                case 'course': return (e.courses?.name || '').toLowerCase();
                case 'instructor': {
                    var inst = analyticsData.instructors && analyticsData.instructors.find(function(i) { return i.id === e.instructor_id; });
                    return ((inst && (inst.full_name || inst.email)) || '').toLowerCase();
                }
                case 'score': return getOverallScorePct(e) != null ? getOverallScorePct(e) : -1;
                case 'rubric': return (e.rubrics?.name || '').toLowerCase();
                default: return '';
            }
        }
        
        function getExportPreviewDisplayValue(e, column) {
            switch (column) {
                case 'date': return e.created_at ? new Date(e.created_at).toLocaleDateString() : '\u2014';
                case 'student': return e.course_students ? (e.course_students.first_name || '') + ' ' + (e.course_students.last_name || '') : '\u2014';
                case 'course': return e.courses && e.courses.name ? e.courses.name : '\u2014';
                case 'instructor': {
                    var inst = analyticsData.instructors && analyticsData.instructors.find(function(i) { return i.id === e.instructor_id; });
                    return inst && (inst.full_name || inst.email) ? (inst.full_name || inst.email) : '\u2014';
                }
                case 'score': var s = getOverallScorePct(e); return s != null ? s.toFixed(1) + '%' : '\u2014';
                case 'rubric': return e.rubrics && e.rubrics.name ? e.rubrics.name : '\u2014';
                default: return '';
            }
        }
        
        function getUniqueColumnValues(column) {
            var evals = analyticsData.filtered || [];
            var set = {};
            evals.forEach(function(e) {
                var v = getExportPreviewDisplayValue(e, column);
                if (v !== undefined && v !== null) set[v] = true;
            });
            var arr = Object.keys(set);
            arr.sort(function(a, b) { return String(a).localeCompare(String(b), undefined, { numeric: true }); });
            return arr;
        }
        
        function openExportHeaderFilter(column, button) {
            if (exportHeaderFilterPanelOpen) {
                exportHeaderFilterPanelOpen.remove();
                if (exportHeaderFilterPanelOpen.getAttribute('data-column') === column) {
                    exportHeaderFilterPanelOpen = null;
                    return;
                }
            }
            var evals = analyticsData.filtered || [];
            var unique = getUniqueColumnValues(column);
            var selected = exportPreviewColumnFilters[column] || [];
            var panel = document.createElement('div');
            panel.className = 'export-header-filter-panel';
            panel.setAttribute('data-column', column);
            var rect = button.getBoundingClientRect();
            panel.style.left = rect.left + 'px';
            panel.style.top = (rect.bottom + 4) + 'px';
            panel.innerHTML = '<div class="export-filter-toolbar"><a href="#" role="button" data-action="selectall">Select all</a><a href="#" role="button" data-action="clear">Clear</a></div><div class="export-filter-list"></div>';
            var list = panel.querySelector('.export-filter-list');
            unique.forEach(function(value) {
                var checked = selected.length === 0 || selected.indexOf(value) !== -1;
                var item = document.createElement('label');
                item.className = 'export-filter-item';
                item.innerHTML = '<input type="checkbox" ' + (checked ? 'checked' : '') + ' data-value="' + escapeHtml(value) + '"><span>' + escapeHtml(value) + '</span>';
                list.appendChild(item);
            });
            panel.querySelector('.export-filter-toolbar [data-action="selectall"]').addEventListener('click', function(e) {
                e.preventDefault();
                exportPreviewColumnFilters[column] = unique.slice();
                renderExportPreview();
                updateExportFilterPanelCheckboxes(panel, column);
            });
            panel.querySelector('.export-filter-toolbar [data-action="clear"]').addEventListener('click', function(e) {
                e.preventDefault();
                exportPreviewColumnFilters[column] = [];
                renderExportPreview();
                updateExportFilterPanelCheckboxes(panel, column);
            });
            list.addEventListener('change', function(e) {
                if (e.target.type !== 'checkbox') return;
                var value = e.target.getAttribute('data-value');
                var arr = exportPreviewColumnFilters[column] || [];
                var idx = arr.indexOf(value);
                if (e.target.checked) {
                    if (idx === -1) arr.push(value);
                } else {
                    if (idx !== -1) arr.splice(idx, 1);
                }
                exportPreviewColumnFilters[column] = arr;
                renderExportPreview();
            });
            document.body.appendChild(panel);
            exportHeaderFilterPanelOpen = panel;
        }
        
        function updateExportFilterPanelCheckboxes(panel, column) {
            if (!panel || !panel.parentNode) return;
            var selected = exportPreviewColumnFilters[column] || [];
            var allSelected = selected.length === 0;
            panel.querySelectorAll('.export-filter-item input').forEach(function(cb) {
                var value = cb.getAttribute('data-value');
                cb.checked = allSelected || selected.indexOf(value) !== -1;
            });
        }
        
        function closeExportHeaderFilterPanel() {
            if (exportHeaderFilterPanelOpen) {
                exportHeaderFilterPanelOpen.remove();
                exportHeaderFilterPanelOpen = null;
            }
        }
        
        function renderExportPreview() {
            const tbody = document.getElementById('exportPreviewTableBody');
            const countEl = document.getElementById('exportPreviewCount');
            const table = document.getElementById('exportPreviewTable');
            
            if (!tbody || !analyticsData.filtered) return;
            
            var evals = (analyticsData.filtered || []).slice();
            var previewLimit = 50;
            
            // Apply column filters (multi-select: row included if each column's value is in selected set, or no filter)
            var cols = ['date', 'student', 'course', 'instructor', 'score', 'rubric'];
            cols.forEach(function(col) {
                var sel = exportPreviewColumnFilters[col];
                if (sel && sel.length > 0) {
                    evals = evals.filter(function(e) { return sel.indexOf(getExportPreviewDisplayValue(e, col)) !== -1; });
                }
            });
            
            if (countEl) countEl.textContent = evals.length;
            
            // Update header: sort label + arrow on .export-th-sort, .has-filter on .export-th-filter
            if (table && table.tHead && table.tHead.rows[0]) {
                var row = table.tHead.rows[0];
                for (var i = 0; i < row.cells.length; i++) {
                    var th = row.cells[i];
                    var col = th.getAttribute('data-sort');
                    if (!col) continue;
                    var sortSpan = th.querySelector('.export-th-sort');
                    var filterBtn = th.querySelector('.export-th-filter');
                    if (sortSpan) {
                        var label = EXPORT_PREVIEW_HEADER_LABELS[col] || col;
                        var arrow = col === exportPreviewSortColumn ? (exportPreviewSortDir === 'asc' ? ' \u2191' : ' \u2193') : '';
                        sortSpan.textContent = label + arrow;
                    }
                    if (filterBtn) {
                        var hasFilter = exportPreviewColumnFilters[col] && exportPreviewColumnFilters[col].length > 0;
                        filterBtn.classList.toggle('has-filter', hasFilter);
                    }
                }
            }
            
            if (evals.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 2rem; color: var(--text-light);">No evaluations match the current filters</td></tr>';
                return;
            }
            
            // Sort by current column/direction
            evals.sort(function(a, b) {
                var va = getExportPreviewSortValue(a, exportPreviewSortColumn);
                var vb = getExportPreviewSortValue(b, exportPreviewSortColumn);
                var cmp = 0;
                if (typeof va === 'number' && typeof vb === 'number') cmp = va - vb;
                else cmp = String(va).localeCompare(String(vb), undefined, { numeric: true });
                return exportPreviewSortDir === 'asc' ? cmp : -cmp;
            });
            
            var html = '';
            evals.slice(0, previewLimit).forEach(function(e) {
                var date = getExportPreviewDisplayValue(e, 'date');
                var studentName = getExportPreviewDisplayValue(e, 'student');
                var courseName = getExportPreviewDisplayValue(e, 'course');
                var instructorName = getExportPreviewDisplayValue(e, 'instructor');
                var scoreDisplay = getExportPreviewDisplayValue(e, 'score');
                var rubricName = getExportPreviewDisplayValue(e, 'rubric');
                html += '<tr>' +
                    '<td style="padding: 0.75rem;">' + escapeHtml(date) + '</td>' +
                    '<td style="padding: 0.75rem;">' + escapeHtml(studentName) + '</td>' +
                    '<td style="padding: 0.75rem;">' + escapeHtml(courseName) + '</td>' +
                    '<td style="padding: 0.75rem;">' + escapeHtml(instructorName) + '</td>' +
                    '<td style="text-align: center; padding: 0.75rem;">' + scoreDisplay + '</td>' +
                    '<td style="padding: 0.75rem;">' + escapeHtml(rubricName) + '</td>' +
                    '</tr>';
            });
            
            if (evals.length > previewLimit) {
                html += '<tr><td colspan="6" style="text-align: center; padding: 1rem; background: var(--bg-alt); color: var(--text-light); font-style: italic;">Showing first ' + previewLimit + ' of ' + evals.length + ' evaluations. Export CSV to see all records.</td></tr>';
            }
            
            tbody.innerHTML = html;
        }
        
        // Delegate click on export preview table headers: sort (label) or open filter (button)
        (function initExportPreviewSort() {
            var table = document.getElementById('exportPreviewTable');
            if (!table) return;
            table.addEventListener('click', function(ev) {
                var filterBtn = ev.target && ev.target.classList && ev.target.classList.contains('export-th-filter') ? ev.target : (ev.target && ev.target.closest ? ev.target.closest('.export-th-filter') : null);
                if (filterBtn && filterBtn.getAttribute('data-sort')) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    openExportHeaderFilter(filterBtn.getAttribute('data-sort'), filterBtn);
                    return;
                }
                var sortSpan = ev.target && ev.target.classList && ev.target.classList.contains('export-th-sort') ? ev.target : (ev.target && ev.target.closest ? ev.target.closest('.export-th-sort') : null);
                var th = ev.target && ev.target.nodeName === 'TH' ? ev.target : (ev.target && ev.target.closest ? ev.target.closest('th') : null);
                if ((sortSpan || th) && !filterBtn && th && th.getAttribute('data-sort')) sortExportPreviewBy(th.getAttribute('data-sort'));
            });
            document.addEventListener('click', function(ev) {
                if (exportHeaderFilterPanelOpen && !exportHeaderFilterPanelOpen.contains(ev.target)) {
                    var btn = document.querySelector('#exportPreviewTable .export-th-filter[data-sort="' + exportHeaderFilterPanelOpen.getAttribute('data-column') + '"]');
                    if (!btn || !btn.contains(ev.target)) closeExportHeaderFilterPanel();
                }
                if (evaluationsHeaderFilterPanelOpen && !evaluationsHeaderFilterPanelOpen.contains(ev.target)) {
                    var tbl = document.getElementById('analyticsEvaluationsTable');
                    var btn = tbl && tbl.querySelector('.export-th-filter[data-sort="' + evaluationsHeaderFilterPanelOpen.getAttribute('data-column') + '"]');
                    if (!btn || !btn.contains(ev.target)) closeEvaluationsHeaderFilterPanel();
                }
            });
            var evalTab = document.getElementById('analyticsEvaluationsTab');
            if (evalTab) evalTab.addEventListener('click', function(ev) {
                var table = ev.target.closest && ev.target.closest('#analyticsEvaluationsTable');
                if (!table) return;
                var filterBtn = ev.target.closest && ev.target.closest('.export-th-filter');
                if (filterBtn && filterBtn.getAttribute('data-sort')) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    openEvaluationsHeaderFilter(filterBtn.getAttribute('data-sort'), filterBtn);
                    return;
                }
                var th = ev.target.closest && ev.target.closest('th[data-sort]');
                if (th && !ev.target.closest('.export-th-filter')) sortEvaluationsByColumn(th.getAttribute('data-sort'));
            });
        })();
        
        var evaluationsColumnFilters = { date: [], student: [], course: [], instructor: [], score: [] };
        var evaluationsSortColumn = 'date';
        var evaluationsSortDir = 'desc';
        var EVALUATIONS_HEADER_LABELS = { date: 'Date', student: 'Student', course: 'Course', instructor: 'Instructor', score: 'Score %' };
        var evaluationsHeaderFilterPanelOpen = null;
        
        function getEvaluationsDisplayValue(e, column) {
            switch (column) {
                case 'date': return e.created_at ? new Date(e.created_at).toLocaleDateString() : '\u2014';
                case 'student': return e.course_students ? (e.course_students.first_name || '') + ' ' + (e.course_students.last_name || '') : '\u2014';
                case 'course': return e.courses && e.courses.name ? e.courses.name : '\u2014';
                case 'instructor': return e.instructorName || '\u2014';
                case 'score': return e.overallScore === 'N/A' ? 'N/A' : (e.overallScore + '%');
                default: return '\u2014';
            }
        }
        
        function getUniqueEvaluationsColumnValues(column, evalsWithDetails) {
            var set = {};
            (evalsWithDetails || []).forEach(function(e) {
                var v = getEvaluationsDisplayValue(e, column);
                if (v !== undefined && v !== null) set[v] = true;
            });
            var arr = Object.keys(set);
            arr.sort(function(a, b) { return String(a).localeCompare(String(b), undefined, { numeric: true }); });
            return arr;
        }
        
        function sortEvaluationsByColumn(column) {
            if (column === evaluationsSortColumn) evaluationsSortDir = evaluationsSortDir === 'asc' ? 'desc' : 'asc';
            else { evaluationsSortColumn = column; evaluationsSortDir = 'asc'; }
            renderEvaluationsTab();
        }
        
        function openEvaluationsHeaderFilter(column, button) {
            if (evaluationsHeaderFilterPanelOpen) {
                evaluationsHeaderFilterPanelOpen.remove();
                if (evaluationsHeaderFilterPanelOpen.getAttribute('data-column') === column) {
                    evaluationsHeaderFilterPanelOpen = null;
                    return;
                }
            }
            var evals = window.evaluationsFullListWithDetails || window.allEvaluationsList || [];
            var unique = getUniqueEvaluationsColumnValues(column, evals);
            var selected = evaluationsColumnFilters[column] || [];
            var panel = document.createElement('div');
            panel.className = 'export-header-filter-panel';
            panel.setAttribute('data-column', column);
            var rect = button.getBoundingClientRect();
            panel.style.left = rect.left + 'px';
            panel.style.top = (rect.bottom + 4) + 'px';
            panel.innerHTML = '<div class="export-filter-toolbar"><a href="#" role="button" data-action="selectall">Select all</a><a href="#" role="button" data-action="clear">Clear</a></div><div class="export-filter-list"></div>';
            var list = panel.querySelector('.export-filter-list');
            unique.forEach(function(value) {
                var checked = selected.length === 0 || selected.indexOf(value) !== -1;
                list.appendChild((function() {
                    var item = document.createElement('label');
                    item.className = 'export-filter-item';
                    item.innerHTML = '<input type="checkbox" ' + (checked ? 'checked' : '') + ' data-value="' + escapeHtml(value) + '"><span>' + escapeHtml(value) + '</span>';
                    return item;
                })());
            });
            panel.querySelector('.export-filter-toolbar [data-action="selectall"]').addEventListener('click', function(e) { e.preventDefault(); evaluationsColumnFilters[column] = unique.slice(); renderEvaluationsTab(); updateEvaluationsFilterPanelCheckboxes(panel, column); });
            panel.querySelector('.export-filter-toolbar [data-action="clear"]').addEventListener('click', function(e) { e.preventDefault(); evaluationsColumnFilters[column] = []; renderEvaluationsTab(); updateEvaluationsFilterPanelCheckboxes(panel, column); });
            list.addEventListener('change', function(e) {
                if (e.target.type !== 'checkbox') return;
                var value = e.target.getAttribute('data-value');
                var arr = evaluationsColumnFilters[column] || [];
                var idx = arr.indexOf(value);
                if (e.target.checked) { if (idx === -1) arr.push(value); } else { if (idx !== -1) arr.splice(idx, 1); }
                evaluationsColumnFilters[column] = arr;
                renderEvaluationsTab();
            });
            document.body.appendChild(panel);
            evaluationsHeaderFilterPanelOpen = panel;
        }
        
        function updateEvaluationsFilterPanelCheckboxes(panel, column) {
            if (!panel || !panel.parentNode) return;
            var selected = evaluationsColumnFilters[column] || [];
            var allSelected = selected.length === 0;
            panel.querySelectorAll('.export-filter-item input').forEach(function(cb) {
                cb.checked = allSelected || selected.indexOf(cb.getAttribute('data-value')) !== -1;
            });
        }
        
        function closeEvaluationsHeaderFilterPanel() {
            if (evaluationsHeaderFilterPanelOpen) { evaluationsHeaderFilterPanelOpen.remove(); evaluationsHeaderFilterPanelOpen = null; }
        }
        
        function renderEvaluationsTab() {
            const evals = analyticsData.filtered;
            const container = document.getElementById('analyticsEvaluationsTab');
            const totalLoaded = analyticsData.evaluations ? analyticsData.evaluations.length : 0;
            const isFilteredToZero = totalLoaded > 0 && evals.length === 0;
            
            if (evals.length === 0) {
                container.innerHTML = '<div class="card" style="text-align: center; padding: 3rem 1.5rem; color: var(--text-light); max-width: 28rem; margin: 0 auto;"><p style="font-size: 2rem; margin-bottom: 0.5rem;"><i data-lucide="file-text" style="width:2rem;height:2rem;display:inline-block;"></i></p><p style="font-weight: 600; margin-bottom: 0.25rem; color: var(--text);">' + (isFilteredToZero ? 'No evaluations match your filters' : 'No evaluations found') + '</p><p style="font-size: 0.9rem; margin-bottom: 1.25rem;">' + (isFilteredToZero ? 'Try broadening the date range or clearing filters above.' : 'Apply filters above to load evaluation data.') + '</p></div>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: container });
                return;
            }
            
            // Add instructor names and calculate average scores
            const evalsWithDetails = evals.map(e => {
                const instructor = analyticsData.instructors.find(i => i.id === e.instructor_id);
                
                // Calculate overall score for this evaluation (normalized to percentage)
                let rawScores = [];
                let normalizedScores = [];
                let evalData = e.evaluation_data;
                if (typeof evalData === 'string') {
                    try {
                        evalData = JSON.parse(evalData);
                    } catch (err) {
                        console.error('Parse error for eval', e.id, err);
                        evalData = null;
                    }
                }
                
                // Handle sections as object (not array)
                if (evalData?.sections && typeof evalData.sections === 'object') {
                    // sections is an object like { "Content": {...}, "Delivery": {...} }
                    Object.values(evalData.sections).forEach(section => {
                        // Each section has a score and maxScore
                        if (section.score !== undefined && section.score !== null && section.maxScore) {
                            const raw = parseFloat(section.score);
                            const max = parseFloat(section.maxScore);
                            rawScores.push(raw);
                            // Normalize to 0-100 scale
                            normalizedScores.push((raw / max) * 100);
                        }
                        
                        // Also check subcategories/feedback arrays for individual item scores
                        const items = section.subcategories || section.feedback || [];
                        if (Array.isArray(items)) {
                            items.forEach(item => {
                                if (item.points !== undefined && item.points !== null && item.maxPoints) {
                                    const raw = parseFloat(item.points);
                                    const max = parseFloat(item.maxPoints);
                                    rawScores.push(raw);
                                    // Normalize to 0-100 scale
                                    normalizedScores.push((raw / max) * 100);
                                }
                            });
                        }
                    });
                }
                
                // Use normalized average for fair comparison across different rubrics
                const overallScore = normalizedScores.length > 0 
                    ? (normalizedScores.reduce((a, b) => a + b, 0) / normalizedScores.length).toFixed(1)
                    : 'N/A';
                
                return {
                    ...e,
                    instructorName: instructor?.full_name || instructor?.email || 'Unknown',
                    overallScore: overallScore, // Percentage
                    rawTotal: rawScores.length > 0 ? rawScores.reduce((a, b) => a + b, 0).toFixed(1) : 'N/A'
                };
            });
            
            const totalCount = analyticsData.evaluations.length;
            window.evaluationsFullListWithDetails = evalsWithDetails;
            
            // Apply column filters (Evaluations tab dropdown filters)
            var cols = ['date', 'student', 'course', 'instructor', 'score'];
            cols.forEach(function(col) {
                var sel = evaluationsColumnFilters[col];
                if (sel && sel.length > 0) {
                    evalsWithDetails = evalsWithDetails.filter(function(e) { return sel.indexOf(getEvaluationsDisplayValue(e, col)) !== -1; });
                }
            });
            var isFiltered = evalsWithDetails.length !== totalCount;
            
            // Sort by evaluations column/direction
            evalsWithDetails.sort(function(a, b) {
                var va = getEvaluationsDisplayValue(a, evaluationsSortColumn);
                var vb = getEvaluationsDisplayValue(b, evaluationsSortColumn);
                var cmp = 0;
                if (evaluationsSortColumn === 'date') {
                    var ta = a.created_at ? new Date(a.created_at).getTime() : 0;
                    var tb = b.created_at ? new Date(b.created_at).getTime() : 0;
                    cmp = ta - tb;
                } else if (evaluationsSortColumn === 'score') {
                    var sa = a.overallScore === 'N/A' ? -1 : parseFloat(a.overallScore);
                    var sb = b.overallScore === 'N/A' ? -1 : parseFloat(b.overallScore);
                    cmp = sa - sb;
                } else cmp = String(va).localeCompare(String(vb), undefined, { numeric: true });
                return evaluationsSortDir === 'asc' ? cmp : -cmp;
            });
            
            window.currentEvaluationsList = evalsWithDetails;
            window.allEvaluationsList = evalsWithDetails;
            
            var headerLabels = EVAL_HEADER_LABELS;
            var sortCol = evaluationsSortColumn;
            var sortDir = evaluationsSortDir;
            var colFilters = evaluationsColumnFilters;
            var theadRow = ['date', 'student', 'course', 'instructor', 'score'].map(function(col) {
                var label = headerLabels[col] || col;
                var arrow = col === sortCol ? (sortDir === 'asc' ? ' \u2191' : ' \u2193') : '';
                var hasFilter = colFilters[col] && colFilters[col].length > 0;
                var centerClass = col === 'score' ? ' export-th-center' : '';
                return '<th data-sort="' + col + '" style="text-align: left; padding: 0.75rem; color: #fff; font-weight: 600; background: var(--primary);" title="Click label to sort; click \u25BE to filter"><div class="export-th-inner' + centerClass + '"><span class="export-th-sort">' + escapeHtml(label) + arrow + '</span><button type="button" class="export-th-filter' + (hasFilter ? ' has-filter' : '') + '" data-sort="' + col + '" aria-label="Filter ' + escapeHtml(label) + '">\u25BE</button></div></th>';
            }).join('');
            
            var tableCardHtmlStart = `
                <div class="card" data-widget-id="card-table" style="overflow: hidden;">
                    <div style="padding: 0.75rem 1rem; border-bottom: 1px solid var(--border); background: var(--bg-alt); display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
                        <span style="color: var(--text-light); font-size: 0.85rem; flex: 1;">${isFiltered ? `${evalsWithDetails.length} of ${totalCount} evaluations` : `${evalsWithDetails.length} evaluation${evalsWithDetails.length !== 1 ? 's' : ''}`}</span>
                        <button type="button" onclick="exportDepartmentData()" class="btn" style="background: var(--primary); color: white; padding: 0.5rem 1rem; font-size: 0.875rem;"><span class="icon-with-text"><i data-lucide="download"></i> Export CSV</span></button>
                    </div>
                    <div style="overflow-x: auto;">
                        <table id="analyticsEvaluationsTable" class="data-table" style="width: 100%; min-width: 560px;">
                            <thead style="background: var(--primary); color: #fff;">
                                <tr>
                                    ${theadRow}
                                    <th style="text-align: center; padding: 0.75rem; color: #fff; font-weight: 600; background: var(--primary);">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="evaluationsTableBody">
            `;
            var html = tableCardHtmlStart;
            
            const totalEvals = evalsWithDetails.length;
            const totalPages = Math.max(1, Math.ceil(totalEvals / ANALYTICS_EVALS_PAGE_SIZE));
            if (analyticsEvaluationsPage >= totalPages) analyticsEvaluationsPage = totalPages - 1;
            if (analyticsEvaluationsPage < 0) analyticsEvaluationsPage = 0;
            const start = analyticsEvaluationsPage * ANALYTICS_EVALS_PAGE_SIZE;
            const pageEvals = evalsWithDetails.slice(start, start + ANALYTICS_EVALS_PAGE_SIZE);
            
            pageEvals.forEach(eval => {
                const studentName = eval.course_students 
                    ? `${eval.course_students.first_name} ${eval.course_students.last_name}`
                    : 'Unknown';
                const courseName = eval.courses?.name || 'Unknown';
                const date = new Date(eval.created_at).toLocaleDateString();
                const evalId = eval.id;
                const scoreColor = eval.overallScore === 'N/A' ? 'var(--text-light)' :
                                  eval.overallScore >= 80 ? 'var(--success)' : 
                                  eval.overallScore >= 60 ? 'var(--warning)' : 'var(--error)';
                
                html += `
                    <tr>
                        <td style="color: var(--text-light); font-size: 0.9rem;">${date}</td>
                        <td><strong>${escapeHtml(studentName)}</strong></td>
                        <td style="color: var(--text-light); font-size: 0.9rem;">${escapeHtml(courseName)}</td>
                        <td style="color: var(--text-light); font-size: 0.9rem;">${escapeHtml(eval.instructorName)}</td>
                        <td style="text-align: center; font-weight: 600; color: ${scoreColor};">${eval.overallScore === 'N/A' ? 'N/A' : `${eval.overallScore}%`}</td>
                        <td style="text-align: center;">
                            <button type="button" onclick="viewEvaluationDetails('${evalId}')" class="btn-secondary" style="padding: 0.25rem 0.6rem; font-size: 0.875rem;">View</button>
                        </td>
                    </tr>
                `;
            });
            
            html += `
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
            
            if (totalEvals > ANALYTICS_EVALS_PAGE_SIZE) {
                const from = start + 1;
                const to = Math.min(start + ANALYTICS_EVALS_PAGE_SIZE, totalEvals);
                html += `
                <div id="analyticsEvaluationsPagination" class="card" style="margin-top: 0.5rem; padding: 0.75rem 1rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.75rem;">
                    <p style="color: var(--text-light); margin: 0; font-size: 0.9rem;">Showing ${from}&ndash;${to} of ${totalEvals}</p>
                    <div style="display: flex; gap: 0.5rem;">
                        <button type="button" onclick="analyticsEvaluationsPage--; updateEvaluationsTable(window.currentEvaluationsList || []);" class="btn-secondary" style="padding: 0.35rem 0.75rem;" ${analyticsEvaluationsPage <= 0 ? 'disabled' : ''}>Previous</button>
                        <button type="button" onclick="analyticsEvaluationsPage++; updateEvaluationsTable(window.currentEvaluationsList || []);" class="btn-secondary" style="padding: 0.35rem 0.75rem;" ${analyticsEvaluationsPage >= totalPages - 1 ? 'disabled' : ''}>Next</button>
                    </div>
                </div>
                `;
            }
            var tableCardHtml = html;
            function customEvalCardHtml(w) {
                return '<div class="card" data-widget-id="' + escapeHtml(w.id) + '"><div class="card-header">' + escapeHtml(w.label || 'Custom section') + '</div><div style="padding:1rem;color:var(--text-light);font-size:0.9rem;">Custom section. Use Edit cards to remove or reorder.</div></div>';
            }
            var evalBlocks = { 'card-table': tableCardHtml };
            var evalTabWidgets = (typeof getTabWidgets === 'function' ? getTabWidgets('evaluations') : []).filter(function(w) { return w.visible !== false; }).sort(function(a, b) { return (a.order || 0) - (b.order || 0); });
            if (!evalTabWidgets.length) evalTabWidgets = (DEFAULT_TAB_WIDGETS.evaluations || []).filter(function(w) { return w.visible !== false; }).sort(function(a, b) { return a.order - b.order; });
            container.innerHTML = evalTabWidgets.map(function(w) { return evalBlocks[w.id] || (w.custom || String(w.id).indexOf('custom_') === 0 ? customEvalCardHtml(w) : ''); }).filter(Boolean).join('') || '<p style="color: var(--text-light); padding: 1rem;">No cards visible. Use Customize → Edit cards to show cards.</p>';
        }
        
        // Evaluations tab: column sort + filter (same as Data Export)
        var evaluationsColumnFilters = { date: [], student: [], course: [], instructor: [], score: [] };
        var evaluationsSortColumn = 'date';
        var evaluationsSortDir = 'desc';
        var evaluationsHeaderFilterPanelOpen = null;
        var EVAL_HEADER_LABELS = { date: 'Date', student: 'Student', course: 'Course', instructor: 'Instructor', score: 'Score %' };
        
        function getEvaluationsDisplayValue(eval, column) {
            switch (column) {
                case 'date': return eval.created_at ? new Date(eval.created_at).toLocaleDateString() : '\u2014';
                case 'student': return eval.course_students ? (eval.course_students.first_name || '') + ' ' + (eval.course_students.last_name || '') : '\u2014';
                case 'course': return eval.courses && eval.courses.name ? eval.courses.name : '\u2014';
                case 'instructor': return (eval.instructorName != null ? eval.instructorName : '\u2014');
                case 'score': return eval.overallScore !== undefined && eval.overallScore !== 'N/A' ? eval.overallScore + '%' : '\u2014';
                default: return '';
            }
        }
        
        function getEvaluationsUniqueValues(column) {
            var list = window.evaluationsFullListWithDetails || [];
            var set = {};
            list.forEach(function(e) {
                var v = getEvaluationsDisplayValue(e, column);
                if (v !== undefined && v !== null) set[v] = true;
            });
            var arr = Object.keys(set);
            arr.sort(function(a, b) { return String(a).localeCompare(String(b), undefined, { numeric: true }); });
            return arr;
        }
        
        function openEvaluationsHeaderFilter(column, button) {
            if (evaluationsHeaderFilterPanelOpen) {
                evaluationsHeaderFilterPanelOpen.remove();
                if (evaluationsHeaderFilterPanelOpen.getAttribute('data-column') === column) {
                    evaluationsHeaderFilterPanelOpen = null;
                    return;
                }
            }
            var unique = getEvaluationsUniqueValues(column);
            var selected = evaluationsColumnFilters[column] || [];
            var panel = document.createElement('div');
            panel.className = 'export-header-filter-panel';
            panel.setAttribute('data-column', column);
            var rect = button.getBoundingClientRect();
            panel.style.left = rect.left + 'px';
            panel.style.top = (rect.bottom + 4) + 'px';
            panel.innerHTML = '<div class="export-filter-toolbar"><a href="#" role="button" data-action="selectall">Select all</a><a href="#" role="button" data-action="clear">Clear</a></div><div class="export-filter-list"></div>';
            var list = panel.querySelector('.export-filter-list');
            unique.forEach(function(value) {
                var checked = selected.length === 0 || selected.indexOf(value) !== -1;
                var item = document.createElement('label');
                item.className = 'export-filter-item';
                item.innerHTML = '<input type="checkbox" ' + (checked ? 'checked' : '') + ' data-value="' + escapeHtml(value) + '"><span>' + escapeHtml(value) + '</span>';
                list.appendChild(item);
            });
            panel.querySelector('.export-filter-toolbar [data-action="selectall"]').addEventListener('click', function(e) { e.preventDefault(); evaluationsColumnFilters[column] = unique.slice(); renderEvaluationsTab(); });
            panel.querySelector('.export-filter-toolbar [data-action="clear"]').addEventListener('click', function(e) { e.preventDefault(); evaluationsColumnFilters[column] = []; renderEvaluationsTab(); });
            list.addEventListener('change', function(e) {
                if (e.target.type !== 'checkbox') return;
                var value = e.target.getAttribute('data-value');
                var arr = evaluationsColumnFilters[column] || [];
                var idx = arr.indexOf(value);
                if (e.target.checked) { if (idx === -1) arr.push(value); } else { if (idx !== -1) arr.splice(idx, 1); }
                evaluationsColumnFilters[column] = arr;
                renderEvaluationsTab();
            });
            document.body.appendChild(panel);
            evaluationsHeaderFilterPanelOpen = panel;
        }
        
        function closeEvaluationsHeaderFilterPanel() {
            if (evaluationsHeaderFilterPanelOpen) { evaluationsHeaderFilterPanelOpen.remove(); evaluationsHeaderFilterPanelOpen = null; }
        }
        
        function sortEvaluationsByColumn(column) {
            if (column === evaluationsSortColumn) evaluationsSortDir = evaluationsSortDir === 'asc' ? 'desc' : 'asc';
            else { evaluationsSortColumn = column; evaluationsSortDir = 'asc'; }
            renderEvaluationsTab();
        }
        
        // Sort evaluations (uses global Sort dropdown when present, else column header sort)
        function sortEvaluations() {
            const sortField = document.getElementById('analyticsGlobalSort')?.value || document.getElementById('evalSortField')?.value || 'date';
            const evals = window.currentEvaluationsList || [];
            
            if (evals.length === 0) return;
            
            switch(sortField) {
                case 'date':
                    evals.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
                    break;
                case 'date-asc':
                    evals.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
                    break;
                case 'student':
                    evals.sort((a, b) => {
                        const nameA = a.course_students ? `${a.course_students.first_name} ${a.course_students.last_name}` : 'Unknown';
                        const nameB = b.course_students ? `${b.course_students.first_name} ${b.course_students.last_name}` : 'Unknown';
                        return nameA.localeCompare(nameB);
                    });
                    break;
                case 'course':
                    evals.sort((a, b) => {
                        const courseA = a.courses?.name || 'Unknown';
                        const courseB = b.courses?.name || 'Unknown';
                        return courseA.localeCompare(courseB);
                    });
                    break;
                case 'instructor':
                    evals.sort((a, b) => a.instructorName.localeCompare(b.instructorName));
                    break;
                case 'score':
                    evals.sort((a, b) => {
                        const scoreA = a.overallScore === 'N/A' ? -1 : parseFloat(a.overallScore);
                        const scoreB = b.overallScore === 'N/A' ? -1 : parseFloat(b.overallScore);
                        return scoreB - scoreA;
                    });
                    break;
                case 'score-asc':
                    evals.sort((a, b) => {
                        const scoreA = a.overallScore === 'N/A' ? 999 : parseFloat(a.overallScore);
                        const scoreB = b.overallScore === 'N/A' ? 999 : parseFloat(b.overallScore);
                        return scoreA - scoreB;
                    });
                    break;
            }
            
            // Re-render table body
            updateEvaluationsTable(evals);
        }
        
        // Apply evaluation filters
        function applyEvalFilters() {
            const scoreFilter = document.getElementById('evalScoreFilter').value;
            let filtered = window.allEvaluationsList || [];
            
            // Apply score filter
            if (scoreFilter !== 'all') {
                filtered = filtered.filter(e => {
                    const score = e.overallScore === 'N/A' ? 0 : parseFloat(e.overallScore);
                    switch(scoreFilter) {
                        case 'high':
                            return score >= 80;
                        case 'medium':
                            return score >= 60 && score < 80;
                        case 'low':
                            return score < 60 && score > 0;
                        default:
                            return true;
                    }
                });
            }
            
            // Update current list and re-apply sort
            window.currentEvaluationsList = filtered;
            analyticsEvaluationsPage = 0;
            sortEvaluations();
        }
        
        // Update evaluations table display (supports pagination)
        function updateEvaluationsTable(evals) {
            const tbody = document.getElementById('evaluationsTableBody');
            if (!tbody) return;
            
            const totalEvals = evals.length;
            const totalPages = Math.max(1, Math.ceil(totalEvals / ANALYTICS_EVALS_PAGE_SIZE));
            if (analyticsEvaluationsPage >= totalPages) analyticsEvaluationsPage = totalPages - 1;
            if (analyticsEvaluationsPage < 0) analyticsEvaluationsPage = 0;
            const start = analyticsEvaluationsPage * ANALYTICS_EVALS_PAGE_SIZE;
            const pageEvals = evals.slice(start, start + ANALYTICS_EVALS_PAGE_SIZE);
            
            let html = '';
            pageEvals.forEach(eval => {
                const studentName = eval.course_students 
                    ? `${eval.course_students.first_name} ${eval.course_students.last_name}`
                    : 'Unknown';
                const courseName = eval.courses?.name || 'Unknown';
                const date = new Date(eval.created_at).toLocaleDateString();
                const evalId = eval.id;
                const scoreColor = eval.overallScore === 'N/A' ? 'var(--text-light)' :
                                  eval.overallScore >= 80 ? 'var(--success)' : 
                                  eval.overallScore >= 60 ? 'var(--warning)' : 'var(--error)';
                
                html += `
                    <tr>
                        <td style="color: var(--text-light); font-size: 0.9rem;">${date}</td>
                        <td><strong>${escapeHtml(studentName)}</strong></td>
                        <td style="color: var(--text-light); font-size: 0.9rem;">${escapeHtml(courseName)}</td>
                        <td style="color: var(--text-light); font-size: 0.9rem;">${escapeHtml(eval.instructorName)}</td>
                        <td style="text-align: center; font-weight: 600; color: ${scoreColor};">${eval.overallScore === 'N/A' ? 'N/A' : `${eval.overallScore}%`}</td>
                        <td style="text-align: center;">
                            <button type="button" onclick="viewEvaluationDetails('${evalId}')" class="btn-secondary" style="padding: 0.25rem 0.6rem; font-size: 0.875rem;">View</button>
                        </td>
                    </tr>
                `;
            });
            
            tbody.innerHTML = html;
            
            const totalCount = (analyticsData.evaluations || []).length;
            const isFiltered = evals.length !== totalCount;
            const countText = document.querySelector('#analyticsEvaluationsTab .card p');
            if (countText) {
                countText.textContent = isFiltered ? `${evals.length} of ${totalCount} evaluations` : `${evals.length} evaluation${evals.length !== 1 ? 's' : ''}`;
            }
            
            const paginationEl = document.getElementById('analyticsEvaluationsPagination');
            if (paginationEl && totalEvals > ANALYTICS_EVALS_PAGE_SIZE) {
                const from = start + 1;
                const to = Math.min(start + ANALYTICS_EVALS_PAGE_SIZE, totalEvals);
                paginationEl.innerHTML = `
                    <p style="color: var(--text-light); margin: 0; font-size: 0.9rem;">Showing ${from}&ndash;${to} of ${totalEvals}</p>
                    <div style="display: flex; gap: 0.5rem;">
                        <button type="button" onclick="analyticsEvaluationsPage--; updateEvaluationsTable(window.currentEvaluationsList || []);" class="btn-secondary" style="padding: 0.35rem 0.75rem;" ${analyticsEvaluationsPage <= 0 ? 'disabled' : ''}>Previous</button>
                        <button type="button" onclick="analyticsEvaluationsPage++; updateEvaluationsTable(window.currentEvaluationsList || []);" class="btn-secondary" style="padding: 0.35rem 0.75rem;" ${analyticsEvaluationsPage >= totalPages - 1 ? 'disabled' : ''}>Next</button>
                    </div>
                `;
            }
        }
        
        // View evaluation details modal
        function viewEvaluationDetails(evaluationId) {
            const evaluation = analyticsData.filtered.find(e => e.id === evaluationId);
            if (!evaluation) {
                alert('Evaluation not found');
                return;
            }
            
            console.log('🔍 Viewing evaluation:', evaluation.id);
            
            const studentName = evaluation.course_students 
                ? `${evaluation.course_students.first_name} ${evaluation.course_students.last_name}`
                : 'Unknown';
            const courseName = evaluation.courses?.name || 'Unknown';
            const date = new Date(evaluation.created_at).toLocaleString();
            
            let detailsHTML = `
                <div style="margin-bottom: 1.5rem;">
                    <p><strong>Student:</strong> ${studentName}</p>
                    <p><strong>Course:</strong> ${courseName}</p>
                    <p><strong>Date:</strong> ${date}</p>
                </div>
            `;
            
            // Parse evaluation_data if it's a string
            let evalData = evaluation.evaluation_data;
            if (typeof evalData === 'string') {
                try {
                    evalData = JSON.parse(evalData);
                } catch (e) {
                    console.error('Error parsing evaluation data:', e);
                    evalData = null;
                }
            }
            
            // Show rubric scores if available
            if (evalData && evalData.sections && typeof evalData.sections === 'object') {
                detailsHTML += '<h4 style="margin-bottom: 1rem;">Rubric Scores</h4>';
                
                // sections is an object like { "Content": {...}, "Delivery": {...} }
                Object.entries(evalData.sections).forEach(([sectionName, section]) => {
                    detailsHTML += `<h5 style="margin-top: 1rem; color: var(--primary);">${sectionName}</h5>`;
                    
                    // Show section score
                    if (section.score !== undefined) {
                        const sectionScore = parseFloat(section.score);
                        const scoreColor = sectionScore >= section.maxScore * 0.8 ? 'var(--success)' : 
                                          sectionScore >= section.maxScore * 0.6 ? 'var(--warning)' : 'var(--error)';
                        detailsHTML += `
                            <div style="background: var(--bg-alt); padding: 0.75rem; border-radius: 0.5rem; margin-top: 0.5rem; margin-bottom: 0.5rem;">
                                <strong>Section Score:</strong> 
                                <span style="font-weight: 600; color: ${scoreColor};">${sectionScore}/${section.maxScore || 'N/A'}</span>
                            </div>
                        `;
                    }
                    
                    // Show subcategories/feedback items
                    const items = section.subcategories || section.feedback || [];
                    if (Array.isArray(items) && items.length > 0) {
                        detailsHTML += '<div style="background: var(--bg-alt); padding: 0.5rem; border-radius: 0.5rem; margin-top: 0.5rem;">';
                        items.forEach(item => {
                            const points = item.points !== undefined ? item.points : 'N/A';
                            const maxPoints = item.maxPoints || 10;
                            const scoreColor = points >= maxPoints * 0.8 ? 'var(--success)' : 
                                              points >= maxPoints * 0.6 ? 'var(--warning)' : 'var(--error)';
                            
                            detailsHTML += `
                                <div style="padding: 0.5rem 0; border-bottom: 1px solid var(--border);">
                                    <div style="display: flex; justify-content: space-between;">
                                        <span><strong>${item.name}</strong></span>
                                        <span style="font-weight: 600; color: ${scoreColor};">${points}/${maxPoints}</span>
                                    </div>
                                    ${item.feedback ? `<div style="color: var(--text-light); font-size: 0.9rem; margin-top: 0.25rem;">${item.feedback}</div>` : ''}
                                </div>
                            `;
                        });
                        detailsHTML += '</div>';
                    }
                });
            }
            
            // Show in modal
            const modal = `
                <div id="evaluationDetailsModal" style="display:flex;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
                    <div style="background:white;padding:2rem;border-radius:1rem;max-width:700px;width:90%;max-height:90vh;overflow-y:auto;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:1.5rem;">
                            <h3 style="margin:0;color:var(--primary);"><span class="icon-with-text"><i data-lucide="bar-chart-2" style="width:1.25em;height:1.25em;"></i> Evaluation Details</span></h3>
                            <button onclick="closeEvaluationDetailsModal()" style="background:none;border:none;font-size:1.5rem;cursor:pointer;color:var(--text-light);padding:0.25rem;" aria-label="Close"><i data-lucide="x" style="width:1.25em;height:1.25em;"></i></button>
                        </div>
                        ${detailsHTML}
                        <div style="margin-top:2rem;text-align:right;">
                            <button onclick="closeEvaluationDetailsModal()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;">
                                Close
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modal);
            var modalEl = document.getElementById('evaluationDetailsModal');
            if (modalEl && typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: modalEl });
        }
        
        // Close evaluation details modal
        function closeEvaluationDetailsModal() {
            const modal = document.getElementById('evaluationDetailsModal');
            if (modal) modal.remove();
        }
        
        // Load department analytics (old function kept for compatibility)
        async function loadDepartmentAnalytics() {
            
            if (!currentUser.department_id) {
                var deptContainer = document.getElementById('departmentAnalyticsContainer');
                deptContainer.innerHTML = '<p style="color: var(--warning);"><span class="icon-with-text"><i data-lucide="alert-triangle" style="width:1.1em;height:1.1em;"></i> You are not assigned to a department.</span></p>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: deptContainer });
                return;
            }
            
            const container = document.getElementById('departmentAnalyticsContainer');
            container.innerHTML = '<p style="color: var(--text-light);">Loading analytics...</p>';
            
            try {
                // Get date range filters (optional when global filter bar removed)
                const startDate = document.getElementById('analyticsStartDate')?.value || '';
                const endDate = document.getElementById('analyticsEndDate')?.value || '';
                
                // Get all instructors in department
                const { data: instructors, error: instError } = await supabaseClient
                    .from('user_profiles')
                    .select('id, email, full_name')
                    .eq('department_id', currentUser.department_id)
                    .eq('account_tier', 'instructor');
                
                if (instError) throw instError;
                
                if (!instructors || instructors.length === 0) {
                    container.innerHTML = '<p style="color: var(--text-light);">No instructors in department.</p>';
                    return;
                }
                
                // Get all evaluations for department instructors
                let query = supabaseClient
                    .from('evaluations')
                    .select(`
                        id,
                        instructor_id,
                        course_id,
                        student_id,
                        created_at,
                        evaluation_data
                    `)
                    .in('instructor_id', instructors.map(i => i.id));
                
                // Apply date filters if set
                if (startDate) {
                    query = query.gte('created_at', startDate);
                }
                if (endDate) {
                    query = query.lte('created_at', endDate + 'T23:59:59');
                }
                
                const { data: evaluations, error: evalError } = await query;
                
                if (evalError) throw evalError;
                
                // Calculate statistics
                const stats = calculateDepartmentStats(instructors, evaluations || []);
                
                // Display analytics
                displayDepartmentAnalytics(stats);
                
            } catch (error) {
                console.error('Error loading analytics:', error);
                container.innerHTML = '<p style="color: var(--error);">Error loading analytics. Please try again.</p>';
            }
        }
        
        // Calculate department statistics
        function calculateDepartmentStats(instructors, evaluations) {
            const stats = {
                totalInstructors: instructors.length,
                totalEvaluations: evaluations.length,
                instructorStats: [],
                dateRange: {
                    start: document.getElementById('analyticsStartDate')?.value || 'All time',
                    end: document.getElementById('analyticsEndDate')?.value || 'Present'
                }
            };
            
            // Calculate per-instructor stats
            instructors.forEach(instructor => {
                const instructorEvals = evaluations.filter(e => e.instructor_id === instructor.id);
                const uniqueStudents = new Set(instructorEvals.map(e => e.student_id)).size;
                const uniqueCourses = new Set(instructorEvals.map(e => e.course_id)).size;
                
                stats.instructorStats.push({
                    name: instructor.full_name || instructor.email,
                    email: instructor.email,
                    evaluationCount: instructorEvals.length,
                    studentCount: uniqueStudents,
                    courseCount: uniqueCourses
                });
            });
            
            // Sort by evaluation count
            stats.instructorStats.sort((a, b) => b.evaluationCount - a.evaluationCount);
            
            return stats;
        }
        
        // Display department analytics
        function displayDepartmentAnalytics(stats) {
            const container = document.getElementById('departmentAnalyticsContainer');
            
            let html = `
                <!-- Overview Cards -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
                    <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; border-left: 4px solid var(--primary);">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--primary);">${stats.totalInstructors}</div>
                        <div style="color: var(--text-light); margin-top: 0.5rem;">Total Instructors</div>
                    </div>
                    <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; border-left: 4px solid var(--success);">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--success);">${stats.totalEvaluations}</div>
                        <div style="color: var(--text-light); margin-top: 0.5rem;">Total Evaluations</div>
                    </div>
                    <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; border-left: 4px solid var(--secondary);">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--secondary);">${stats.totalEvaluations > 0 ? Math.round(stats.totalEvaluations / stats.totalInstructors) : 0}</div>
                        <div style="color: var(--text-light); margin-top: 0.5rem;">Avg per Instructor</div>
                    </div>
                </div>
                
                <div style="background: var(--bg-alt); padding: 1rem; border-radius: 0.5rem; margin-bottom: 2rem;">
                    <p style="margin: 0; color: var(--text-light); font-size: 0.9rem;">
                        📅 Date Range: ${stats.dateRange.start} to ${stats.dateRange.end}
                    </p>
                </div>
                
                <!-- Instructor Breakdown Table -->
                <h4 style="margin-bottom: 1rem;">Instructor Activity</h4>
                <div style="background: var(--bg); border: 1px solid var(--border); border-radius: 0.5rem; overflow: hidden;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead style="background: var(--bg-alt);">
                            <tr>
                                <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Instructor</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Courses</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Students</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Evaluations</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">% of Total</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            stats.instructorStats.forEach(instructor => {
                const percentage = stats.totalEvaluations > 0 
                    ? Math.round((instructor.evaluationCount / stats.totalEvaluations) * 100)
                    : 0;
                
                html += `
                    <tr style="border-bottom: 1px solid var(--border);">
                        <td style="padding: 0.75rem;">
                            <strong>${instructor.name}</strong>
                            <br><small style="color: var(--text-light);">${instructor.email}</small>
                        </td>
                        <td style="padding: 0.75rem; text-align: center;">${instructor.courseCount}</td>
                        <td style="padding: 0.75rem; text-align: center;">${instructor.studentCount}</td>
                        <td style="padding: 0.75rem; text-align: center;"><strong>${instructor.evaluationCount}</strong></td>
                        <td style="padding: 0.75rem; text-align: center;">
                            <div style="background: var(--bg-alt); border-radius: 0.25rem; padding: 0.25rem;">
                                ${percentage}%
                            </div>
                        </td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
            `;
            
            container.innerHTML = html;
            console.log('✓ Analytics loaded:', stats);
        }
        
        // Export department data to CSV (for research - SPSS compatible)
        async function exportDepartmentData() {
            if (!supabaseClient || !isAdmin()) return;
            
            if (!currentUser.department_id) {
                alert('You are not assigned to a department.');
                return;
            }
            
            try {
                console.log('💾 Exporting SPSS-compatible department data...');
                
                // Get date range filters (optional when global filter bar removed)
                const startDate = document.getElementById('analyticsStartDate')?.value || '';
                const endDate = document.getElementById('analyticsEndDate')?.value || '';
                
                // Get all instructors in department
                const { data: instructors, error: instError } = await supabaseClient
                    .from('user_profiles')
                    .select('id, email, full_name, is_research_partner')
                    .eq('department_id', currentUser.department_id)
                    .eq('account_tier', 'instructor');
                
                if (instError) throw instError;
                
                // Get all evaluations with full details (explicit FKs: DB has multiple FKs to courses and course_students)
                let query = supabaseClient
                    .from('evaluations')
                    .select(`
                        id,
                        instructor_id,
                        course_id,
                        student_id,
                        created_at,
                        evaluation_data,
                        courses!fk_evaluations_course (id, name, semester, year),
                        course_students!fk_evaluations_student (id, first_name, last_name)
                    `)
                    .in('instructor_id', instructors.map(i => i.id));
                
                // Apply date filters
                if (startDate) query = query.gte('created_at', startDate);
                if (endDate) query = query.lte('created_at', endDate + 'T23:59:59');
                
                const { data: evaluations, error: evalError } = await query;
                
                if (evalError) throw evalError;
                
                if (!evaluations || evaluations.length === 0) {
                    alert('No evaluation data found for the selected date range.');
                    return;
                }
                
                // Phase 3: Only export evaluations for students who have consented (suitable for research/LLM)
                const courseIds = [...new Set(evaluations.map(e => e.course_id))];
                const { data: consentedRows, error: consentErr } = await supabaseClient
                    .from('consent_forms')
                    .select('course_id, student_id')
                    .eq('consent_type', 'data_collection')
                    .eq('consent_given', true)
                    .in('course_id', courseIds);
                if (consentErr) {
                    console.error('Error fetching consent for export:', consentErr);
                    alert('Could not verify student consent. Export cancelled.');
                    return;
                }
                const consentedSet = new Set((consentedRows || []).map(r => r.course_id + '|' + r.student_id));
                const evaluationsConsented = evaluations.filter(e => consentedSet.has(e.course_id + '|' + e.student_id));
                if (evaluationsConsented.length === 0) {
                    alert('No evaluations with student consent in the selected date range.\n\nOnly students who have submitted consent (via the consent link) can be included in research/LLM export.');
                    return;
                }
                if (evaluationsConsented.length < evaluations.length) {
                    console.log('Export: including only consented students:', evaluationsConsented.length, 'of', evaluations.length);
                }
                
                // Audit: log export of evaluation/student data for FERPA
                await logAccess('export', 'evaluations', null, null, { evaluation_count: evaluationsConsented.length, format: 'csv', purpose: 'department_export', consented_only: true });
                
                // Create instructor lookup
                const instructorMap = {};
                instructors.forEach(i => {
                    instructorMap[i.id] = i;
                });
                
                // Collect all unique rubric categories across consented evaluations
                const allCategories = new Set();
                evaluationsConsented.forEach(eval => {
                    let evalData = eval.evaluation_data;
                    if (typeof evalData === 'string') {
                        try {
                            evalData = JSON.parse(evalData);
                        } catch (e) {
                            return;
                        }
                    }
                    
                    // sections is an object like { "Content": {...}, "Delivery": {...} }
                    if (evalData?.sections && typeof evalData.sections === 'object') {
                        // Add section names
                        Object.keys(evalData.sections).forEach(sectionName => {
                            allCategories.add(sectionName);
                        });
                        
                        // Add subcategory/feedback item names
                        Object.values(evalData.sections).forEach(section => {
                            const items = section.subcategories || section.feedback || [];
                            if (Array.isArray(items)) {
                                items.forEach(item => {
                                    if (item.name) {
                                        allCategories.add(item.name);
                                    }
                                });
                            }
                        });
                    }
                });
                
                const categoryList = Array.from(allCategories).sort();
                
                // Build SPSS-compatible CSV header
                let csv = 'EvalID,Date,Year,Month,Day,';
                csv += 'InstructorID,InstructorName,InstructorEmail,ResearchPartner,';
                csv += 'CourseID,CourseName,Semester,';
                csv += 'StudentID,StudentFirstName,StudentLastName,';
                
                // Add columns for each rubric category - BOTH raw and percentage
                categoryList.forEach(cat => {
                    // Convert category name to valid variable name (remove spaces, special chars)
                    const varName = cat.replace(/[^a-zA-Z0-9]/g, '_');
                    csv += `${varName}_Raw,${varName}_Pct,${varName}_Max,`;
                });
                
                csv += 'OverallScore_Pct\n';
                
                // Build data rows (consented students only)
                evaluationsConsented.forEach(eval => {
                    const instructor = instructorMap[eval.instructor_id];
                    const date = new Date(eval.created_at);
                    
                    // Basic info
                    csv += `"${eval.id}",`;
                    csv += `"${date.toISOString().split('T')[0]}",`;
                    csv += `${date.getFullYear()},`;
                    csv += `${date.getMonth() + 1},`;
                    csv += `${date.getDate()},`;
                    
                    // Instructor info
                    csv += `"${instructor?.id || ''}",`;
                    csv += `"${(instructor?.full_name || '').replace(/"/g, '""')}",`;
                    csv += `"${instructor?.email || ''}",`;
                    csv += `${instructor?.is_research_partner ? '1' : '0'},`;
                    
                    // Course info
                    csv += `"${eval.course_id || ''}",`;
                    csv += `"${(eval.courses?.name || '').replace(/"/g, '""')}",`;
                    csv += `"${eval.courses?.semester && eval.courses?.year ? eval.courses.semester + ' ' + eval.courses.year : ''}",`;
                    
                    // Student info
                    csv += `"${eval.student_id || ''}",`;
                    csv += `"${(eval.course_students?.first_name || '').replace(/"/g, '""')}",`;
                    csv += `"${(eval.course_students?.last_name || '').replace(/"/g, '""')}",`;
                    
                    // Parse evaluation data
                    let evalData = eval.evaluation_data;
                    if (typeof evalData === 'string') {
                        try {
                            evalData = JSON.parse(evalData);
                        } catch (e) {
                            evalData = null;
                        }
                    }
                    
                    // Create score lookup for this evaluation
                    const scores = {};
                    let allPercentages = [];
                    
                    if (evalData?.sections && typeof evalData.sections === 'object') {
                        Object.entries(evalData.sections).forEach(([sectionName, section]) => {
                            // Add section score
                            if (section.score !== undefined && section.score !== null && section.maxScore) {
                                const raw = parseFloat(section.score);
                                const max = parseFloat(section.maxScore);
                                const pct = (raw / max) * 100;
                                
                                scores[sectionName] = {
                                    raw: raw,
                                    pct: pct.toFixed(1),
                                    max: max
                                };
                                allPercentages.push(pct);
                            }
                            
                            // Add subcategory/feedback item scores
                            const items = section.subcategories || section.feedback || [];
                            if (Array.isArray(items)) {
                                items.forEach(item => {
                                    if (item.name && item.points !== undefined && item.points !== null && item.maxPoints) {
                                        const raw = parseFloat(item.points);
                                        const max = parseFloat(item.maxPoints);
                                        const pct = (raw / max) * 100;
                                        
                                        scores[item.name] = {
                                            raw: raw,
                                            pct: pct.toFixed(1),
                                            max: max
                                        };
                                        allPercentages.push(pct);
                                    }
                                });
                            }
                        });
                    }
                    
                    // Add score for each category (or empty if not present) - raw, pct, max
                    categoryList.forEach(cat => {
                        if (scores[cat]) {
                            csv += `${scores[cat].raw},${scores[cat].pct},${scores[cat].max},`;
                        } else {
                            csv += ',,,'; // Empty raw, pct, max
                        }
                    });
                    
                    // Add overall percentage score
                    const overallPct = allPercentages.length > 0 
                        ? (allPercentages.reduce((a, b) => a + b, 0) / allPercentages.length).toFixed(1)
                        : '';
                    csv += `${overallPct}\n`;
                });
                
                // Download CSV
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                
                const departmentName = currentUser.department?.name || 'Department';
                const dateStr = new Date().toISOString().split('T')[0];
                a.download = `${departmentName}_SPSS_Data_${dateStr}.csv`;
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
                console.log('✓ Exported', evaluationsConsented.length, 'evaluations (consented only) to SPSS-compatible CSV');
                console.log('✓ Rubric categories as columns:', categoryList.length);
                alert(`✓ Exported ${evaluationsConsented.length} evaluations (consented students only) to SPSS-compatible CSV!\n\n` +
                      `File: ${a.download}\n\n` +
                      `Format: Each rubric category has 3 columns:\n` +
                      `  - CategoryName_Raw (actual points earned)\n` +
                      `  - CategoryName_Pct (normalized 0-100%)\n` +
                      `  - CategoryName_Max (max possible points)\n\n` +
                      `Normalized percentages allow fair comparison across different rubrics.\n` +
                      `Numeric codes: ResearchPartner (1=Yes, 0=No)\n` +
                      `Date components: Year, Month, Day for time series analysis`);
                
            } catch (error) {
                console.error('Error exporting data:', error);
                alert('Error exporting data. Please try again.');
            }
        }
        
        // View instructor's courses (for admins)
        async function viewInstructorCourses(instructorId, instructorEmail) {
            console.log('📚 Viewing courses for:', instructorEmail);
            
            if (!supabaseClient) return;
            
            try {
                // Load instructor's courses
                const { data: courses, error } = await supabaseClient
                    .from('courses')
                    .select(`
                        id,
                        name,
                        semester,
                        year,
                        created_at
                    `)
                    .eq('instructor_id', instructorId)
                    .order('created_at', { ascending: false });
                
                if (error) throw error;
                
                // Load student counts for each course
                const coursesWithCounts = await Promise.all(courses.map(async (course) => {
                    const { data: students, error: studError } = await supabaseClient
                        .from('course_students')
                        .select('id')
                        .eq('course_id', course.id);
                    
                    const { data: evaluations, error: evalError } = await supabaseClient
                        .from('evaluations')
                        .select('id')
                        .eq('course_id', course.id);
                    
                    return {
                        ...course,
                        student_count: students?.length || 0,
                        evaluation_count: evaluations?.length || 0
                    };
                }));
                
                // Show in modal
                showInstructorCoursesModal(instructorEmail, coursesWithCounts);
                
            } catch (error) {
                console.error('Error loading instructor courses:', error);
                alert('Error loading courses. Please try again.');
            }
        }
        
        // Show instructor courses modal
        function showInstructorCoursesModal(instructorEmail, courses) {
            // Create modal HTML
            let html = `
                <div id="instructorCoursesModal" style="display:flex;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
                    <div style="background:white;padding:2rem;border-radius:1rem;max-width:900px;width:90%;max-height:90vh;overflow-y:auto;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:1.5rem;">
                            <h3 style="margin:0;color:var(--primary);"><span class="icon-with-text"><i data-lucide="book-open" style="width:1.25em;height:1.25em;"></i> Courses - ${instructorEmail}</span></h3>
                            <button onclick="closeInstructorCoursesModal()" style="background:none;border:none;cursor:pointer;color:var(--text-light);padding:0.25rem;" aria-label="Close"><i data-lucide="x" style="width:1.25em;height:1.25em;"></i></button>
                        </div>
            `;
            
            if (!courses || courses.length === 0) {
                html += '<p style="color:var(--text-light);">This instructor has no courses yet.</p>';
            } else {
                html += `
                    <div style="background:var(--bg);border:1px solid var(--border);border-radius:0.5rem;overflow:hidden;">
                        <table style="width:100%;border-collapse:collapse;">
                            <thead style="background:var(--bg-alt);">
                                <tr>
                                    <th style="padding:0.75rem;text-align:left;border-bottom:1px solid var(--border);">Course</th>
                                    <th style="padding:0.75rem;text-align:left;border-bottom:1px solid var(--border);">Semester</th>
                                    <th style="padding:0.75rem;text-align:center;border-bottom:1px solid var(--border);">Students</th>
                                    <th style="padding:0.75rem;text-align:center;border-bottom:1px solid var(--border);">Evaluations</th>
                                    <th style="padding:0.75rem;text-align:left;border-bottom:1px solid var(--border);">Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                courses.forEach(course => {
                    const semester = course.semester && course.year 
                        ? `${course.semester} ${course.year}`
                        : '—';
                    
                    html += `
                        <tr style="border-bottom:1px solid var(--border);">
                            <td style="padding:0.75rem;">
                                <strong>${course.name}</strong>
                            </td>
                            <td style="padding:0.75rem;color:var(--text-light);">${semester}</td>
                            <td style="padding:0.75rem;text-align:center;">${course.student_count}</td>
                            <td style="padding:0.75rem;text-align:center;">${course.evaluation_count}</td>
                            <td style="padding:0.75rem;">
                                <button onclick="viewCourseStudents('${course.id}', '${course.name.replace(/'/g, "\\'")}', '${instructorEmail}')" 
                                        style="padding:0.25rem 0.75rem;font-size:0.875rem;"><span class="icon-with-text"><i data-lucide="users" style="width:1em;height:1em;"></i> View Students</span></button>
                            </td>
                        </tr>
                    `;
                });
                
                html += `
                            </tbody>
                        </table>
                    </div>
                    <p style="margin-top:1rem;color:var(--text-light);font-size:0.875rem;">
                        Total courses: ${courses.length} | 
                        Total students: ${courses.reduce((sum, c) => sum + c.student_count, 0)} | 
                        Total evaluations: ${courses.reduce((sum, c) => sum + c.evaluation_count, 0)}
                    </p>
                `;
            }
            
            html += `
                        <div style="margin-top:1.5rem;text-align:right;">
                            <button onclick="closeInstructorCoursesModal()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;">
                                Close
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            // Add to page
            document.body.insertAdjacentHTML('beforeend', html);
            var modalEl = document.getElementById('instructorCoursesModal');
            if (modalEl && typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: modalEl });
        }
        
        // Close instructor courses modal
        function closeInstructorCoursesModal() {
            const modal = document.getElementById('instructorCoursesModal');
            if (modal) modal.remove();
        }
        
        // View course students (for admins viewing instructor's courses)
        async function viewCourseStudents(courseId, courseName, instructorEmail) {
            console.log('👥 Viewing students for course:', courseName);
            if (!supabaseClient) {
                alert('Not connected to database.');
                return;
            }
            try {
                const { data: students, error } = await supabaseClient
                    .from('course_students')
                    .select('id, first_name, last_name, email, student_id')
                    .eq('course_id', courseId)
                    .order('last_name')
                    .order('first_name');
                if (error) throw error;
                const list = (students || []).map(s => {
                    const name = escapeHtml((s.first_name || '') + ' ' + (s.last_name || '')).trim() || '—';
                    const email = escapeHtml(s.email || '—');
                    const sid = escapeHtml(s.student_id || '');
                    return `<tr><td>${name}</td><td>${email}</td><td>${sid}</td></tr>`;
                }).join('');
                const existing = document.getElementById('courseStudentsModal');
                if (existing) existing.remove();
                const modal = document.createElement('div');
                modal.id = 'courseStudentsModal';
                modal.style.cssText = 'display:flex;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;';
                modal.innerHTML = `
                    <div style="background:white;padding:2rem;border-radius:1rem;max-width:560px;width:90%;box-shadow:0 10px 40px rgba(0,0,0,0.3);max-height:80vh;overflow:hidden;display:flex;flex-direction:column;">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:1rem;flex-shrink:0;">
                            <h3 style="margin:0;color:var(--primary);"><span class="icon-with-text"><i data-lucide="users" style="width:1.25em;height:1.25em;"></i> Students — ${escapeHtml(courseName)}</span></h3>
                            <button type="button" onclick="closeCourseStudentsModal()" style="padding:0.35rem 0.75rem;border:1px solid var(--border);border-radius:0.25rem;background:var(--bg);cursor:pointer;">Close</button>
                        </div>
                        <p style="color:var(--text-light);font-size:0.9rem;margin:0 0 1rem 0;">Instructor: ${escapeHtml(instructorEmail || '')}</p>
                        <div style="overflow:auto;flex:1;">
                            ${(students || []).length === 0
                                ? '<p style="color:var(--text-light);">No students in this course.</p>'
                                : '<table class="data-table" style="width:100%;"><thead><tr><th>Name</th><th>Email</th><th>Student ID</th></tr></thead><tbody>' + list + '</tbody></table>'}
                        </div>
                    </div>`;
                modal.onclick = function(e) { if (e.target === modal) closeCourseStudentsModal(); };
                document.body.appendChild(modal);
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: modal });
            } catch (err) {
                console.error('viewCourseStudents:', err);
                alert('Error loading students. Please try again.');
            }
        }
        function closeCourseStudentsModal() {
            const modal = document.getElementById('courseStudentsModal');
            if (modal) modal.remove();
        }
        
        // View instructor details (for admins)
        async function viewInstructorDetails(instructorId, instructorEmail) {
            console.log('👤 Viewing details for:', instructorEmail);
            
            if (!supabaseClient) return;
            
            try {
                // Get instructor info
                const { data: instructor, error: userError } = await supabaseClient
                    .from('user_profiles')
                    .select(`
                        id,
                        email,
                        full_name,
                        account_tier,
                        is_research_partner,
                        research_partner_opt_out_requested,
                        research_partner_opt_out_approved,
                        research_partner_opt_out_reason,
                        created_at,
                        departments (name),
                        institutions (name)
                    `)
                    .eq('id', instructorId)
                    .single();
                
                if (userError) throw userError;
                
                // Get course count
                const { data: courses, error: courseError } = await supabaseClient
                    .from('courses')
                    .select('id')
                    .eq('instructor_id', instructorId);
                
                // Get evaluation count
                const { data: evaluations, error: evalError } = await supabaseClient
                    .from('evaluations')
                    .select('id')
                    .eq('instructor_id', instructorId);
                
                // Show details modal
                showInstructorDetailsModal(instructor, courses?.length || 0, evaluations?.length || 0);
                
            } catch (error) {
                console.error('Error loading instructor details:', error);
                alert('Error loading details. Please try again.');
            }
        }
        
        // Show instructor details modal
        function showInstructorDetailsModal(instructor, courseCount, evaluationCount) {
            const researchStatus = instructor.is_research_partner 
                ? '<span style="color:var(--success);font-weight:600;" class="icon-with-text"><i data-lucide="check-circle" style="width:1em;height:1em;"></i> Active Research Partner</span>'
                : '<span style="color:var(--text-light);">Not a research partner</span>';
            
            let optOutStatus = '';
            if (instructor.research_partner_opt_out_requested && !instructor.research_partner_opt_out_approved) {
                optOutStatus = `
                    <div style="background:#fff3cd;border-left:4px solid var(--warning);padding:1rem;margin-top:1rem;border-radius:0.5rem;">
                        <strong class="icon-with-text"><i data-lucide="alert-triangle" style="width:1em;height:1em;"></i> Pending Opt-Out Request</strong>
                        <p style="margin:0.5rem 0 0 0;color:var(--text);">
                            ${instructor.research_partner_opt_out_reason || 'No reason provided'}
                        </p>
                    </div>
                `;
            }
            
            const html = `
                <div id="instructorDetailsModal" style="display:flex;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
                    <div style="background:white;padding:2rem;border-radius:1rem;max-width:600px;width:90%;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:1.5rem;">
                            <h3 style="margin:0;color:var(--primary);"><span class="icon-with-text"><i data-lucide="user" style="width:1.25em;height:1.25em;"></i> Instructor Details</span></h3>
                            <button onclick="closeInstructorDetailsModal()" style="background:none;border:none;cursor:pointer;color:var(--text-light);padding:0.25rem;" aria-label="Close"><i data-lucide="x" style="width:1.25em;height:1.25em;"></i></button>
                        </div>
                        
                        <div style="margin-bottom:1.5rem;">
                            <p><strong>Name:</strong> ${instructor.full_name || 'Not set'}</p>
                            <p><strong>Email:</strong> ${instructor.email}</p>
                            <p><strong>Institution:</strong> ${instructor.institutions?.name || '—'}</p>
                            <p><strong>Department:</strong> ${instructor.departments?.name || '—'}</p>
                            <p><strong>Member since:</strong> ${new Date(instructor.created_at).toLocaleDateString()}</p>
                        </div>
                        
                        <div style="background:var(--bg-alt);padding:1rem;border-radius:0.5rem;margin-bottom:1.5rem;">
                            <h4 style="margin:0 0 0.5rem 0;">Activity Summary</h4>
                            <p style="margin:0.25rem 0;" class="icon-with-text"><i data-lucide="book-open" style="width:1em;height:1em;"></i> Courses: ${courseCount}</p>
                            <p style="margin:0.25rem 0;" class="icon-with-text"><i data-lucide="bar-chart-2" style="width:1em;height:1em;"></i> Evaluations: ${evaluationCount}</p>
                        </div>
                        
                        <div style="margin-bottom:1.5rem;">
                            <h4 style="margin:0 0 0.5rem 0;">Research Partner Status</h4>
                            <p style="margin:0;">${researchStatus}</p>
                            ${optOutStatus}
                        </div>
                        
                        <div style="text-align:right;">
                            <button onclick="closeInstructorDetailsModal()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;">
                                Close
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', html);
            var modalEl = document.getElementById('instructorDetailsModal');
            if (modalEl && typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: modalEl });
        }
        
        // Close instructor details modal
        function closeInstructorDetailsModal() {
            const modal = document.getElementById('instructorDetailsModal');
            if (modal) modal.remove();
        }
        
        // Admin Functions
        async function loadAllUsers() {
            if (!supabaseClient || !canManageUsers()) return;
            
            try {
                const { data: users, error } = await supabaseClient
                    .from('user_profiles')
                    .select(`
                        id,
                        email,
                        full_name,
                        account_tier,
                        is_admin,
                        is_super_admin,
                        created_at,
                        institutions (
                            name
                        ),
                        departments (
                            name
                        )
                    `)
                    .order('created_at', { ascending: false });
                
                if (error) throw error;
                
                const container = document.getElementById('usersListContainer');
                
                if (!users || users.length === 0) {
                    container.innerHTML = '<p style="color: var(--text-light);">No users found.</p>';
                    return;
                }
                
                // Build user list HTML
                let html = `
                    <div style="background: var(--bg); border: 1px solid var(--border); border-radius: 0.5rem; overflow: hidden;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead style="background: var(--bg-alt);">
                                <tr>
                                    <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Email</th>
                                    <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Name</th>
                                    <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Institution</th>
                                    <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Department</th>
                                    <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Tier</th>
                                    <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Admin</th>
                                    <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                users.forEach(user => {
                    // Determine tier badge based on new tier system
                    let tierBadge = '';
                    switch(user.account_tier) {
                        case 'super_admin':
                            tierBadge = '<span style="background: #9333ea; color: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600;">🌐 Super Admin</span>';
                            break;
                        case 'admin':
                            tierBadge = '<span style="background: var(--primary); color: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600;">🏛️ Admin</span>';
                            break;
                        case 'instructor':
                            tierBadge = '<span style="background: var(--success); color: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600;" class="icon-with-text"><i data-lucide="user" style="width:0.9em;height:0.9em;"></i> Instructor</span>';
                            break;
                        case 'demo':
                            tierBadge = '<span style="background: var(--warning); color: black; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600;" class="icon-with-text"><i data-lucide="theater" style="width:0.9em;height:0.9em;"></i> Demo</span>';
                            break;
                        default:
                            tierBadge = '<span style="background: var(--text-light); color: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem;">Unknown</span>';
                    }
                    
                    const adminBadge = user.is_admin || user.is_super_admin
                        ? '<span style="color: var(--success); font-size: 1.25rem;"><i data-lucide="check" style="width:1.25rem;height:1.25rem;"></i></span>'
                        : '<span style="color: var(--text-light);">—</span>';
                    
                    const institutionName = user.institutions?.name || '—';
                    const departmentName = user.departments?.name || '—';
                    
                    html += `
                        <tr style="border-bottom: 1px solid var(--border);">
                            <td style="padding: 0.75rem;">${user.email}</td>
                            <td style="padding: 0.75rem; color: var(--text-light);">${user.full_name || '—'}</td>
                            <td style="padding: 0.75rem; color: var(--text-light);">${institutionName}</td>
                            <td style="padding: 0.75rem; color: var(--text-light);">${departmentName}</td>
                            <td style="padding: 0.75rem;">${tierBadge}</td>
                            <td style="padding: 0.75rem; text-align: center;">${adminBadge}</td>
                            <td style="padding: 0.75rem;">
                                <button onclick="editUserTier('${user.id}', '${user.email}', '${user.account_tier}', ${user.is_admin})" 
                                        style="padding: 0.25rem 0.75rem; font-size: 0.875rem;">
                                    Edit
                                </button>
                            </td>
                        </tr>
                    `;
                });
                
                html += `
                            </tbody>
                        </table>
                    </div>
                    <p style="margin-top: 1rem; color: var(--text-light); font-size: 0.875rem;">
                        Total users: ${users.length}
                    </p>
                `;
                
                container.innerHTML = html;
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: container });
                
            } catch (error) {
                console.error('Error loading users:', error);
                document.getElementById('usersListContainer').innerHTML = 
                    `<p style="color: var(--danger);">Error loading users: ${error.message}</p>`;
            }
        }
        
        // Edit user tier
        function editUserTier(userId, email, currentTier, isAdmin) {
            const newTier = prompt(
                `Change account tier for ${email}\n\n` +
                `Current tier: ${currentTier}\n` +
                `Current admin: ${isAdmin ? 'Yes' : 'No'}\n\n` +
                `Enter new tier:\n` +
                `- demo (testing only)\n` +
                `- instructor (faculty)\n` +
                `- admin (department head)\n` +
                `- super_admin (system-wide)`,
                currentTier
            );
            
            if (!newTier || newTier === currentTier) return;
            
            const validTiers = ['demo', 'instructor', 'admin', 'super_admin'];
            if (!validTiers.includes(newTier)) {
                alert('Invalid tier. Must be one of: demo, instructor, admin, super_admin');
                return;
            }
            
            // Warn when promoting to super_admin
            if (newTier === 'super_admin') {
                const confirm = window.confirm(
                    `⚠️ WARNING: Promoting ${email} to Super Admin\n\n` +
                    `This will give them:\n` +
                    `- Access to ALL institutions\n` +
                    `- Ability to manage ALL users\n` +
                    `- System-wide administration\n\n` +
                    `Are you sure?`
                );
                if (!confirm) return;
            }
            
            updateUserTier(userId, email, newTier, null);
        }
        
        // Update user tier in database
        async function updateUserTier(userId, email, newTier, toggleAdmin) {
            if (!supabaseClient || !canManageUsers()) return;
            
            try {
                const updates = {
                    account_tier: newTier,
                    updated_at: new Date().toISOString()
                };
                
                // If toggleAdmin is provided, update admin status
                if (toggleAdmin !== null) {
                    updates.is_admin = toggleAdmin;
                }
                
                const { error } = await supabaseClient
                    .from('user_profiles')
                    .update(updates)
                    .eq('id', userId);
                
                if (error) throw error;
                
                alert(`✓ Updated ${email} to ${newTier}${toggleAdmin !== null ? (toggleAdmin ? ' (Admin)' : ' (Not Admin)') : ''}`);
                
                // Reload user list
                loadAllUsers();
                
            } catch (error) {
                console.error('Error updating user:', error);
                alert('Error updating user: ' + error.message);
            }
        }
        
        function showInviteForm() {
            document.getElementById('inviteFormCard').classList.remove('hidden');
        }
        
        function cancelInvite() {
            document.getElementById('inviteFormCard').classList.add('hidden');
            document.getElementById('inviteForm').reset();
        }
        
        async function sendInvite(event) {
            event.preventDefault();
            
            const recipientEmail = document.getElementById('inviteEmail').value;
            const name = document.getElementById('inviteName').value;
            const institution = document.getElementById('inviteInstitution').value;
            const autoApprove = document.getElementById('inviteAutoApprove').checked;
            
            // Get the current deployment URL
            const deploymentUrl = window.location.origin + window.location.pathname;
            const registrationUrl = `${deploymentUrl}#register`;
            
            // Create invitation record in database
            let inviteToken = null;
            if (supabaseClient && autoApprove) {
                try {
                    inviteToken = generateInviteToken();
                    const { error } = await supabaseClient
                        .from('invitations')
                        .insert({
                            email: recipientEmail,
                            name: name,
                            institution: institution,
                            invited_by: currentUser.email,
                            invite_token: inviteToken,
                            account_tier: 'research_partner',
                            expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString()
                        });
                    
                    if (error) {
                        console.error('Could not save invitation:', error);
                    }
                } catch (err) {
                    console.error('Error saving invitation:', err);
                }
            }
            
            // Show sending modal
            showSendingInvitationModal(recipientEmail, name, institution, registrationUrl, autoApprove);
            
            cancelInvite();
        }
        
        // Show modal for sending invitation
        function showSendingInvitationModal(recipientEmail, name, institution, registrationUrl, autoApprove) {
            const modal = document.createElement('div');
            modal.id = 'invitationModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                padding: 2rem;
            `;
            
            const institutionLine = institution ? `<tr><td style="padding: 8px 12px; color: var(--text-light); border-bottom: 1px solid var(--border);">Institution:</td><td style="padding: 8px 12px; border-bottom: 1px solid var(--border);"><strong>${institution}</strong></td></tr>` : '';
            
            modal.innerHTML = `
                <div style="background: var(--bg); border-radius: 12px; max-width: 700px; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3);">
                    <div style="background: var(--primary); padding: 2rem; border-radius: 12px 12px 0 0; color: white;">
                        <h2 style="margin: 0; font-size: 1.5rem; font-weight: 600;"><span class="icon-with-text"><i data-lucide="mail" style="width:1.25em;height:1.25em;"></i> Send Research Partner Invitation</span></h2>
                        <p style="margin: 0.5rem 0 0 0; opacity: 0.9;">Review and send invitation to join SpeechGradebook</p>
                    </div>
                    
                    <div style="padding: 2rem;">
                        <!-- Recipient Info -->
                        <div style="background: var(--bg-alt); border-radius: 8px; padding: 1.5rem; margin-bottom: 1.5rem; border-left: 4px solid var(--primary);">
                            <h3 style="margin: 0 0 1rem 0; font-size: 1rem; color: var(--text);">Invitation Details</h3>
                            <table style="width: 100%; border-collapse: collapse;">
                                <tr>
                                    <td style="padding: 8px 12px; color: var(--text-light); border-bottom: 1px solid var(--border); width: 120px;">To:</td>
                                    <td style="padding: 8px 12px; border-bottom: 1px solid var(--border);"><strong>${recipientEmail}</strong></td>
                                </tr>
                                <tr>
                                    <td style="padding: 8px 12px; color: var(--text-light); border-bottom: 1px solid var(--border);">Name:</td>
                                    <td style="padding: 8px 12px; border-bottom: 1px solid var(--border);"><strong>${name || 'Not provided'}</strong></td>
                                </tr>
                                ${institutionLine}
                                <tr>
                                    <td style="padding: 8px 12px; color: var(--text-light);">Access Level:</td>
                                    <td style="padding: 8px 12px;"><span style="background: var(--success); color: white; padding: 4px 12px; border-radius: 4px; font-size: 0.875rem; font-weight: 600;">Research Partner</span></td>
                                </tr>
                            </table>
                        </div>
                        
                        <!-- Email Preview -->
                        <div style="background: var(--bg); border: 2px solid var(--border); border-radius: 8px; padding: 2rem; margin-bottom: 1.5rem;">
                            <div style="border-bottom: 2px solid var(--primary); padding-bottom: 1rem; margin-bottom: 1.5rem;">
                                <p style="margin: 0; color: var(--text-light); font-size: 0.875rem;">Subject:</p>
                                <p style="margin: 0.25rem 0 0 0; font-size: 1.125rem; font-weight: 600; color: var(--text);">Invitation to SpeechGradebook Research Partnership</p>
                            </div>
                            
                            <div style="line-height: 1.8; color: var(--text); font-size: 0.9375rem;">
                                <p style="margin: 0 0 1.5rem 0;">Dear ${name || 'Colleague'},</p>
                                
                                <p style="margin: 0 0 1.5rem 0;">You're invited to join <strong>SpeechGradebook</strong> as a <strong style="color: var(--primary);">Research Partner</strong>.</p>
                                
                                <div style="background: var(--bg-alt); border-left: 4px solid var(--primary); padding: 1rem 1.5rem; margin: 1.5rem 0; border-radius: 4px;">
                                    <p style="margin: 0 0 0.75rem 0; font-weight: 600; color: var(--primary);">Benefits:</p>
                                    <ul style="margin: 0; padding-left: 1.25rem;">
                                        <li style="margin-bottom: 0.5rem;">Full evaluation storage and correction tracking</li>
                                        <li style="margin-bottom: 0.5rem;">Contribute to AI training research</li>
                                        <li style="margin-bottom: 0.5rem;">Help improve speech education technology</li>
                                    </ul>
                                </div>
                                
                                <div style="background: var(--warning-bg); border-left: 4px solid var(--warning); padding: 1rem 1.5rem; margin: 1.5rem 0; border-radius: 4px;">
                                    <p style="margin: 0 0 0.75rem 0; font-weight: 600; color: var(--warning-dark);">To get started:</p>
                                    <ol style="margin: 0; padding-left: 1.25rem;">
                                        <li style="margin-bottom: 0.5rem;">Register at: <a href="${registrationUrl}" style="color: var(--primary); text-decoration: none; font-weight: 600;">${registrationUrl}</a></li>
                                        <li style="margin-bottom: 0.5rem;">Use this email address (<strong>${recipientEmail}</strong>) during registration</li>
                                        <li style="margin-bottom: 0;">Your account will be automatically upgraded to Research Partner</li>
                                    </ol>
                                </div>
                                
                                ${institution ? `<p style="margin: 1.5rem 0;"><strong>Institution:</strong> ${institution}</p>` : ''}
                                
                                <p style="margin: 1.5rem 0;">Questions? Contact us at <a href="mailto:speechgradebook@proton.me" style="color: var(--primary); text-decoration: none;">speechgradebook@proton.me</a></p>
                                
                                <div style="background: var(--success-bg); border-left: 4px solid var(--success); padding: 1rem 1.5rem; margin: 1.5rem 0; border-radius: 4px;">
                                    <p style="margin: 0 0 0.75rem 0; font-weight: 600; color: var(--success-dark);">After registration, you'll have full access to:</p>
                                    <ul style="margin: 0; padding-left: 1.25rem;">
                                        <li style="margin-bottom: 0.5rem;">Unlimited speech evaluations</li>
                                        <li style="margin-bottom: 0.5rem;">Save and track student progress</li>
                                        <li style="margin-bottom: 0.5rem;">Edit and correct AI evaluations</li>
                                        <li style="margin-bottom: 0;">Contribute to groundbreaking research</li>
                                    </ul>
                                </div>
                                
                                <div style="margin-top: 2rem; padding-top: 1.5rem; border-top: 1px solid var(--border);">
                                    <p style="margin: 0 0 0.25rem 0;">Best regards,</p>
                                    <p style="margin: 0; font-weight: 600;">Anna McClure, Ph.D.</p>
                                    <p style="margin: 0.25rem 0 0 0; color: var(--text-light); font-size: 0.875rem;">SpeechGradebook Research Team</p>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                            <button onclick="closeInvitationModal()" class="btn-secondary" style="padding: 0.75rem 1.5rem;">Cancel</button>
                            <button onclick="copyInvitationForManualSend('${recipientEmail.replace(/'/g, "\\'")}', '${name.replace(/'/g, "\\'")}', '${institution.replace(/'/g, "\\'")}', '${registrationUrl}')" style="padding: 0.75rem 1.5rem;"><span class="icon-with-text"><i data-lucide="clipboard-copy" style="width:1em;height:1em;"></i> Copy Text</span></button>
                            <button onclick="sendInvitationEmail('${recipientEmail.replace(/'/g, "\\'")}', '${name.replace(/'/g, "\\'")}', '${institution.replace(/'/g, "\\'")}', '${registrationUrl}')" style="padding: 0.75rem 2rem;"><span class="icon-with-text"><i data-lucide="send" style="width:1em;height:1em;"></i> Send Invitation</span></button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: modal });
        }
        
        // Send invitation email directly
        async function sendInvitationEmail(recipientEmail, name, institution, registrationUrl) {
            const button = event.target;
            const originalText = button.innerHTML;
            button.innerHTML = '⏳ Sending...';
            button.disabled = true;
            
            try {
                const subject = 'Invitation to SpeechGradebook Research Partnership';
                
                // Create HTML version
                const htmlBody = createHTMLInvitation(recipientEmail, name, institution, registrationUrl);
                
                // For Gmail, use their compose URL with HTML support
                const isGmail = currentUser.email && currentUser.email.includes('@gmail.com');
                
                if (isGmail) {
                    // Open Gmail compose
                    const gmailUrl = `https://mail.google.com/mail/?view=cm&fs=1&to=${encodeURIComponent(recipientEmail)}&su=${encodeURIComponent(subject)}`;
                    window.open(gmailUrl, '_blank');
                    
                    // Copy HTML to clipboard for pasting
                    navigator.clipboard.writeText(htmlBody).then(() => {
                        setTimeout(() => {
                            alert('✅ Gmail opened!\n\nHTML email copied to clipboard.\n\n1. In Gmail, click the three dots (...) at bottom\n2. Select "Rich formatting mode"\n3. Paste (Ctrl+V or Cmd+V)\n4. Send!');
                            closeInvitationModal();
                        }, 500);
                    });
                } else {
                    // For other email clients, use mailto with plain text
                    const plainBody = createPlainTextInvitation(recipientEmail, name, institution, registrationUrl);
                    const mailtoLink = `mailto:${recipientEmail}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(plainBody)}`;
                    window.location.href = mailtoLink;
                    
                    setTimeout(() => {
                        alert('✅ Email client opened!\n\nPlease send the invitation.');
                        closeInvitationModal();
                    }, 1000);
                }
                
            } catch (error) {
                console.error('Error sending invitation:', error);
                alert('❌ Could not send invitation.\n\nPlease use the "Copy Text" button and send manually.');
                button.innerHTML = originalText;
                button.disabled = false;
            }
        }
        
        // Create HTML email version
        function createHTMLInvitation(recipientEmail, name, institution, registrationUrl) {
            return `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body style="margin: 0; padding: 0; font-family: 'Work Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background-color: #f5f5f5;">
    <div style="max-width: 600px; margin: 0 auto; background-color: #ffffff;">
        <!-- Header -->
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 40px 30px; text-align: center;">
            <h1 style="color: #ffffff; margin: 0; font-size: 28px; font-weight: 600; font-family: 'Crimson Pro', serif;">SpeechGradebook</h1>
            <p style="color: rgba(255,255,255,0.9); margin: 10px 0 0 0; font-size: 16px;">Research Partnership Invitation</p>
        </div>
        
        <!-- Content -->
        <div style="padding: 40px 30px; line-height: 1.8; color: #333333;">
            <p style="margin: 0 0 20px 0; font-size: 16px;">Dear ${name || 'Colleague'},</p>
            
            <p style="margin: 0 0 24px 0; font-size: 16px;">You're invited to join <strong>SpeechGradebook</strong> as a <strong style="color: #667eea;">Research Partner</strong>.</p>
            
            <!-- Benefits Box -->
            <div style="background-color: #f0f4ff; border-left: 4px solid #667eea; padding: 20px; margin: 24px 0; border-radius: 4px;">
                <p style="margin: 0 0 12px 0; font-weight: 600; color: #667eea; font-size: 16px;">Benefits:</p>
                <ul style="margin: 0; padding-left: 20px; font-size: 15px;">
                    <li style="margin-bottom: 8px;">Full evaluation storage and correction tracking</li>
                    <li style="margin-bottom: 8px;">Contribute to AI training research</li>
                    <li style="margin-bottom: 0;">Help improve speech education technology</li>
                </ul>
            </div>
            
            <!-- Getting Started Box -->
            <div style="background-color: #fff9e6; border-left: 4px solid #ffc107; padding: 20px; margin: 24px 0; border-radius: 4px;">
                <p style="margin: 0 0 12px 0; font-weight: 600; color: #f57c00; font-size: 16px;">To get started:</p>
                <ol style="margin: 0; padding-left: 20px; font-size: 15px;">
                    <li style="margin-bottom: 8px;">Register at: <a href="${registrationUrl}" style="color: #667eea; text-decoration: none; font-weight: 600;">${registrationUrl}</a></li>
                    <li style="margin-bottom: 8px;">Use this email address (<strong>${recipientEmail}</strong>) during registration</li>
                    <li style="margin-bottom: 0;">Your account will be automatically upgraded to Research Partner</li>
                </ol>
            </div>
            
            ${institution ? `<p style="margin: 24px 0; font-size: 15px;"><strong>Institution:</strong> ${institution}</p>` : ''}
            
            <p style="margin: 24px 0; font-size: 15px;">Questions? Contact us at <a href="mailto:speechgradebook@proton.me" style="color: #667eea; text-decoration: none;">speechgradebook@proton.me</a></p>
            
            <!-- Access Box -->
            <div style="background-color: #e8f5e9; border-left: 4px solid #4caf50; padding: 20px; margin: 24px 0; border-radius: 4px;">
                <p style="margin: 0 0 12px 0; font-weight: 600; color: #2e7d32; font-size: 16px;">After registration, you'll have full access to:</p>
                <ul style="margin: 0; padding-left: 20px; font-size: 15px;">
                    <li style="margin-bottom: 8px;">Unlimited speech evaluations</li>
                    <li style="margin-bottom: 8px;">Save and track student progress</li>
                    <li style="margin-bottom: 8px;">Edit and correct AI evaluations</li>
                    <li style="margin-bottom: 0;">Contribute to groundbreaking research</li>
                </ul>
            </div>
            
            <!-- Signature -->
            <div style="margin-top: 40px; padding-top: 24px; border-top: 1px solid #e0e0e0;">
                <p style="margin: 0 0 4px 0; font-size: 15px;">Best regards,</p>
                <p style="margin: 0; font-weight: 600; font-size: 16px;">Anna McClure, Ph.D.</p>
                <p style="margin: 4px 0 0 0; color: #666666; font-size: 14px;">SpeechGradebook Research Team</p>
            </div>
        </div>
        
        <!-- Footer -->
        <div style="background-color: #f5f5f5; padding: 20px 30px; text-align: center; border-top: 1px solid #e0e0e0;">
            <p style="margin: 0; color: #999999; font-size: 13px;">SpeechGradebook | Instructor-Informed Speech Assessment</p>
        </div>
    </div>
</body>
</html>`;
        }
        
        // Create plain text version for email
        function createPlainTextInvitation(recipientEmail, name, institution, registrationUrl) {
            return `Dear ${name || 'Colleague'},

You're invited to join SpeechGradebook as a Research Partner.

BENEFITS:
• Full evaluation storage and correction tracking
• Contribute to AI training research
• Help improve speech education technology

TO GET STARTED:
1. Register at: ${registrationUrl}
2. Use this email address (${recipientEmail}) during registration
3. Your account will be automatically upgraded to Research Partner

${institution ? `Institution: ${institution}\n\n` : ''}Questions? Contact us at speechgradebook@proton.me

AFTER REGISTRATION, YOU'LL HAVE FULL ACCESS TO:
• Unlimited speech evaluations
• Save and track student progress
• Edit and correct AI evaluations
• Contribute to groundbreaking research

Best regards,
Anna McClure, Ph.D.
SpeechGradebook Research Team`;
        }
        
        // Copy invitation text for manual sending
        function copyInvitationForManualSend(recipientEmail, name, institution, registrationUrl) {
            const text = createPlainTextInvitation(recipientEmail, name, institution, registrationUrl);
            
            navigator.clipboard.writeText(text).then(() => {
                alert(`✅ Invitation text copied to clipboard!\n\nYou can now:\n1. Open your email client\n2. Compose new email to: ${recipientEmail}\n3. Paste the invitation text`);
            }).catch(() => {
                // Fallback
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                alert(`✅ Invitation text copied!\n\nSend to: ${recipientEmail}`);
            });
        }
        
        // Close invitation modal
        function closeInvitationModal() {
            const modal = document.getElementById('invitationModal');
            if (modal) {
                modal.remove();
            }
        }
        
        // Generate a simple invite token
        function generateInviteToken() {
            return Math.random().toString(36).substring(2) + Date.now().toString(36);
        }

        function setActiveSection(sectionId, navId) {
            // Hide all sections using display (not just class)
            document.querySelectorAll('.section').forEach(s => {
                s.classList.remove('active');
                s.style.display = 'none'; // CRITICAL: Actually hide the section
            });
            
            // Show selected section
            const selectedSection = document.getElementById(sectionId);
            if (selectedSection) {
                selectedSection.classList.add('active');
                selectedSection.style.display = 'block'; // CRITICAL: Actually show the section
            }
            
            // Update nav (active state and aria-current for accessibility)
            document.querySelectorAll('.nav-link').forEach(n => {
                n.classList.remove('active');
                n.removeAttribute('aria-current');
            });
            const selectedNav = document.getElementById(navId);
            if (selectedNav) {
                selectedNav.classList.add('active');
                selectedNav.setAttribute('aria-current', 'page');
            }
        }

        // ===== TENANT/THEME MANAGEMENT =====
        function switchTenant(tenantId) {
            currentTenant = tenantId;
            applyTenant(tenantId);
            localStorage.setItem('current_tenant', tenantId);
        }

        function applyTenant(tenantId) {
            const config = TENANT_CONFIGS[tenantId] || TENANT_CONFIGS['default'];
            
            // Apply colors
            const root = document.documentElement;
            root.style.setProperty('--primary', config.colors.primary);
            root.style.setProperty('--primary-dark', config.colors.primaryDark);
            root.style.setProperty('--secondary', config.colors.secondary);
            root.style.setProperty('--accent', config.colors.accent);
            
            // Apply fonts
            root.style.setProperty('--heading-font', config.typography.headingFont);
            root.style.setProperty('--body-font', config.typography.bodyFont);
            root.style.setProperty('--heading-weight', config.typography.headingWeight);
            root.style.setProperty('--body-weight', config.typography.bodyWeight);
            
            // Apply branding (appName, tagline, logo)
            const appNameEl = document.getElementById('appName');
            if (appNameEl) appNameEl.textContent = config.branding.appName;
            const appTaglineEl = document.getElementById('appTagline');
            if (appTaglineEl) appTaglineEl.textContent = config.branding.tagline;
            const appLogoEl = document.getElementById('appLogo');
            if (appLogoEl) {
                if (tenantId === 'default') {
                    appLogoEl.innerHTML = '<img src="assets/logo-dark-bg.png" alt="Speech Gradebook" style="width: 100%; height: 100%; object-fit: cover; object-position: center; border-radius: 50%;">';
                    appLogoEl.style.backgroundColor = '#ffffff';
                } else {
                    appLogoEl.textContent = config.shortName || '';
                    appLogoEl.style.backgroundColor = '#ffffff';
                }
            }
            document.title = `${config.branding.appName} - ${config.name}`;
            
            // Apply footer
            const footerLinks = document.getElementById('footerLinks');
            footerLinks.innerHTML = config.footer.links.map(link => 
                `<a href="${link.url}">${link.text}</a>`
            ).join('');
            
            document.getElementById('footerCopyright').textContent = config.footer.copyright;
            document.getElementById('footerAdditional').textContent = config.footer.additionalText || '';
            
            // Apply contact (preserve mailto link inside #supportEmail)
            const supportEl = document.getElementById('supportEmail');
            if (supportEl) {
                const email = config.contact.supportEmail || 'speechgradebook@proton.me';
                const link = supportEl.querySelector('a');
                if (link) {
                    link.href = 'mailto:' + email;
                    link.textContent = email;
                } else {
                    const safeHref = 'mailto:' + String(email).replace(/"/g, '&quot;');
                    supportEl.innerHTML = '<a href="' + safeHref + '">' + escapeHtml(email) + '</a>';
                }
            }
            
            // Update tenant selector
            document.getElementById('tenantSelect').value = tenantId;
        }

        // ===== FILE UPLOAD =====
        function initializeFileUpload() {
            const uploadZone = document.getElementById('uploadZone');
            const fileInput = document.getElementById('fileInput');

            uploadZone.addEventListener('click', () => fileInput.click());

            uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadZone.classList.add('drag-over');
            });

            uploadZone.addEventListener('dragleave', () => {
                uploadZone.classList.remove('drag-over');
            });

            uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadZone.classList.remove('drag-over');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });

            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFile(e.target.files[0]);
                }
            });
        }

        function handleFile(file) {
            const sizeMB = (file.size / 1024 / 1024).toFixed(2);
            
            uploadedFile = file;
            document.getElementById('fileName').textContent = `📎 ${file.name} (${formatFileSize(file.size)})`;
            document.getElementById('fileInfo').classList.remove('hidden');
            document.getElementById('continueButtonContainer').style.display = 'block';
        }

        function removeFile() {
            uploadedFile = null;
            document.getElementById('fileInfo').classList.add('hidden');
            document.getElementById('fileInput').value = '';
            document.getElementById('continueButtonContainer').style.display = 'none';
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        // ===== STEP NAVIGATION =====
        function moveToStep(step) {
            currentStep = step;
            console.log('=== moveToStep(' + step + ') called ===');
            
            // Hide all steps
            document.getElementById('uploadStep').classList.add('hidden');
            document.getElementById('detailsStep').classList.add('hidden');
            document.getElementById('processingStep').classList.add('hidden');
            document.getElementById('resultsStep').classList.add('hidden');
            
            // Update step indicators
            for (let i = 1; i <= 4; i++) {
                const stepEl = document.getElementById(`step${i}`);
                stepEl.classList.remove('active', 'completed');
                if (i < step) {
                    stepEl.classList.add('completed');
                } else if (i === step) {
                    stepEl.classList.add('active');
                }
            }
            
            // Update card header based on step
            const headerEl = document.getElementById('evaluateCardHeader');
            if (step === 4) {
                headerEl.innerHTML = '<span class="icon-with-text"><i data-lucide="bar-chart-2"></i> Speech Evaluation Results</span>';
            } else {
                headerEl.innerHTML = '<span class="icon-with-text"><i data-lucide="mic"></i> Evaluate a Speech</span>';
            }
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: headerEl });
            
            // Show current step
            if (step === 1) {
                document.getElementById('uploadStep').classList.remove('hidden');
            } else if (step === 2) {
                document.getElementById('detailsStep').classList.remove('hidden');
                // Populate rubric selector
                populateRubricSelector();
                if (typeof updateEvalProviderHint === 'function') updateEvalProviderHint();
            } else if (step === 3) {
                document.getElementById('processingStep').classList.remove('hidden');
            } else if (step === 4) {
                console.log('Showing results step');
                document.getElementById('resultsStep').classList.remove('hidden');
            }
        }

        async function populateRubricSelector() {
            const select = document.getElementById('rubricSelect');
            if (!select) return;
            
            const rubrics = await getAllRubrics();
            const classes = JSON.parse(getUserItem('classes') || '[]');
            
            // Clear existing options except the first one
            select.innerHTML = '<option value="">-- Select a Rubric --</option>';
            
            // Separate rubrics by type
            const defaultRubrics = rubrics.filter(r => r.id === 'default');
            
            // Filter unassigned rubrics (no courseId or courseIds)
            const unassignedRubrics = rubrics.filter(r => {
                if (r.id === 'default') return false;
                const hasOldCourseId = r.courseId && r.courseId !== '';
                const hasNewCourseIds = r.courseIds && Array.isArray(r.courseIds) && r.courseIds.length > 0;
                return !hasOldCourseId && !hasNewCourseIds;
            });
            
            // Add default rubric
            if (defaultRubrics.length > 0) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = 'System Default';
                defaultRubrics.forEach(rubric => {
                    const option = document.createElement('option');
                    option.value = rubric.id;
                    option.textContent = `${rubric.name} (${rubric.totalPoints} pts)`;
                    optgroup.appendChild(option);
                });
                select.appendChild(optgroup);
            }
            
            // Group rubrics by course NAME (not ID) to consolidate sections
            const rubricsByCourse = {};
            rubrics.filter(r => r.id !== 'default').forEach(rubric => {
                // Get courseIds for this rubric (handle both old and new format)
                let courseIds = [];
                if (rubric.courseIds && Array.isArray(rubric.courseIds)) {
                    courseIds = rubric.courseIds;
                } else if (rubric.courseId) {
                    courseIds = [rubric.courseId];
                }
                
                // Add rubric to each course it's assigned to
                courseIds.forEach(courseId => {
                    const course = classes.find(c => c.id === courseId);
                    if (course) {
                        // Use course name + semester + year as key
                        const courseKey = `${course.name}|${course.semester}|${course.year}`;
                        if (!rubricsByCourse[courseKey]) {
                            rubricsByCourse[courseKey] = {
                                name: course.name,
                                semester: course.semester,
                                year: course.year,
                                rubrics: []
                            };
                        }
                        // Avoid duplicates
                        if (!rubricsByCourse[courseKey].rubrics.find(r => r.id === rubric.id)) {
                            rubricsByCourse[courseKey].rubrics.push(rubric);
                        }
                    }
                });
            });
            
            // Add course-specific rubrics grouped by course name
            Object.keys(rubricsByCourse).sort().forEach(courseKey => {
                const courseGroup = rubricsByCourse[courseKey];
                
                const optgroup = document.createElement('optgroup');
                optgroup.label = `${courseGroup.name} - ${courseGroup.semester} ${courseGroup.year}`;
                
                courseGroup.rubrics.forEach(rubric => {
                    const option = document.createElement('option');
                    option.value = rubric.id;
                    option.textContent = `${rubric.name} (${rubric.totalPoints} pts)`;
                    if (rubric.speechType) {
                        option.textContent += ` - ${rubric.speechType}`;
                    }
                    optgroup.appendChild(option);
                });
                
                select.appendChild(optgroup);
            });
            
            // Add unassigned custom rubrics
            if (unassignedRubrics.length > 0) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = 'Rubrics (No Course)';
                unassignedRubrics.forEach(rubric => {
                    const option = document.createElement('option');
                    option.value = rubric.id;
                    option.textContent = `${rubric.name} (${rubric.totalPoints} pts)`;
                    if (rubric.speechType) {
                        option.textContent += ` - ${rubric.speechType}`;
                    }
                    optgroup.appendChild(option);
                });
                select.appendChild(optgroup);
            }
            
            // Pre-select the Self-Introduction rubric if available
            const selfIntroRubric = rubrics.find(r => r.id === 'self-intro-1');
            if (selfIntroRubric) {
                select.value = selfIntroRubric.id;
            }
        }

        // ===== FORMS =====
        function initializeForms() {
            console.log('initializeForms() called');
            
            // Student form
            const studentForm = document.getElementById('studentForm');
            console.log('studentForm element:', studentForm);
            
            if (!studentForm) {
                console.error('ERROR: studentForm element not found!');
                return;
            }
            
            console.log('Adding submit event listener to studentForm...');
            studentForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                console.log('>>> FORM SUBMITTED <<<');
                
                try {
                    if (!uploadedFile) {
                        console.log('Form validation: No file uploaded');
                        alert('Please upload a speech recording first.');
                        return;
                    }
                    console.log('Form validation: File OK');

                    console.log('Form handler: Calling moveToStep(3)');
                    moveToStep(3);
                    console.log('Form handler: Calling processAndEvaluate()');
                    await processAndEvaluate();
                    console.log('Form handler: processAndEvaluate() completed');
                } catch (error) {
                    console.error('FORM HANDLER ERROR:', error);
                    alert('Form submission error: ' + error.message);
                    moveToStep(2);
                }
            });
            console.log('✓ Submit event listener attached to studentForm');
            
            // Also add click listener to submit button for debugging
            const submitBtn = document.getElementById('submitEvaluationBtn');
            if (submitBtn) {
                submitBtn.addEventListener('click', function(e) {
                    console.log('Submit button clicked!');
                    console.log('Form validity:', studentForm.checkValidity());
                    console.log('Rubric selected:', document.getElementById('rubricSelect').value);
                    const defaultUrl = 'http://localhost:8000/api';
                    console.log('Evaluation server URL:', localStorage.getItem('finetuned_api_url') || defaultUrl);
                    
                    // Check if form is valid
                    if (!studentForm.checkValidity()) {
                        console.log('Form is INVALID - browser will show validation message');
                        return;
                    }
                    
                    console.log('Form is valid, but submit event not firing - manually triggering...');
                    // Manually call the submit handler since the form submit event isn't firing
                    e.preventDefault();
                    studentForm.dispatchEvent(new Event('submit'));
                });
                console.log('✓ Click listener attached to submit button');
            }

            // Create class form
            document.getElementById('createClassForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const newClass = {
                    id: Date.now().toString(),
                    name: document.getElementById('className').value,
                    semester: document.getElementById('classSemester').value,
                    section: document.getElementById('classSection').value,
                    year: document.getElementById('classYear').value,
                    notes: document.getElementById('classNotes').value,
                    roster: [],
                    evaluations: [],
                    createdAt: new Date().toISOString()
                };
                
                // Save to localStorage first (immediate)
                const classes = JSON.parse(getUserItem('classes') || '[]');
                classes.push(newClass);
                setUserItem('classes', JSON.stringify(classes));
                console.log('✓ Class saved to localStorage');
                
                // Also save to Supabase (async)
                if (supabaseClient) {
                    saveCourseToSupabase(newClass).then(supabaseCourse => {
                        if (supabaseCourse) {
                            // Update with Supabase ID
                            newClass.supabaseId = supabaseCourse.id;
                            const updated = classes.find(c => c.id === newClass.id);
                            if (updated) {
                                updated.supabaseId = supabaseCourse.id;
                                setUserItem('classes', JSON.stringify(classes));
                            }
                        }
                    }).catch(err => {
                        console.log('Supabase save failed, but localStorage succeeded');
                    });
                }
                
                alert('✓ Class created successfully!');
                document.getElementById('createClassForm').reset();
                cancelCreateClass();
                await loadClasses();
            });

            // Create rubric form
            document.getElementById('createRubricForm').addEventListener('submit', (e) => {
                e.preventDefault();
                
                try {
                    const rubricData = collectRubricData();
                    
                    // Validation
                    if (!rubricData.name) {
                        alert('Please enter a rubric name');
                        return;
                    }
                    
                    if (rubricData.totalPoints < 1) {
                        alert('Total points must be at least 1');
                        return;
                    }
                    
                    if (rubricData.categories.length === 0) {
                        alert('Please add at least one category with subcategories');
                        return;
                    }
                    
                    // Check that all categories have subcategories
                    const emptyCategories = rubricData.categories.filter(cat => cat.subcategories.length === 0);
                    if (emptyCategories.length > 0) {
                        alert('All categories must have at least one subcategory');
                        return;
                    }
                    
                    // Save using the new storage system
                    const savedRubric = saveRubric(rubricData);
                    
                    const isEditing = document.getElementById('editingRubricId').value !== '';
                    alert(isEditing ? '✓ Rubric updated successfully!' : '✓ Rubric created successfully!');
                    
                    document.getElementById('createRubricForm').reset();
                    cancelCreateRubric();
                    loadRubrics();
                } catch (error) {
                    console.error('Error saving rubric:', error);
                    alert('Error saving rubric: ' + error.message);
                }
            });

            // Add student form
            document.getElementById('addStudentForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const newStudent = {
                    id: Date.now().toString(),
                    firstName: document.getElementById('studentFirstName').value,
                    lastName: document.getElementById('studentLastName').value,
                    email: document.getElementById('studentEmailAdd').value,
                    studentId: document.getElementById('studentIdAdd').value,
                    addedAt: new Date().toISOString()
                };
                
                const classes = JSON.parse(getUserItem('classes') || '[]');
                const classIndex = classes.findIndex(c => c.id === currentClassId);
                
                if (classIndex !== -1) {
                    if (!classes[classIndex].roster) {
                        classes[classIndex].roster = [];
                    }
                    classes[classIndex].roster.push(newStudent);
                    setUserItem('classes', JSON.stringify(classes));
                    console.log('✓ Student saved to localStorage');
                    
                    // Also save to Supabase if course has supabaseId
                    const course = classes[classIndex];
                    if (supabaseClient && course.supabaseId) {
                        await saveStudentsToSupabase(course.supabaseId, [newStudent]);
                    }
                    
                    alert('✓ Student added successfully!');
                    document.getElementById('addStudentForm').reset();
                    cancelAddStudent();
                    await viewClass(currentClassId); // Refresh the view
                }
            });
        }

        function updateEvalProviderHint() {
            var providerEl = document.getElementById('evalApiProvider');
            var hintEl = document.getElementById('localhostServerHint');
            if (!hintEl || !providerEl) return;
            var provider = providerEl.value;
            if (provider !== 'finetuned') {
                hintEl.style.display = 'none';
                return;
            }
            var defaultUrl = 'http://localhost:8000/api';
            var apiUrl = (localStorage.getItem('finetuned_api_url') || defaultUrl);
            hintEl.style.display = (apiUrl.indexOf('localhost') !== -1) ? 'block' : 'none';
        }

        // ===== SPEECH EVALUATION =====
        async function processAndEvaluate() {
            console.log('=== processAndEvaluate START ===');
            console.log('uploadedFile:', uploadedFile);
            
            // Reset correction log for new evaluation
            correctionLog = [];
            
            // Check if file is uploaded
            if (!uploadedFile) {
                console.log('FAILURE: No file uploaded');
                alert('No file uploaded. Please go back to Step 1 and upload a speech recording.');
                moveToStep(1);
                return;
            }
            console.log('✓ File uploaded:', uploadedFile.name);
            
            // Provider and key/URL from form and Settings
            const apiProvider = (document.getElementById('evalApiProvider') && document.getElementById('evalApiProvider').value) || 'gemini';
            const defaultFinetunedUrl = 'http://localhost:8000/api';
            let apiKey;
            if (apiProvider === 'finetuned') {
                apiKey = (localStorage.getItem('finetuned_api_url') || defaultFinetunedUrl).replace(/\/$/, '');
            } else if (apiProvider === 'gemini') {
                apiKey = localStorage.getItem('gemini_api_key') || '';
            } else if (apiProvider === 'gpt4o') {
                apiKey = localStorage.getItem('openai_api_key') || '';
            } else if (apiProvider === 'claude') {
                apiKey = localStorage.getItem('anthropic_api_key') || '';
            } else {
                apiKey = '';
            }
            console.log('API Provider:', apiProvider);
            console.log('API key/URL:', apiKey ? 'Present' : 'Missing');
            if (apiProvider !== 'finetuned' && apiProvider !== 'demo' && !apiKey) {
                alert('Set your API key in Settings (click Settings in the sidebar) for ' + (apiProvider === 'gemini' ? 'Gemini' : apiProvider === 'gpt4o' ? 'OpenAI' : 'Claude') + '.');
                return;
            }
            if (apiProvider === 'finetuned' && !apiKey) {
                alert('Set the Evaluation server URL in Settings, or use an API provider (Gemini, Claude, GPT-4o) to evaluate and build training data.');
                return;
            }
            
            const selectedRubricId = document.getElementById('rubricSelect').value;
            console.log('Selected rubric ID:', selectedRubricId);
            
            if (!selectedRubricId) {
                console.log('FAILURE: No rubric selected');
                alert('Please select a rubric for evaluation.');
                moveToStep(2);
                return;
            }
            console.log('✓ Rubric selected');

            const assignmentType = document.getElementById('assignmentType').value;
            const studentName = 'Student'; // Removed student name input field
            
            console.log('Student name:', studentName);
            console.log('Assignment type:', assignmentType);
            console.log('=== All validations passed, starting evaluation ===');
            
            document.getElementById('processingMessage').textContent = 
                'Analyzing speech content and delivery for ' + studentName + '...';

            try {
                // Get the selected rubric
                const selectedRubric = await getRubricById(selectedRubricId);
                if (!selectedRubric) {
                    console.log('FAILURE: Rubric not found in storage');
                    throw new Error('Selected rubric not found');
                }
                
                console.log('✓ Using rubric:', selectedRubric.name);
                
                // Pass rubric and provider to evaluation function
                console.log('Calling evaluateSpeech...');
                const result = await evaluateSpeech(apiKey, uploadedFile, assignmentType, selectedRubric, apiProvider);
                console.log('✓ Evaluation complete');
                result.aiProvider = apiProvider;
                evaluationResults = result;
                moveToStep(4);
                displayResults(result);
            } catch (error) {
                console.error('EVALUATION ERROR:', error);
                alert('Error evaluating speech: ' + error.message);
                moveToStep(2);
            }
        }

        // ===== DEMO MODE EVALUATION =====
        async function generateDemoEvaluation(file, assignmentType, rubric) {
            console.log('>>> Generating demo evaluation');
            updateProcessingMessage('Generating realistic demo feedback...');
            
            // Simulate processing delay
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            const metrics = calculateRubricMetrics(rubric);
            const studentName = 'Student'; // Generic name since field was removed
            const speechDate = document.getElementById('speechDate').value || new Date().toISOString().split('T')[0];
            
            // First, decide on an overall performance level (70-95%)
            const overallPercentage = 70 + (Math.random() * 25); // 70-95%
            
            // Generate scores that add up correctly
            const sections = {};
            let totalScore = 0;
            let totalMaxScore = 0;
            
            rubric.categories.forEach((category, catIndex) => {
                const categoryName = typeof category === 'string' ? category : category.name;
                const subcategories = typeof category === 'string' ? 
                    ['Introduction', 'Main Points', 'Conclusion'] : 
                    (category.subcategories || []);
                
                const categoryFeedback = [];
                let categoryScore = 0;
                let categoryMaxScore = 0;
                
                subcategories.forEach((sub, subIndex) => {
                    const subName = typeof sub === 'string' ? sub : sub.name;
                    const subPoints = typeof sub === 'string' ? 10 : (sub.points || 10);
                    
                    // Vary individual scores slightly around the overall percentage (±10%)
                    const variance = (Math.random() * 20) - 10; // -10% to +10%
                    const subPercentage = Math.max(60, Math.min(100, overallPercentage + variance));
                    const score = Math.round(subPoints * (subPercentage / 100));
                    
                    // Generate feedback based on score
                    const percentage = (score / subPoints) * 100;
                    let feedback;
                    let grade;
                    
                    if (percentage >= 90) {
                        feedback = `Excellent ${subName.toLowerCase()}. Demonstrates strong mastery of this area.`;
                        grade = 'A';
                    } else if (percentage >= 80) {
                        feedback = `Good ${subName.toLowerCase()}. Shows solid understanding with room for minor improvements.`;
                        grade = 'B';
                    } else if (percentage >= 70) {
                        feedback = `Adequate ${subName.toLowerCase()}. Meets basic requirements but could be enhanced.`;
                        grade = 'C';
                    } else if (percentage >= 60) {
                        feedback = `${subName} needs improvement. Consider focusing more on this area.`;
                        grade = 'D';
                    } else {
                        feedback = `${subName} needs significant improvement. Consider focusing more on this area.`;
                        grade = 'F';
                    }
                    
                    categoryFeedback.push({
                        name: subName,
                        points: score,
                        maxPoints: subPoints,
                        grade: grade,
                        feedback: feedback
                    });
                    
                    categoryScore += score;
                    categoryMaxScore += subPoints;
                });
                
                // Create overall category feedback string
                const avgPercentage = (categoryScore / categoryMaxScore) * 100;
                let overallFeedback;
                if (avgPercentage >= 90) {
                    overallFeedback = `Excellent performance in ${categoryName}. Strong demonstration of skills across all areas.`;
                } else if (avgPercentage >= 80) {
                    overallFeedback = `Good work in ${categoryName}. Solid performance with minor areas for improvement.`;
                } else if (avgPercentage >= 70) {
                    overallFeedback = `Adequate ${categoryName}. Meets basic requirements but could be strengthened.`;
                } else {
                    overallFeedback = `${categoryName} needs significant improvement. Focus on developing these skills.`;
                }
                
                sections[categoryName] = {
                    feedback: overallFeedback,
                    score: categoryScore,
                    maxScore: categoryMaxScore,
                    subcategories: categoryFeedback
                };
                
                totalScore += categoryScore;
                totalMaxScore += categoryMaxScore;
            });
            
            // Calculate final percentage from actual scores
            const finalPercentage = (totalScore / totalMaxScore) * 100;
            const letterGrade = getLetterGrade(finalPercentage, rubric.gradeScale);
            
            console.log('Demo evaluation:', {
                totalScore,
                totalMaxScore,
                percentage: finalPercentage.toFixed(1),
                letterGrade
            });
            
            // Generate realistic timeline markers
            const speechDuration = 330; // 5:30 minutes in seconds
            const timeline_markers = [];
            
            // Add 3-7 markers spread throughout speech
            const numMarkers = Math.floor(Math.random() * 5) + 3; // 3-7 markers
            const categories = rubric.categories.map(cat => 
                typeof cat === 'string' ? cat : cat.name
            );
            
            // Define realistic issues for each category
            const issueTemplates = {
                'Introduction': {
                    'positive': ['Strong attention-getter', 'Clear thesis statement', 'Excellent preview of main points'],
                    'minor': ['Attention-getter could be stronger', 'Preview slightly unclear', 'Rushed introduction'],
                    'moderate': ['Missing preview of main points', 'Weak attention-getter', 'No clear thesis']
                },
                'Organization': {
                    'positive': ['Clear transition', 'Strong signpost phrase', 'Logical flow between ideas'],
                    'minor': ['Transition could be smoother', 'Signpost needed here', 'Slight organizational gap'],
                    'moderate': ['Abrupt topic change', 'Missing transition', 'Confusing sequence']
                },
                'Content': {
                    'positive': ['Excellent supporting evidence', 'Strong example usage', 'Compelling story'],
                    'minor': ['Example could be more specific', 'Source citation needed', 'Claim needs support'],
                    'moderate': ['Lack of supporting evidence', 'Unsupported claim', 'Weak reasoning']
                },
                'Delivery': {
                    'positive': ['Great vocal variety', 'Strong emphasis here', 'Clear pronunciation'],
                    'minor': ['Vocalized pause ("um")', 'Speaking slightly fast', 'Volume a bit low'],
                    'moderate': ['Multiple filler words', 'Speaking too fast', 'Monotone delivery']
                },
                'Eye Contact': {
                    'positive': ['Great audience engagement', 'Scanning all sections', 'Natural connection with audience'],
                    'minor': ['Brief glance at notes', 'Favoring one side slightly', 'Quick look down'],
                    'moderate': ['Looking down at notes', 'Avoiding audience gaze', 'Reading from slides']
                },
                'Body Language': {
                    'positive': ['Confident posture', 'Effective gestures', 'Good use of space'],
                    'minor': ['Hands in pockets briefly', 'Slight fidgeting', 'Standing too still'],
                    'moderate': ['Distracting movements', 'Poor posture', 'Awkward gestures']
                },
                'Conclusion': {
                    'positive': ['Strong closing statement', 'Clear call to action', 'Memorable ending'],
                    'minor': ['Conclusion slightly rushed', 'Could restate thesis more clearly', 'Ending a bit abrupt'],
                    'moderate': ['No clear conclusion', 'Forgot to summarize', 'Weak ending']
                }
            };
            
            // Generate markers
            for (let i = 0; i < numMarkers; i++) {
                // Spread markers throughout speech
                const seconds = Math.floor((speechDuration / (numMarkers + 1)) * (i + 1));
                const minutes = Math.floor(seconds / 60);
                const secs = seconds % 60;
                const timestamp = `${minutes}:${secs.toString().padStart(2, '0')}`;
                
                // Pick random category from rubric
                const category = categories[Math.floor(Math.random() * categories.length)];
                
                // Determine severity (weighted toward positive/minor)
                const severityRoll = Math.random();
                let severity;
                if (severityRoll < 0.3) severity = 'positive';
                else if (severityRoll < 0.8) severity = 'minor';
                else severity = 'moderate';
                
                // Get appropriate issue template
                const categoryTemplates = issueTemplates[category] || issueTemplates['Delivery'];
                const issueList = categoryTemplates[severity] || categoryTemplates['minor'];
                const issue = issueList[Math.floor(Math.random() * issueList.length)];
                
                // Generate contextual note based on severity
                let note;
                if (severity === 'positive') {
                    const positiveNotes = [
                        'This was a strong moment in your speech. Keep up this excellent technique!',
                        'Very effective here. This really engaged the audience.',
                        'Great job with this element. Consider using this approach more often.',
                        'This demonstrated strong mastery of the technique.'
                    ];
                    note = positiveNotes[Math.floor(Math.random() * positiveNotes.length)];
                } else if (severity === 'minor') {
                    const minorNotes = [
                        'Small issue that\'s easy to fix with practice. Not a major concern.',
                        'Minor point to work on for your next speech. Otherwise looking good.',
                        'This is easily correctable. Just be mindful of it during practice.',
                        'Worth noting, but doesn\'t significantly impact your overall performance.'
                    ];
                    note = minorNotes[Math.floor(Math.random() * minorNotes.length)];
                } else {
                    const moderateNotes = [
                        'This is an area that needs attention before your next speech. Practice this specifically.',
                        'Work on improving this aspect. It impacted the effectiveness of your message.',
                        'This requires focused practice. Consider getting feedback on this element.',
                        'Important area for improvement. This affects audience comprehension.'
                    ];
                    note = moderateNotes[Math.floor(Math.random() * moderateNotes.length)];
                }
                
                timeline_markers.push({
                    timestamp: timestamp,
                    seconds: seconds,
                    category: category,
                    issue: issue,
                    severity: severity,
                    note: note
                });
            }
            
            // Sort by time
            timeline_markers.sort((a, b) => a.seconds - b.seconds);
            
            console.log('Generated timeline markers:', timeline_markers.length);
            
            // Generate overall comments
            const overallComments = finalPercentage >= 90 ? 
                "Outstanding speech overall. Demonstrates strong mastery across all evaluated areas. Continue refining these excellent skills." :
                finalPercentage >= 80 ?
                "Strong performance with solid execution in most areas. Focus on the identified improvement areas to reach the next level." :
                finalPercentage >= 70 ?
                "Adequate performance meeting basic requirements. Review the specific feedback in each category and work on identified weaknesses." :
                "Significant improvement needed. Focus on the fundamental skills highlighted in the feedback and practice consistently.";
            
            return {
                studentName: studentName,
                speechDate: speechDate,
                assignmentType: assignmentType,
                speechTime: '5:30',
                rubricUsed: rubric.name,
                sections: sections,
                totalScore: totalScore,
                maxScore: totalMaxScore,
                percentage: finalPercentage.toFixed(1),
                letterGrade: letterGrade,
                gradeScale: rubric.gradeScale,
                aiProvider: 'demo',
                transcript: '[Demo Mode - No actual transcription performed]',
                timeline_markers: timeline_markers,
                overallComments: overallComments
            };
        }
        
        function getLetterGrade(percentage, gradeScale) {
            if (!gradeScale) return 'N/A';
            
            const grades = Object.entries(gradeScale).sort((a, b) => {
                const minA = a[1].min !== undefined ? a[1].min : parseFloat(a[1].range?.split('-')[0] || 0);
                const minB = b[1].min !== undefined ? b[1].min : parseFloat(b[1].range?.split('-')[0] || 0);
                return minB - minA;
            });
            
            for (const [grade, config] of grades) {
                const min = config.min !== undefined ? config.min : parseFloat(config.range?.split('-')[0] || 0);
                if (percentage >= min) {
                    return grade;
                }
            }
            
            return 'F';
        }

        async function evaluateSpeech(apiKey, file, assignmentType, rubric, apiProvider = 'gemini') {
            console.log('>>> evaluateSpeech called');
            console.log('    API Provider:', apiProvider);
            console.log('    API key:', apiKey ? 'Present' : 'Missing');
            console.log('    File:', file ? file.name : 'Missing');
            console.log('    File size:', file ? (file.size / 1024 / 1024).toFixed(2) + ' MB' : 'N/A');
            console.log('    Assignment type:', assignmentType);
            console.log('    Rubric:', rubric ? rubric.name : 'Missing');
            
            // Check file size based on provider
            let maxSizeBytes;
            if (apiProvider === 'finetuned') {
                maxSizeBytes = 100 * 1024 * 1024; // 100MB for Fine-tuned (server transcribes)
            } else if (apiProvider === 'gemini') {
                maxSizeBytes = 100 * 1024 * 1024; // 100MB for Gemini
            } else if (apiProvider === 'gpt4o') {
                maxSizeBytes = 100 * 1024 * 1024; // 100MB for GPT-4o (generous limit)
            } else {
                maxSizeBytes = 25 * 1024 * 1024; // 25MB for Claude (due to base64 encoding)
            }
            
            if (file.size > maxSizeBytes) {
                const sizeMB = (file.size / 1024 / 1024).toFixed(2);
                const limitMB = (maxSizeBytes / 1024 / 1024).toFixed(0);
                const providerName = apiProvider === 'finetuned' ? 'Fine-tuned' : 
                                    apiProvider === 'gemini' ? 'Gemini' : 
                                    apiProvider === 'gpt4o' ? 'GPT-4o' : 'Claude';
                throw new Error(
                    `File is ${sizeMB} MB, which exceeds the ${limitMB} MB limit for ${providerName}.\n\n` +
                    `Please compress the file or use a different format.`
                );
            }
            
            // Use the passed rubric (or fallback to default if not provided)
            if (!rubric) {
                rubric = getRubricById('default') || DEFAULT_RUBRIC;
            }
            
            const metrics = calculateRubricMetrics(rubric);
            console.log('    Metrics calculated:', metrics);
            
            // Route to demo mode if selected
            if (apiProvider === 'demo') {
                console.log('>>> Using Demo Mode - generating mock evaluation');
                return await generateDemoEvaluation(file, assignmentType, rubric);
            }
            
            // Route to the appropriate API
            if (apiProvider === 'finetuned') {
                return await evaluateWithFinetuned(apiKey, file, assignmentType, rubric);
            } else if (apiProvider === 'gpt4o') {
                return await evaluateWithGPT4o(apiKey, file, assignmentType, rubric);
            } else if (apiProvider === 'gemini') {
                return await evaluateWithGemini(apiKey, file, assignmentType, rubric);
            } else {
                return await evaluateWithClaude(apiKey, file, assignmentType, rubric);
            }
        }
        
        // ===== FINE-TUNED (SPEECHGRADEBOOK MISTRAL 7B) EVALUATION =====
        async function evaluateWithFinetuned(apiUrl, file, assignmentType, rubric) {
            console.log('>>> Using Fine-tuned API (SpeechGradebook Mistral 7B)');
            try {
                let videoNotes = '';
                const isVideo = file.type && file.type.startsWith('video');
                const geminiKey = localStorage.getItem('gemini_api_key') || '';
                if (isVideo && geminiKey && typeof getVideoNotesFromGemini === 'function') {
                    updateProcessingMessage('Getting video notes (body movement, eye contact, etc.)...');
                    try {
                        videoNotes = await getVideoNotesFromGemini(geminiKey, file);
                    } catch (e) {
                        console.warn('Video notes unavailable, continuing with transcript only:', e.message);
                    }
                }
                updateProcessingMessage('Sending file to Fine-tuned server (transcription + evaluation)...');
                const formData = new FormData();
                formData.append('file', file);
                formData.append('rubric', JSON.stringify(rubric));
                if (videoNotes) formData.append('video_notes', videoNotes);
                const response = await fetch(apiUrl + '/evaluate_with_file', {
                    method: 'POST',
                    body: formData
                });
                if (!response.ok) {
                    const errText = await response.text();
                    if (response.status === 501) {
                        throw new Error('Fine-tuned server does not support file upload. Install Whisper on the server: pip install openai-whisper');
                    }
                    if (response.status === 503 && (errText || '').includes('Model not loaded')) {
                        throw new Error(
                            'The Fine-tuned server is running but no model is loaded. ' +
                            'Train your model first (see llm_training/IMPLEMENTATION_GUIDE.md), then restart the server with: ' +
                            'python serve_model.py --model_path ./mistral7b-speech-lora --port 8000'
                        );
                    }
                    throw new Error(errText || 'Fine-tuned server error: ' + response.status);
                }
                const data = await response.json();
                updateProcessingMessage('Calculating final scores...');
                const duration = await getVideoDuration(file);
                return formatFinetunedResults(data, rubric, duration, videoNotes);
            } catch (error) {
                console.error('Fine-tuned evaluation error:', error);
                const isConnectionError = error.message === 'Load failed' || error.message === 'Failed to fetch' || error.name === 'TypeError';
                if (isConnectionError) {
                    var hint = (apiUrl.indexOf('localhost') !== -1)
                        ? ' Start the server on this computer: open a terminal, go to the SpeechGradebook folder, and run ./run_local.sh (or: uvicorn app:app --host 0.0.0.0 --port 8000).'
                        : ' Make sure the server is running and the URL is correct.';
                    throw new Error(
                        'Could not connect to the Fine-tuned server at ' + apiUrl + '.' + hint
                    );
                }
                throw new Error('Fine-tuned evaluation failed: ' + error.message);
            }
        }
        
        function formatFinetunedResults(apiResponse, rubric, duration, video_notes) {
            const sections = {};
            let totalScore = 0;
            const apiSections = apiResponse.sections || {};
            const gradeScale = rubric.gradeScale || {};
            rubric.categories.forEach((category) => {
                const apiCat = apiSections[category.name];
                if (!apiCat || !apiCat.subcategories) {
                    sections[category.name] = {
                        score: 0,
                        maxScore: category.subcategories.length * (rubric.totalPoints / (rubric.categories.reduce((n, c) => n + c.subcategories.length, 0))),
                        feedback: 'No feedback provided.',
                        subcategories: category.subcategories.map((subName) => ({
                            name: subName,
                            grade: 'C',
                            gradeLabel: 'Developing',
                            points: 0,
                            maxPoints: 0
                        }))
                    };
                    return;
                }
                const subcategoryDetails = category.subcategories.map((subName, subIndex) => {
                    const apiSub = apiCat.subcategories.find(s => s.name === subName) || apiCat.subcategories[subIndex];
                    const points = apiSub ? (apiSub.points || 0) : 0;
                    const maxPoints = apiSub ? (apiSub.maxPoints || 0) : 0;
                    const subPct = maxPoints > 0 ? (points / maxPoints) * 100 : 0;
                    const grade = getLetterGrade(subPct, gradeScale);
                    return {
                        name: subName,
                        grade: grade,
                        gradeLabel: gradeScale[grade]?.label || 'Developing',
                        points: parseFloat(Number(points).toFixed(2)),
                        maxPoints: parseFloat(Number(maxPoints).toFixed(2))
                    };
                });
                const score = apiCat.score != null ? apiCat.score : subcategoryDetails.reduce((s, d) => s + d.points, 0);
                const maxScore = apiCat.maxScore != null ? apiCat.maxScore : subcategoryDetails.reduce((s, d) => s + d.maxPoints, 0);
                sections[category.name] = {
                    score: parseFloat(Number(score).toFixed(2)),
                    maxScore: parseFloat(Number(maxScore).toFixed(2)),
                    feedback: apiCat.feedback || 'No feedback provided.',
                    subcategories: subcategoryDetails
                };
                totalScore += sections[category.name].score;
            });
            const percentage = rubric.totalPoints > 0 ? ((totalScore / rubric.totalPoints) * 100).toFixed(1) : '0';
            const letterGrade = getLetterGrade(parseFloat(percentage), gradeScale);
            return {
                studentName: 'Student',
                speechDate: document.getElementById('speechDate').value,
                assignmentType: rubric.speechType || 'General Speech',
                speechTime: duration || '0:00',
                sections: sections,
                totalScore: parseFloat(totalScore.toFixed(2)),
                maxScore: rubric.totalPoints,
                percentage: percentage,
                letterGrade: letterGrade,
                gradeScale: rubric.gradeScale,
                rubricUsed: rubric.name,
                overallComments: apiResponse.overallComments || '',
                transcript: apiResponse.transcript || '',
                video_notes: video_notes || ''
            };
        }
        
        // ===== CLAUDE API EVALUATION =====
        async function evaluateWithClaude(apiKey, file, assignmentType, rubric) {
            console.log('>>> Using Claude API (Audio Only)');
            const metrics = calculateRubricMetrics(rubric);
            
            try {
                let audioFile = file;
                
                // If file is video, extract audio automatically
                if (file.type.startsWith('video/')) {
                    console.log('>>> Video detected, extracting audio...');
                    updateProcessingMessage('Extracting audio from video...');
                    audioFile = await extractAudioFromVideo(file);
                    console.log('✓ Audio extracted from video');
                }
                
                // Phase 2a: File Processing - Convert audio to base64
                console.log('>>> Phase 2a: Processing audio file...');
                updateProcessingMessage('Processing audio file...');
                const { base64Audio, mediaType, duration } = await processAudioFile(audioFile);
                console.log('✓ Audio processed:', mediaType, duration);
                
                // Phase 2b: Speech Transcription
                console.log('>>> Phase 2b: Transcribing speech...');
                updateProcessingMessage('Transcribing speech...');
                const transcript = await transcribeSpeech(apiKey, base64Audio, mediaType);
                console.log('✓ Transcription received, length:', transcript.length);
                
                if (!transcript || transcript.trim().length === 0) {
                    throw new Error('Transcription failed or returned empty. Please ensure the audio is clear and try again.');
                }
                
                // Phase 2c: AI Evaluation Against Rubric
                updateProcessingMessage('Analyzing speech against rubric...');
                const aiEvaluation = await evaluateWithClaudeAI(apiKey, transcript, rubric);
                
                // Phase 2d: Results Validation & Formatting
                updateProcessingMessage('Calculating final scores...');
                const results = formatEvaluationResults(aiEvaluation, rubric, transcript, duration);
                
                return results;
                
            } catch (error) {
                console.error('Claude evaluation error:', error);
                throw new Error(`Claude evaluation failed: ${error.message}`);
            }
        }
        
        // Extract audio from video file using Web Audio API and MediaRecorder
        async function extractAudioFromVideo(videoFile) {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                video.preload = 'metadata';
                video.muted = true;
                
                video.onloadedmetadata = async function() {
                    try {
                        // Create media element source
                        const source = audioContext.createMediaElementSource(video);
                        
                        // Create destination for recording
                        const dest = audioContext.createMediaStreamDestination();
                        source.connect(dest);
                        
                        // Set up MediaRecorder
                        const mediaRecorder = new MediaRecorder(dest.stream);
                        const chunks = [];
                        
                        mediaRecorder.ondataavailable = (e) => {
                            if (e.data.size > 0) {
                                chunks.push(e.data);
                            }
                        };
                        
                        mediaRecorder.onstop = () => {
                            const audioBlob = new Blob(chunks, { type: 'audio/webm' });
                            const audioFile = new File([audioBlob], 'extracted-audio.webm', { type: 'audio/webm' });
                            URL.revokeObjectURL(video.src);
                            resolve(audioFile);
                        };
                        
                        // Start recording and play video
                        mediaRecorder.start();
                        video.play();
                        
                        // Stop when video ends
                        video.onended = () => {
                            mediaRecorder.stop();
                            audioContext.close();
                        };
                        
                    } catch (error) {
                        URL.revokeObjectURL(video.src);
                        reject(new Error('Failed to extract audio: ' + error.message));
                    }
                };
                
                video.onerror = function() {
                    URL.revokeObjectURL(video.src);
                    reject(new Error('Failed to load video for audio extraction'));
                };
                
                video.src = URL.createObjectURL(videoFile);
            });
        }
        
        // ===== GPT-4O-MINI API EVALUATION =====
        async function evaluateWithGPT4o(apiKey, file, assignmentType, rubric) {
            console.log('>>> Using GPT-4o-mini API (Image/Frame Analysis)');
            const metrics = calculateRubricMetrics(rubric);
            
            try {
                let frameBase64;
                
                // Check if file is an image or video
                if (file.type.startsWith('image/')) {
                    // Direct image upload
                    console.log('>>> Phase 1: Processing uploaded image...');
                    updateProcessingMessage('Processing image...');
                    frameBase64 = await fileToBase64(file);
                    console.log('✓ Image processed');
                } else {
                    // Extract frame from video
                    console.log('>>> Phase 1: Extracting frame from video...');
                    updateProcessingMessage('Extracting video frame...');
                    frameBase64 = await extractVideoFrame(file);
                    console.log('✓ Video frame extracted');
                }
                
                // Phase 2: Send to GPT-4o for analysis
                console.log('>>> Phase 2: Analyzing with GPT-4o...');
                updateProcessingMessage('Analyzing speech delivery...');
                const gptEvaluation = await analyzeWithGPT4o(apiKey, frameBase64, rubric);
                console.log('✓ GPT-4o analysis complete');
                
                // Phase 3: Format results
                updateProcessingMessage('Calculating final scores...');
                const duration = file.type.startsWith('image/') ? '0:00' : await getVideoDuration(file);
                const results = formatGPTResults(gptEvaluation, rubric, duration);
                
                return results;
                
            } catch (error) {
                console.error('GPT-4o evaluation error:', error);
                throw new Error(`GPT-4o evaluation failed: ${error.message}`);
            }
        }
        
        // Extract a representative frame from video
        async function extractVideoFrame(file) {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                let hasResolved = false;
                
                // Set timeout to prevent hanging
                const timeout = setTimeout(() => {
                    if (!hasResolved) {
                        URL.revokeObjectURL(video.src);
                        reject(new Error('Video loading timed out after 30 seconds. The video format may not be supported by your browser. Try converting to MP4.'));
                    }
                }, 30000);
                
                video.preload = 'metadata';
                video.muted = true;
                video.playsInline = true;
                
                video.onloadedmetadata = function() {
                    console.log('Video metadata loaded. Duration:', video.duration, 'seconds');
                    // Seek to 2 seconds in (or middle if shorter)
                    const seekTime = Math.min(2, video.duration / 2);
                    console.log('Seeking to:', seekTime, 'seconds');
                    video.currentTime = seekTime;
                };
                
                video.onseeked = function() {
                    console.log('Video seeked successfully');
                    
                    if (hasResolved) return;
                    hasResolved = true;
                    clearTimeout(timeout);
                    
                    try {
                        // Set canvas size to video size (limit to reasonable dimensions)
                        const maxWidth = 1280;
                        const maxHeight = 720;
                        let width = video.videoWidth;
                        let height = video.videoHeight;
                        
                        // Scale down if too large
                        if (width > maxWidth) {
                            height = (height * maxWidth) / width;
                            width = maxWidth;
                        }
                        if (height > maxHeight) {
                            width = (width * maxHeight) / height;
                            height = maxHeight;
                        }
                        
                        canvas.width = width;
                        canvas.height = height;
                        
                        console.log('Canvas size:', width, 'x', height);
                        
                        // Draw video frame to canvas
                        ctx.drawImage(video, 0, 0, width, height);
                        
                        // Convert to base64
                        const base64 = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];
                        console.log('Frame extracted, base64 length:', base64.length);
                        
                        // Clean up
                        URL.revokeObjectURL(video.src);
                        
                        resolve(base64);
                    } catch (error) {
                        URL.revokeObjectURL(video.src);
                        reject(new Error('Failed to extract frame: ' + error.message));
                    }
                };
                
                video.onerror = function(e) {
                    if (hasResolved) return;
                    hasResolved = true;
                    clearTimeout(timeout);
                    
                    URL.revokeObjectURL(video.src);
                    
                    let errorMsg = 'Failed to load video.';
                    if (video.error) {
                        switch (video.error.code) {
                            case 1:
                                errorMsg += ' Video loading was aborted.';
                                break;
                            case 2:
                                errorMsg += ' Network error occurred.';
                                break;
                            case 3:
                                errorMsg += ' Video codec not supported by browser. Try converting to MP4.';
                                break;
                            case 4:
                                errorMsg += ' Video format not supported. Try converting to MP4.';
                                break;
                        }
                    }
                    reject(new Error(errorMsg));
                };
                
                // Load the video
                try {
                    const url = URL.createObjectURL(file);
                    console.log('Loading video from blob URL...');
                    video.src = url;
                    video.load();
                } catch (error) {
                    hasResolved = true;
                    clearTimeout(timeout);
                    reject(new Error('Failed to create video URL: ' + error.message));
                }
            });
        }
        
        // Analyze with GPT-4o API
        async function analyzeWithGPT4o(apiKey, frameBase64, rubric) {
            const prompt = buildGPTPrompt(rubric);
            
            log.debug('GPT-4o API Request Details:');
            log.debug('  - API Key length:', apiKey.length);
            log.debug('  - Frame base64 length:', frameBase64.length);
            
            // Validate API key format
            if (!validateApiKeyFormat(apiKey, 'openai')) {
                throw new Error('Invalid OpenAI API key format. Key should start with "sk-". Make sure you\'re using an OpenAI API key from https://platform.openai.com/api-keys');
            }
            
            const requestBody = {
                model: 'gpt-4o-mini',
                messages: [{
                    role: 'user',
                    content: [
                        {
                            type: 'text',
                            text: prompt
                        },
                        {
                            type: 'image_url',
                            image_url: {
                                url: `data:image/jpeg;base64,${frameBase64}`
                            }
                        }
                    ]
                }],
                max_tokens: 4096
            };
            
            console.log('Calling OpenAI API...');
            
            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(requestBody)
                });
                
                console.log('GPT-4o API Response Status:', response.status);
                console.log('GPT-4o API Response OK:', response.ok);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('GPT-4o API Error Response:', errorText);
                    
                    let errorMessage;
                    try {
                        const errorData = JSON.parse(errorText);
                        errorMessage = errorData.error?.message || errorText;
                    } catch (e) {
                        errorMessage = errorText;
                    }
                    
                    throw new Error(`GPT-4o API error (${response.status}): ${errorMessage}`);
                }
                
                const data = await response.json();
                console.log('GPT-4o API Response received successfully');
                
                const responseText = data.choices?.[0]?.message?.content || '';
                
                if (!responseText) {
                    console.error('GPT-4o response structure:', JSON.stringify(data, null, 2));
                    throw new Error('GPT-4o returned empty response');
                }
                
                return parseGPTEvaluation(responseText);
            } catch (error) {
                console.error('GPT-4o API fetch error:', error);
                throw error;
            }
        }
        
        // Build prompt for GPT-4o
        function buildGPTPrompt(rubric) {
            let prompt = `You are an expert speech instructor evaluating a student's speech presentation. You are viewing a SINGLE FRAME from the middle of their speech video. Analyze this frame for nonverbal delivery cues, and infer verbal content quality based on context clues.

IMPORTANT: You only have ONE FRAME to work with, so focus on:
- What you CAN see: posture, body language, facial expression, eye direction, hand position, professional appearance
- What you can INFER: likely confidence level, engagement, preparation

RUBRIC INFORMATION:
- Assignment Type: ${rubric.speechType || 'General Speech'}
- Total Points: ${rubric.totalPoints}
- Grading Scale:
`;
            
            Object.entries(rubric.gradeScale).forEach(([grade, info]) => {
                prompt += `  ${grade} (${info.label}): ${Math.round(info.percentage * 100)}% of points\n`;
            });
            
            prompt += '\nCATEGORIES TO EVALUATE:\n';
            
            rubric.categories.forEach((category, index) => {
                prompt += `\n${index + 1}. ${category.name}\n`;
                category.subcategories.forEach((sub, subIndex) => {
                    prompt += `   ${String.fromCharCode(97 + subIndex)}. ${sub}\n`;
                });
            });
            
            prompt += `
EVALUATION INSTRUCTIONS:
1. Analyze the single frame carefully
2. For NONVERBAL categories (eye contact, gestures, body language, appearance):
   - Give specific grades based on what you observe
   - Note: "Eye contact appears direct/averted", "Posture is upright/slouched", etc.
3. For VERBAL categories (content, organization, language):
   - Make reasonable inferences based on the speaker's apparent confidence and preparation
   - Grade conservatively (B/C range) since you can't hear the actual content
4. For EACH subcategory, assign a letter grade (A, B, C, D, or F)
5. Be fair but realistic about the limitations of single-frame analysis

CRITICAL: Return your evaluation in this EXACT JSON format (no additional text before or after):
{
  "evaluations": [
    {
      "category": "Category Name",
      "feedback": "Detailed feedback based on visible cues in the frame",
      "subcategories": [
        { "name": "Subcategory Name", "grade": "A" },
        { "name": "Another Subcategory", "grade": "B" }
      ]
    }
  ],
  "overallComments": "Overall assessment noting this is based on a single frame analysis, with observations about visible delivery and inferred content quality",
  "transcript": "Note: Single frame analysis - actual speech content not available"
}

Ensure every subcategory receives a grade. Be honest about limitations while being as helpful as possible.`;

            return prompt;
        }
        
        // Parse GPT evaluation response
        function parseGPTEvaluation(responseText) {
            try {
                let jsonText = responseText.trim();
                
                // Remove markdown code blocks if present
                const codeBlockMatch = jsonText.match(/```(?:json)?\s*([\s\S]*?)```/);
                if (codeBlockMatch) {
                    jsonText = codeBlockMatch[1].trim();
                }
                
                // Try to find JSON object
                const jsonMatch = jsonText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    jsonText = jsonMatch[0];
                }
                
                const evaluation = JSON.parse(jsonText);
                
                // Validate structure
                if (!evaluation.evaluations || !Array.isArray(evaluation.evaluations)) {
                    throw new Error('Invalid evaluation format: missing evaluations array');
                }
                
                if (!evaluation.overallComments) {
                    throw new Error('Invalid evaluation format: missing overallComments');
                }
                
                return evaluation;
                
            } catch (error) {
                console.error('Failed to parse GPT evaluation:', error);
                console.error('Response text:', responseText);
                throw new Error('Failed to parse GPT evaluation response. Please try again.');
            }
        }
        
        // Format GPT results into expected structure
        function formatGPTResults(gptEvaluation, rubric, duration) {
            const metrics = calculateRubricMetrics(rubric);
            const sections = {};
            let totalScore = 0;
            
            rubric.categories.forEach((category, categoryIndex) => {
                const gptCategory = gptEvaluation.evaluations.find(
                    e => e.category === category.name
                );
                
                if (!gptCategory) {
                    console.warn(`No GPT evaluation found for category: ${category.name}`);
                    return;
                }
                
                const grades = category.subcategories.map((subName) => {
                    const gptSub = gptCategory.subcategories.find(s => s.name === subName);
                    return gptSub ? gptSub.grade : 'C';
                });
                
                const categoryScore = calculateCategoryScore(rubric, categoryIndex, grades);
                const pointsPerSub = metrics.pointsPerSubcategory;
                
                const subcategoryDetails = category.subcategories.map((subName, subIndex) => {
                    const grade = grades[subIndex];
                    const gradePercentage = rubric.gradeScale[grade]?.percentage || 0.8;
                    const points = pointsPerSub * gradePercentage;
                    
                    return {
                        name: subName,
                        grade: grade,
                        gradeLabel: rubric.gradeScale[grade]?.label || 'Developing',
                        points: parseFloat(points.toFixed(2)),
                        maxPoints: parseFloat(pointsPerSub.toFixed(2))
                    };
                });
                
                sections[category.name] = {
                    score: categoryScore.score,
                    maxScore: categoryScore.maxScore,
                    feedback: gptCategory.feedback || 'No feedback provided.',
                    subcategories: subcategoryDetails
                };
                
                totalScore += categoryScore.score;
            });
            
            const percentage = ((totalScore / rubric.totalPoints) * 100).toFixed(1);
            const letterGrade = getLetterGrade(percentage, rubric.gradeScale);
            
            return {
                studentName: 'Student',
                speechDate: document.getElementById('speechDate').value,
                assignmentType: rubric.speechType || 'General Speech',
                speechTime: duration || '0:00',
                sections: sections,
                totalScore: parseFloat(totalScore.toFixed(2)),
                maxScore: rubric.totalPoints,
                percentage: percentage,
                letterGrade: letterGrade,
                gradeScale: rubric.gradeScale,
                rubricUsed: rubric.name,
                overallComments: gptEvaluation.overallComments,
                transcript: gptEvaluation.transcript || ''
            };
        }
        
        // ===== GEMINI API EVALUATION =====
        async function evaluateWithGemini(apiKey, file, assignmentType, rubric) {
            console.log('>>> Using Gemini API (Full Video Analysis)');
            const metrics = calculateRubricMetrics(rubric);
            
            try {
                // Phase 1: Convert file to base64
                console.log('>>> Phase 1: Processing video/audio file...');
                updateProcessingMessage('Processing video file...');
                const base64Data = await fileToBase64(file);
                console.log('✓ File converted to base64');
                
                // Phase 2: Send to Gemini for comprehensive analysis
                console.log('>>> Phase 2: Analyzing video with Gemini...');
                updateProcessingMessage('Analyzing speech content and delivery...');
                const geminiEvaluation = await analyzeWithGemini(apiKey, base64Data, file.type, rubric);
                console.log('✓ Gemini analysis complete');
                
                // Phase 3: Format results
                updateProcessingMessage('Calculating final scores...');
                const duration = await getVideoDuration(file);
                const results = formatGeminiResults(geminiEvaluation, rubric, duration);
                
                return results;
                
            } catch (error) {
                console.error('Gemini evaluation error:', error);
                throw new Error(`Gemini evaluation failed: ${error.message}`);
            }
        }
        
        // Convert file to base64
        async function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const base64 = e.target.result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        // Get video/audio duration
        async function getVideoDuration(file) {
            return new Promise((resolve) => {
                const url = URL.createObjectURL(file);
                const media = document.createElement(file.type.startsWith('video') ? 'video' : 'audio');
                media.onloadedmetadata = function() {
                    const duration = Math.floor(media.duration);
                    const minutes = Math.floor(duration / 60);
                    const seconds = duration % 60;
                    URL.revokeObjectURL(url);
                    resolve(`${minutes}:${seconds.toString().padStart(2, '0')}`);
                };
                media.onerror = function() {
                    URL.revokeObjectURL(url);
                    resolve('0:00');
                };
                media.src = url;
            });
        }
        
        // Analyze with Gemini API
        async function analyzeWithGemini(apiKey, base64Data, mimeType, rubric) {
            const prompt = buildGeminiPrompt(rubric);
            
            log.debug('Gemini API Request Details:');
            log.debug('  - API Key length:', apiKey.length, '(should be around 39 characters)');
            log.debug('  - MIME type:', mimeType);
            log.debug('  - Base64 data length:', base64Data.length);
            log.debug('  - Prompt length:', prompt.length);
            
            // Validate API key format
            if (!validateApiKeyFormat(apiKey, 'gemini')) {
                throw new Error('Invalid Gemini API key format. Key should start with "AIza". Make sure you\'re using a Gemini API key from https://aistudio.google.com/app/apikey');
            }
            
            const requestBody = {
                contents: [{
                    parts: [
                        {
                            inline_data: {
                                mime_type: mimeType,
                                data: base64Data
                            }
                        },
                        {
                            text: prompt
                        }
                    ]
                }]
            };
            
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`;
            console.log('Gemini API URL:', url.substring(0, 100) + '...');
            console.log('Request size: ~' + Math.round(JSON.stringify(requestBody).length / 1024 / 1024) + ' MB');
            
            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                console.log('Gemini API Response Status:', response.status);
                console.log('Gemini API Response OK:', response.ok);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Gemini API Error Response:', errorText);
                    
                    let errorMessage;
                    try {
                        const errorData = JSON.parse(errorText);
                        errorMessage = errorData.error?.message || errorText;
                    } catch (e) {
                        errorMessage = errorText;
                    }
                    
                    throw new Error(`Gemini API error (${response.status}): ${errorMessage}`);
                }
                
                const data = await response.json();
                console.log('Gemini API Response received successfully');
                
                const responseText = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                
                if (!responseText) {
                    console.error('Gemini response structure:', JSON.stringify(data, null, 2));
                    throw new Error('Gemini returned empty response');
                }
                
                return parseGeminiEvaluation(responseText);
            } catch (error) {
                console.error('Gemini API fetch error:', error);
                console.error('Error name:', error.name);
                console.error('Error message:', error.message);
                throw error;
            }
        }
        
        // Build prompt for Gemini
        function buildGeminiPrompt(rubric) {
            let prompt = `You are an expert speech instructor evaluating a student's speech presentation. Analyze this video recording for BOTH verbal content AND nonverbal delivery.

RUBRIC INFORMATION:
- Assignment Type: ${rubric.speechType || 'General Speech'}
- Total Points: ${rubric.totalPoints}
- Grading Scale:
`;
            
            Object.entries(rubric.gradeScale).forEach(([grade, info]) => {
                prompt += `  ${grade} (${info.label}): ${Math.round(info.percentage * 100)}% of points\n`;
            });
            
            prompt += '\nCATEGORIES TO EVALUATE:\n';
            
            rubric.categories.forEach((category, index) => {
                prompt += `\n${index + 1}. ${category.name}\n`;
                category.subcategories.forEach((sub, subIndex) => {
                    prompt += `   ${String.fromCharCode(97 + subIndex)}. ${sub}\n`;
                });
            });
            
            prompt += `
EVALUATION INSTRUCTIONS:
1. Watch the ENTIRE video carefully
2. Evaluate BOTH:
   - VERBAL: Speech content, organization, language use, clarity
   - NONVERBAL: Eye contact, gestures, body language, facial expressions, posture, movement
3. For EACH subcategory, assign a letter grade (A, B, C, D, or F)
4. Base your evaluation on evidence from the video
5. Be fair but rigorous in your assessment

For nonverbal categories (eye contact, gestures, body language):
- Observe actual behavior in the video
- Note specific examples (e.g., "maintained eye contact 80% of the time", "used descriptive hand gestures")
- Consider camera angle limitations but evaluate what is visible

CRITICAL: Return your evaluation in this EXACT JSON format (no additional text before or after):
{
  "video_notes": "One paragraph describing visual delivery only: body movement, eye contact, gestures, posture, use of presentation slides if visible, and facial expressions. Be specific and observational.",
  "evaluations": [
    {
      "category": "Category Name",
      "feedback": "Detailed feedback including specific observations from the video (both verbal and visual)",
      "subcategories": [
        { "name": "Subcategory Name", "grade": "A" },
        { "name": "Another Subcategory", "grade": "B" }
      ]
    }
  ],
  "overallComments": "Overall assessment referencing specific moments from the video, both verbal content and physical delivery",
  "transcript": "Brief summary of what was said (2-3 sentences)"
}

Ensure every subcategory receives a grade. Include "video_notes" as a single paragraph of visual-only observations. Be specific in your feedback and reference actual observations from the video.`;

            return prompt;
        }
        
        // Parse Gemini evaluation response
        function parseGeminiEvaluation(responseText) {
            try {
                let jsonText = responseText.trim();
                
                // Remove markdown code blocks if present
                const codeBlockMatch = jsonText.match(/```(?:json)?\s*([\s\S]*?)```/);
                if (codeBlockMatch) {
                    jsonText = codeBlockMatch[1].trim();
                }
                
                // Try to find JSON object
                const jsonMatch = jsonText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    jsonText = jsonMatch[0];
                }
                
                const evaluation = JSON.parse(jsonText);
                
                // Validate structure
                if (!evaluation.evaluations || !Array.isArray(evaluation.evaluations)) {
                    throw new Error('Invalid evaluation format: missing evaluations array');
                }
                
                if (!evaluation.overallComments) {
                    throw new Error('Invalid evaluation format: missing overallComments');
                }
                
                // video_notes is optional; default to empty string for backward compatibility
                if (typeof evaluation.video_notes !== 'string') {
                    evaluation.video_notes = evaluation.video_notes ? String(evaluation.video_notes) : '';
                }
                return evaluation;
                
            } catch (error) {
                console.error('Failed to parse Gemini evaluation:', error);
                console.error('Response text:', responseText);
                throw new Error('Failed to parse Gemini evaluation response. Please try again.');
            }
        }
        
        // Format Gemini results into expected structure
        function formatGeminiResults(geminiEvaluation, rubric, duration) {
            const metrics = calculateRubricMetrics(rubric);
            const sections = {};
            let totalScore = 0;
            
            rubric.categories.forEach((category, categoryIndex) => {
                const geminiCategory = geminiEvaluation.evaluations.find(
                    e => e.category === category.name
                );
                
                if (!geminiCategory) {
                    console.warn(`No Gemini evaluation found for category: ${category.name}`);
                    return;
                }
                
                const grades = category.subcategories.map((subName) => {
                    const geminiSub = geminiCategory.subcategories.find(s => s.name === subName);
                    return geminiSub ? geminiSub.grade : 'C';
                });
                
                const categoryScore = calculateCategoryScore(rubric, categoryIndex, grades);
                const pointsPerSub = metrics.pointsPerSubcategory;
                
                const subcategoryDetails = category.subcategories.map((subName, subIndex) => {
                    const grade = grades[subIndex];
                    const gradePercentage = rubric.gradeScale[grade]?.percentage || 0.8;
                    const points = pointsPerSub * gradePercentage;
                    
                    return {
                        name: subName,
                        grade: grade,
                        gradeLabel: rubric.gradeScale[grade]?.label || 'Developing',
                        points: parseFloat(points.toFixed(2)),
                        maxPoints: parseFloat(pointsPerSub.toFixed(2))
                    };
                });
                
                sections[category.name] = {
                    score: categoryScore.score,
                    maxScore: categoryScore.maxScore,
                    feedback: geminiCategory.feedback || 'No feedback provided.',
                    subcategories: subcategoryDetails
                };
                
                totalScore += categoryScore.score;
            });
            
            const percentage = ((totalScore / rubric.totalPoints) * 100).toFixed(1);
            const letterGrade = getLetterGrade(percentage, rubric.gradeScale);
            
            return {
                studentName: 'Student',
                speechDate: document.getElementById('speechDate').value,
                assignmentType: rubric.speechType || 'General Speech',
                speechTime: duration || '0:00',
                sections: sections,
                totalScore: parseFloat(totalScore.toFixed(2)),
                maxScore: rubric.totalPoints,
                percentage: percentage,
                letterGrade: letterGrade,
                gradeScale: rubric.gradeScale,
                rubricUsed: rubric.name,
                overallComments: geminiEvaluation.overallComments,
                transcript: geminiEvaluation.transcript || '',
                video_notes: geminiEvaluation.video_notes || ''
            };
        }
        
        // Get video-only notes from Gemini (for Fine-tuned model: body movement, eye contact, slides, etc.)
        async function getVideoNotesFromGemini(apiKey, file) {
            const base64Data = await fileToBase64(file);
            const mimeType = file.type || 'video/mp4';
            const prompt = 'Watch this video and write ONE paragraph (3-5 sentences) describing ONLY the visual delivery. Include: body movement, eye contact, gestures, posture, use of presentation slides if visible, and facial expressions. Be specific and observational. Do not summarize what was said. Output only the paragraph, no JSON or labels.';
            const requestBody = {
                contents: [{
                    parts: [
                        { inline_data: { mime_type: mimeType, data: base64Data } },
                        { text: prompt }
                    ]
                }]
            };
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`;
            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody)
            });
            if (!response.ok) {
                const err = await response.text();
                throw new Error('Gemini video notes failed: ' + (JSON.parse(err).error?.message || err));
            }
            const data = await response.json();
            const text = (data.candidates?.[0]?.content?.parts?.[0]?.text || '').trim();
            return text || '';
        }
        
        // Helper function to update processing message
        function updateProcessingMessage(message) {
            const messageElement = document.getElementById('processingMessage');
            if (messageElement) {
                messageElement.textContent = message;
            }
        }
        
        // Phase 2a: Process audio/video file and convert to base64
        async function processAudioFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const base64Data = e.target.result.split(',')[1];
                    
                    // Determine media type
                    let mediaType = file.type;
                    
                    // Handle common audio formats
                    if (!mediaType || mediaType === '') {
                        const extension = file.name.split('.').pop().toLowerCase();
                        const typeMap = {
                            'mp3': 'audio/mpeg',
                            'wav': 'audio/wav',
                            'webm': 'audio/webm',
                            'mp4': 'audio/mp4',
                            'm4a': 'audio/mp4',
                            'ogg': 'audio/ogg'
                        };
                        mediaType = typeMap[extension] || 'audio/mpeg';
                    }
                    
                    // Estimate duration (not exact, just for display)
                    const estimatedDuration = Math.floor(file.size / 16000); // Rough estimate
                    const minutes = Math.floor(estimatedDuration / 60);
                    const seconds = estimatedDuration % 60;
                    const duration = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    
                    resolve({
                        base64Audio: base64Data,
                        mediaType: mediaType,
                        duration: duration
                    });
                };
                
                reader.onerror = function(error) {
                    reject(new Error('Failed to read audio file: ' + error));
                };
                
                reader.readAsDataURL(file);
            });
        }
        
        // Phase 2b: Transcribe speech using Claude API
        async function transcribeSpeech(apiKey, base64Audio, mediaType) {
            console.log('transcribeSpeech - API key length:', apiKey.length);
            
            // Sanitize API key - remove any non-ASCII characters
            const cleanApiKey = apiKey.replace(/[^\x00-\x7F]/g, '').trim();
            console.log('transcribeSpeech - Cleaned API key length:', cleanApiKey.length);
            
            if (cleanApiKey !== apiKey) {
                console.warn('API key contained non-ASCII characters that were removed');
            }
            
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': cleanApiKey,
                    'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                    model: 'claude-sonnet-4-20250514',
                    max_tokens: 4096,
                    messages: [
                        {
                            role: 'user',
                            content: [
                                {
                                    type: 'document',
                                    source: {
                                        type: 'base64',
                                        media_type: mediaType,
                                        data: base64Audio
                                    }
                                },
                                {
                                    type: 'text',
                                    text: 'Please transcribe this speech audio. Provide only the transcript text without any additional commentary or formatting.'
                                }
                            ]
                        }
                    ]
                })
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error?.message || `API request failed with status ${response.status}`);
            }
            
            const data = await response.json();
            const transcript = data.content[0]?.text || '';
            
            return transcript.trim();
        }
        
        // Phase 2c: Evaluate transcript against rubric using Claude API
        async function evaluateWithClaudeAI(apiKey, transcript, rubric) {
            // Build the evaluation prompt
            const prompt = buildEvaluationPrompt(transcript, rubric);
            
            // Sanitize API key - remove any non-ASCII characters
            const cleanApiKey = apiKey.replace(/[^\x00-\x7F]/g, '').trim();
            
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': cleanApiKey,
                    'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                    model: 'claude-sonnet-4-20250514',
                    max_tokens: 4096,
                    messages: [
                        {
                            role: 'user',
                            content: prompt
                        }
                    ]
                })
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error?.message || `API request failed with status ${response.status}`);
            }
            
            const data = await response.json();
            const responseText = data.content[0]?.text || '';
            
            // Parse the JSON response
            return parseAIEvaluation(responseText);
        }
        
        // Build the evaluation prompt for Claude
        function buildEvaluationPrompt(transcript, rubric) {
            let prompt = `You are an expert speech instructor grading a student's speech. Evaluate the following speech transcript against the provided rubric.

SPEECH TRANSCRIPT:
${transcript}

RUBRIC INFORMATION:
- Assignment Type: ${rubric.speechType || 'General Speech'}
- Total Points: ${rubric.totalPoints}
- Grading Scale:
`;
            
            // Add grade scale information
            Object.entries(rubric.gradeScale).forEach(([grade, info]) => {
                prompt += `  ${grade} (${info.label}): ${Math.round(info.percentage * 100)}% of points\n`;
            });
            
            prompt += '\nCATEGORIES AND SUBCATEGORIES TO EVALUATE:\n';
            
            // Add all categories and subcategories
            rubric.categories.forEach((category, index) => {
                prompt += `\n${index + 1}. ${category.name}\n`;
                category.subcategories.forEach((sub, subIndex) => {
                    prompt += `   ${String.fromCharCode(97 + subIndex)}. ${sub}\n`;
                });
            });
            
            prompt += `
TASK:
For EACH subcategory listed above, you must:
1. Assign a letter grade (A, B, C, D, or F) based on how well the speech demonstrates that specific criterion
2. Base your evaluation on evidence from the transcript
3. Be fair but rigorous in your assessment

Additionally, provide:
- Specific feedback for each CATEGORY (not subcategory) explaining the overall performance
- Overall comments on the entire speech with constructive suggestions for improvement

IMPORTANT: Return your evaluation in this EXACT JSON format (no additional text before or after):
{
  "evaluations": [
    {
      "category": "Category Name",
      "feedback": "Detailed feedback for this category based on the transcript",
      "subcategories": [
        { "name": "Subcategory Name", "grade": "A" },
        { "name": "Another Subcategory", "grade": "B" }
      ]
    }
  ],
  "overallComments": "Overall assessment of the speech with specific examples from the transcript and actionable suggestions for improvement"
}

Ensure every subcategory from the rubric receives a grade. Be specific in your feedback and reference actual content from the speech.`;

            return prompt;
        }
        
        // Parse AI evaluation response
        function parseAIEvaluation(responseText) {
            try {
                // Try to extract JSON from the response
                // Handle cases where Claude might wrap it in markdown code blocks
                let jsonText = responseText.trim();
                
                // Remove markdown code blocks if present
                const codeBlockMatch = jsonText.match(/```(?:json)?\s*([\s\S]*?)```/);
                if (codeBlockMatch) {
                    jsonText = codeBlockMatch[1].trim();
                }
                
                // Try to find JSON object
                const jsonMatch = jsonText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    jsonText = jsonMatch[0];
                }
                
                const evaluation = JSON.parse(jsonText);
                
                // Validate the structure
                if (!evaluation.evaluations || !Array.isArray(evaluation.evaluations)) {
                    throw new Error('Invalid evaluation format: missing evaluations array');
                }
                
                if (!evaluation.overallComments) {
                    throw new Error('Invalid evaluation format: missing overallComments');
                }
                
                return evaluation;
                
            } catch (error) {
                console.error('Failed to parse AI evaluation:', error);
                console.error('Response text:', responseText);
                throw new Error('Failed to parse AI evaluation response. Please try again.');
            }
        }
        
        // Phase 2d: Format evaluation results into the expected structure
        function formatEvaluationResults(aiEvaluation, rubric, transcript, duration) {
            const metrics = calculateRubricMetrics(rubric);
            const sections = {};
            let totalScore = 0;
            
            // Process each category from the AI evaluation
            rubric.categories.forEach((category, categoryIndex) => {
                // Find matching evaluation from AI response
                const aiCategory = aiEvaluation.evaluations.find(
                    e => e.category === category.name
                );
                
                if (!aiCategory) {
                    console.warn(`No AI evaluation found for category: ${category.name}`);
                    return;
                }
                
                // Build grade array for this category
                const grades = category.subcategories.map((subName) => {
                    const aiSub = aiCategory.subcategories.find(s => s.name === subName);
                    return aiSub ? aiSub.grade : 'C'; // Default to C if missing
                });
                
                // Calculate category score
                const categoryScore = calculateCategoryScore(rubric, categoryIndex, grades);
                const pointsPerSub = metrics.pointsPerSubcategory;
                
                // Build subcategory details
                const subcategoryDetails = category.subcategories.map((subName, subIndex) => {
                    const grade = grades[subIndex];
                    const gradePercentage = rubric.gradeScale[grade]?.percentage || 0.8;
                    const points = pointsPerSub * gradePercentage;
                    
                    return {
                        name: subName,
                        grade: grade,
                        gradeLabel: rubric.gradeScale[grade]?.label || 'Developing',
                        points: parseFloat(points.toFixed(2)),
                        maxPoints: parseFloat(pointsPerSub.toFixed(2))
                    };
                });
                
                sections[category.name] = {
                    score: categoryScore.score,
                    maxScore: categoryScore.maxScore,
                    feedback: aiCategory.feedback || 'No feedback provided.',
                    subcategories: subcategoryDetails
                };
                
                totalScore += categoryScore.score;
            });
            
            const percentage = ((totalScore / rubric.totalPoints) * 100).toFixed(1);
            const letterGrade = getLetterGrade(percentage, rubric.gradeScale);
            
            return {
                studentName: 'Student',
                speechDate: document.getElementById('speechDate').value,
                assignmentType: rubric.speechType || 'General Speech',
                speechTime: duration || '0:00',
                sections: sections,
                totalScore: parseFloat(totalScore.toFixed(2)),
                maxScore: rubric.totalPoints,
                percentage: percentage,
                letterGrade: letterGrade,
                gradeScale: rubric.gradeScale,
                rubricUsed: rubric.name,
                overallComments: aiEvaluation.overallComments,
                transcript: transcript // Store transcript for reference
            };
        }

        // Generate feedback based on category and grades
        function generateCategoryFeedback(categoryName, grades) {
            const avgGrade = calculateAverageGrade(grades);
            
            const feedbackMap = {
                'Content - Introduction': {
                    'A': 'Excellent opening with clear attention getter. Introduction effectively established topic relevance and purpose.',
                    'B': 'Strong opening with clear attention getter. Introduction effectively established topic relevance. Good connection to audience.',
                    'C': 'Adequate introduction present. Could improve attention-getting technique and clearer statement of purpose.',
                    'D': 'Introduction present but lacks clear attention getter or purpose statement.',
                    'F': 'Introduction needs significant improvement in capturing attention and establishing purpose.'
                },
                'Content - Organization': {
                    'A': 'Excellent organizational structure with clear pattern. Smooth transitions and perfect time management.',
                    'B': 'Clear organizational pattern evident. Transitions could be smoother. Excellent time management.',
                    'C': 'Basic organizational structure present. Transitions need improvement. Time management adequate.',
                    'D': 'Organization unclear. Transitions weak. Time management needs attention.',
                    'F': 'Lacks clear organizational pattern. Poor transitions and time management.'
                },
                'Content - Conclusion': {
                    'A': 'Excellent conclusion with memorable final thought and effective summary of main points.',
                    'B': 'Strong conclusion with good summary. Final thought could be more memorable.',
                    'C': 'Adequate conclusion present. Could strengthen summary and final thought.',
                    'D': 'Weak conclusion. Lacks clear summary or memorable ending.',
                    'F': 'No clear conclusion or summary provided.'
                },
                'Content - Assignment': {
                    'A': 'Outstanding content that fully addresses all assignment requirements. Personal stories highly engaging and philosophy exceptionally well-articulated.',
                    'B': 'Content clearly addressed assignment requirements. Personal stories were engaging and philosophy was well-articulated.',
                    'C': 'Content addresses most assignment requirements. Could develop ideas more fully.',
                    'D': 'Content partially addresses assignment. Ideas need more development.',
                    'F': 'Content does not adequately address assignment requirements.'
                },
                'Delivery - Nonverbal': {
                    'A': 'Excellent eye contact, natural gestures, and enthusiastic delivery. Highly professional appearance.',
                    'B': 'Good eye contact and gestures. Enthusiastic delivery. Some improvement needed in reducing nervous movements. Professional appearance.',
                    'C': 'Adequate eye contact and gestures. Could improve enthusiasm and reduce distracting movements.',
                    'D': 'Limited eye contact. Gestures need improvement. Lacks enthusiasm.',
                    'F': 'Poor eye contact and minimal effective gestures. Unprofessional delivery.'
                },
                'Delivery - Verbal': {
                    'A': 'Excellent vocal variety, volume, and speaking rate. Perfect use of pauses. Fully extemporaneous with no filler words.',
                    'B': 'Excellent vocal variety and appropriate volume. Good speaking rate. Mostly extemporaneous style with minimal notes. Some filler words present.',
                    'C': 'Adequate vocal delivery. Could improve variety and reduce dependence on notes. Noticeable filler words.',
                    'D': 'Limited vocal variety. Over-reliant on notes. Excessive filler words.',
                    'F': 'Poor vocal delivery. Reading from notes. Excessive filler words interfere with message.'
                }
            };
            
            return feedbackMap[categoryName]?.[avgGrade] || 'Feedback not available.';
        }

        // Calculate average grade from an array of grades
        function calculateAverageGrade(grades) {
            const gradeValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'F': 1 };
            const sum = grades.reduce((total, grade) => total + gradeValues[grade], 0);
            const avg = sum / grades.length;
            
            if (avg >= 4.5) return 'A';
            if (avg >= 3.5) return 'B';
            if (avg >= 2.5) return 'C';
            if (avg >= 1.5) return 'D';
            return 'F';
        }

        // ===== RUBRIC STORAGE & MANAGEMENT =====
        
        // Create a default "General Speech Evaluation" rubric
        const DEFAULT_RUBRIC = {
            id: 'default',
            name: "General Speech Evaluation",
            description: "Simplified evaluation for verbal and nonverbal communication",
            totalPoints: 50,
            courseId: null,
            speechType: "General",
            createdDate: new Date().toISOString(),
            gradeScale: {
                A: { label: "Professional", percentage: 1.00, range: "100-91" },
                B: { label: "Proficient", percentage: 0.90, range: "90-89" },
                C: { label: "Developing", percentage: 0.80, range: "80-71" },
                D: { label: "Unprofessional", percentage: 0.70, range: "70-61" },
                F: { label: "Unacceptable", percentage: 0.60, range: "60-0" }
            },
            categories: [
                {
                    name: "Verbal Delivery",
                    subcategories: [
                        "Vocal Volume and Clarity",
                        "Speaking Rate and Pacing",
                        "Vocal Variety and Expression",
                        "Minimal Filler Words"
                    ]
                },
                {
                    name: "Nonverbal Delivery",
                    subcategories: [
                        "Eye Contact",
                        "Gestures and Body Language",
                        "Confidence and Enthusiasm",
                        "Professional Appearance"
                    ]
                }
            ]
        };

        // Initialize rubrics in localStorage if not exists
        function initializeRubrics() {
            const existingRubrics = localStorage.getItem('speech_rubrics');
            if (!existingRubrics) {
                // Create initial rubrics array with default and self-intro
                const initialRubrics = [
                    DEFAULT_RUBRIC,
                    {
                        id: 'self-intro-1',
                        name: "Self Introduction Speech",
                        description: "Comprehensive rubric for self-introduction speeches",
                        totalPoints: 50,
                        courseId: null,
                        speechType: "Self-Introduction",
                        createdDate: new Date().toISOString(),
                        gradeScale: SELF_INTRO_RUBRIC.gradeScale,
                        categories: SELF_INTRO_RUBRIC.categories
                    }
                ];
                localStorage.setItem('speech_rubrics', JSON.stringify(initialRubrics));
            }
        }

        // Get all rubrics
        // ===== SUPABASE COURSE FUNCTIONS =====
        
        // Save course to Supabase
        async function saveCourseToSupabase(course) {
            if (!supabaseClient) {
                console.log('Supabase not available, using localStorage only');
                return null;
            }
            
            try {
                // Use current authenticated user ID
                let creatorId = currentUser?.id;
                
                if (!creatorId) {
                    console.error('No authenticated user');
                    return null;
                }
                
                const courseData = {
                    instructor_id: creatorId,
                    name: course.name,
                    code: course.section || null,
                    semester: course.semester || null,
                    year: parseInt(course.year) || null
                };
                
                // If course has Supabase ID, update it
                if (course.supabaseId) {
                    const { data, error } = await supabaseClient
                        .from('courses')
                        .update(courseData)
                        .eq('id', course.supabaseId)
                        .select();
                    
                    if (error) {
                        console.error('Failed to update course:', error);
                        return null;
                    }
                    console.log('✓ Course updated in Supabase');
                    return data[0];
                } else {
                    const { data, error } = await supabaseClient
                        .from('courses')
                        .insert([courseData])
                        .select();
                    
                    if (error) {
                        console.error('Failed to save course:', error);
                        return null;
                    }
                    console.log('✓ Course saved to Supabase');
                    
                    // Save students if they exist
                    if (course.roster && course.roster.length > 0) {
                        await saveStudentsToSupabase(data[0].id, course.roster);
                    }
                    
                    return data[0];
                }
            } catch (error) {
                console.error('Supabase error saving course:', error);
                return null;
            }
        }
        
        // Save students to Supabase
        async function saveStudentsToSupabase(courseId, students) {
            if (!supabaseClient || !students || students.length === 0) {
                return null;
            }
            
            try {
                const studentsData = students.map(student => ({
                    course_id: courseId,
                    student_user_id: null,
                    first_name: student.firstName || student.name?.split(' ')[0] || '',
                    last_name: student.lastName || student.name?.split(' ').slice(1).join(' ') || '',
                    email: student.email || null,
                    student_id: student.studentId || null
                }));
                
                const { data, error } = await supabaseClient
                    .from('course_students')
                    .insert(studentsData)
                    .select();
                
                if (error) {
                    console.error('Failed to save students:', error);
                    return null;
                }
                
                console.log(`✓ ${data.length} students saved to Supabase`);
                return data;
            } catch (error) {
                console.error('Supabase error saving students:', error);
                return null;
            }
        }
        
        // Load courses from Supabase
        async function loadCoursesFromSupabase() {
            if (!supabaseClient || !currentUser) {
                console.log('Cannot load courses: No Supabase client or user');
                return null;
            }
            
            console.log('=== LOADING COURSES FROM SUPABASE ===');
            console.log('View mode:', currentViewMode);
            console.log('User tier:', userTier);
            console.log('User ID:', currentUser.id);
            console.log('Institution:', currentUser.institution_id);
            
            try {
                let query = supabaseClient
                    .from('courses')
                    .select(`
                        *,
                        course_students!course_students_course_id_fkey (
                            id,
                            first_name,
                            last_name,
                            email,
                            student_id
                        )
                    `);
                
                // Filter based on view mode and optional scope filters
                if (currentViewMode === 'own' || userTier === 'instructor') {
                    // Own courses only
                    console.log('Filtering: Own courses only (instructor_id =', currentUser.id, ')');
                    query = query.eq('instructor_id', currentUser.id);
                } else if (currentViewMode === 'institution' && isAdmin()) {
                    // Admin: department (institution) courses, optionally by instructor
                    const institutionId = currentUser.institution_id;
                    if (currentFilterInstructorId) {
                        console.log('Filtering: Department, instructor =', currentFilterInstructorId);
                        query = query.eq('instructor_id', currentFilterInstructorId);
                    } else {
                        const { data: institutionInstructors, error: instError } = await supabaseClient
                            .from('user_profiles')
                            .select('id')
                            .eq('institution_id', institutionId);
                        if (instError) {
                            console.error('Error loading institution instructors:', instError);
                        }
                        if (institutionInstructors && institutionInstructors.length > 0) {
                            const instructorIds = institutionInstructors.map(i => i.id);
                            query = query.in('instructor_id', instructorIds);
                        } else {
                            query = query.eq('instructor_id', '00000000-0000-0000-0000-000000000000'); // no match
                        }
                    }
                } else if (currentViewMode === 'institution' && isSuperAdmin() && currentFilterInstitutionId) {
                    // Super admin: courses for selected institution, optionally by instructor
                    if (currentFilterInstructorId) {
                        console.log('Filtering: Institution', currentFilterInstitutionId, ', instructor =', currentFilterInstructorId);
                        query = query.eq('instructor_id', currentFilterInstructorId);
                    } else {
                        const { data: institutionInstructors, error: instError } = await supabaseClient
                            .from('user_profiles')
                            .select('id')
                            .eq('institution_id', currentFilterInstitutionId);
                        if (instError) {
                            console.error('Error loading institution instructors:', instError);
                        }
                        if (institutionInstructors && institutionInstructors.length > 0) {
                            const instructorIds = institutionInstructors.map(i => i.id);
                            query = query.in('instructor_id', instructorIds);
                        } else {
                            query = query.eq('instructor_id', '00000000-0000-0000-0000-000000000000');
                        }
                    }
                } else if (currentViewMode === 'institution' && isSuperAdmin() && !currentFilterInstitutionId) {
                    // Super admin chose "Institution" but no institution selected yet
                    console.log('Filtering: Select an institution to view courses');
                    return [];
                } else if (currentViewMode === 'all' && isSuperAdmin()) {
                    // Super admin: all courses (no institution filter selected)
                    console.log('Filtering: ALL institutions (no filter - super admin)');
                } else if (currentViewMode === 'demo') {
                    // Demo mode: Don't load from Supabase
                    console.log('Demo mode: Skipping Supabase load');
                    return null;
                } else {
                    console.warn('Unknown view mode or insufficient permissions:', currentViewMode);
                }
                
                const { data: courses, error } = await query.order('created_at', { ascending: false });
                
                if (error) {
                    console.error('❌ Failed to load courses:', error);
                    return null;
                }
                
                console.log(`✅ Loaded ${courses.length} courses from Supabase (${currentViewMode} view)`);
                
                // Audit: log course and roster (student) data access for FERPA
                const totalStudents = (courses || []).reduce((sum, c) => sum + (c.course_students?.length || 0), 0);
                await logAccess('view', 'courses', null, null, { course_count: courses.length, student_count: totalStudents });
                if (totalStudents > 0) {
                    await logAccess('view', 'course_students', null, null, { course_count: courses.length, student_count: totalStudents });
                }
                
                // Log course details for debugging
                if (courses.length > 0) {
                    console.log('First course:', {
                        name: courses[0].name,
                        instructor_id: courses[0].instructor_id,
                        created_at: courses[0].created_at
                    });
                }
                
                console.log('=== COURSE LOAD COMPLETE ===');
                return courses;
            } catch (error) {
                console.error('❌ Supabase error loading courses:', error);
                return null;
            }
        }
        
        // ===== CONSENT & LOCAL-ONLY EVALUATIONS =====
        // Students who do not consent to research/LLM are still evaluated; their data is stored only in localStorage (classes), not in Supabase.

        /** Returns true if student has consented to cloud storage (single catch-all data_collection consent); false = store locally only. */
        async function getStudentConsentForStorage(courseId, studentId) {
            if (!supabaseClient || !courseId || !studentId) return false;
            try {
                const { data, error } = await supabaseClient
                    .from('consent_forms')
                    .select('consent_given')
                    .eq('course_id', courseId)
                    .eq('student_id', studentId)
                    .eq('consent_type', 'data_collection');
                if (error) return false;
                return (data || []).some(function(r) { return r.consent_given === true; });
            } catch (e) {
                return false;
            }
        }

        // Save evaluation to Supabase
        async function saveEvaluationToSupabase(evaluation, courseId, studentId, rubricId) {
            if (!supabaseClient || !currentUser) {
                console.log('Cannot save evaluation: no Supabase or user');
                return null;
            }
            
            try {
                const evaluationData = {
                    instructor_id: currentUser.id,
                    student_id: studentId, // course_students table ID
                    course_id: courseId,
                    rubric_id: rubricId,
                    video_url: null, // Will be added in Phase B6
                    audio_url: null,
                    transcript: evaluation.transcript || null,
                    ai_provider: evaluation.aiProvider || 'unknown',
                    evaluation_data: {
                        sections: evaluation.sections,
                        studentName: evaluation.studentName,
                        speechDate: evaluation.speechDate,
                        assignmentType: evaluation.assignmentType,
                        speechTime: evaluation.speechTime,
                        rubricUsed: evaluation.rubricUsed,
                        totalScore: evaluation.totalScore,
                        maxScore: evaluation.maxScore,
                        percentage: evaluation.percentage,
                        letterGrade: evaluation.letterGrade,
                        overallComments: evaluation.overallComments,
                        timeline_markers: evaluation.timeline_markers || [],
                        video_notes: evaluation.video_notes || null,
                        corrections: correctionLog || [],  // Include correction log
                        edited: correctionLog && correctionLog.length > 0
                    },
                    total_score: evaluation.totalScore || 0,
                    letter_grade: evaluation.letterGrade || 'N/A',
                    status: 'completed'
                };
                
                const { data, error } = await supabaseClient
                    .from('evaluations')
                    .insert([evaluationData])
                    .select();
                
                if (error) {
                    console.error('Failed to save evaluation to Supabase:', error);
                    return null;
                }
                
                // Log creation for FERPA compliance
                if (data && data[0]) {
                    await logAccess('create', 'evaluations', data[0].id, studentId, {
                        course_id: courseId,
                        rubric_id: rubricId,
                        total_score: evaluation.totalScore
                    });
                }
                
                console.log('✓ Evaluation saved to Supabase');
                return data[0];
            } catch (error) {
                console.error('Supabase error saving evaluation:', error);
                return null;
            }
        }
        
        // Load evaluations from Supabase
        async function loadEvaluationsFromSupabase(courseId = null, studentId = null) {
            if (!supabaseClient || !currentUser) {
                return null;
            }
            
            try {
                let query = supabaseClient
                    .from('evaluations')
                    .select(`
                        *,
                        course:courses!evaluations_course_id_fkey(id, name, code, semester, year),
                        student:course_students!evaluations_student_id_fkey(id, first_name, last_name, email),
                        rubric:rubrics!evaluations_rubric_id_fkey(id, name)
                    `);
                
                // Only filter by instructor for instructors; admin/super_admin see per RLS
                if (userTier === 'instructor') {
                    query = query.eq('instructor_id', currentUser.id);
                }
                query = query.order('created_at', { ascending: false });
                
                if (courseId) {
                    query = query.eq('course_id', courseId);
                }
                
                if (studentId) {
                    query = query.eq('student_id', studentId);
                }
                
                const { data, error } = await query;
                
                if (error) {
                    console.error('Failed to load evaluations from Supabase:', error);
                    return null;
                }
                
                // Log access for FERPA compliance
                if (data && data.length > 0) {
                    const uniqueStudentIds = [...new Set(data.map(e => e.student_id))];
                    for (const sid of uniqueStudentIds) {
                        await logAccess('view', 'evaluations', null, sid, {
                            course_id: courseId,
                            evaluation_count: data.filter(e => e.student_id === sid).length
                        });
                    }
                }
                
                console.log(`✓ Loaded ${data.length} evaluations from Supabase`);
                return data;
            } catch (error) {
                console.error('Supabase error loading evaluations:', error);
                return null;
            }
        }
        
        // ===== SUPABASE RUBRIC FUNCTIONS =====
        
        // Save rubric to Supabase
        async function saveRubricToSupabase(rubric) {
            if (!supabaseClient) {
                console.log('Supabase not available, using localStorage only');
                return null;
            }
            
            try {
                // Use current authenticated user ID
                let creatorId = currentUser?.id;
                
                if (!creatorId) {
                    console.error('No authenticated user');
                    return null;
                }
                
                // Validate UUID format
                const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
                if (!uuidRegex.test(creatorId)) {
                    console.error('Invalid UUID format for creator_id:', creatorId);
                    return null;
                }
                
                const rubricData = {
                    creator_id: creatorId, // Using authenticated user
                    name: rubric.name,
                    speech_type: rubric.speechType || null,
                    total_points: rubric.totalPoints || 0,
                    grade_scale: rubric.gradeScale,
                    categories: rubric.categories,
                    is_template: rubric.isTemplate || false
                };
                // When an admin uploads/creates a rubric, share it with their institution so instructors can use it
                if (currentUser?.is_admin && currentUser?.institution_id) {
                    rubricData.institution_id = currentUser.institution_id;
                }
                
                // If rubric has a Supabase ID, update it
                if (rubric.supabaseId) {
                    const { data, error } = await supabaseClient
                        .from('rubrics')
                        .update(rubricData)
                        .eq('id', rubric.supabaseId)
                        .select();
                    
                    if (error) {
                        console.error('Failed to update rubric in Supabase:', error);
                        return null;
                    }
                    console.log('✓ Rubric updated in Supabase');
                    return data[0];
                } else {
                    // Insert new rubric
                    const { data, error } = await supabaseClient
                        .from('rubrics')
                        .insert([rubricData])
                        .select();
                    
                    if (error) {
                        console.error('Failed to save rubric to Supabase:', error);
                        return null;
                    }
                    console.log('✓ Rubric saved to Supabase');
                    return data[0];
                }
            } catch (error) {
                console.error('Supabase error saving rubric:', error);
                return null;
            }
        }
        
        // Load rubrics from Supabase
        async function loadRubricsFromSupabase() {
            if (!supabaseClient) {
                return null;
            }
            
            try {
                const { data, error } = await supabaseClient
                    .from('rubrics')
                    .select('*')
                    .order('created_at', { ascending: false });
                
                if (error) {
                    console.error('Failed to load rubrics from Supabase:', error);
                    return null;
                }
                
                console.log(`✓ Loaded ${data.length} rubrics from Supabase`);
                return data;
            } catch (error) {
                console.error('Supabase error loading rubrics:', error);
                return null;
            }
        }
        
        // Hybrid function: Get all rubrics (Supabase + localStorage)
        async function getAllRubrics() {
            // Try Supabase first
            const supabaseRubrics = await loadRubricsFromSupabase();
            
            if (supabaseRubrics && supabaseRubrics.length > 0) {
                // Convert Supabase format to app format
                return supabaseRubrics.map(sr => ({
                    id: sr.id,
                    supabaseId: sr.id,
                    name: sr.name,
                    speechType: sr.speech_type,
                    totalPoints: sr.total_points,
                    gradeScale: sr.grade_scale,
                    categories: sr.categories,
                    isTemplate: sr.is_template,
                    createdDate: sr.created_at,
                    modifiedDate: sr.updated_at
                }));
            }
            
            // Fallback to localStorage
            const rubrics = localStorage.getItem('speech_rubrics');
            return rubrics ? JSON.parse(rubrics) : [];
        }

        // Get rubrics by course
        async function getRubricsByCourse(courseId) {
            const rubrics = await getAllRubrics();
            return rubrics.filter(r => r.courseId === courseId);
        }

        // Get rubric by ID
        async function getRubricById(rubricId) {
            const rubrics = await getAllRubrics();
            return rubrics.find(r => r.id === rubricId);
        }

        // Save/update rubric (hybrid: Supabase + localStorage)
        async function saveRubric(rubric) {
            // Save to localStorage first (immediate, synchronous)
            const rubrics = localStorage.getItem('speech_rubrics');
            const localRubrics = rubrics ? JSON.parse(rubrics) : [];
            const existingIndex = localRubrics.findIndex(r => r.id === rubric.id);
            
            if (existingIndex >= 0) {
                // Update existing
                rubric.modifiedDate = new Date().toISOString();
                localRubrics[existingIndex] = rubric;
            } else {
                // Add new
                if (!rubric.id) {
                    rubric.id = 'rubric-' + Date.now();
                }
                rubric.createdDate = new Date().toISOString();
                localRubrics.push(rubric);
            }
            
            localStorage.setItem('speech_rubrics', JSON.stringify(localRubrics));
            console.log('✓ Rubric saved to localStorage');
            
            // Also save to Supabase (async, non-blocking)
            if (supabaseClient) {
                saveRubricToSupabase(rubric).then(supabaseRubric => {
                    if (supabaseRubric) {
                        // Update the rubric with Supabase ID
                        rubric.supabaseId = supabaseRubric.id;
                        const updated = localRubrics.find(r => r.id === rubric.id);
                        if (updated) {
                            updated.supabaseId = supabaseRubric.id;
                            localStorage.setItem('speech_rubrics', JSON.stringify(localRubrics));
                        }
                    }
                }).catch(err => {
                    console.log('Supabase save failed, but localStorage succeeded');
                });
            }
            
            return rubric;
        }

        // Duplicate rubric
        async function duplicateRubric(rubricId) {
            const original = await getRubricById(rubricId);
            if (!original) return null;
            
            const duplicate = {
                ...JSON.parse(JSON.stringify(original)), // Deep copy
                id: 'rubric-' + Date.now(),
                supabaseId: undefined, // Remove supabaseId so it creates new in database
                name: original.name + " (Copy)",
                createdDate: new Date().toISOString(),
                modifiedDate: null
            };
            
            return await saveRubric(duplicate);
        }

        // Delete rubric
        async function deleteRubric(rubricId) {
            // Don't allow deleting the default rubric
            if (rubricId === 'default') {
                alert('Cannot delete the default rubric.');
                return false;
            }
            
            const rubrics = await getAllRubrics();
            const filtered = rubrics.filter(r => r.id !== rubricId);
            localStorage.setItem('speech_rubrics', JSON.stringify(filtered));
            
            // Also delete from Supabase if it has a supabase ID
            if (supabaseClient) {
                const rubricToDelete = rubrics.find(r => r.id === rubricId);
                if (rubricToDelete && rubricToDelete.supabaseId) {
                    await supabaseClient
                        .from('rubrics')
                        .delete()
                        .eq('id', rubricToDelete.supabaseId);
                }
            }
            
            return true;
        }

        // Get rubrics grouped by course
        function getRubricsGroupedByCourse() {
            const rubrics = getAllRubrics();
            const grouped = {
                'unassigned': []
            };
            
            rubrics.forEach(rubric => {
                if (!rubric.courseId) {
                    grouped['unassigned'].push(rubric);
                } else {
                    if (!grouped[rubric.courseId]) {
                        grouped[rubric.courseId] = [];
                    }
                    grouped[rubric.courseId].push(rubric);
                }
            });
            
            return grouped;
        }

        // Populate course selector in rubric form with checkboxes
        function populateCourseSelector(selectedCourseIds = []) {
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const container = document.getElementById('rubricCoursesContainer');
            
            if (!container) return;
            
            // Clear container
            container.innerHTML = '';
            
            if (classes.length === 0) {
                container.innerHTML = '<p style="color: var(--text-light); text-align: center;">No courses available. Create courses in "My Classes" first.</p>';
                return;
            }
            
            // Group courses by course name for better organization
            const courseGroups = {};
            classes.forEach(cls => {
                if (!courseGroups[cls.name]) {
                    courseGroups[cls.name] = [];
                }
                courseGroups[cls.name].push(cls);
            });
            
            // Create checkboxes grouped by course name
            Object.keys(courseGroups).sort().forEach(courseName => {
                const sections = courseGroups[courseName];
                
                // Add course name header if multiple sections exist
                if (sections.length > 1) {
                    const header = document.createElement('div');
                    header.style.cssText = 'font-weight: 600; color: var(--primary); margin-top: 0.5rem; margin-bottom: 0.25rem; font-size: 0.9rem;';
                    header.textContent = courseName;
                    container.appendChild(header);
                }
                
                // Add checkbox for each section
                sections.forEach(cls => {
                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.style.cssText = 'padding: 0.4rem; display: flex; align-items: center;';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `course_${cls.id}`;
                    checkbox.value = cls.id;
                    checkbox.className = 'course-checkbox';
                    checkbox.style.cssText = 'margin-right: 0.5rem; cursor: pointer;';
                    
                    // Check if this course is in the selected list
                    if (selectedCourseIds.includes(cls.id)) {
                        checkbox.checked = true;
                    }
                    
                    const label = document.createElement('label');
                    label.htmlFor = `course_${cls.id}`;
                    label.style.cssText = 'cursor: pointer; user-select: none;';
                    label.textContent = `${cls.name} - ${cls.semester} ${cls.year} (Section ${cls.section})`;
                    
                    checkboxDiv.appendChild(checkbox);
                    checkboxDiv.appendChild(label);
                    container.appendChild(checkboxDiv);
                });
            });
        }

        // Populate course filter dropdown in Rubrics section
        function populateCourseFilter() {
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const filter = document.getElementById('courseFilter');
            
            if (!filter) return;
            
            // Clear existing options except "All Courses"
            filter.innerHTML = '<option value="">All Courses</option>';
            
            // Add "Unassigned" option
            filter.innerHTML += '<option value="unassigned">Unassigned (No Course)</option>';
            
            // Group classes by course name + semester + year
            const courseGroups = {};
            classes.forEach(cls => {
                const courseKey = `${cls.name}|${cls.semester}|${cls.year}`;
                if (!courseGroups[courseKey]) {
                    courseGroups[courseKey] = {
                        name: cls.name,
                        semester: cls.semester,
                        year: cls.year,
                        ids: []
                    };
                }
                courseGroups[courseKey].ids.push(cls.id);
            });
            
            // Add grouped courses to filter
            Object.keys(courseGroups).sort().forEach(courseKey => {
                const group = courseGroups[courseKey];
                const option = document.createElement('option');
                option.value = group.ids.join(','); // Store all section IDs as comma-separated
                option.textContent = `${group.name} - ${group.semester} ${group.year}`;
                filter.appendChild(option);
            });
        }

        // Filter rubrics display based on selected course
        async function filterRubricsByCourse() {
            const filterValue = document.getElementById('courseFilter').value;
            
            // Initialize rubrics storage if needed
            initializeRubrics();
            
            // Get all rubrics (getAllRubrics is async) and classes
            let allRubrics = await getAllRubrics();
            if (!Array.isArray(allRubrics)) allRubrics = [];
            const classes = JSON.parse(getUserItem('classes') || '[]');
            
            // Filter rubrics based on selection
            let filteredRubrics = allRubrics;
            
            if (filterValue === 'unassigned') {
                // Show only rubrics with no courses assigned
                filteredRubrics = allRubrics.filter(r => {
                    const hasOldCourseId = r.courseId && r.courseId !== '';
                    const hasNewCourseIds = r.courseIds && Array.isArray(r.courseIds) && r.courseIds.length > 0;
                    return !hasOldCourseId && !hasNewCourseIds;
                });
            } else if (filterValue !== '') {
                // Filter by course - filterValue contains comma-separated IDs for all sections of a course
                const courseIdsToMatch = filterValue.split(',');
                
                filteredRubrics = allRubrics.filter(rubric => {
                    // Get rubric's course IDs (handle both old and new format)
                    let rubricCourseIds = [];
                    if (rubric.courseIds && Array.isArray(rubric.courseIds)) {
                        rubricCourseIds = rubric.courseIds;
                    } else if (rubric.courseId) {
                        rubricCourseIds = [rubric.courseId];
                    }
                    
                    // Check if rubric is assigned to any of the course sections
                    return rubricCourseIds.some(id => courseIdsToMatch.includes(id));
                });
            }
            
            // Display filtered rubrics
            const list = document.getElementById('rubricsList');
            if (!list) return;
            
            if (filteredRubrics.length === 0) {
                list.innerHTML = '<p style="color: var(--text-light); text-align: center; padding: 2rem;">No rubrics found for this filter.</p>';
                return;
            }
            
            list.innerHTML = filteredRubrics.map(rubric => {
                // Get course info - handle both courseIds array and old courseId
                let courseInfo = '';
                let courseIdsToDisplay = [];
                
                if (rubric.courseIds && Array.isArray(rubric.courseIds) && rubric.courseIds.length > 0) {
                    courseIdsToDisplay = rubric.courseIds;
                } else if (rubric.courseId) {
                    courseIdsToDisplay = [rubric.courseId];
                }
                
                if (courseIdsToDisplay.length > 0) {
                    const courses = courseIdsToDisplay
                        .map(id => classes.find(c => c.id === id))
                        .filter(c => c);
                    
                    if (courses.length > 0) {
                        // Group by course name
                        const courseGroups = {};
                        courses.forEach(course => {
                            if (!courseGroups[course.name]) {
                                courseGroups[course.name] = [];
                            }
                            courseGroups[course.name].push(course);
                        });
                        
                        // Format display
                        const courseDisplays = Object.keys(courseGroups).map(courseName => {
                            const sections = courseGroups[courseName];
                            const firstCourse = sections[0];
                            const sectionNums = sections.map(s => s.section).join(', ');
                            const sectionText = sections.length > 1 ? `Sections ${sectionNums}` : `Section ${sectionNums}`;
                            return `${courseName} (${firstCourse.semester} ${firstCourse.year}) - ${sectionText}`;
                        });
                        
                        courseInfo = ` • <span style="color: var(--primary); font-weight: 500;">${courseDisplays.join(' • ')}</span>`;
                    } else if (courseIdsToDisplay.length > 0) {
                        courseInfo = ' • <span style="color: #999;">Course(s) not found</span>';
                    }
                }
                
                return `
                <div class="rubric-item">
                    <div class="rubric-info">
                        <h4>${rubric.name}</h4>
                        <p>${rubric.description || 'No description'} • ${rubric.totalPoints} points${rubric.speechType ? ' • ' + rubric.speechType : ''}${courseInfo}</p>
                    </div>
                    <div class="rubric-actions">
                        <button class="btn-small btn-view" data-rubric-id="${rubric.id}">View</button>
                        <button class="btn-small btn-edit" data-rubric-id="${rubric.id}">Edit</button>
                        <button class="btn-small btn-duplicate" data-rubric-id="${rubric.id}">Duplicate</button>
                        ${rubric.id !== 'default' ? `
                            <button class="btn-small btn-danger btn-delete" data-rubric-id="${rubric.id}">Delete</button>
                        ` : ''}
                    </div>
                </div>
            `;
            }).join('');
            
            // Re-attach event listeners to all buttons
            document.querySelectorAll('.btn-view').forEach(btn => {
                btn.addEventListener('click', () => viewRubric(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-edit').forEach(btn => {
                btn.addEventListener('click', () => editRubric(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-duplicate').forEach(btn => {
                btn.addEventListener('click', () => duplicateRubricUI(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-delete').forEach(btn => {
                btn.addEventListener('click', () => deleteRubricUI(btn.dataset.rubricId));
            });
        }


        function displayResults(results) {
            let html = '';
            
            // Show editing mode banner if editing
            if (editingEvaluationId) {
                html += `
                    <div style="background: #0066cc; color: white; padding: 1rem 1.5rem; border-radius: 0.5rem; margin-bottom: 2rem; display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong style="font-size: 1.1rem;">📝 Editing Mode</strong>
                            <p style="margin: 0.5rem 0 0 0; opacity: 0.9;">Make your changes below, then click "Save Evaluation" to update.</p>
                        </div>
                        <button onclick="cancelEdit()" style="background: white; color: #0066cc; border: none; padding: 0.5rem 1rem; border-radius: 0.25rem; cursor: pointer; font-weight: 600;">Cancel Edit</button>
                    </div>
                `;
            }
            
            html += `
                <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 2rem;">
                    <strong>Student:</strong> ${escapeHtml(results.studentName || '')}<br>
                    <strong>Date:</strong> ${escapeHtml(results.speechDate || '')}<br>
                    <strong>Assignment:</strong> ${escapeHtml(results.assignmentType || '')}<br>
                    <strong>Speech Time:</strong> ${escapeHtml(results.speechTime || '')}
                </div>
                
                <div class="score-banner">
                    <h2 style="color: white;">Final Score</h2>
                    <div class="score-value">${escapeHtml(String(results.totalScore || 0))} / ${escapeHtml(String(results.maxScore || 0))}</div>
                    <div class="score-percentage">${results.maxScore > 0 ? escapeHtml(((results.totalScore / results.maxScore) * 100).toFixed(1)) : '0'}%</div>
                </div>
                
                <h3 style="margin-bottom: 1rem;">Detailed Scores by Category</h3>
                <div style="display: grid; gap: 1rem; margin-bottom: 2rem;">
            `;
            
            for (const [section, data] of Object.entries(results.sections)) {
                const sectionId = section.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                html += `
                    <div style="background: var(--bg-alt); padding: 1rem; border-radius: 0.5rem; border-left: 4px solid var(--primary);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                            <strong style="text-transform: capitalize;">${section}</strong>
                            <div style="display: flex; align-items: center; gap: 0.75rem;">
                                <strong style="color: var(--primary);">${data.score} / ${data.maxScore}</strong>
                                <button onclick="editSection(\`${section.replace(/`/g, '\\`')}\`)" style="background: var(--primary); color: white; border: none; padding: 0.25rem 0.75rem; border-radius: 0.25rem; cursor: pointer; font-size: 0.85rem;">✏️ Edit</button>
                            </div>
                        </div>
                        <p style="color: var(--text-light); font-size: 0.9rem; margin-bottom: 0.75rem;" id="feedback-${sectionId}">${data.feedback}</p>
                `;
                
                // Show subcategory breakdown if available
                if (data.subcategories && data.subcategories.length > 0) {
                    html += `<div style="background: white; padding: 0.75rem; border-radius: 0.25rem; margin-top: 0.75rem;">
                        <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text);">Subcategory Breakdown:</div>
                    `;
                    
                    data.subcategories.forEach(sub => {
                        const gradeColor = sub.grade === 'A' ? '#28a745' : 
                                          sub.grade === 'B' ? '#5cb85c' :
                                          sub.grade === 'C' ? '#f0ad4e' :
                                          sub.grade === 'D' ? '#d9534f' : '#c9302c';
                        
                        html += `
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.4rem 0; border-bottom: 1px solid var(--border);">
                                <span style="font-size: 0.85rem; color: var(--text);">${sub.name}</span>
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <span style="background: ${gradeColor}; color: white; padding: 0.15rem 0.4rem; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600;">${sub.grade}</span>
                                    <span style="font-size: 0.85rem; color: var(--text-light);">${sub.points} / ${sub.maxPoints} pts</span>
                                </div>
                            </div>
                        `;
                    });
                    
                    html += `</div>`;
                }
                
                html += `</div>`;
            }
            
            html += `
                </div>
                
                <div style="background: #fffef7; border: 2px solid var(--accent); padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 1rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                        <h3 style="color: var(--primary); margin: 0;">Overall Comments</h3>
                        <button onclick="editOverallComments()" style="background: var(--primary); color: white; border: none; padding: 0.25rem 0.75rem; border-radius: 0.25rem; cursor: pointer; font-size: 0.85rem;">✏️ Edit</button>
                    </div>
                    <p id="overall-comments-text">${results.overallComments}</p>
                </div>
            `;
            
            // Add transcript section if available
            if (results.transcript && results.transcript.trim().length > 0) {
                html += `
                    <details style="background: var(--bg-alt); padding: 1rem; border-radius: 0.5rem; margin-top: 1rem;">
                        <summary style="cursor: pointer; font-weight: 600; color: var(--primary); padding: 0.5rem;">
                            📝 View Speech Transcript
                        </summary>
                        <div style="margin-top: 1rem; padding: 1rem; background: white; border-radius: 0.25rem; max-height: 300px; overflow-y: auto; font-family: monospace; font-size: 0.9rem; line-height: 1.6;">
                            ${escapeHtml(results.transcript).replace(/\n/g, '<br>')}
                        </div>
                    </details>
                `;
            }
            
            // Add timeline markers section if available
            if (results.timeline_markers && results.timeline_markers.length > 0) {
                html += `
                    <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; margin-top: 2rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                            <h3 style="margin: 0; color: var(--primary);">⏱️ Timeline Markers</h3>
                            <button onclick="editTimelineMarkers()" style="background: var(--primary); color: white; border: none; padding: 0.25rem 0.75rem; border-radius: 0.25rem; cursor: pointer; font-size: 0.85rem;">✏️ Edit Markers</button>
                        </div>
                        <p style="color: var(--text-light); margin-bottom: 1.5rem; font-size: 0.95rem;">
                            Review specific moments in your video using these timestamps. 
                            Open your video file on your device and seek to the times listed below to see exactly what was observed.
                        </p>
                        <div id="timeline-markers-content">
                `;
                
                // Group markers by category
                const markersByCategory = {};
                results.timeline_markers.forEach(marker => {
                    if (!markersByCategory[marker.category]) {
                        markersByCategory[marker.category] = [];
                    }
                    markersByCategory[marker.category].push(marker);
                });
                
                // Display each category
                Object.keys(markersByCategory).forEach(category => {
                    const markers = markersByCategory[category];
                    
                    html += `
                        <div style="margin-bottom: 1.5rem;">
                            <h4 style="margin: 0 0 0.75rem 0; color: var(--text-dark); font-size: 1.1rem; font-family: var(--body-font);">${escapeHtml(category)}</h4>
                            <div style="display: grid; gap: 0.75rem;">
                    `;
                    
                    markers.forEach(marker => {
                        // Color coding based on severity
                        const severityColors = {
                            'positive': '#10b981',   // green
                            'minor': '#f59e0b',      // orange
                            'moderate': '#f59e0b',   // orange
                            'major': '#ef4444'       // red
                        };
                        
                        const severityIcons = {
                            'positive': '✓',
                            'minor': '⚠',
                            'moderate': '⚠',
                            'major': '✕'
                        };
                        
                        const color = severityColors[marker.severity] || '#f59e0b';
                        const icon = severityIcons[marker.severity] || '⚠';
                        
                        html += `
                            <div style="background: white; padding: 0.75rem; border-radius: 0.25rem; border-left: 4px solid ${color}; display: flex; gap: 1rem; align-items: start;">
                                <div style="background: ${color}; color: white; min-width: 60px; height: 60px; border-radius: 0.25rem; display: flex; align-items: center; justify-content: center; flex-shrink: 0; font-size: 0.95rem; font-weight: bold; text-align: center; padding: 0.25rem;">
                                    ${escapeHtml(marker.timestamp || '')}
                                </div>
                                <div style="flex: 1;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.25rem;">
                                        <span style="font-size: 1.2rem;">${icon}</span>
                                        <strong style="color: var(--text-dark); font-size: 1rem;">${escapeHtml(marker.issue || '')}</strong>
                                    </div>
                                    <p style="margin: 0; color: var(--text-light); font-size: 0.9rem; line-height: 1.5;">
                                        ${escapeHtml(marker.note || '')}
                                    </p>
                                </div>
                            </div>
                        `;
                    });
                    
                    html += `
                            </div>
                        </div>
                    `;
                });
                
                html += `</div></div></div>`;
            }
            
            document.getElementById('resultsContent').innerHTML = html;
            
            // Update correction count badge if corrections exist
            if (typeof updateCorrectionCount === 'function') {
                updateCorrectionCount();
            }
        }

        // ===== EDIT FUNCTIONALITY =====
        
        let currentEditingSection = null;
        let correctionLog = [];
        
        // Edit Section Score and Feedback
        function editSection(sectionName) {
            console.log('editSection called with:', sectionName);
            if (!evaluationResults) {
                console.error('No evaluationResults available');
                return;
            }
            
            currentEditingSection = sectionName;
            const section = evaluationResults.sections[sectionName];
            
            if (!section) {
                console.error('Section not found:', sectionName);
                console.log('Available sections:', Object.keys(evaluationResults.sections));
                alert('Error: Could not find section "' + sectionName + '"');
                return;
            }
            
            console.log('Editing section:', section);
            
            document.getElementById('editSectionName').textContent = sectionName.charAt(0).toUpperCase() + sectionName.slice(1);
            document.getElementById('editSectionScore').value = section.score;
            document.getElementById('editSectionMaxScore').textContent = section.maxScore;
            document.getElementById('editSectionAIFeedback').textContent = section.feedback;
            document.getElementById('editSectionFeedback').value = section.feedback;
            document.getElementById('editSectionReason').value = '';
            document.getElementById('editSectionReason').placeholder = 'Required: Explain why you\'re making changes (helps improve AI)';
            
            // Populate subcategories if they exist
            const subcategoriesContainer = document.getElementById('editSubcategoriesContainer');
            if (section.subcategories && section.subcategories.length > 0) {
                let subHTML = '<h4 style="margin-bottom:1rem;font-size:1rem;color:var(--text-dark);">Edit Subcategories:</h4>';
                
                section.subcategories.forEach((sub, index) => {
                    const gradeColor = sub.grade === 'A' ? '#28a745' : 
                                      sub.grade === 'B' ? '#5cb85c' :
                                      sub.grade === 'C' ? '#f0ad4e' :
                                      sub.grade === 'D' ? '#d9534f' : '#c9302c';
                    
                    // Create safe IDs
                    const sectionId = sectionName.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                    
                    subHTML += `
                        <div style="background:var(--bg-alt);padding:1rem;border-radius:0.5rem;margin-bottom:1rem;border-left:4px solid ${gradeColor};">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.75rem;">
                                <strong style="font-size:0.95rem;color:var(--text-dark);">${sub.name}</strong>
                                <span style="background:${gradeColor};color:white;padding:0.25rem 0.5rem;border-radius:0.25rem;font-size:0.85rem;font-weight:600;">${sub.grade}</span>
                            </div>
                            <div style="display:flex;gap:1rem;align-items:center;">
                                <div style="flex:1;">
                                    <label style="display:block;font-size:0.85rem;font-weight:600;margin-bottom:0.25rem;">Points:</label>
                                    <div style="display:flex;gap:0.5rem;align-items:center;">
                                        <input type="number" 
                                               id="subcategory-${sectionId}-${index}-points" 
                                               value="${sub.points}" 
                                               min="0" 
                                               max="${sub.maxPoints}"
                                               onchange="updateSubcategoryGrade(\`${sectionName.replace(/`/g, '\\`')}\`, ${index})"
                                               style="width:70px;padding:0.5rem;border:2px solid #ddd;border-radius:0.25rem;font-size:0.9rem;">
                                        <span style="font-size:0.9rem;color:var(--text-light);">/ ${sub.maxPoints}</span>
                                    </div>
                                </div>
                                <div style="flex:2;">
                                    <label style="display:block;font-size:0.85rem;font-weight:600;margin-bottom:0.25rem;">Feedback (optional):</label>
                                    <textarea id="subcategory-${sectionId}-${index}-feedback" 
                                              rows="2" 
                                              style="width:100%;padding:0.5rem;border:2px solid #ddd;border-radius:0.25rem;resize:vertical;font-size:0.85rem;"
                                              placeholder="Optional subcategory feedback...">${sub.feedback || ''}</textarea>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                subcategoriesContainer.innerHTML = subHTML;
                subcategoriesContainer.style.display = 'block';
            } else {
                subcategoriesContainer.style.display = 'none';
            }
            
            document.getElementById('editSectionModal').style.display = 'flex';
            console.log('Edit modal displayed');
        }
        
        // Update subcategory grade when points change
        function updateSubcategoryGrade(sectionName, index) {
            const sectionId = sectionName.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
            const pointsInput = document.getElementById(`subcategory-${sectionId}-${index}-points`);
            const points = parseInt(pointsInput.value) || 0;
            const section = evaluationResults.sections[sectionName];
            const sub = section.subcategories[index];
            const maxPoints = sub.maxPoints;
            
            // Calculate percentage and letter grade
            const percentage = (points / maxPoints) * 100;
            let grade = 'F';
            if (percentage >= 90) grade = 'A';
            else if (percentage >= 80) grade = 'B';
            else if (percentage >= 70) grade = 'C';
            else if (percentage >= 60) grade = 'D';
            
            // Update the displayed grade badge color
            const parentDiv = pointsInput.closest('div[style*="border-left"]');
            const gradeBadge = parentDiv.querySelector('span[style*="background"]');
            
            const gradeColors = {
                'A': '#28a745',
                'B': '#5cb85c',
                'C': '#f0ad4e',
                'D': '#d9534f',
                'F': '#c9302c'
            };
            
            if (gradeBadge) {
                const color = gradeColors[grade];
                gradeBadge.style.background = color;
                gradeBadge.textContent = grade;
                parentDiv.style.borderLeftColor = color;
            }
            
            // Update total section score (sum of all subcategory points)
            let totalPoints = 0;
            section.subcategories.forEach((s, i) => {
                const input = document.getElementById(`subcategory-${sectionId}-${i}-points`);
                if (input) {
                    totalPoints += parseInt(input.value) || 0;
                }
            });
            
            document.getElementById('editSectionScore').value = totalPoints;
        }
        
        function closeEditSectionModal() {
            document.getElementById('editSectionModal').style.display = 'none';
            currentEditingSection = null;
        }
        
        function saveEditedSection() {
            if (!currentEditingSection || !evaluationResults) return;
            
            const section = evaluationResults.sections[currentEditingSection];
            const sectionId = currentEditingSection.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
            const newFeedback = document.getElementById('editSectionFeedback').value.trim();
            const reason = document.getElementById('editSectionReason').value.trim();
            
            // Check if any changes were made
            let hasChanges = false;
            
            // Check feedback change
            if (newFeedback !== section.feedback) {
                hasChanges = true;
            }
            
            // Check subcategory changes
            if (section.subcategories && section.subcategories.length > 0) {
                section.subcategories.forEach((sub, index) => {
                    const pointsInput = document.getElementById(`subcategory-${sectionId}-${index}-points`);
                    const feedbackInput = document.getElementById(`subcategory-${sectionId}-${index}-feedback`);
                    
                    if (pointsInput) {
                        const newPoints = parseInt(pointsInput.value) || 0;
                        const newSubFeedback = feedbackInput ? feedbackInput.value.trim() : '';
                        
                        if (newPoints !== sub.points || newSubFeedback !== (sub.feedback || '')) {
                            hasChanges = true;
                        }
                    }
                });
            }
            
            // If changes were made, require a reason
            if (hasChanges && !reason) {
                alert('Please provide a reason for your changes. This helps improve the AI evaluation system.');
                document.getElementById('editSectionReason').focus();
                return;
            }
            
            // Update subcategories if they exist
            if (section.subcategories && section.subcategories.length > 0) {
                section.subcategories.forEach((sub, index) => {
                    const pointsInput = document.getElementById(`subcategory-${sectionId}-${index}-points`);
                    const feedbackInput = document.getElementById(`subcategory-${sectionId}-${index}-feedback`);
                    
                    if (pointsInput) {
                        const newPoints = parseInt(pointsInput.value) || 0;
                        const newSubFeedback = feedbackInput ? feedbackInput.value.trim() : '';
                        
                        // Log correction if points changed
                        if (newPoints !== sub.points) {
                            correctionLog.push({
                                timestamp: new Date().toISOString(),
                                field: `${currentEditingSection}.${sub.name}.points`,
                                ai_value: sub.points,
                                instructor_value: newPoints,
                                reason: reason
                            });
                        }
                        
                        // Log correction if feedback changed
                        if (newSubFeedback !== (sub.feedback || '')) {
                            correctionLog.push({
                                timestamp: new Date().toISOString(),
                                field: `${currentEditingSection}.${sub.name}.feedback`,
                                ai_value: sub.feedback || '',
                                instructor_value: newSubFeedback,
                                reason: reason
                            });
                        }
                        
                        // Update subcategory
                        sub.points = newPoints;
                        sub.feedback = newSubFeedback;
                        
                        // Recalculate grade
                        const percentage = (newPoints / sub.maxPoints) * 100;
                        if (percentage >= 90) sub.grade = 'A';
                        else if (percentage >= 80) sub.grade = 'B';
                        else if (percentage >= 70) sub.grade = 'C';
                        else if (percentage >= 60) sub.grade = 'D';
                        else sub.grade = 'F';
                    }
                });
                
                // Recalculate section score from subcategories
                let newSectionScore = 0;
                section.subcategories.forEach(sub => {
                    newSectionScore += sub.points;
                });
                
                // Log if section total changed
                if (newSectionScore !== section.score) {
                    correctionLog.push({
                        timestamp: new Date().toISOString(),
                        field: `${currentEditingSection}_total_score`,
                        ai_value: section.score,
                        instructor_value: newSectionScore,
                        reason: reason
                    });
                }
                
                section.score = newSectionScore;
            }
            
            // Log correction if feedback changed
            if (newFeedback !== section.feedback) {
                correctionLog.push({
                    timestamp: new Date().toISOString(),
                    field: `${currentEditingSection}_feedback`,
                    ai_value: section.feedback,
                    instructor_value: newFeedback,
                    reason: reason
                });
            }
            
            // Update section feedback
            section.feedback = newFeedback;
            
            // Recalculate total score for entire evaluation
            let newTotal = 0;
            for (const [key, data] of Object.entries(evaluationResults.sections)) {
                newTotal += data.score;
            }
            evaluationResults.totalScore = newTotal;
            evaluationResults.percentage = ((newTotal / evaluationResults.maxScore) * 100).toFixed(1);
            
            // Update letter grade
            const percentage = (newTotal / evaluationResults.maxScore) * 100;
            evaluationResults.letterGrade = getLetterGrade(percentage, evaluationResults.gradeScale);
            
            // Re-display results
            displayResults(evaluationResults);
            
            closeEditSectionModal();
            
            // Update correction count badge
            updateCorrectionCount();
            
            showNotification('✓ Section updated! Remember to save the evaluation.', 'success');
        }
        
        // Edit Overall Comments
        function editOverallComments() {
            if (!evaluationResults) return;
            
            document.getElementById('editCommentsAI').textContent = evaluationResults.overallComments;
            document.getElementById('editCommentsText').value = evaluationResults.overallComments;
            document.getElementById('editCommentsReason').value = '';
            
            document.getElementById('editCommentsModal').style.display = 'flex';
        }
        
        function closeEditCommentsModal() {
            document.getElementById('editCommentsModal').style.display = 'none';
        }
        
        function saveEditedComments() {
            if (!evaluationResults) return;
            
            const newComments = document.getElementById('editCommentsText').value.trim();
            const reason = document.getElementById('editCommentsReason').value.trim();
            
            if (newComments !== evaluationResults.overallComments) {
                // Require reason for changes
                if (!reason) {
                    alert('Please provide a reason for changing the comments. This helps improve the AI evaluation system.');
                    document.getElementById('editCommentsReason').focus();
                    return;
                }
                
                correctionLog.push({
                    timestamp: new Date().toISOString(),
                    field: 'overall_comments',
                    ai_value: evaluationResults.overallComments,
                    instructor_value: newComments,
                    reason: reason
                });
                
                evaluationResults.overallComments = newComments;
                
                // Update display
                document.getElementById('overall-comments-text').textContent = newComments;
                
                closeEditCommentsModal();
                
                // Update correction count badge
                updateCorrectionCount();
                
                showNotification('✓ Comments updated! Remember to save the evaluation.', 'success');
            } else {
                closeEditCommentsModal();
            }
        }
        
        // Edit Timeline Markers
        function editTimelineMarkers() {
            if (!evaluationResults || !evaluationResults.timeline_markers) return;
            
            renderMarkersList();
            document.getElementById('editMarkersModal').style.display = 'flex';
        }
        
        function closeEditMarkersModal() {
            document.getElementById('editMarkersModal').style.display = 'none';
        }
        
        function renderMarkersList() {
            const markers = evaluationResults.timeline_markers || [];
            let html = '';
            
            markers.forEach((marker, index) => {
                const severityColors = {
                    'positive': '#10b981',
                    'minor': '#f59e0b',
                    'moderate': '#f59e0b',
                    'major': '#ef4444'
                };
                const color = severityColors[marker.severity] || '#f59e0b';
                
                html += `
                    <div style="background:var(--bg-alt);padding:1rem;border-radius:0.5rem;margin-bottom:1rem;border-left:4px solid ${color};" data-marker-index="${index}">
                        <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:1rem;">
                            <div style="flex:1;">
                                <label style="display:block;font-weight:600;font-size:0.85rem;margin-bottom:0.25rem;">Timestamp:</label>
                                <input type="text" id="marker-time-${index}" value="${escapeHtml(marker.timestamp || '')}" style="width:100px;padding:0.5rem;border:2px solid #ddd;border-radius:0.25rem;" placeholder="0:45">
                            </div>
                            <div style="flex:2;margin-left:1rem;">
                                <label style="display:block;font-weight:600;font-size:0.85rem;margin-bottom:0.25rem;">Category:</label>
                                <input type="text" id="marker-category-${index}" value="${escapeHtml(marker.category || '')}" style="width:100%;padding:0.5rem;border:2px solid #ddd;border-radius:0.25rem;">
                            </div>
                            <button onclick="deleteMarker(${index})" style="margin-left:1rem;padding:0.5rem;background:#dc3545;color:white;border:none;border-radius:0.25rem;cursor:pointer;">🗑️</button>
                        </div>
                        <div style="margin-bottom:0.75rem;">
                            <label style="display:block;font-weight:600;font-size:0.85rem;margin-bottom:0.25rem;">Issue:</label>
                            <input type="text" id="marker-issue-${index}" value="${escapeHtml(marker.issue || '')}" style="width:100%;padding:0.5rem;border:2px solid #ddd;border-radius:0.25rem;">
                        </div>
                        <div style="margin-bottom:0.75rem;">
                            <label style="display:block;font-weight:600;font-size:0.85rem;margin-bottom:0.25rem;">Note:</label>
                            <textarea id="marker-note-${index}" rows="2" style="width:100%;padding:0.5rem;border:2px solid #ddd;border-radius:0.25rem;resize:vertical;">${escapeHtml(marker.note || '')}</textarea>
                        </div>
                        <div>
                            <label style="display:block;font-weight:600;font-size:0.85rem;margin-bottom:0.25rem;">Severity:</label>
                            <select id="marker-severity-${index}" style="padding:0.5rem;border:2px solid #ddd;border-radius:0.25rem;">
                                <option value="positive" ${marker.severity === 'positive' ? 'selected' : ''}>✓ Positive</option>
                                <option value="minor" ${marker.severity === 'minor' ? 'selected' : ''}>⚠ Minor</option>
                                <option value="moderate" ${marker.severity === 'moderate' ? 'selected' : ''}>⚠ Moderate</option>
                                <option value="major" ${marker.severity === 'major' ? 'selected' : ''}>✕ Major</option>
                            </select>
                        </div>
                    </div>
                `;
            });
            
            if (markers.length === 0) {
                html = '<p style="text-align:center;color:#999;padding:2rem;">No timeline markers yet. Click "Add New Marker" below.</p>';
            }
            
            document.getElementById('editMarkersList').innerHTML = html;
        }
        
        function deleteMarker(index) {
            if (!confirm('Delete this marker?')) return;
            
            const marker = evaluationResults.timeline_markers[index];
            
            correctionLog.push({
                timestamp: new Date().toISOString(),
                field: 'timeline_marker_removed',
                marker_index: index,
                ai_value: marker,
                reason: 'Marker removed by instructor'
            });
            
            evaluationResults.timeline_markers.splice(index, 1);
            renderMarkersList();
        }
        
        function addNewMarker() {
            if (!evaluationResults.timeline_markers) {
                evaluationResults.timeline_markers = [];
            }
            
            evaluationResults.timeline_markers.push({
                timestamp: '0:00',
                seconds: 0,
                category: 'New Category',
                issue: 'New Issue',
                severity: 'minor',
                note: 'Add your observation here...'
            });
            
            correctionLog.push({
                timestamp: new Date().toISOString(),
                field: 'timeline_marker_added',
                reason: 'Marker added by instructor'
            });
            
            renderMarkersList();
        }
        
        function saveEditedMarkers() {
            if (!evaluationResults || !evaluationResults.timeline_markers) return;
            
            // Update all markers from form inputs
            evaluationResults.timeline_markers.forEach((marker, index) => {
                const timestamp = document.getElementById(`marker-time-${index}`).value;
                const category = document.getElementById(`marker-category-${index}`).value;
                const issue = document.getElementById(`marker-issue-${index}`).value;
                const note = document.getElementById(`marker-note-${index}`).value;
                const severity = document.getElementById(`marker-severity-${index}`).value;
                
                // Convert timestamp to seconds
                const parts = timestamp.split(':');
                const seconds = parseInt(parts[0]) * 60 + parseInt(parts[1] || 0);
                
                marker.timestamp = timestamp;
                marker.seconds = seconds;
                marker.category = category;
                marker.issue = issue;
                marker.note = note;
                marker.severity = severity;
            });
            
            // Re-display results with updated markers
            displayResults(evaluationResults);
            
            closeEditMarkersModal();
            showNotification('✓ Timeline markers updated! Remember to save the evaluation.', 'success');
        }
        
        
        // Correction History Functions
        function viewCorrectionHistory() {
            if (!correctionLog || correctionLog.length === 0) {
                alert('No corrections have been made to this evaluation yet.');
                return;
            }
            
            const content = document.getElementById('correctionHistoryContent');
            let html = `<div style="color:var(--text-light);font-size:0.9rem;margin-bottom:1rem;padding:0.75rem;background:var(--bg-alt);border-radius:0.5rem;">
                <strong>${correctionLog.length}</strong> correction${correctionLog.length !== 1 ? 's' : ''} recorded
            </div>`;
            
            // Group corrections by timestamp for better readability
            correctionLog.forEach((correction, index) => {
                const date = new Date(correction.timestamp);
                const timeStr = date.toLocaleString();
                
                // Determine field display name
                let fieldDisplay = correction.field;
                if (correction.field && correction.field.includes('.')) {
                    const parts = correction.field.split('.');
                    fieldDisplay = `${parts[0]} → ${parts[1]}`;
                    if (parts[2]) fieldDisplay += ` (${parts[2]})`;
                }
                
                // Safely stringify values for display
                const safeStringify = (value) => {
                    if (value == null) return '';
                    if (typeof value === 'object') {
                        try {
                            return escapeHtml(JSON.stringify(value));
                        } catch (e) {
                            return escapeHtml(String(value));
                        }
                    }
                    return escapeHtml(String(value));
                };
                
                html += `
                    <div style="background:white;border:1px solid var(--border);border-radius:0.5rem;padding:1rem;margin-bottom:1rem;border-left:4px solid var(--primary);">
                        <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:0.75rem;">
                            <div>
                                <strong style="color:var(--primary);font-size:0.95rem;">${escapeHtml(fieldDisplay || '')}</strong>
                                <div style="color:var(--text-light);font-size:0.85rem;margin-top:0.25rem;">${escapeHtml(timeStr || '')}</div>
                            </div>
                            <span style="background:var(--bg-alt);padding:0.25rem 0.75rem;border-radius:0.25rem;font-size:0.85rem;font-weight:600;">#${index + 1}</span>
                        </div>
                        
                        ${correction.ai_value !== undefined ? `
                            <div style="margin-bottom:0.75rem;">
                                <div style="font-size:0.85rem;font-weight:600;color:var(--text-light);margin-bottom:0.25rem;">AI Original:</div>
                                <div style="background:var(--bg-alt);padding:0.5rem;border-radius:0.25rem;font-size:0.9rem;font-family:monospace;">
                                    ${safeStringify(correction.ai_value)}
                                </div>
                            </div>
                            
                            <div style="margin-bottom:0.75rem;">
                                <div style="font-size:0.85rem;font-weight:600;color:var(--primary);margin-bottom:0.25rem;">Instructor Correction:</div>
                                <div style="background:var(--success);background:rgba(40,167,69,0.1);padding:0.5rem;border-radius:0.25rem;font-size:0.9rem;border-left:3px solid var(--success);">
                                    ${safeStringify(correction.instructor_value)}
                                </div>
                            </div>
                        ` : ''}
                        
                        <div>
                            <div style="font-size:0.85rem;font-weight:600;color:var(--text-dark);margin-bottom:0.25rem;">Reason:</div>
                            <div style="color:var(--text);font-size:0.9rem;font-style:italic;">
                                "${escapeHtml(correction.reason || '')}"
                            </div>
                        </div>
                    </div>
                `;
            });
            
            content.innerHTML = html;
            document.getElementById('correctionHistoryModal').style.display = 'flex';
        }
        
        function closeCorrectionHistoryModal() {
            document.getElementById('correctionHistoryModal').style.display = 'none';
        }
        
        // Update correction count badge when corrections are made
        function updateCorrectionCount() {
            const countSpan = document.getElementById('correctionCount');
            const btn = document.getElementById('viewCorrectionsBtn');
            
            if (correctionLog && correctionLog.length > 0) {
                countSpan.textContent = correctionLog.length;
                btn.style.display = 'inline-block';
            } else {
                btn.style.display = 'none';
            }
        }
        
        // Notification helper
        function showNotification(message, type = 'info') {
            const colors = {
                success: '#28a745',
                error: '#dc3545',
                info: '#17a2b8'
            };
            
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${colors[type]};
                color: white;
                padding: 1rem 1.5rem;
                border-radius: 0.5rem;
                box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                z-index: 10000;
                animation: slideIn 0.3s ease-out;
            `;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease-out';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }


        // Export evaluation as accessible HTML file
        function downloadPDF() {
            if (!evaluationResults) {
                alert('No evaluation results to download.');
                return;
            }
            // Audit: log export of evaluation report for FERPA
            logAccess('export', 'evaluations', null, null, { purpose: 'download_report', format: 'html' });
            exportEvaluationHTML(evaluationResults, evaluationResults.studentName);
        }
        
        async function exportEvaluationHTML(evaluation, studentName) {
            console.log('Exporting evaluation as accessible HTML...');
            
            // Build timeline markers HTML if they exist
            let timelineHTML = '';
            if (evaluation.timeline_markers && evaluation.timeline_markers.length > 0) {
                // Group by category
                const markersByCategory = {};
                evaluation.timeline_markers.forEach(marker => {
                    if (!markersByCategory[marker.category]) {
                        markersByCategory[marker.category] = [];
                    }
                    markersByCategory[marker.category].push(marker);
                });
                
                timelineHTML = `
            <section aria-labelledby="timeline-markers">
                <h2 id="timeline-markers">Timeline Markers</h2>
                
                <div class="instructions" role="note">
                    <h3>How to Use Timeline Markers</h3>
                    <p>Open your video file on your device and seek to the timestamps below to review specific moments from your speech. These markers highlight both strengths and areas for improvement.</p>
                </div>
                `;
                
                Object.entries(markersByCategory).forEach(([category, markers]) => {
                    timelineHTML += `
                <article aria-labelledby="${category.toLowerCase().replace(/\s+/g, '-')}-heading">
                    <h3 id="${category.toLowerCase().replace(/\s+/g, '-')}-heading">${category}</h3>
                    `;
                    
                    markers.forEach(marker => {
                        const severityClass = marker.severity || 'minor';
                        const icon = {positive: '✓', minor: '⚠', moderate: '⚠', major: '✕'}[severityClass] || '⚠';
                        
                        timelineHTML += `
                    <div class="marker ${severityClass}" role="article" aria-label="${severityClass === 'positive' ? 'Strength' : 'Area for improvement'} at ${marker.timestamp}">
                        <div class="marker-time" aria-label="Timestamp">${marker.timestamp}</div>
                        <div class="marker-content">
                            <h4><span aria-hidden="true">${icon}</span> ${marker.issue}</h4>
                            <p>${marker.note}</p>
                        </div>
                    </div>
                        `;
                    });
                    
                    timelineHTML += `</article>`;
                });
                
                timelineHTML += `</section>`;
            }
            
            // Create complete HTML document
            const htmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speech Evaluation - ${studentName}</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Work Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; line-height: 1.6; color: #333; max-width: 800px; margin: 0 auto; padding: 2rem; background: #f5f5f5; }
        .container { background: white; padding: 3rem; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        :focus { outline: 3px solid var(--primary); outline-offset: 2px; }
        @media (prefers-contrast: high) { body { background: white; color: black; } .container { border: 2px solid black; } }
        @media print { body { background: white; padding: 0; } .container { box-shadow: none; padding: 1rem; } .no-print { display: none !important; } .section, .marker { page-break-inside: avoid; } }
        h1, h2, h3 { font-family: 'Crimson Pro', serif; }
        h1 { font-size: 2rem; color: #1e293b; margin-bottom: 1.5rem; border-bottom: 3px solid var(--primary); padding-bottom: 0.5rem; }
        h2 { font-size: 1.5rem; color: #1e293b; margin: 2rem 0 1rem 0; }
        h3 { font-size: 1.25rem; color: #334155; margin: 1.5rem 0 0.75rem 0; }
        .meta-info { background: #f1f5f9; padding: 1rem; border-radius: 4px; margin-bottom: 2rem; }
        .meta-info p { margin: 0.25rem 0; }
        .score-highlight { background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%); color: white; padding: 1.5rem; border-radius: 8px; margin: 2rem 0; }
        .score-highlight h2 { color: white; margin: 0 0 0.5rem 0; }
        .section { background: #f8fafc; padding: 1.5rem; border-radius: 4px; margin-bottom: 1rem; border-left: 4px solid var(--primary); }
        .section-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; }
        .section-score { font-size: 1.25rem; font-weight: bold; color: var(--primary); }
        .marker { display: flex; gap: 1rem; background: white; padding: 1rem; border-radius: 4px; margin-bottom: 0.75rem; border-left: 3px solid; }
        .marker.positive { border-left-color: #10b981; }
        .marker.minor { border-left-color: #f59e0b; }
        .marker.moderate { border-left-color: #f59e0b; }
        .marker.major { border-left-color: #ef4444; }
        .marker-time { min-width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; border-radius: 4px; font-weight: bold; color: white; flex-shrink: 0; }
        .marker.positive .marker-time { background: #10b981; }
        .marker.minor .marker-time { background: #f59e0b; }
        .marker.moderate .marker-time { background: #f59e0b; }
        .marker.major .marker-time { background: #ef4444; }
        .marker-content h4 { margin: 0 0 0.5rem 0; color: #1e293b; }
        .marker-content p { margin: 0; color: #64748b; }
        .instructions { background: #fef3c7; border: 1px solid #f59e0b; padding: 1rem; border-radius: 4px; margin: 1rem 0; }
        .instructions h3 { margin-top: 0; color: #92400e; }
        .button { display: inline-block; background: var(--primary); color: white; padding: 0.75rem 1.5rem; border-radius: 4px; text-decoration: none; font-weight: 600; border: none; cursor: pointer; margin-right: 1rem; }
        .button:hover { background: var(--primary-dark); }
        .skip-link { position: absolute; top: -40px; left: 0; background: var(--primary); color: white; padding: 8px; z-index: 100; }
        .skip-link:focus { top: 0; }
    </style>
</head>
<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>
    <div class="container">
        <div class="no-print" style="margin-bottom: 2rem; display: flex; gap: 1rem;">
            <button onclick="window.print()" class="button">🖨️ Print / Save as PDF</button>
            <button onclick="window.close()" class="button" style="background: #6b7280;">✕ Close</button>
        </div>
        <main id="main-content">
            <header>
                <h1>Speech Evaluation Report</h1>
                <div class="meta-info" role="contentinfo">
                    <p><strong>Student:</strong> ${studentName}</p>
                    <p><strong>Date:</strong> ${evaluation.speechDate || new Date().toLocaleDateString()}</p>
                    <p><strong>Assignment:</strong> ${evaluation.assignmentType || 'Speech Evaluation'}</p>
                    <p><strong>Rubric:</strong> ${evaluation.rubricUsed || 'Standard'}</p>
                </div>
            </header>
            <section class="score-highlight" aria-labelledby="overall-score">
                <h2 id="overall-score">Overall Score</h2>
                <p style="font-size: 2rem; margin: 0.5rem 0;">${evaluation.totalScore}/${evaluation.maxScore} <span style="font-size: 1.5rem;">(${evaluation.percentage}%)</span></p>
                <p style="font-size: 1.5rem; margin: 0;">Grade: ${evaluation.letterGrade}</p>
            </section>
            <section aria-labelledby="section-scores">
                <h2 id="section-scores">Section Scores & Feedback</h2>
                ${Object.keys(evaluation.sections || {}).map(sectionKey => {
                    const section = evaluation.sections[sectionKey];
                    const sectionName = sectionKey.charAt(0).toUpperCase() + sectionKey.slice(1);
                    return `<article class="section"><div class="section-header"><h3>${sectionName}</h3><span class="section-score" aria-label="${sectionName} score">${section.score}/${section.maxScore}</span></div><p>${section.feedback || 'No feedback provided.'}</p></article>`;
                }).join('')}
            </section>
            ${timelineHTML}
            <footer style="margin-top: 3rem; padding-top: 2rem; border-top: 1px solid #e2e8f0; color: #64748b; font-size: 0.875rem;">
                <p>Generated by SpeechGradebook on ${new Date().toLocaleDateString()}</p>
            </footer>
        </main>
    </div>
</body>
</html>`;
            
            // Create blob and download
            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${studentName.replace(/\s+/g, '_')}_Evaluation_${evaluation.speechDate || 'report'}.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log('✓ Accessible HTML evaluation exported');
        }
        
        window.exportEvaluationHTML = exportEvaluationHTML;

        function emailResults() {
            if (!evaluationResults) {
                alert('No evaluation results to email.');
                return;
            }
            
            // Prompt for student email
            const studentEmail = prompt('Enter student email address:');
            
            if (!studentEmail || !studentEmail.includes('@')) {
                alert('Please enter a valid email address.');
                return;
            }
            
            const subject = `Speech Evaluation Results - ${evaluationResults.assignmentType}`;
            const body = `Dear Student,\n\nYour speech evaluation results are ready.\n\nFinal Score: ${evaluationResults.totalScore} / ${evaluationResults.maxScore}\nGrade: ${evaluationResults.letterGrade || 'N/A'}\n\nPlease contact your instructor for the complete evaluation details.\n\nBest regards`;
            
            const mailtoLink = `mailto:${studentEmail}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
            window.open(mailtoLink);
        }

        function startOver() {
            uploadedFile = null;
            evaluationResults = null;
            document.getElementById('studentForm').reset();
            document.getElementById('fileInfo').classList.add('hidden');
            document.getElementById('fileInput').value = '';
            moveToStep(1);
        }

        // ===== CLASSES MANAGEMENT =====
        /** Render course cards into classesGrid (used by loadClasses and instructor filter) */
        function renderInstructorCoursesGrid(classesToRender) {
            const grid = document.getElementById('classesGrid');
            if (!grid) return;
            const classes = classesToRender || [];
            const cardPromises = classes.map(async cls => {
                let evalCount = 0;
                if (supabaseClient && cls.supabaseId) {
                    const supabaseEvals = await loadEvaluationsFromSupabase(cls.supabaseId);
                    if (supabaseEvals) evalCount = supabaseEvals.length;
                }
                if (cls.roster) {
                    cls.roster.forEach(student => {
                        if (student.evaluations) evalCount += student.evaluations.length;
                    });
                }
                return `
                <div class="class-card" data-class-id="${cls.id}">
                    <div class="class-header">${escapeHtml(cls.name)}</div>
                    <div class="class-meta">
                        ${escapeHtml(cls.semester || '')} ${escapeHtml((cls.year || '').toString())} • Section ${escapeHtml(cls.section || '')}
                    </div>
                    <p style="color: var(--text-light); font-size: 0.9rem; margin-bottom: 1rem;">
                        ${escapeHtml(cls.notes || 'No description')}
                    </p>
                    <div class="class-stats">
                        <div class="stat">
                            <div class="stat-value">${(cls.roster || []).length}</div>
                            <div class="stat-label">Students</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value">${evalCount}</div>
                            <div class="stat-label">Evaluations</div>
                        </div>
                    </div>
                </div>
                `;
            });
            Promise.all(cardPromises).then(cards => {
                grid.innerHTML = cards.join('');
                document.querySelectorAll('.class-card').forEach(card => {
                    card.addEventListener('click', async function() {
                        const classId = this.getAttribute('data-class-id');
                        await viewClass(classId);
                    });
                });
            });
        }

        async function loadClasses() {
            // Try Supabase first
            const supabaseCourses = await loadCoursesFromSupabase();
            
            let classes = [];
            
            if (supabaseCourses && supabaseCourses.length > 0) {
                // Convert Supabase format to app format
                classes = supabaseCourses.map(course => ({
                    id: course.id,
                    supabaseId: course.id,
                    name: course.name,
                    semester: course.semester || 'Fall',
                    section: course.code || '001',
                    year: course.year?.toString() || '2024',
                    notes: '',
                    roster: (course.course_students || []).map(student => ({
                        supabaseId: student.id,
                        firstName: student.first_name,
                        lastName: student.last_name,
                        name: `${student.first_name} ${student.last_name}`,
                        email: student.email || '',
                        studentId: student.student_id || '',
                        evaluations: []
                    })),
                    evaluations: []
                }));
                
                // Store in user-scoped localStorage so viewClass can find them
                setUserItem('classes', JSON.stringify(classes));
                console.log('✓ Synced Supabase classes to user-scoped localStorage');
            } else if (Array.isArray(supabaseCourses) && supabaseCourses.length === 0) {
                classes = [];
            } else {
                classes = JSON.parse(getUserItem('classes') || '[]');
            }
            
            // Demo: seed sample courses
            if (typeof userTier !== 'undefined' && userTier === 'demo' && classes.length === 0) {
                classes = [
                    { id: 'demo-c1', supabaseId: null, name: 'COMM 101', semester: 'Fall', section: '001', year: '2025', notes: 'Introduction to Public Speaking (demo)', roster: [{ supabaseId: null, firstName: 'Alex', lastName: 'Smith', name: 'Alex Smith', email: 'alex@example.edu', studentId: '', evaluations: [] }, { supabaseId: null, firstName: 'Jordan', lastName: 'Lee', name: 'Jordan Lee', email: 'jordan@example.edu', studentId: '', evaluations: [] }], evaluations: [] },
                    { id: 'demo-c2', supabaseId: null, name: 'COMM 205', semester: 'Fall', section: '002', year: '2025', notes: 'Persuasive Speaking (demo)', roster: [{ supabaseId: null, firstName: 'Sam', lastName: 'Jones', name: 'Sam Jones', email: 'sam@example.edu', studentId: '', evaluations: [] }], evaluations: [] }
                ];
            }
            
            const isInstructorView = userTier === 'instructor' || (currentViewMode === 'own' && typeof isAdmin === 'function' && !isAdmin() && typeof isSuperAdmin === 'function' && !isSuperAdmin());
            if (isInstructorView) {
                _instructorCoursesAll = classes.slice();
                populateInstructorFilterDropdowns(classes);
                renderInstructorCoursesGrid(getInstructorFilteredClasses());
            } else {
                renderInstructorCoursesGrid(classes);
            }
        }

        function showCreateClass() {
            document.getElementById('createClassCard').classList.remove('hidden');
        }

        function cancelCreateClass() {
            document.getElementById('createClassCard').classList.add('hidden');
            document.getElementById('createClassForm').reset();
        }

        function toggleEvalType(typeId) {
            const content = document.getElementById(typeId);
            const arrow = document.getElementById(typeId + '-arrow');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.style.transform = 'rotate(90deg)';
            } else {
                content.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
            }
        }

        
        // Sort evaluations dynamically
        // Make sortEvaluations globally accessible
        window.sortEvaluations = sortEvaluations;

        async function viewClass(classId) {
            currentClassId = classId; // Store for later use
            
            // Load classes fresh from Supabase/localStorage
            await loadClasses();
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const selectedClass = classes.find(c => c.id === classId);
            
            if (!selectedClass) {
                alert('Class not found');
                console.error('Class ID not found:', classId, 'Available IDs:', classes.map(c => c.id));
                return;
            }
            
            const roster = selectedClass.roster || [];
            
            // Gather all evaluations - from both Supabase and localStorage
            const evals = [];
            
            // Load from Supabase if available
            if (supabaseClient && selectedClass.supabaseId) {
                console.log('Loading evaluations from Supabase for course:', selectedClass.supabaseId);
                const supabaseEvals = await loadEvaluationsFromSupabase(selectedClass.supabaseId);
                console.log('Supabase evaluations result:', supabaseEvals);
                
                if (supabaseEvals && supabaseEvals.length > 0) {
                    console.log('Processing', supabaseEvals.length, 'Supabase evaluations');
                    supabaseEvals.forEach(ev => {
                        console.log('Evaluation data:', ev);
                        evals.push({
                            studentName: ev.student ? `${ev.student.first_name} ${ev.student.last_name}` : 'Unknown',
                            studentId: ev.student_id,
                            date: new Date(ev.created_at).toLocaleDateString(),
                            type: ev.evaluation_data?.assignmentType || 'Unknown',
                            totalScore: ev.total_score || 0,
                            maxScore: ev.evaluation_data?.maxScore || 100,
                            results: ev.evaluation_data
                        });
                    });
                    console.log('✓ Added', evals.length, 'evaluations from Supabase');
                } else {
                    console.log('No evaluations found in Supabase for this course');
                }
            } else {
                console.log('Supabase not available or course has no supabaseId');
            }
            
            // Also gather from localStorage (for backwards compatibility)
            roster.forEach(student => {
                if (student.evaluations) {
                    student.evaluations.forEach(ev => {
                        // Only add if not already in evals (avoid duplicates)
                        const exists = evals.find(e => 
                            e.studentId === student.id && 
                            e.date === ev.date &&
                            e.type === ev.type
                        );
                        if (!exists) {
                            evals.push({
                                studentName: escapeHtml((student.firstName || '') + ' ' + (student.lastName || '')),
                                studentId: student.id,
                                date: ev.date,
                                type: ev.type,
                                totalScore: ev.results.totalScore,
                                maxScore: ev.results.maxScore,
                                results: ev.results
                            });
                        }
                    });
                }
            });
            
            // Load consent status per student for this course (instructor view)
            let consentByStudent = {};
            if (supabaseClient && selectedClass.supabaseId) {
                try {
                    const { data: consentRows, error: consentErr } = await supabaseClient
                        .from('consent_forms')
                        .select('student_id, consent_given')
                        .eq('course_id', selectedClass.supabaseId)
                        .eq('consent_type', 'data_collection');
                    if (!consentErr && consentRows && consentRows.length > 0) {
                        consentRows.forEach(function(r) {
                            consentByStudent[r.student_id] = r.consent_given;
                        });
                    }
                } catch (e) {
                    console.warn('Could not load consent status:', e);
                }
            }
            
            // Update title
            document.getElementById('classDetailTitle').textContent = 
                `${selectedClass.name} - ${selectedClass.semester} ${selectedClass.year}`;
            
            console.log('Final evals array before display:', evals);
            console.log('Evals count:', evals.length);
            
            // Build content
            let html = `
                <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 2rem;">
                    <strong>Section:</strong> ${selectedClass.section}<br>
                    <strong>Notes:</strong> ${selectedClass.notes || 'None'}<br>
                    <strong>Students:</strong> ${roster.length}<br>
                    <strong>Evaluations:</strong> ${evals.length}
                </div>
            `;
            
            // Students section with Add button
            html += `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 2rem; margin-bottom: 1rem;">
                    <h3 style="margin: 0;">👥 Students</h3>
                    <button onclick="showAddStudent()"><span class="icon-with-text"><i data-lucide="user-plus"></i> Add Student</span></button>
                </div>
            `;
            
            if (roster.length === 0) {
                html += '<p style="color: var(--text-light);">No students yet. Click "Add Student" to get started.</p>';
            } else {
                html += '<ul style="list-style: none; padding: 0;">';
                roster.forEach(student => {
                    // Count evaluations for this student from the evals array
                    const studentEvals = evals.filter(e => e.studentId === student.id || e.studentId === student.supabaseId);
                    const evalCount = studentEvals.length;
                    
                    let evalText = '';
                    if (evalCount > 0) {
                        evalText = ` • ${evalCount} evaluation${evalCount > 1 ? 's' : ''}`;
                    }
                    
                    const studentSupabaseId = student.supabaseId || student.id;
                    const consentStatus = consentByStudent[studentSupabaseId];
                    let consentBadge = '';
                    if (consentStatus === true) {
                        consentBadge = '<span style="font-size: 0.8rem; color: var(--success); font-weight: 500;">Consented</span>';
                    } else if (consentStatus === false) {
                        consentBadge = '<span style="font-size: 0.8rem; color: var(--text-light);">Declined</span>';
                    } else {
                        consentBadge = '<span style="font-size: 0.8rem; color: var(--text-light);">No response</span>';
                    }
                    
                    const studentId = escapeHtml(String(studentSupabaseId || ''));
                    const firstName = escapeHtml(student.firstName || '');
                    const lastName = escapeHtml(student.lastName || '');
                    const email = escapeHtml(student.email || 'No email');
                    
                    html += `<li style="background: var(--bg-alt); padding: 1rem; margin-bottom: 0.5rem; border-radius: 0.5rem; display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong>${firstName} ${lastName}</strong><br>
                            <span style="color: var(--text-light); font-size: 0.9rem;">${email}${evalText}</span>
                            <div style="margin-top: 0.35rem;">${consentBadge}</div>
                        </div>
                        <div style="display: flex; gap: 0.5rem; align-items: center;">
                            ${evalCount > 0 ? `<button onclick="viewStudentEvals('${studentId}')" class="btn-small">View Evals</button>` : ''}
                        </div>
                    </li>`;
                });
                html += '</ul>';
            }
            
            // Show content
            document.getElementById('classDetailContent').innerHTML = html;
            
            // Switch to class detail view
            setActiveSection('classDetailSection', 'navDashboard');
        }

        // ===== RUBRICS MANAGEMENT =====
        async function loadRubrics() {
            // Initialize rubrics storage if needed
            initializeRubrics();
            
            // Populate course filter dropdown
            populateCourseFilter();
            
            // Get all rubrics from storage (now async)
            let allRubrics = await getAllRubrics();
            if (!Array.isArray(allRubrics)) allRubrics = [];
            
            // Get all classes for course name lookup
            const classes = JSON.parse(getUserItem('classes') || '[]');
            
            const list = document.getElementById('rubricsList');
            if (!list) return; // Exit if element doesn't exist yet
            
            list.innerHTML = allRubrics.map(rubric => {
                // Get course info - handle both new courseIds array and old single courseId
                let courseInfo = '';
                let courseIdsToDisplay = [];
                
                if (rubric.courseIds && Array.isArray(rubric.courseIds) && rubric.courseIds.length > 0) {
                    courseIdsToDisplay = rubric.courseIds;
                } else if (rubric.courseId) {
                    // Backward compatibility with single courseId
                    courseIdsToDisplay = [rubric.courseId];
                }
                
                if (courseIdsToDisplay.length > 0) {
                    const courses = courseIdsToDisplay
                        .map(id => classes.find(c => c.id === id))
                        .filter(c => c); // Remove undefined (deleted courses)
                    
                    if (courses.length > 0) {
                        // Group by course name
                        const courseGroups = {};
                        courses.forEach(course => {
                            if (!courseGroups[course.name]) {
                                courseGroups[course.name] = [];
                            }
                            courseGroups[course.name].push(course);
                        });
                        
                        // Format display: "CMST 210 (Fall 2024) - Sections 001, 002"
                        const courseDisplays = Object.keys(courseGroups).map(courseName => {
                            const sections = courseGroups[courseName];
                            const firstCourse = sections[0];
                            const sectionNums = sections.map(s => s.section).join(', ');
                            const sectionText = sections.length > 1 ? `Sections ${sectionNums}` : `Section ${sectionNums}`;
                            return `${courseName} (${firstCourse.semester} ${firstCourse.year}) - ${sectionText}`;
                        });
                        
                        courseInfo = ` • <span style="color: var(--primary); font-weight: 500;">${courseDisplays.join(' • ')}</span>`;
                    } else if (courseIdsToDisplay.length > 0) {
                        courseInfo = ' • <span style="color: #999;">Course(s) not found</span>';
                    }
                }
                
                return `
                <div class="rubric-item">
                    <div class="rubric-info">
                        <h4>${rubric.name}</h4>
                        <p>${rubric.description || 'No description'} • ${rubric.totalPoints} points${rubric.speechType ? ' • ' + rubric.speechType : ''}${courseInfo}</p>
                    </div>
                    <div class="rubric-actions">
                        <button class="btn-small btn-view" data-rubric-id="${rubric.id}">View</button>
                        <button class="btn-small btn-edit" data-rubric-id="${rubric.id}">Edit</button>
                        <button class="btn-small btn-duplicate" data-rubric-id="${rubric.id}">Duplicate</button>
                        ${rubric.id !== 'default' ? `
                            <button class="btn-small btn-danger btn-delete" data-rubric-id="${rubric.id}">Delete</button>
                        ` : ''}
                    </div>
                </div>
            `;
            }).join('');
            
            // Add event listeners to all buttons
            document.querySelectorAll('.btn-view').forEach(btn => {
                btn.addEventListener('click', () => viewRubric(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-edit').forEach(btn => {
                btn.addEventListener('click', () => editRubric(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-duplicate').forEach(btn => {
                btn.addEventListener('click', () => duplicateRubricUI(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-delete').forEach(btn => {
                btn.addEventListener('click', () => {
                    console.log('Delete button clicked via event listener!');
                    deleteRubricUI(btn.dataset.rubricId);
                });
            });
        }

        function viewRubric(rubricId) {
            const rubric = getRubricById(rubricId);
            if (!rubric) return;
            
            const metrics = calculateRubricMetrics(rubric);
            const maxPointsPerSub = metrics.pointsPerSubcategory;
            
            // Get course info - handle both courseIds array and old courseId
            let courseInfo = '';
            let courseIdsToDisplay = [];
            
            if (rubric.courseIds && Array.isArray(rubric.courseIds) && rubric.courseIds.length > 0) {
                courseIdsToDisplay = rubric.courseIds;
            } else if (rubric.courseId) {
                courseIdsToDisplay = [rubric.courseId];
            }
            
            if (courseIdsToDisplay.length > 0) {
                const classes = JSON.parse(getUserItem('classes') || '[]');
                const courses = courseIdsToDisplay
                    .map(id => classes.find(c => c.id === id))
                    .filter(c => c);
                
                if (courses.length > 0) {
                    const courseDisplays = courses.map(course => 
                        `${course.name} - ${course.semester} ${course.year} (Section ${course.section})`
                    ).join('<br>');
                    courseInfo = `<strong>Course${courses.length > 1 ? 's' : ''}:</strong> ${courseDisplays}<br>`;
                }
            }
            
            let html = `
                <div style="background: white; padding: 2rem; border-radius: 0.5rem; max-width: 800px; margin: 2rem auto;">
                    <h2>${rubric.name}</h2>
                    <p style="color: var(--text-light); margin-bottom: 1rem;">${rubric.description || ''}</p>
                    <div style="background: var(--bg-alt); padding: 1rem; border-radius: 0.5rem; margin-bottom: 1.5rem;">
                        ${courseInfo}
                        <strong>Total Points:</strong> ${rubric.totalPoints}<br>
                        <strong>Total Subcategories:</strong> ${metrics.totalSubcategories}<br>
                        <strong>Maximum Points per Subcategory:</strong> ${maxPointsPerSub.toFixed(2)} (when graded as A)
                    </div>
                    <h3>Grade Scale & Points per Subcategory</h3>
                    <p style="color: var(--text-light); font-size: 0.9rem; margin-bottom: 0.5rem;">Each subcategory can earn different points based on the grade received:</p>
                    <div style="margin-bottom: 1.5rem;">
            `;
            
            for (const [grade, info] of Object.entries(rubric.gradeScale)) {
                const points = (maxPointsPerSub * info.percentage).toFixed(2);
                html += `<div style="padding: 0.5rem; border-left: 3px solid var(--primary); margin-bottom: 0.5rem; background: var(--bg-alt);">
                    <strong>${grade} - ${info.label}:</strong> ${info.percentage * 100}% → <strong>${points} points</strong> per subcategory (Range: ${info.range})
                </div>`;
            }
            
            html += `</div><h3>Categories & Subcategories</h3>`;
            
            rubric.categories.forEach((cat, idx) => {
                const catMetrics = metrics.categoryPoints[idx];
                html += `
                    <div style="margin-bottom: 1.5rem; padding: 1rem; border: 1px solid var(--border); border-radius: 0.5rem;">
                        <h4>${cat.name} <span style="color: var(--primary);">(Max: ${catMetrics.maxPoints.toFixed(1)} points)</span></h4>
                        <p style="color: var(--text-light); font-size: 0.9rem;">${catMetrics.subcategoryCount} subcategories × ${maxPointsPerSub.toFixed(2)} points each (if all A's)</p>
                        <ul style="margin-top: 0.5rem;">
                            ${cat.subcategories.map(sub => `<li>${sub}</li>`).join('')}
                        </ul>
                    </div>
                `;
            });
            
            html += `<button onclick="closeModal()">Close</button></div>`;
            
            showModal(html);
        }

        async function editRubric(rubricId) {
            const rubric = await getRubricById(rubricId);
            if (!rubric) {
                alert('Rubric not found');
                return;
            }
            loadRubricIntoForm(rubric);
        }

        async function duplicateRubricUI(rubricId) {
            console.log('Duplicating rubric:', rubricId);
            const newRubric = await duplicateRubric(rubricId);
            if (newRubric) {
                await loadRubrics();
                alert(`✓ Rubric duplicated: ${newRubric.name}`);
            }
        }

        async function deleteRubricUI(rubricId) {
            console.log('Delete button clicked for:', rubricId);
            const rubric = await getRubricById(rubricId);
            if (!rubric) {
                console.error('Rubric not found:', rubricId);
                return;
            }
            
            console.log('Found rubric:', rubric.name);
            
            // Use custom confirmation modal instead of native confirm
            showConfirmModal(
                'Delete Rubric',
                `Are you sure you want to delete "${rubric.name}"? This action cannot be undone.`,
                async () => {
                    // User clicked Yes/Confirm
                    console.log('User confirmed deletion via custom modal');
                    const deleteResult = await deleteRubric(rubricId);
                    console.log('deleteRubric returned:', deleteResult);
                    
                    if (deleteResult) {
                        console.log('Rubric deleted successfully');
                        await loadRubrics();
                        alert('✓ Rubric deleted successfully');
                    } else {
                        console.error('Delete function returned false');
                    }
                },
                () => {
                    // User clicked No/Cancel
                    console.log('User cancelled deletion via custom modal');
                }
            );
        }

        // Make functions globally accessible
        window.deleteRubricUI = deleteRubricUI;
        window.duplicateRubricUI = duplicateRubricUI;
        window.viewRubric = viewRubric;
        window.editRubric = editRubric;
        window.showCreateRubric = showCreateRubric;
        window.cancelCreateRubric = cancelCreateRubric;
        window.addCategory = addCategory;
        window.removeCategory = removeCategory;
        window.addSubcategory = addSubcategory;
        window.removeSubcategory = removeSubcategory;

        // Test function to verify everything is working
        async function testDeleteFunction() {
            console.log('=== TEST FUNCTION CALLED ===');
            console.log('deleteRubricUI exists?', typeof window.deleteRubricUI);
            console.log('deleteRubric exists?', typeof deleteRubric);
            console.log('getRubricById exists?', typeof getRubricById);
            
            const allRubrics = await getAllRubrics();
            const arr = Array.isArray(allRubrics) ? allRubrics : [];
            console.log('All rubrics:', arr);
            
            if (arr.length > 0) {
                const testId = arr[arr.length - 1].id;
                console.log('Attempting to call deleteRubricUI with ID:', testId);
                try {
                    await deleteRubricUI(testId);
                } catch (e) {
                    console.error('Error calling deleteRubricUI:', e);
                }
            }
        }
        window.testDeleteFunction = testDeleteFunction;

        function showModal(content) {
            const modal = document.getElementById('saveModal');
            if (!modal) return;
            
            modal.innerHTML = `
                <div onclick="closeModal()" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 9999; display: flex; align-items: center; justify-content: center;">
                    <div onclick="event.stopPropagation()" style="background: white; border-radius: 0.5rem; max-height: 90vh; overflow-y: auto; max-width: 90vw;">
                        ${content}
                    </div>
                </div>
            `;
            modal.style.display = 'flex';
        }

        function closeModal() {
            const modal = document.getElementById('saveModal');
            if (modal) {
                modal.style.display = 'none';
                modal.innerHTML = '';
            }
        }

        function showConfirmModal(title, message, onConfirm, onCancel) {
            const modal = document.getElementById('saveModal');
            if (!modal) {
                console.error('Modal element not found');
                return;
            }
            
            modal.innerHTML = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 9999; display: flex; align-items: center; justify-content: center;">
                    <div onclick="event.stopPropagation()" style="background: white; border-radius: 0.5rem; padding: 2rem; max-width: 500px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                        <h3 style="margin-bottom: 1rem; color: var(--primary);">${title}</h3>
                        <p style="margin-bottom: 2rem; color: var(--text);">${message}</p>
                        <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                            <button id="confirmCancel" class="btn-secondary" style="padding: 0.5rem 1.5rem;">Cancel</button>
                            <button id="confirmYes" class="btn-danger" style="padding: 0.5rem 1.5rem;">Delete</button>
                        </div>
                    </div>
                </div>
            `;
            modal.style.display = 'flex';
            
            // Add event listeners
            document.getElementById('confirmYes').addEventListener('click', () => {
                closeModal();
                if (onConfirm) onConfirm();
            });
            
            document.getElementById('confirmCancel').addEventListener('click', () => {
                closeModal();
                if (onCancel) onCancel();
            });
        }

        // Make modal functions globally accessible
        window.showModal = showModal;
        window.closeModal = closeModal;
        window.showConfirmModal = showConfirmModal;

        function showCreateRubric() {
            document.getElementById('rubricFormHeader').textContent = 'Create Custom Rubric';
            document.getElementById('rubricSubmitBtn').textContent = 'Create Rubric';
            document.getElementById('editingRubricId').value = '';
            document.getElementById('createRubricForm').reset();
            
            // Populate course selector
            populateCourseSelector();
            
            // Initialize with one empty category
            document.getElementById('categoriesContainer').innerHTML = '';
            addCategory();
            
            document.getElementById('createRubricCard').classList.remove('hidden');
            document.getElementById('createRubricCard').scrollIntoView({ behavior: 'smooth' });
        }

        function cancelCreateRubric() {
            document.getElementById('createRubricCard').classList.add('hidden');
            document.getElementById('createRubricForm').reset();
            document.getElementById('categoriesContainer').innerHTML = '';
        }

        // ===== UPLOAD RUBRIC FUNCTIONS =====
        
        function showUploadRubric() {
            document.getElementById('uploadRubricForm').reset();
            document.getElementById('uploadProgress').classList.add('hidden');
            document.getElementById('uploadRubricCard').classList.remove('hidden');
            document.getElementById('uploadRubricCard').scrollIntoView({ behavior: 'smooth' });
            
            // Load saved API keys
            const savedGeminiKey = localStorage.getItem('gemini_api_key');
            const savedOpenAIKey = localStorage.getItem('openai_api_key');
            const savedClaudeKey = localStorage.getItem('anthropic_api_key');
            
            // Pre-fill API key if one is saved
            if (savedGeminiKey) {
                document.getElementById('uploadAiProvider').value = 'gemini';
                document.getElementById('uploadApiKey').value = savedGeminiKey;
            } else if (savedOpenAIKey) {
                document.getElementById('uploadAiProvider').value = 'gpt4o';
                document.getElementById('uploadApiKey').value = savedOpenAIKey;
            } else if (savedClaudeKey) {
                document.getElementById('uploadAiProvider').value = 'claude';
                document.getElementById('uploadApiKey').value = savedClaudeKey;
            }
        }
        
        function cancelUploadRubric() {
            document.getElementById('uploadRubricCard').classList.add('hidden');
            document.getElementById('uploadRubricForm').reset();
        }
        
        // Handle upload rubric form submission
        document.getElementById('uploadRubricForm')?.addEventListener('submit', async function(e) {
            e.preventDefault();
            await processUploadedRubric();
        });
        
        async function processUploadedRubric() {
            const fileInput = document.getElementById('uploadRubricFile');
            const rubricName = document.getElementById('uploadRubricName').value;
            const aiProvider = document.getElementById('uploadAiProvider').value;
            const apiKey = document.getElementById('uploadApiKey').value;
            
            if (!fileInput.files || !fileInput.files[0]) {
                alert('Please select a file to upload');
                return;
            }
            
            const file = fileInput.files[0];
            const maxSize = 10 * 1024 * 1024; // 10MB
            
            if (file.size > maxSize) {
                alert('File size exceeds 10MB limit. Please use a smaller file.');
                return;
            }
            
            // Show progress
            const progressDiv = document.getElementById('uploadProgress');
            const progressText = document.getElementById('uploadProgressText');
            const progressBar = document.getElementById('uploadProgressBar');
            progressDiv.classList.remove('hidden');
            progressText.textContent = 'Reading file...';
            progressBar.style.width = '20%';
            
            try {
                // Convert file to base64
                const base64Data = await fileToBase64(file);
                progressText.textContent = 'Analyzing rubric structure...';
                progressBar.style.width = '40%';
                
                // Extract rubric using AI
                const extractedRubric = await extractRubricWithAI(base64Data, file.type, aiProvider, apiKey);
                progressText.textContent = 'Creating rubric...';
                progressBar.style.width = '80%';
                
                if (!extractedRubric) {
                    throw new Error('Failed to extract rubric from file');
                }
                
                // Create the rubric object
                const rubric = {
                    name: rubricName,
                    speechType: extractedRubric.speechType || 'General',
                    totalPoints: extractedRubric.totalPoints || 100,
                    gradeScale: extractedRubric.gradeScale || {
                        A: { min: 90, label: 'Excellent' },
                        B: { min: 80, label: 'Good' },
                        C: { min: 70, label: 'Satisfactory' },
                        D: { min: 60, label: 'Needs Improvement' },
                        F: { min: 0, label: 'Unsatisfactory' }
                    },
                    categories: extractedRubric.categories,
                    isTemplate: false,
                    extractedFrom: file.name
                };
                
                // Save the rubric
                await saveRubric(rubric);
                
                progressText.textContent = '✅ Rubric created successfully!';
                progressBar.style.width = '100%';
                
                // Reload rubrics display
                await loadRubrics();
                
                // Close form after brief delay
                setTimeout(() => {
                    cancelUploadRubric();
                    alert(`Rubric "${rubricName}" has been created successfully from ${file.name}!`);
                }, 1500);
                
            } catch (error) {
                console.error('Error processing rubric:', error);
                progressDiv.classList.add('hidden');
                alert('Failed to process rubric: ' + error.message + '\n\nPlease check:\n- Your API key is correct\n- The file contains a clear rubric structure\n- Your internet connection is working');
            }
        }
        
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    const base64 = reader.result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        async function extractRubricWithAI(base64Data, mimeType, provider, apiKey) {
            console.log('Extracting rubric with', provider);
            
            const prompt = `You are analyzing a rubric document. Extract ALL the information and return ONLY a valid JSON object (no markdown, no explanation, no preamble).

The JSON must have this exact structure:
{
  "speechType": "type of speech if mentioned, or 'General'",
  "totalPoints": total possible points as a number,
  "categories": [
    {
      "name": "Category Name",
      "subcategories": [
        {
          "name": "Subcategory Name",
          "points": point value as number,
          "description": "criteria description"
        }
      ]
    }
  ],
  "gradeScale": {
    "A": {"min": 90, "label": "Excellent"},
    "B": {"min": 80, "label": "Good"},
    "C": {"min": 70, "label": "Satisfactory"},
    "D": {"min": 60, "label": "Needs Improvement"},
    "F": {"min": 0, "label": "Unsatisfactory"}
  }
}

Extract every category, subcategory, point value, and grading criterion you can find. If the grading scale is specified in the rubric, use those values instead of the defaults shown above.

Return ONLY the JSON object, nothing else.`;

            if (provider === 'gemini') {
                return await extractWithGemini(base64Data, mimeType, prompt, apiKey);
            } else if (provider === 'gpt4o') {
                return await extractWithOpenAI(base64Data, mimeType, prompt, apiKey);
            } else if (provider === 'claude') {
                return await extractWithClaude(base64Data, mimeType, prompt, apiKey);
            }
        }
        
        async function extractWithGemini(base64Data, mimeType, prompt, apiKey) {
            // Use gemini-1.5-flash which supports both text and images
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{
                        parts: [
                            { text: prompt },
                            {
                                inline_data: {
                                    mime_type: mimeType,
                                    data: base64Data
                                }
                            }
                        ]
                    }],
                    generationConfig: {
                        temperature: 0.4,
                        topK: 32,
                        topP: 1,
                        maxOutputTokens: 2048
                    }
                })
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                console.error('Gemini API error:', errorData);
                
                // Provide helpful error message
                if (response.status === 404) {
                    throw new Error(`API key may be invalid. Please:\n1. Get a new key from https://aistudio.google.com/app/apikey\n2. Make sure it's enabled for Gemini API\n3. Try again with the new key`);
                } else if (response.status === 400) {
                    throw new Error(`Bad request: ${errorData.error?.message || 'Check your file format'}`);
                } else {
                    throw new Error(`Gemini API error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
                }
            }
            
            const data = await response.json();
            
            if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
                throw new Error('Unexpected response format from Gemini API');
            }
            
            const text = data.candidates[0].content.parts[0].text;
            
            // Clean up the response to extract JSON
            const jsonMatch = text.match(/\{[\s\S]*\}/);
            if (!jsonMatch) {
                console.error('AI Response:', text);
                throw new Error('No valid JSON found in AI response. The AI may not have recognized a rubric structure in the image.');
            }
            
            return JSON.parse(jsonMatch[0]);
        }
        
        async function extractWithOpenAI(base64Data, mimeType, prompt, apiKey) {
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: 'gpt-4o',
                    messages: [{
                        role: 'user',
                        content: [
                            { type: 'text', text: prompt },
                            {
                                type: 'image_url',
                                image_url: {
                                    url: `data:${mimeType};base64,${base64Data}`
                                }
                            }
                        ]
                    }],
                    max_tokens: 2000
                })
            });
            
            if (!response.ok) {
                throw new Error(`OpenAI API error: ${response.status}`);
            }
            
            const data = await response.json();
            const text = data.choices[0].message.content;
            
            const jsonMatch = text.match(/\{[\s\S]*\}/);
            if (!jsonMatch) {
                throw new Error('No valid JSON found in AI response');
            }
            
            return JSON.parse(jsonMatch[0]);
        }
        
        async function extractWithClaude(base64Data, mimeType, prompt, apiKey) {
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                    model: 'claude-3-5-sonnet-20241022',
                    max_tokens: 2000,
                    messages: [{
                        role: 'user',
                        content: [
                            { type: 'text', text: prompt },
                            {
                                type: 'image',
                                source: {
                                    type: 'base64',
                                    media_type: mimeType,
                                    data: base64Data
                                }
                            }
                        ]
                    }]
                })
            });
            
            if (!response.ok) {
                throw new Error(`Claude API error: ${response.status}`);
            }
            
            const data = await response.json();
            const text = data.content[0].text;
            
            const jsonMatch = text.match(/\{[\s\S]*\}/);
            if (!jsonMatch) {
                throw new Error('No valid JSON found in AI response');
            }
            
            return JSON.parse(jsonMatch[0]);
        }

        let categoryCounter = 0;

        function addCategory() {
            categoryCounter++;
            const container = document.getElementById('categoriesContainer');
            const categoryDiv = document.createElement('div');
            categoryDiv.className = 'category-item';
            categoryDiv.id = `category-${categoryCounter}`;
            categoryDiv.style.cssText = 'background: var(--bg-alt); padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem; border: 1px solid var(--border);';
            
            categoryDiv.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                    <input type="text" placeholder="Category Name (e.g., Content - Introduction)" 
                           class="category-name" style="flex: 1; margin-right: 1rem; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;" required>
                    <button type="button" onclick="removeCategory('category-${categoryCounter}')" class="btn-small btn-danger">Remove Category</button>
                </div>
                <div class="subcategories-container" id="subcategories-${categoryCounter}"></div>
                <button type="button" onclick="addSubcategory('subcategories-${categoryCounter}')" class="btn-small" style="margin-top: 0.5rem;">➕ Add Subcategory</button>
            `;
            
            container.appendChild(categoryDiv);
            
            // Add one default subcategory
            addSubcategory(`subcategories-${categoryCounter}`);
        }

        function removeCategory(categoryId) {
            const element = document.getElementById(categoryId);
            if (element) {
                element.remove();
            }
        }

        let subcategoryCounter = 0;

        function addSubcategory(containerId) {
            subcategoryCounter++;
            const container = document.getElementById(containerId);
            const subDiv = document.createElement('div');
            subDiv.id = `subcategory-${subcategoryCounter}`;
            subDiv.style.cssText = 'display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.5rem;';
            
            subDiv.innerHTML = `
                <span style="color: var(--text-light); font-size: 0.9rem;">•</span>
                <input type="text" placeholder="Subcategory (e.g., Eye Contact)" 
                       class="subcategory-name" style="flex: 1; padding: 0.4rem; border: 1px solid var(--border); border-radius: 0.25rem;" required>
                <button type="button" onclick="removeSubcategory('subcategory-${subcategoryCounter}')" class="btn-small btn-danger" style="padding: 0.25rem 0.5rem; font-size: 0.8rem;">✕</button>
            `;
            
            container.appendChild(subDiv);
        }

        function removeSubcategory(subId) {
            const element = document.getElementById(subId);
            if (element) {
                element.remove();
            }
        }

        function collectRubricData() {
            // Collect selected course IDs from checkboxes
            const selectedCourseIds = Array.from(document.querySelectorAll('.course-checkbox:checked'))
                .map(checkbox => checkbox.value);
            
            const rubricData = {
                id: document.getElementById('editingRubricId').value || ('rubric-' + Date.now()),
                name: document.getElementById('rubricName').value.trim(),
                description: document.getElementById('rubricDescription').value.trim(),
                totalPoints: parseInt(document.getElementById('rubricTotalPoints').value),
                speechType: document.getElementById('rubricSpeechType').value.trim() || null,
                courseIds: selectedCourseIds.length > 0 ? selectedCourseIds : [], // Array of course IDs
                gradeScale: {
                    A: {
                        label: document.getElementById('gradeA_label').value,
                        percentage: parseFloat(document.getElementById('gradeA_pct').value) / 100,
                        range: document.getElementById('gradeA_range').value
                    },
                    B: {
                        label: document.getElementById('gradeB_label').value,
                        percentage: parseFloat(document.getElementById('gradeB_pct').value) / 100,
                        range: document.getElementById('gradeB_range').value
                    },
                    C: {
                        label: document.getElementById('gradeC_label').value,
                        percentage: parseFloat(document.getElementById('gradeC_pct').value) / 100,
                        range: document.getElementById('gradeC_range').value
                    },
                    D: {
                        label: document.getElementById('gradeD_label').value,
                        percentage: parseFloat(document.getElementById('gradeD_pct').value) / 100,
                        range: document.getElementById('gradeD_range').value
                    },
                    F: {
                        label: document.getElementById('gradeF_label').value,
                        percentage: parseFloat(document.getElementById('gradeF_pct').value) / 100,
                        range: document.getElementById('gradeF_range').value
                    }
                },
                categories: []
            };

            // Collect categories and subcategories
            const categoryElements = document.querySelectorAll('.category-item');
            
            categoryElements.forEach((catEl) => {
                const categoryName = catEl.querySelector('.category-name').value.trim();
                if (!categoryName) return;

                const subcategories = [];
                const subInputs = catEl.querySelectorAll('.subcategory-name');
                
                subInputs.forEach((subInput) => {
                    const subName = subInput.value.trim();
                    if (subName) {
                        subcategories.push(subName);
                    }
                });

                if (subcategories.length > 0) {
                    rubricData.categories.push({
                        name: categoryName,
                        subcategories: subcategories
                    });
                }
            });

            return rubricData;
        }

        function loadRubricIntoForm(rubric) {
            document.getElementById('rubricFormHeader').textContent = 'Edit Rubric';
            document.getElementById('rubricSubmitBtn').textContent = 'Save Changes';
            document.getElementById('editingRubricId').value = rubric.id;
            
            // Normalize from Supabase snake_case if needed
            const gradeScale = rubric.gradeScale || rubric.grade_scale || {};
            const totalPoints = rubric.totalPoints ?? rubric.total_points ?? 100;
            const speechType = rubric.speechType ?? rubric.speech_type ?? '';
            
            // Basic info
            document.getElementById('rubricName').value = rubric.name || '';
            document.getElementById('rubricDescription').value = rubric.description || '';
            document.getElementById('rubricTotalPoints').value = totalPoints;
            document.getElementById('rubricSpeechType').value = speechType;
            
            // Populate course selector with pre-selected courses
            // Handle both old single courseId and new courseIds array for backward compatibility
            let selectedCourseIds = [];
            if (rubric.courseIds && Array.isArray(rubric.courseIds)) {
                selectedCourseIds = rubric.courseIds;
            } else if (rubric.courseId) {
                // Backward compatibility: convert old single courseId to array
                selectedCourseIds = [rubric.courseId];
            }
            populateCourseSelector(selectedCourseIds);
            
            // Grade scale (with fallbacks for missing or Supabase format)
            for (const grade of ['A', 'B', 'C', 'D', 'F']) {
                const gradeData = gradeScale[grade] || {};
                const labelEl = document.getElementById(`grade${grade}_label`);
                const pctEl = document.getElementById(`grade${grade}_pct`);
                const rangeEl = document.getElementById(`grade${grade}_range`);
                if (labelEl) labelEl.value = gradeData.label ?? '';
                if (pctEl) pctEl.value = (gradeData.percentage != null ? gradeData.percentage * 100 : 0);
                if (rangeEl) rangeEl.value = gradeData.range ?? '';
            }
            
            // Clear and rebuild categories
            document.getElementById('categoriesContainer').innerHTML = '';
            categoryCounter = 0;
            subcategoryCounter = 0;
            
            const categories = rubric.categories || [];
            categories.forEach((category) => {
                addCategory();
                const lastCategory = document.querySelector('.category-item:last-child');
                if (lastCategory) {
                    const nameInput = lastCategory.querySelector('.category-name');
                    if (nameInput) nameInput.value = category.name || '';
                }
                const subContainer = lastCategory ? lastCategory.querySelector('.subcategories-container') : null;
                if (subContainer) subContainer.innerHTML = '';
                
                const subcats = category.subcategories || [];
                if (subContainer && subContainer.id) {
                    subcats.forEach((subName) => {
                        addSubcategory(subContainer.id);
                        const allSubInputs = subContainer.querySelectorAll('.subcategory-name');
                        const lastSubInput = allSubInputs[allSubInputs.length - 1];
                        if (lastSubInput) lastSubInput.value = (typeof subName === 'string' ? subName : (subName && subName.name) ? subName.name : '');
                    });
                }
            });
            
            document.getElementById('createRubricCard').classList.remove('hidden');
            document.getElementById('createRubricCard').scrollIntoView({ behavior: 'smooth' });
        }

        // ===== STUDENT MANAGEMENT =====
        function showAddStudent() {
            document.getElementById('addStudentCard').classList.remove('hidden');
        }

        function cancelAddStudent() {
            document.getElementById('addStudentCard').classList.add('hidden');
            document.getElementById('addStudentForm').reset();
        }

        async function viewStudentEvals(studentId) {
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const cls = classes.find(c => c.id === currentClassId);
            if (!cls) return;
            
            const student = cls.roster.find(s => s.id === studentId || s.supabaseId === studentId);
            if (!student) {
                alert('Student not found.');
                return;
            }
            
            // Load evaluations from Supabase
            let allEvals = [];
            if (supabaseClient && cls.supabaseId) {
                const supabaseEvals = await loadEvaluationsFromSupabase(cls.supabaseId, student.supabaseId || studentId);
                if (supabaseEvals && supabaseEvals.length > 0) {
                    allEvals = supabaseEvals.map(ev => ({
                        date: new Date(ev.created_at).toLocaleDateString(),
                        type: ev.evaluation_data?.assignmentType || 'Unknown',
                        results: ev.evaluation_data,
                        supabaseId: ev.id
                    }));
                }
            }
            
            // Also check localStorage
            if (student.evaluations && student.evaluations.length > 0) {
                allEvals = [...allEvals, ...student.evaluations];
            }
            
            if (allEvals.length === 0) {
                alert('No evaluations found for this student.');
                return;
            }
            
            let html = `
                <div class="card">
                    <div class="card-header">${escapeHtml(student.firstName || '')} ${escapeHtml(student.lastName || '')} - Evaluations</div>
                    <div style="margin-bottom: 1rem;">
                        <button onclick="viewClass('${currentClassId}')" class="btn-secondary">← Back to Class</button>
                    </div>
                    <div style="color: var(--text-light); margin-bottom: 1rem;">Click on an evaluation to view details</div>
            `;
            
            allEvals.forEach((ev, index) => {
                const date = ev.date || 'No date';
                const type = ev.type || 'Unknown';
                const results = ev.results;
                const evalId = ev.supabaseId || ev.id;
                const percentage = (((results.totalScore || 0) / (results.maxScore || 50)) * 100).toFixed(0);
                let color = 'var(--success)';
                if (percentage < 70) color = 'var(--error)';
                else if (percentage < 80) color = 'var(--warning)';
                
                html += `
                    <div style="background: var(--bg-alt); border-radius: 0.5rem; margin-bottom: 0.75rem; border-left: 4px solid ${color}; overflow: hidden;">
                        <!-- Collapsed Header (clickable) -->
                        <div onclick="toggleEvaluation('eval-${index}')" style="padding: 1rem; cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong style="font-size: 1.1rem;">${type}</strong><br>
                                <span style="color: var(--text-light); font-size: 0.9rem;">${date}</span>
                            </div>
                            <div style="text-align: right; display: flex; align-items: center; gap: 1rem;">
                                <div>
                                    <div style="font-size: 1.3rem; font-weight: bold; color: var(--primary);">
                                        ${results.totalScore || 0}/${results.maxScore || 50}
                                    </div>
                                    <div style="font-size: 0.9rem; color: ${color}; font-weight: 600;">${percentage}% • ${results.letterGrade || 'N/A'}</div>
                                </div>
                                <span id="eval-${index}-arrow" style="font-size: 1.2rem; color: var(--text-light);">▼</span>
                            </div>
                        </div>
                        
                        <!-- Expanded Details (hidden by default) -->
                        <div id="eval-${index}" class="hidden" style="padding: 0 1rem 1rem 1rem; border-top: 1px solid var(--border);">
                            <div style="padding-top: 1rem;">
                `;
                
                // Display individual sections
                if (results.sections) {
                    html += '<div style="background: white; padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem;">';
                    html += '<strong style="display: block; margin-bottom: 0.75rem;">Section Scores:</strong>';
                    
                    Object.keys(results.sections).forEach(sectionKey => {
                        const section = results.sections[sectionKey];
                        const sectionName = sectionKey.charAt(0).toUpperCase() + sectionKey.slice(1);
                        html += `
                            <div style="border-left: 3px solid var(--primary); padding-left: 1rem; margin-bottom: 1rem;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                                    <strong>${sectionName}</strong>
                                    <span style="color: var(--primary); font-weight: bold;">${section.score}/${section.maxScore}</span>
                                </div>
                                <p style="color: var(--text-light); margin: 0; font-size: 0.9rem;">${section.feedback || 'No feedback'}</p>
                            </div>
                        `;
                    });
                    
                    html += '</div>';
                }
                
                // Display timeline markers if available
                if (results.timeline_markers && results.timeline_markers.length > 0) {
                    html += `
                        <div style="background: white; padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem;">
                            <strong style="display: block; margin-bottom: 0.75rem;">⏱️ Timeline Markers (${results.timeline_markers.length}):</strong>
                    `;
                    
                    // Group by category
                    const markersByCategory = {};
                    results.timeline_markers.forEach(marker => {
                        if (!markersByCategory[marker.category]) {
                            markersByCategory[marker.category] = [];
                        }
                        markersByCategory[marker.category].push(marker);
                    });
                    
                    Object.keys(markersByCategory).forEach(category => {
                        html += `<div style="margin-bottom: 1rem;"><strong style="color: var(--primary);">${category}:</strong><div style="margin-top: 0.5rem;">`;
                        
                        markersByCategory[category].forEach(marker => {
                            const markerColor = {positive: '#10b981', minor: '#f59e0b', moderate: '#f59e0b', major: '#ef4444'}[marker.severity] || '#f59e0b';
                            const icon = {positive: '✓', minor: '⚠', moderate: '⚠', major: '✕'}[marker.severity] || '⚠';
                            
                            html += `
                                <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem; padding: 0.5rem; background: var(--bg-alt); border-left: 3px solid ${markerColor}; border-radius: 0.25rem;">
                                    <span style="color: ${markerColor}; font-weight: bold; min-width: 50px;">[${marker.timestamp}]</span>
                                    <span><strong>${icon} ${marker.issue}:</strong> ${marker.note}</span>
                                </div>
                            `;
                        });
                        
                        html += `</div></div>`;
                    });
                    
                    html += '</div>';
                }
                
                // Display overall comments
                html += `
                    <div style="background: white; padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem;">
                        <strong>Overall Comments:</strong><br>
                        <p style="margin: 0.5rem 0 0 0;">${results.overallComments || 'No comments'}</p>
                    </div>
                    
                    <div style="display: flex; gap: 1rem;">
                        <button onclick="editSavedEvaluation('${evalId}', '${studentId}')" style="background: var(--primary); color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: pointer; font-weight: 600;">✏️ Edit Evaluation</button>
                        <button onclick="downloadSavedEvaluation('${evalId}', '${studentId}')" style="background: var(--secondary); color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: pointer; font-weight: 600;">📄 Download Report</button>
                    </div>
                    </div>
                    </div>
                    </div>
                `;
            });
            
            html += '</div>';
            document.getElementById('classDetailContent').innerHTML = html;
        }
        
        // Toggle evaluation expand/collapse
        function toggleEvaluation(evalId) {
            const content = document.getElementById(evalId);
            const arrow = document.getElementById(evalId + '-arrow');
            
            if (content.classList.contains('hidden')) {
                content.classList.remove('hidden');
                arrow.textContent = '▲';
            } else {
                content.classList.add('hidden');
                arrow.textContent = '▼';
            }
        }

        function deleteStudent(studentId) {
            if (!confirm('Are you sure you want to delete this student?')) return;
            
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const classIndex = classes.findIndex(c => c.id === currentClassId);
            
            if (classIndex !== -1) {
                classes[classIndex].roster = classes[classIndex].roster.filter(s => s.id !== studentId);
                setUserItem('classes', JSON.stringify(classes));
                viewClass(currentClassId); // Refresh the view
            }
        }

        // Edit saved evaluation
        let editingEvaluationId = null;
        let editingStudentId = null;
        
        async function editSavedEvaluation(evaluationId, studentId) {
            console.log('=== editSavedEvaluation START ===');
            console.log('Evaluation ID:', evaluationId);
            console.log('Student ID:', studentId);
            
            // Store IDs for later update
            editingEvaluationId = evaluationId;
            editingStudentId = studentId;
            
            // Load the evaluation from Supabase or localStorage
            let evaluation = null;
            
            if (supabaseClient && currentUser) {
                console.log('Loading from Supabase...');
                const { data, error } = await supabaseClient
                    .from('evaluations')
                    .select('*')
                    .eq('id', evaluationId)
                    .single();
                
                if (data) {
                    console.log('✓ Loaded from Supabase');
                    evaluation = data.evaluation_data;
                } else if (error) {
                    console.error('Supabase error:', error);
                }
            }
            
            // Fallback to localStorage if not in Supabase
            if (!evaluation) {
                console.log('Trying localStorage...');
                const classes = JSON.parse(getUserItem('classes') || '[]');
                const cls = classes.find(c => c.id === currentClassId);
                if (cls) {
                    const student = cls.roster.find(s => s.id === studentId || s.supabaseId === studentId);
                    if (student && student.evaluations) {
                        const evalRecord = student.evaluations.find(e => e.id === evaluationId || e.supabaseId === evaluationId);
                        if (evalRecord) {
                            evaluation = evalRecord.results;
                            console.log('✓ Loaded from localStorage');
                        }
                    }
                }
            }
            
            if (!evaluation) {
                console.error('Could not load evaluation!');
                alert('Could not load evaluation for editing.');
                return;
            }
            
            console.log('Evaluation loaded:', evaluation);
            
            // CRITICAL: Ensure gradeScale is present (for old evaluations that don't have it)
            if (!evaluation.gradeScale && evaluation.rubricUsed) {
                console.log('⚠️ gradeScale missing, attempting to fetch from rubric...');
                const allRubrics = await getAllRubrics();
                const matchingRubric = allRubrics.find(r => r.name === evaluation.rubricUsed);
                if (matchingRubric && matchingRubric.gradeScale) {
                    evaluation.gradeScale = matchingRubric.gradeScale;
                    console.log('✓ gradeScale restored from rubric:', matchingRubric.name);
                    
                    // Recalculate letter grade with the restored gradeScale
                    const percentage = ((evaluation.totalScore / evaluation.maxScore) * 100).toFixed(1);
                    evaluation.letterGrade = getLetterGrade(percentage, evaluation.gradeScale);
                    evaluation.percentage = percentage;
                    console.log('✓ Recalculated letterGrade:', evaluation.letterGrade);
                } else {
                    console.warn('⚠️ Could not find matching rubric to restore gradeScale');
                }
            }
            
            // Set the evaluation as current for editing
            evaluationResults = evaluation;
            correctionLog = evaluation.corrections || [];
            console.log('Set evaluationResults and correctionLog');
            
            // Hide all main sections
            console.log('Hiding main sections...');
            const mainSections = ['dashboardSection'];
            mainSections.forEach(id => {
                const element = document.getElementById(id);
                console.log(`  ${id}:`, element ? 'found' : 'NOT FOUND');
                if (element) {
                    element.classList.remove('active');
                    console.log(`  ${id}: hidden`);
                }
            });
            
            // Show evaluation section
            console.log('Showing evaluation section...');
            const evalSection = document.getElementById('evaluateSection');
            console.log('  evaluateSection:', evalSection ? 'found' : 'NOT FOUND');
            if (evalSection) {
                evalSection.classList.add('active');
                console.log('  evaluateSection: visible');
            }
            
            // Hide all steps within evaluation section
            console.log('Hiding other steps...');
            const steps = ['uploadStep', 'detailsStep', 'processingStep'];
            steps.forEach(id => {
                const element = document.getElementById(id);
                console.log(`  ${id}:`, element ? 'found' : 'NOT FOUND');
                if (element) {
                    element.classList.add('hidden');
                    console.log(`  ${id}: hidden`);
                }
            });
            
            // Show results step
            console.log('Showing results step...');
            const resultsStep = document.getElementById('resultsStep');
            console.log('  resultsStep:', resultsStep ? 'found' : 'NOT FOUND');
            console.log('  resultsStep classes before:', resultsStep ? resultsStep.className : 'N/A');
            if (resultsStep) {
                resultsStep.classList.remove('hidden');
                console.log('  resultsStep classes after:', resultsStep.className);
                console.log('  resultsStep: visible');
            }
            
            // Display the results for editing
            console.log('Calling displayResults...');
            displayResults(evaluation);
            console.log('displayResults complete');
            
            // Check if content was added
            const resultsContent = document.getElementById('resultsContent');
            console.log('resultsContent:', resultsContent ? 'found' : 'NOT FOUND');
            console.log('resultsContent innerHTML length:', resultsContent ? resultsContent.innerHTML.length : 0);
            
            // Show notification
            showNotification('📝 Editing Mode: Make changes and click "Save Results" to update.', 'info');
            
            // Scroll to top
            window.scrollTo(0, 0);
            
            console.log('=== editSavedEvaluation END ===');
        }
        
        // Download saved evaluation
        async function downloadSavedEvaluation(evaluationId, studentId) {
            let evaluation = null;
            
            if (supabaseClient && currentUser) {
                const { data, error } = await supabaseClient
                    .from('evaluations')
                    .select('*')
                    .eq('id', evaluationId)
                    .single();
                
                if (data) {
                    evaluation = data.evaluation_data;
                }
            }
            
            if (!evaluation) {
                const classes = JSON.parse(getUserItem('classes') || '[]');
                const cls = classes.find(c => c.id === currentClassId);
                if (cls) {
                    const student = cls.roster.find(s => s.id === studentId || s.supabaseId === studentId);
                    if (student && student.evaluations) {
                        const evalRecord = student.evaluations.find(e => e.id === evaluationId || e.supabaseId === evaluationId);
                        if (evalRecord) {
                            evaluation = evalRecord.results;
                        }
                    }
                }
            }
            
            if (!evaluation) {
                alert('Could not load evaluation for download.');
                return;
            }
            
            // Export as HTML
            const studentName = evaluation.studentName || 'Student';
            await exportEvaluationHTML(evaluation, studentName);
        }
        
        // Cancel editing mode
        function cancelEdit() {
            if (confirm('Cancel editing? Any unsaved changes will be lost.')) {
                editingEvaluationId = null;
                editingStudentId = null;
                correctionLog = [];
                
                // Return to class view
                viewClass(currentClassId);
            }
        }

        // ===== SETTINGS =====
        function loadSavedSettings() {
            // Evaluation server URL (Fine-tuned model); default localhost for all users
            const defaultFinetunedUrl = 'http://localhost:8000/api';
            const finetunedUrl = localStorage.getItem('finetuned_api_url');
            const savedFinetunedEl = document.getElementById('savedFinetunedUrl');
            if (savedFinetunedEl) savedFinetunedEl.value = finetunedUrl || defaultFinetunedUrl;
            // Load all three API keys (for other features if used)
            const geminiKey = localStorage.getItem('gemini_api_key');
            const openaiKey = localStorage.getItem('openai_api_key');
            const claudeKey = localStorage.getItem('anthropic_api_key');
            
            if (geminiKey) {
                document.getElementById('savedGeminiKey').value = geminiKey;
            }
            if (openaiKey) {
                document.getElementById('savedOpenAIKey').value = openaiKey;
            }
            if (claudeKey) {
                document.getElementById('savedClaudeKey').value = claudeKey;
            }
            
            // Note: Theme settings (colors, fonts, logo) are now managed by admins
            // in the Theme Customizer, not in user settings
        }

        function showApiKeyInput(provider) {
            // Hide all API key input sections
            const sections = document.querySelectorAll('.api-key-input-section');
            sections.forEach(section => section.style.display = 'none');
            
            // Show helper text
            const helperText = document.getElementById('apiKeyHelperText');
            if (helperText) helperText.style.display = provider ? 'block' : 'none';
            
            // Show selected provider's input section
            if (provider) {
                const selectedSection = document.getElementById(`apiKeyInput-${provider}`);
                if (selectedSection) selectedSection.style.display = 'block';
            }
        }
        
        function loadApiKeySettings() {
            // Load saved API keys/URLs into inputs
            const finetunedUrl = localStorage.getItem('finetuned_api_url');
            const geminiKey = localStorage.getItem('gemini_api_key');
            const openaiKey = localStorage.getItem('openai_api_key');
            const claudeKey = localStorage.getItem('anthropic_api_key');
            
            if (finetunedUrl) document.getElementById('savedFinetunedUrl').value = finetunedUrl;
            if (geminiKey) document.getElementById('savedGeminiKey').value = geminiKey;
            if (openaiKey) document.getElementById('savedOpenAIKey').value = openaiKey;
            if (claudeKey) document.getElementById('savedClaudeKey').value = claudeKey;
            
            // Auto-select provider if one is configured
            if (geminiKey) {
                document.getElementById('apiProviderSelect').value = 'gemini';
                showApiKeyInput('gemini');
            } else if (openaiKey) {
                document.getElementById('apiProviderSelect').value = 'openai';
                showApiKeyInput('openai');
            } else if (claudeKey) {
                document.getElementById('apiProviderSelect').value = 'anthropic';
                showApiKeyInput('anthropic');
            } else if (finetunedUrl) {
                document.getElementById('apiProviderSelect').value = 'finetuned';
                showApiKeyInput('finetuned');
            }
        }
        
        function saveSettings() {
            // Evaluation server URL (Fine-tuned model)
            const savedFinetunedEl = document.getElementById('savedFinetunedUrl');
            if (savedFinetunedEl) {
                const url = savedFinetunedEl.value.trim().replace(/\/$/, '');
                if (url) localStorage.setItem('finetuned_api_url', url);
                else localStorage.removeItem('finetuned_api_url');
            }
            // Save all three API keys (for other features if used)
            const geminiKey = document.getElementById('savedGeminiKey').value.trim();
            const openaiKey = document.getElementById('savedOpenAIKey').value.trim();
            const claudeKey = document.getElementById('savedClaudeKey').value.trim();
            
            if (geminiKey) {
                localStorage.setItem('gemini_api_key', geminiKey);
            }
            if (openaiKey) {
                localStorage.setItem('openai_api_key', openaiKey);
            }
            if (claudeKey) {
                localStorage.setItem('anthropic_api_key', claudeKey);
            }
            
            // Save theme settings
            const primaryColor = document.getElementById('primaryColor').value;
            const headingFont = document.getElementById('headingFont').value;
            const bodyFont = document.getElementById('bodyFont').value;
            
            localStorage.setItem('primary_color', primaryColor);
            localStorage.setItem('heading_font', headingFont);
            localStorage.setItem('body_font', bodyFont);
            
            showMessage('settingsMessage', '✅ Settings saved successfully! Your API keys are now stored securely.', 'success');
        }

        function resetSettings() {
            if (!confirm('Reset all settings to defaults? This will clear all saved API keys.')) return;
            
            // Clear all API keys
            localStorage.removeItem('gemini_api_key');
            localStorage.removeItem('openai_api_key');
            localStorage.removeItem('anthropic_api_key');
            localStorage.removeItem('finetuned_api_url');
            localStorage.removeItem('current_tenant');
            localStorage.removeItem('custom_logo');
            localStorage.removeItem('primary_color');
            localStorage.removeItem('heading_font');
            localStorage.removeItem('body_font');
            
            // Reset form fields
            const savedFinetunedEl = document.getElementById('savedFinetunedUrl');
            if (savedFinetunedEl) savedFinetunedEl.value = '';
            document.getElementById('savedGeminiKey').value = '';
            document.getElementById('savedOpenAIKey').value = '';
            document.getElementById('savedClaudeKey').value = '';
            
            currentTenant = 'default';
            applyTenant('default');
            
            showMessage('settingsMessage', '✅ Settings reset to defaults.', 'success');
        }

        // Note: handleLogoUpload is defined earlier in the theme customizer section
        // Old duplicate removed to prevent conflicts

        function updatePrimaryColor(color) {
            document.documentElement.style.setProperty('--primary', color);
            
            // Generate dark variant
            const darkColor = adjustColorBrightness(color, -20);
            document.documentElement.style.setProperty('--primary-dark', darkColor);
        }

        function adjustColorBrightness(hex, percent) {
            const num = parseInt(hex.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255))
                .toString(16).slice(1);
        }

        function updateFonts() {
            const headingFont = document.getElementById('headingFont').value;
            const bodyFont = document.getElementById('bodyFont').value;
            
            document.documentElement.style.setProperty('--heading-font', headingFont);
            document.documentElement.style.setProperty('--body-font', bodyFont);
        }

        // ===== UTILITIES =====
        function showMessage(elementId, message, type) {
            const el = document.getElementById(elementId);
            el.textContent = message;
                el.className = type === 'error' ? 'error-message' : 'success-message';
        }

        // ===== SAVE TO CLASS FUNCTIONS =====
        function openSaveModal() {
            // If editing, just update directly without modal
            if (editingEvaluationId) {
                updateExistingEvaluation();
                return;
            }
            
            // Otherwise show the save modal as normal
            try {
                var classes = JSON.parse(getUserItem('classes') || '[]');
                var sel = document.getElementById('saveClassSel');
                sel.innerHTML = '<option value="">-- Select Class --</option>';
                for (var i = 0; i < classes.length; i++) {
                    var opt = document.createElement('option');
                    opt.value = i;
                    opt.textContent = classes[i].name + ' - ' + classes[i].semester + ' ' + classes[i].year;
                    sel.appendChild(opt);
                }
                document.getElementById('saveModal').style.display = 'flex';
            } catch(e) {
                console.error(e);
            }
        }

        function loadSaveStudents() {
            try {
                var idx = document.getElementById('saveClassSel').value;
                var sel = document.getElementById('saveStudentSel');
                sel.innerHTML = '<option value="">-- Select Student --</option>';
                if (!idx) return;
                var classes = JSON.parse(getUserItem('classes') || '[]');
                var cls = classes[idx];
                if (cls && cls.roster) {
                    for (var i = 0; i < cls.roster.length; i++) {
                        var s = cls.roster[i];
                        var opt = document.createElement('option');
                        opt.value = i;
                        opt.textContent = s.firstName + ' ' + s.lastName;
                        sel.appendChild(opt);
                    }
                }
            } catch(e) {
                console.error(e);
            }
        }

        async function doSaveEval() {
            try {
                // Check account tier for save permission
                if (!hasResearchAccess()) {
                    const upgrade = confirm(
                        '🎭 Demo Mode Limitation\n\n' +
                        'Evaluations cannot be saved in Demo mode.\n\n' +
                        'To save evaluations and contribute to research:\n' +
                        '• Upgrade to Research Partner\n' +
                        '• Full evaluation storage\n' +
                        '• Correction tracking\n' +
                        '• Help improve AI\n\n' +
                        'Contact speechgradebook@proton.me to upgrade.\n\n' +
                        'Click OK to copy email address.'
                    );
                    
                    if (upgrade) {
                        // Copy email to clipboard
                        navigator.clipboard.writeText('speechgradebook@proton.me').then(() => {
                            alert('Email address copied to clipboard!');
                        });
                    }
                    return;
                }
                
                // Check if we're editing an existing evaluation
                const isEditing = editingEvaluationId !== null;
                
                if (isEditing) {
                    // UPDATE existing evaluation
                    await updateExistingEvaluation();
                } else {
                    // INSERT new evaluation (original behavior)
                    var savedLocallyOnly = false;
                    var cIdx = document.getElementById('saveClassSel').value;
                    var sIdx = document.getElementById('saveStudentSel').value;
                    if (!cIdx || sIdx === '') {
                        alert('Please select both class and student');
                        return;
                    }
                    if (!evaluationResults) {
                        alert('No evaluation to save');
                        return;
                    }
                    
                    // Get class and student info
                    var classes = JSON.parse(getUserItem('classes') || '[]');
                    var classData = classes[cIdx];
                    var student = classData.roster[sIdx];
                    
                    if (!student.evaluations) {
                        student.evaluations = [];
                    }
                    
                    // Create evaluation record
                    var rec = {
                        id: Date.now().toString(),
                        date: document.getElementById('speechDate').value,
                        type: document.getElementById('assignmentType').value,
                        results: evaluationResults,
                        corrections: correctionLog,  // Include instructor corrections
                        editedAt: correctionLog.length > 0 ? new Date().toISOString() : null,
                        savedAt: new Date().toISOString()
                    };
                    
                    // Save to localStorage first (immediate)
                    student.evaluations.push(rec);
                    classes[cIdx].roster[sIdx] = student;
                    setUserItem('classes', JSON.stringify(classes));
                    console.log('✓ Evaluation saved to localStorage');
                    
                    // Also save to Supabase if available
                    if (supabaseClient && currentUser) {
                        const rubricId = document.getElementById('rubricSelect').value;
                        
                        // Get Supabase IDs if they exist
                        const courseSupabaseId = classData.supabaseId || classData.id;
                        const studentSupabaseId = student.supabaseId || student.id;
                        
                        // Get rubric's Supabase ID
                        const rubrics = await getAllRubrics();
                        const selectedRubric = rubrics.find(r => r.id === rubricId);
                        const rubricSupabaseId = selectedRubric?.supabaseId || null;
                        
                        console.log('Attempting Supabase save with IDs:', {
                            course: courseSupabaseId,
                            student: studentSupabaseId,
                            rubric: rubricSupabaseId,
                            user: currentUser.id
                        });
                        
                        // Only save if all IDs are valid UUIDs
                        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
                        const validIds = uuidRegex.test(courseSupabaseId) && 
                                       uuidRegex.test(studentSupabaseId) && 
                                       (!rubricSupabaseId || uuidRegex.test(rubricSupabaseId));
                        
                        if (validIds) {
                            try {
                                // Phase 3: consent check before saving to cloud (no consent = local only)
                                const consent = await getStudentConsentForStorage(courseSupabaseId, studentSupabaseId);
                                if (consent) {
                                    const result = await saveEvaluationToSupabase(
                                        evaluationResults,
                                        courseSupabaseId,
                                        studentSupabaseId,
                                        rubricSupabaseId
                                    );
                                    if (result) {
                                        console.log('✓ Evaluation saved to Supabase with ID:', result.id);
                                    } else {
                                        console.warn('⚠️ Supabase save returned null - check console for errors');
                                    }
                                } else {
                                    savedLocallyOnly = true;
                                    console.log('✓ Evaluation not sent to cloud (student has not consented); stored in localStorage only.');
                                }
                            } catch (error) {
                                console.error('Error saving evaluation:', error);
                            }
                        } else {
                            console.warn('⚠️ Invalid UUIDs for Supabase save:', {
                                course: courseSupabaseId,
                                student: studentSupabaseId,
                                rubric: rubricSupabaseId
                            });
                            log.debug('Note: Course, student, and rubric must be created in Supabase before evaluations can be saved to database');
                        }
                    } else {
                        log.debug('Supabase not available or user not logged in');
                    }
                    
                    if (savedLocallyOnly) {
                        alert('✓ Evaluation saved for ' + student.firstName + ' ' + student.lastName + ' (stored locally — student has not consented to cloud/research use).');
                    } else {
                        alert('✓ Evaluation saved for ' + student.firstName + ' ' + student.lastName);
                    }
                    closeSaveModal();
                }
            } catch(e) {
                console.error('Error saving evaluation:', e);
                alert('Error: ' + e.message);
            }
        }
        
        // Update existing evaluation
        async function updateExistingEvaluation() {
            if (!evaluationResults || !editingEvaluationId) {
                alert('No evaluation to update');
                return;
            }
            
            // Update in Supabase
            if (supabaseClient && currentUser) {
                try {
                    const { data, error } = await supabaseClient
                        .from('evaluations')
                        .update({
                            evaluation_data: {
                                sections: evaluationResults.sections,
                                studentName: evaluationResults.studentName,
                                speechDate: evaluationResults.speechDate,
                                assignmentType: evaluationResults.assignmentType,
                                speechTime: evaluationResults.speechTime,
                                rubricUsed: evaluationResults.rubricUsed,
                                totalScore: evaluationResults.totalScore,
                                maxScore: evaluationResults.maxScore,
                                percentage: evaluationResults.percentage,
                                letterGrade: evaluationResults.letterGrade,
                                gradeScale: evaluationResults.gradeScale,
                                overallComments: evaluationResults.overallComments,
                                timeline_markers: evaluationResults.timeline_markers || [],
                                video_notes: evaluationResults.video_notes || null,
                                corrections: correctionLog || [],
                                edited: true,
                                editedAt: new Date().toISOString()
                            },
                            total_score: evaluationResults.totalScore || 0,
                            letter_grade: evaluationResults.letterGrade || 'N/A',
                            updated_at: new Date().toISOString()
                        })
                        .eq('id', editingEvaluationId);
                    
                    if (error) {
                        console.error('Error updating evaluation:', error);
                        alert('Error updating evaluation in database: ' + error.message);
                        return;
                    }
                    
                    // Log update for FERPA compliance
                    await logAccess('update', 'evaluations', editingEvaluationId, editingStudentId, {
                        action_detail: 'evaluation_data and scores updated'
                    });
                    
                    console.log('✓ Evaluation updated in Supabase');
                } catch (error) {
                    console.error('Supabase error:', error);
                    alert('Error updating evaluation: ' + error.message);
                    return;
                }
            }
            
            // Also update localStorage
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const cls = classes.find(c => c.id === currentClassId);
            if (cls) {
                const student = cls.roster.find(s => s.id === editingStudentId || s.supabaseId === editingStudentId);
                if (student && student.evaluations) {
                    const evalIndex = student.evaluations.findIndex(e => 
                        e.id === editingEvaluationId || e.supabaseId === editingEvaluationId
                    );
                    if (evalIndex !== -1) {
                        student.evaluations[evalIndex].results = evaluationResults;
                        student.evaluations[evalIndex].corrections = correctionLog;
                        student.evaluations[evalIndex].editedAt = new Date().toISOString();
                        setUserItem('classes', JSON.stringify(classes));
                        console.log('✓ Evaluation updated in localStorage');
                    }
                }
            }
            
            alert('✓ Evaluation updated successfully!');
            
            // Clear editing state
            editingEvaluationId = null;
            editingStudentId = null;
            
            // Return to class view
            viewClass(currentClassId);
        }

        function closeSaveModal() {
            document.getElementById('saveModal').style.display = 'none';
        }
    </script>
    </div> <!-- End mainApp -->
</body>
</html>
