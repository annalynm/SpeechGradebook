<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpeechGradebook</title>
    <link rel="icon" id="faviconLink" href="assets/3d-logo-transparent.png" type="image/png">
    
    <!-- Fonts (Bunny Fonts - privacy-friendly, less blocked than Google Fonts) -->
    <link href="https://fonts.bunny.net/css?family=Montserrat:400,500,600,700|Source+Sans+3:400,600,700|Roboto:400,500,700|Open+Sans:400,600,700|Crimson+Pro:400,600,700|Work+Sans:400,600,700&display=swap" rel="stylesheet">
    
    <!-- Supabase JS Library -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- Config: served dynamically by Python app when env vars set; fallback to static config.js -->
    <script src="config.js"></script>
    <!-- Lucide Icons (replaces emojis in UI) -->
    <script src="https://unpkg.com/lucide@0.460.0/dist/umd/lucide.js"></script>
    
    <style>
        /* SpeechGradebook theme (default) - dark blue. Custom themes (e.g. University of Tennessee) override via JS from institution_themes. */
        :root {
            /* SpeechGradebook Light Theme (Option 7) */
            --primary: #1e3a5f;
            --primary-dark: #142940;
            --primary-light: #2d4a6f;
            --secondary: #5a6c7d;
            --accent: #4a6fa5;
            
            /* Apple HIG: Text colors with WCAG AA contrast (4.5:1 on white) - Option 7 */
            --text: #1a1a1a;              /* High contrast for body text (WCAG AAA: 16.6:1) */
            --text-secondary: #4a4a4a;     /* Secondary text (WCAG AA: 7.1:1) */
            --text-light: #6b6b6b;        /* Light text (WCAG AA: 4.6:1) - minimum for body */
            --text-disabled: #9a9a9a;     /* Disabled text (WCAG AA: 2.8:1 - only for disabled states) */
            
            /* Apple HIG: Background colors - Option 7 */
            --bg: #fafbfc;                 /* Subtle off-white for reduced eye strain */
            --bg-alt: #f1f4f7;             /* Secondary background for cards/panels */
            --bg-hover: #e8ecf0;           /* Hover state background */
            --card: #ffffff;               /* Card background - white for clarity */
            --border: #d1d5db;             /* Border color with good contrast */
            --border-light: #e5e7eb;       /* Lighter borders for subtle separation */
            
            /* Apple HIG: Semantic colors with proper contrast */
            --success: #059669;           /* Green - WCAG AA on white (3.2:1) - use with white text or darker shade */
            --success-bg: #d1fae5;       /* Light green background */
            --success-text: #065f46;     /* Dark green text (WCAG AA: 7.1:1) */
            --success-border: #10b981;    /* Success border */
            
            --warning: #d97706;           /* Orange - WCAG AA on white (3.0:1) */
            --warning-bg: #fef3c7;        /* Light orange background */
            --warning-text: #92400e;      /* Dark orange text (WCAG AA: 7.4:1) */
            --warning-border: #f59e0b;    /* Warning border */
            
            --error: #b91c1c;             /* Red - WCAG AA on white (4.5:1) */
            --error-bg: #fee2e2;          /* Light red background */
            --error-text: #991b1b;        /* Dark red text (WCAG AA: 7.0:1) */
            --error-border: #dc2626;      /* Error border */
            
            --info: #0284c7;               /* Blue - WCAG AA on white (3.2:1) */
            --info-bg: #dbeafe;           /* Light blue background */
            --info-text: #0c4a6e;         /* Dark blue text (WCAG AA: 7.8:1) */
            --info-border: #3b82f6;       /* Info border */
            
            /* Apple HIG: Interactive states with proper contrast */
            --link: #2563eb;              /* Link color (WCAG AA: 4.6:1 on white) */
            --link-hover: #1d4ed8;        /* Link hover (WCAG AA: 5.8:1) */
            --link-visited: #7c3aed;       /* Visited link (WCAG AA: 4.7:1) */
            
            /* Apple HIG: Focus indicators */
            --focus-ring: #2563eb;        /* Focus ring color */
            --focus-ring-offset: 2px;     /* Focus ring offset */
            --heading-font: 'Roboto', sans-serif;
            --body-font: 'Roboto', sans-serif;
            --heading-weight: 700;
            --body-weight: 400;
            /* Typography hierarchy */
            --text-title-size: 1.5rem;
            --text-title-weight: 700;
            --text-headline-size: 1.25rem;
            --text-headline-weight: 600;
            --text-body-size: 1rem;
            --text-caption-size: 0.875rem;
            
            /* Apple HIG: Spacing System (8px base unit) */
            --space-xs: 0.25rem;   /* 4px */
            --space-sm: 0.5rem;     /* 8px */
            --space-md: 1rem;       /* 16px */
            --space-lg: 1.5rem;     /* 24px */
            --space-xl: 2rem;       /* 32px */
            --space-2xl: 3rem;      /* 48px */
            --space-3xl: 4rem;      /* 64px */
            
            /* Apple HIG: Elevation System (for depth) */
            --elevation-0: none;
            --elevation-1: 0 1px 3px rgba(0, 0, 0, 0.08), 0 1px 2px rgba(0, 0, 0, 0.06);
            --elevation-2: 0 3px 6px rgba(0, 0, 0, 0.1), 0 2px 4px rgba(0, 0, 0, 0.06);
            --elevation-3: 0 10px 20px rgba(0, 0, 0, 0.1), 0 3px 6px rgba(0, 0, 0, 0.08);
            --elevation-4: 0 15px 30px rgba(0, 0, 0, 0.12), 0 5px 10px rgba(0, 0, 0, 0.08);
            
            /* Apple HIG: Motion (respects prefers-reduced-motion) */
            --motion-fast: 0.15s;
            --motion-normal: 0.25s;
            --motion-slow: 0.35s;
            --motion-ease: cubic-bezier(0.4, 0.0, 0.2, 1);
            --motion-ease-in: cubic-bezier(0.4, 0.0, 1, 1);
            --motion-ease-out: cubic-bezier(0.0, 0.0, 0.2, 1);
            
            /* Apple HIG: Border Radius */
            --radius-sm: 0.375rem;  /* 6px */
            --radius-md: 0.5rem;     /* 8px */
            --radius-lg: 0.75rem;    /* 12px */
            --radius-xl: 1rem;       /* 16px */
            --radius-full: 9999px;
        }
        
        /* Dark Mode Variables - Refined for accessibility and aesthetics */
        :root[data-theme="dark"] {
            /* Primary colors - lighter for better visibility on dark backgrounds */
            --primary: #5a8fc7;              /* Lighter blue for better contrast */
            --primary-dark: #4a7fb7;        /* Slightly darker primary */
            --primary-light: #6a9fd7;       /* Light primary variant */
            --secondary: #9bb0d4;           /* Lighter secondary */
            --accent: #e5c158;              /* Brighter accent for visibility */
            
            /* Dark mode text colors - optimized for WCAG AA/AAA contrast on dark backgrounds */
            --text: #ffffff;                 /* Pure white for maximum contrast (WCAG AAA: 21:1 on #1d1d1f) */
            --text-secondary: #e5e5e7;      /* Light gray for secondary text (WCAG AA: 12.6:1) */
            --text-light: #b8b8ba;         /* Medium gray for light text (WCAG AA: 7.1:1) */
            --text-disabled: #8e8e93;        /* Disabled text (WCAG AA: 4.5:1) */
            
            /* Dark mode background colors - refined Apple-style dark mode */
            --bg: #1d1d1f;                  /* Slightly lighter than pure black for reduced eye strain */
            --bg-alt: #2d2d30;              /* Secondary background (cards, panels) */
            --bg-hover: #3a3a3d;            /* Hover state background */
            --card: #2d2d30;                /* Card background - distinct from main bg */
            --border: #48484a;              /* Visible borders with good contrast */
            --border-light: #3a3a3d;        /* Lighter borders for subtle separation */
            
            /* Dark mode semantic colors - optimized for dark backgrounds */
            --success: #34c759;             /* Apple System Green - brighter for visibility */
            --success-bg: rgba(52, 199, 89, 0.15);  /* Subtle green background */
            --success-text: #34c759;         /* Green text */
            --success-border: #34c759;      /* Green border */
            
            --warning: #ff9500;              /* Apple System Orange - brighter */
            --warning-bg: rgba(255, 149, 0, 0.15);  /* Subtle orange background */
            --warning-text: #ff9500;        /* Orange text */
            --warning-border: #ff9500;      /* Orange border */
            
            --error: #ff3b30;               /* Apple System Red - brighter */
            --error-bg: rgba(255, 59, 48, 0.15);    /* Subtle red background */
            --error-text: #ff3b30;          /* Red text */
            --error-border: #ff3b30;        /* Red border */
            
            --info: #007aff;                 /* Apple System Blue - brighter */
            --info-bg: rgba(0, 122, 255, 0.15);   /* Subtle blue background */
            --info-text: #007aff;           /* Blue text */
            --info-border: #007aff;         /* Blue border */
            
            /* Dark mode interactive states - optimized for visibility */
            --link: #64b5f6;                /* Light blue for links */
            --link-hover: #90caf9;          /* Lighter blue on hover */
            --link-visited: #ba68c8;        /* Purple for visited links */
            
            /* Dark mode focus indicators */
            --focus-ring: #007aff;           /* Blue focus ring */
            
            /* Dark mode elevation adjustments - lighter shadows for dark backgrounds */
            --elevation-1: 0 1px 3px rgba(0, 0, 0, 0.3), 0 1px 2px rgba(0, 0, 0, 0.2);
            --elevation-2: 0 3px 6px rgba(0, 0, 0, 0.4), 0 2px 4px rgba(0, 0, 0, 0.3);
            --elevation-3: 0 10px 20px rgba(0, 0, 0, 0.5), 0 3px 6px rgba(0, 0, 0, 0.4);
            --elevation-4: 0 15px 30px rgba(0, 0, 0, 0.6), 0 5px 10px rgba(0, 0, 0, 0.5);
        }
        
        /* Dark mode specific overrides for better contrast and aesthetics */
        :root[data-theme="dark"] input[type="text"],
        :root[data-theme="dark"] input[type="email"],
        :root[data-theme="dark"] input[type="password"],
        :root[data-theme="dark"] input[type="number"],
        :root[data-theme="dark"] input[type="url"],
        :root[data-theme="dark"] textarea,
        :root[data-theme="dark"] select {
            background: var(--card);
            color: var(--text);
            border-color: var(--border);
        }
        
        :root[data-theme="dark"] input[type="text"]:focus,
        :root[data-theme="dark"] input[type="email"]:focus,
        :root[data-theme="dark"] input[type="password"]:focus,
        :root[data-theme="dark"] input[type="number"]:focus,
        :root[data-theme="dark"] input[type="url"]:focus,
        :root[data-theme="dark"] textarea:focus,
        :root[data-theme="dark"] select:focus {
            border-color: var(--primary);
            background: var(--card);
        }
        
        /* Dark mode tab hover states */
        :root[data-theme="dark"] .analytics-tab:hover,
        :root[data-theme="dark"] .settings-tab:hover,
        :root[data-theme="dark"] .support-tab:hover,
        :root[data-theme="dark"] .instructor-dashboard-tab:hover {
            background: rgba(255, 255, 255, 0.08);
        }
        
        :root[data-theme="dark"] .analytics-tab-active,
        :root[data-theme="dark"] .settings-tab-active,
        :root[data-theme="dark"] .support-tab-active,
        :root[data-theme="dark"] .instructor-dashboard-tab-active {
            background: rgba(90, 143, 199, 0.15); /* Primary color with transparency */
        }
        
        /* Dark mode card hover */
        :root[data-theme="dark"] .card:hover {
            border-color: rgba(90, 143, 199, 0.3); /* Primary color border */
        }
        
        /* Dark mode dropdown hover */
        :root[data-theme="dark"] .dropdown-item:hover {
            background: var(--bg-hover);
        }
        
        /* Dark mode code blocks */
        :root[data-theme="dark"] code {
            background: var(--bg-alt);
            color: var(--text);
            border: 1px solid var(--border);
        }
        
        /* Dark mode header adjustments */
        :root[data-theme="dark"] header {
            border-bottom: 1px solid var(--border);
        }
        
        /* Option 7 Dark Theme specific overrides - fixes glare and contrast issues */
        .theme-option7-dark .data-table tbody tr {
            background: var(--card) !important;
            color: var(--text) !important;
        }
        
        .theme-option7-dark .data-table tbody tr:hover {
            background: var(--bg-hover) !important;
        }
        
        .theme-option7-dark .data-table td {
            color: var(--text) !important;
            background: transparent !important;
        }
        
        /* Fix any white backgrounds that cause glare */
        .theme-option7-dark .card,
        .theme-option7-dark .class-card,
        .theme-option7-dark .kpi-card,
        .theme-option7-dark .chart-card {
            background: var(--card) !important;
            color: var(--text) !important;
        }
        
        /* Fix search inputs and form elements */
        .theme-option7-dark input[type="text"],
        .theme-option7-dark input[type="email"],
        .theme-option7-dark input[type="password"],
        .theme-option7-dark input[type="search"],
        .theme-option7-dark textarea,
        .theme-option7-dark select {
            background: var(--card) !important;
            color: var(--text) !important;
            border-color: var(--border) !important;
        }
        
        /* Fix filter controls and panels */
        .theme-option7-dark .filter-controls {
            background: var(--bg-alt) !important;
        }
        
        /* Fix chart table headers */
        .theme-option7-dark .chart-card .data-table th {
            background: var(--bg-alt) !important;
            color: var(--text) !important;
        }
        
        /* Ensure table headers maintain contrast */
        .theme-option7-dark .data-table thead {
            background: var(--primary) !important;
            color: white !important;
        }
        
        /* Fix any elements with hardcoded white backgrounds */
        .theme-option7-dark [style*="background: white"],
        .theme-option7-dark [style*="background: #fff"],
        .theme-option7-dark [style*="background: #ffffff"] {
            background: var(--card) !important;
        }
        
        /* Ensure readable text in all contexts */
        .theme-option7-dark .text-light,
        .theme-option7-dark .text-secondary {
            color: var(--text-light) !important;
        }
        
        /* Apple HIG: Respect prefers-reduced-motion */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* Targeted approach: Only force normal weight on text content elements */
        /* This prevents custom fonts from appearing bold while preserving button styles */
        p, span, a:not(.button):not(.btn):not(.nav-link),
        li, td, label:not([for]), 
        .class-card, .student-card, .eval-card,
        .class-meta, .class-stats, .stat-label,
        textarea, input[type="text"], input[type="email"], input[type="password"], select {
            font-weight: 400 !important;
            font-style: normal !important;
        }
        
        /* Explicitly allow bold for semantic elements */
        h1, h2, h3, h4, h5, h6,
        strong, b, .font-bold,
        th {
            font-weight: 700 !important;
        }
        
        /* Explicitly allow italic for semantic elements */
        em, i, .font-italic {
            font-style: italic !important;
        }
        
        /* Preserve button and UI element weights (semi-bold for clarity) */
        button, .btn, .button,
        input[type="button"], input[type="submit"],
        .nav-link,
        .card-header,
        .step-label.active {
            font-weight: 600 !important;
        }
        
        body {
            font-family: var(--body-font);
            font-weight: 400; /* Always normal weight */
            font-style: normal; /* Always normal style */
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
        }
        
        h1, h2, h3, h4, h5, h6 {
            font-family: var(--heading-font);
            font-weight: 700; /* Always bold for headings */
            font-style: normal; /* Always normal style */
            color: var(--primary);
        }
        
        /* Typography hierarchy (Apple HIG–aligned) — single source of truth */
        .text-title { font-size: var(--text-title-size); font-weight: var(--text-title-weight); line-height: 1.3; color: var(--text); }
        .text-headline { font-size: var(--text-headline-size); font-weight: var(--text-headline-weight); line-height: 1.35; color: var(--text); }
        .text-body { font-size: var(--text-body-size); font-weight: 400; line-height: 1.6; color: var(--text); }
        .text-body-secondary { font-size: 0.9375rem; font-weight: 400; color: var(--text-secondary); line-height: 1.5; }
        .text-caption { font-size: var(--text-caption-size); font-weight: 400; color: var(--text-light); line-height: 1.4; }
        /* Apply hierarchy to components */
        .card-header, .dashboard-shell-title, .modal-box h3, .class-header {
            font-size: var(--text-headline-size); font-weight: var(--text-headline-weight); line-height: 1.35; font-family: var(--heading-font);
        }
        .card-header { 
            color: var(--primary); 
            margin-bottom: var(--space-lg); 
            border-bottom: 2px solid var(--border); 
            padding-bottom: var(--space-md); 
        }
        .modal-box h3 { margin: 0 0 0.75rem 0; color: var(--primary); }
        .class-header { color: var(--primary); margin-bottom: var(--space-sm); }
        .dashboard-shell-title { margin-bottom: 0.25rem; color: var(--text); }
        .dashboard-shell-subtitle, .modal-box p, .empty-state .empty-state-desc, .kpi-card .kpi-title, .chart-card .chart-subtitle, .chart-card .chart-description {
            font-size: var(--text-caption-size); font-weight: 400; color: var(--text-light); line-height: 1.4;
        }
        .dashboard-shell-subtitle { margin-bottom: var(--space-lg); }
        .modal-box p { margin: 0 0 var(--space-md) 0; color: var(--text-light); line-height: 1.5; }
        .empty-state .empty-state-title { font-size: var(--text-headline-size); font-weight: var(--text-headline-weight); margin-bottom: 0.35rem; color: var(--text); line-height: 1.35; }
        .stat-value { font-size: var(--text-title-size); font-weight: var(--text-title-weight); color: var(--primary); }
        .stat-label, .kpi-card .kpi-subtext, .kpi-card .kpi-footer, .chart-card .chart-footer { font-size: var(--text-caption-size); font-weight: 400; color: var(--text-light); line-height: 1.4; }
        .class-meta { font-size: var(--text-caption-size); font-weight: 400; color: var(--text-light); line-height: 1.5; margin-bottom: var(--space-md); }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 var(--space-md);
        }
        
        /* Remove all spacing between header and class detail section */
        header {
            margin-bottom: 0 !important;
        }
        
        main#main-content {
            margin-top: 0 !important;
            padding-top: 0 !important;
        }
        
        header + main#main-content {
            margin-top: 0 !important;
            padding-top: 0 !important;
        }
        
        #classDetailSection {
            margin-top: 0 !important;
            padding-top: 0 !important;
        }
        
        #mainApp > #classDetailSection {
            margin-top: 0 !important;
            padding-top: 0 !important;
        }
        
        #mainApp > main#main-content > #classDetailSection {
            margin-top: 0 !important;
            padding-top: 0 !important;
        }
        
        /* Header - Apple HIG: Clear hierarchy, proper elevation */
        header {
            font-family: var(--body-font);
            background: var(--primary-dark);
            color: white;
            padding: var(--space-lg) 0;
            box-shadow: var(--elevation-2);
            margin-bottom: 0 !important;
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--space-lg);
            flex-wrap: wrap;
        }
        
        /* Left section: Logo + Navigation */
        .header-left {
            display: flex;
            align-items: center;
            gap: var(--space-lg);
            flex: 1;
            min-width: 0;
        }
        
        /* Navigation on left side */
        .primary-nav {
            display: flex;
            align-items: center;
            gap: var(--space-md);
        }
        
        /* Right section: Search and Account menu */
        .header-right {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            flex-shrink: 0;
        }
        
        .logo-section {
            display: flex;
            align-items: center;
            gap: var(--space-md);
            flex-shrink: 0;
            min-width: 0; /* Allow text truncation */
        }
        
        .logo {
            width: 70px;
            height: 70px;
            background: #ffffff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.8rem;
            color: var(--primary);
            flex-shrink: 0; /* Prevent compression */
        }
        
        .logo img {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Scale to fit without cropping */
            object-position: center;
            border-radius: 50%;
            padding: 12%; /* Add padding so logo doesn't touch edges */
        }
        
        /* Transparent logo styling for light mode - display as-is on white/light backgrounds */
        .logo img[src*="3d-logo-transparent"],
        .logo img[src*="3d-logo-transparent.png"],
        #appLogo img[src*="3d-logo-transparent"],
        #appLogo img[src*="3d-logo-transparent.png"],
        .auth-logo img[src*="3d-logo-transparent"],
        .auth-logo img[src*="3d-logo-transparent.png"] {
            filter: none; /* Logo has dark blue ribbon and white waves - visible on light backgrounds */
        }
        
        /* Transparent logo styling for dark mode - keep original colors (no inversion) */
        :root[data-theme="dark"] .logo img[src*="3d-logo-transparent"],
        :root[data-theme="dark"] .logo img[src*="3d-logo-transparent.png"],
        :root[data-theme="dark"] #appLogo img[src*="3d-logo-transparent"],
        :root[data-theme="dark"] #appLogo img[src*="3d-logo-transparent.png"],
        :root[data-theme="dark"] .auth-logo img[src*="3d-logo-transparent"],
        :root[data-theme="dark"] .auth-logo img[src*="3d-logo-transparent.png"],
        .theme-option7-dark .logo img[src*="3d-logo-transparent"],
        .theme-option7-dark .logo img[src*="3d-logo-transparent.png"],
        .theme-option7-dark #appLogo img[src*="3d-logo-transparent"],
        .theme-option7-dark #appLogo img[src*="3d-logo-transparent.png"],
        .theme-option7-dark .auth-logo img[src*="3d-logo-transparent"],
        .theme-option7-dark .auth-logo img[src*="3d-logo-transparent.png"] {
            filter: none; /* Keep original logo colors in dark mode */
        }
        
        /* Header logo circle: always pure white on account pages (no yellow/theme tint) */
        header .logo,
        header #appLogo {
            position: relative;
            background: #ffffff !important;
            background-color: #ffffff !important;
        }
        
        /* Dark mode header logo - keep white background */
        :root[data-theme="dark"] header .logo,
        :root[data-theme="dark"] header #appLogo,
        .theme-option7-dark header .logo,
        .theme-option7-dark header #appLogo {
            background: #ffffff !important;
            background-color: #ffffff !important;
        }
        
        header #appLogo img {
            position: relative;
            z-index: 0;
        }
        
        .app-title h1 {
            font-family: var(--heading-font);
            font-weight: 700;
            color: white;
            font-size: 1.8rem;
            margin-bottom: var(--space-xs);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .app-title {
            min-width: 0; /* Allow text truncation */
            flex: 0 1 auto;
        }
        
        .tagline {
            font-size: 0.9rem;
            opacity: 0.9;
        }
        
        /* Navigation - Apple HIG: Clean, spacious design with better hierarchy */
        /* Primary Navigation: Core workflows */
        nav.primary-nav {
            font-family: var(--body-font);
            display: flex;
            gap: var(--space-md);
            align-items: center;
            flex-wrap: wrap;
            flex-shrink: 0;
        }
        
        /* Utility Navigation: Search and Account */
        .utility-nav {
            display: flex;
            align-items: center;
            gap: var(--space-md);
            flex-shrink: 0;
        }
        
        .nav-link {
            color: white;
            text-decoration: none;
            padding: var(--space-sm) var(--space-lg);
            border-radius: var(--radius-md);
            transition: all var(--motion-normal) var(--motion-ease);
            min-height: 2.75rem;
            display: inline-flex;
            align-items: center;
            box-sizing: border-box;
            font-size: 0.9375rem;
            font-weight: 500;
            white-space: nowrap;
            position: relative;
            flex-shrink: 0;
        }
        
        /* Account Dropdown */
        .account-dropdown-wrapper {
            position: relative;
        }
        
        .account-dropdown-trigger {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 2.75rem;
            height: 2.75rem;
            background: transparent;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: var(--radius-md);
            transition: all var(--motion-normal) var(--motion-ease);
            flex-shrink: 0;
        }
        
        .account-dropdown-trigger:hover {
            background: rgba(255,255,255,0.12);
        }
        
        .account-dropdown-trigger:focus-visible {
            outline: 2px solid white;
            outline-offset: 2px;
        }
        
        .account-dropdown-trigger[aria-expanded="true"] {
            background: rgba(255,255,255,0.18);
        }
        
        .account-icon {
            width: 1.25rem;
            height: 1.25rem;
        }
        
        .user-display-name {
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .account-dropdown-menu {
            position: absolute;
            top: calc(100% + var(--space-xs));
            right: 0;
            min-width: 220px;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            box-shadow: var(--elevation-3);
            z-index: 1000;
            padding: var(--space-xs) 0;
            margin-top: var(--space-xs);
        }
        
        .account-dropdown-menu.hidden {
            display: none;
        }
        
        .dropdown-header {
            padding: var(--space-sm) var(--space-md);
            border-bottom: 1px solid var(--border);
            margin-bottom: var(--space-xs);
        }
        
        .dropdown-user-name {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text);
            display: block;
        }
        
        .dropdown-item {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            padding: var(--space-sm) var(--space-md);
            color: var(--text);
            text-decoration: none;
            font-size: 0.9375rem;
            transition: background var(--motion-fast) var(--motion-ease);
            cursor: pointer;
        }
        
        .dropdown-item:hover {
            background: var(--bg-alt);
        }
        
        .dropdown-item i {
            width: 1rem;
            height: 1rem;
            color: var(--text-light);
        }
        
        /* Logout item - ensure dark text for visibility */
        .dropdown-item-logout {
            color: var(--text) !important;
            font-weight: 500;
        }
        
        .dropdown-item-logout i {
            color: var(--text) !important;
        }
        
        .dropdown-divider {
            height: 1px;
            background: var(--border);
            margin: var(--space-xs) 0;
        }
        
        /* Evaluation actions dropdown */
        .eval-actions-dropdown {
            position: relative;
        }
        
        .eval-actions-menu button:hover {
            background: var(--bg-alt) !important;
        }
        
        .eval-actions-menu button:focus {
            outline: 2px solid var(--focus-ring);
            outline-offset: -2px;
        }
        
        #userDisplay {
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .nav-link:focus-visible {
            outline: 2px solid white;
            outline-offset: 2px;
        }
        
        .nav-link:hover {
            background: rgba(255,255,255,0.12);
            transform: translateY(-1px);
        }
        
        .nav-link.active {
            background: rgba(255,255,255,0.18);
            font-weight: 600;
        }
        
        .nav-link.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 2px;
            background: white;
            border-radius: var(--radius-full);
        }
        
        /* Reduce icon size in nav for cleaner look */
        .nav-link .icon-with-text i {
            width: 1rem;
            height: 1rem;
        }
        
        .nav-link .icon-with-text {
            gap: var(--space-sm);
        }
        
        /* Main Content - Apple HIG: Generous spacing */
        main {
            font-family: var(--body-font);
            padding: var(--space-xl) 0;
            min-height: calc(100vh - 200px);
        }
        
        /* Remove top padding from main when class detail section is active */
        main#main-content:has(#classDetailSection.active) {
            padding-top: 0 !important;
            margin-top: 0 !important;
            min-height: 0 !important;
            height: auto !important;
        }
        
        /* Also target directly - more specific */
        #classDetailSection.active {
            margin-top: 0 !important;
            padding-top: 0 !important;
            position: relative !important;
            top: 0 !important;
        }
        
        /* Remove top padding from main container when showing class detail */
        body:has(#classDetailSection.active) main#main-content,
        #mainApp:has(#classDetailSection.active) main#main-content {
            padding-top: 0 !important;
            margin-top: 0 !important;
            min-height: 0 !important;
            height: auto !important;
        }
        
        /* Force remove main padding when class detail is shown - highest specificity */
        #mainApp main#main-content:has(#classDetailSection.active),
        #mainApp:has(#classDetailSection.active) main#main-content {
            padding-top: 0 !important;
            margin-top: 0 !important;
            min-height: 0 !important;
            height: auto !important;
        }
        
        /* Hide all other sections when classDetailSection is active */
        main#main-content:has(#classDetailSection.active) > .section:not(#classDetailSection) {
            display: none !important;
            height: 0 !important;
            margin: 0 !important;
            padding: 0 !important;
        }
        
        .section {
            display: none;
            margin-top: 0;
            padding-top: 0;
        }
        
        .section.active {
            display: block;
            margin-top: 0;
            padding-top: 0;
        }
        
        #classDetailSection {
            margin-top: 0 !important;
            padding-top: 0 !important;
        }
        
        /* Remove all top spacing from card in class detail section */
        #classDetailSection .card {
            margin-top: 0 !important;
            padding-top: 0 !important;
        }
        
        /* Minimize top padding on card-header in class detail section */
        #classDetailSection .card-header {
            padding-top: 0.5rem !important;
            margin-top: 0 !important;
        }
        
        /* Cards - Apple HIG: Proper spacing and elevation with enhanced visual interest */
        .card {
            background: var(--card);
            border-radius: var(--radius-lg);
            padding: var(--space-xl);
            box-shadow: var(--elevation-1);
            margin-bottom: var(--space-xl);
            border: 1px solid rgba(0,0,0,0.05);
            transition: all var(--motion-normal) var(--motion-ease);
            position: relative;
            overflow: hidden;
        }
        
        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--primary) 0%, var(--primary-light) 50%, var(--primary) 100%);
            opacity: 0;
            transition: opacity var(--motion-normal) var(--motion-ease);
        }
        
        .card:hover {
            box-shadow: var(--elevation-3);
            transform: translateY(-2px);
            border-color: rgba(30, 58, 95, 0.15);
        }
        
        .card:hover::before {
            opacity: 1;
        }
        
        .card-header {
            font-family: var(--heading-font);
            font-size: var(--text-headline-size);
            font-weight: var(--text-headline-weight);
            line-height: 1.35;
            margin-bottom: 1.5rem;
            color: var(--primary);
            border-bottom: 2px solid var(--border);
            padding-bottom: 1rem;
        }
        .card-header.text-title { font-size: 1.5rem; font-weight: 700; line-height: 1.3; }
        
        /* Icon button for card headers - Apple HIG compliant */
        .icon-button-add {
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        .icon-button-add:active {
            background: var(--bg-alt) !important;
            color: var(--primary) !important;
            transform: scale(0.95);
        }
        @media (prefers-reduced-motion: reduce) {
            .icon-button-add {
                transition: none;
            }
        }
        
        /* Analytics tabs: affordance + responsive */
        .analytics-tablist {
            flex-wrap: nowrap;
            min-width: 0;
            -webkit-overflow-scrolling: touch;
        }
        .analytics-tab {
            padding: 0.75rem 1.5rem;
            border: none;
            background: none;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            color: var(--text-light);
            font-weight: 400;
            font-size: 1rem;
            white-space: nowrap;
            flex-shrink: 0;
            border-radius: 0.25rem 0.25rem 0 0;
            transition: background 0.2s, color 0.2s, border-color 0.2s;
            position: relative;
            box-sizing: border-box;
        }
        .analytics-tab:hover {
            color: var(--text);
            background: rgba(0,0,0,0.03);
        }
        .analytics-tab:focus-visible {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
        }
        .analytics-tab-active {
            border-bottom-color: var(--primary);
            color: var(--primary);
            font-weight: 600;
            background: rgba(30, 58, 95, 0.06);
            border-bottom-width: 3px;
            border-bottom-style: solid;
        }
        
        /* Instructor dashboard top-level tabs (Courses | Rubrics | Course Insights) */
        .instructor-dashboard-tablist {
            display: flex;
            gap: 0.25rem;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--border);
            padding-bottom: 0;
            flex-wrap: wrap;
        }
        .instructor-dashboard-tab {
            padding: 0.75rem 1.25rem;
            border: none;
            background: none;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
            color: var(--text-light);
            font-weight: 500;
            font-size: 1rem;
            border-radius: 0.25rem 0.25rem 0 0;
            transition: background 0.2s, color 0.2s, border-color 0.2s;
        }
        .instructor-dashboard-tab:hover {
            color: var(--text);
            background: rgba(0,0,0,0.04);
        }
        .instructor-dashboard-tab-active {
            border-bottom-color: var(--primary);
            color: var(--primary);
            font-weight: 600;
            background: rgba(30, 58, 95, 0.06);
        }

        /* Settings section tabs (General | Consent | Admin) */
        .settings-tablist {
            display: flex;
            gap: 0.25rem;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--border);
            padding-bottom: 0;
            flex-wrap: wrap;
        }
        .settings-tab {
            padding: 0.75rem 1.25rem;
            border: none;
            background: none;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
            color: var(--text-light);
            font-weight: 500;
            font-size: 1rem;
            border-radius: 0.25rem 0.25rem 0 0;
            transition: background 0.2s, color 0.2s, border-color 0.2s;
        }
        .settings-tab:hover {
            color: var(--text);
            background: rgba(0,0,0,0.04);
        }
        .settings-tab-active {
            border-bottom-color: var(--primary);
            color: var(--primary);
            font-weight: 600;
        }
        /* Admin Settings Sidebar Navigation */
        .admin-settings-container {
            display: grid;
            grid-template-columns: 240px 1fr;
            gap: 2rem;
            min-height: 600px;
        }
        
        .admin-settings-sidebar {
            border-right: 1px solid var(--border);
            padding-right: 1.5rem;
            position: sticky;
            top: 2rem;
            align-self: start;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }
        
        /* General Settings Sidebar (mirror Admin tab styles) */
        .general-settings-container {
            display: grid;
            grid-template-columns: 240px 1fr;
            gap: 2rem;
            min-height: 600px;
        }
        
        .general-settings-sidebar {
            border-right: 1px solid var(--border);
            padding-right: 1.5rem;
            position: sticky;
            top: 2rem;
            align-self: start;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }
        
        .general-settings-sidebar h4 {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-light);
            margin-bottom: 1rem;
            padding: 0 1rem;
        }
        
        .general-settings-sidebar ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .general-nav-item {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            border: none;
            background: none;
            text-align: left;
            color: var(--text);
            font-size: 0.9375rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 0.25rem;
            position: relative;
        }
        
        .general-nav-item:hover {
            background: var(--bg-alt);
        }
        
        .general-nav-item.active {
            background: var(--primary);
            color: white;
            font-weight: 600;
        }
        
        .general-nav-item.active i {
            color: white;
        }
        
        .general-nav-item i {
            width: 1.25rem;
            height: 1.25rem;
            flex-shrink: 0;
            color: var(--text-light);
        }
        
        .general-nav-item.active i {
            color: white;
        }
        
        .general-settings-content {
            overflow-y: auto;
            padding-right: 1rem;
        }
        
        .general-section {
            display: none;
        }
        
        .general-section.active {
            display: block;
        }
        
        .general-section-header {
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }
        
        .general-section-header h2 {
            font-size: 1.5rem;
            font-weight: 700;
            margin: 0 0 0.5rem 0;
        }
        
        .general-section-description {
            color: var(--text-light);
            font-size: 0.9375rem;
            margin: 0;
        }
        
        .general-card {
            background: var(--bg-alt);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        @media (max-width: 768px) {
            .general-settings-container {
                grid-template-columns: 1fr;
            }
            
            .general-settings-sidebar {
                border-right: none;
                border-bottom: 1px solid var(--border);
                padding-bottom: 1rem;
                margin-bottom: 1.5rem;
                position: static;
                max-height: none;
            }
            
            .general-settings-sidebar ul {
                display: flex;
                overflow-x: auto;
                gap: 0.5rem;
            }
            
            .general-nav-item {
                white-space: nowrap;
                flex-shrink: 0;
            }
        }
        
        .admin-settings-sidebar h4 {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-light);
            margin-bottom: 1rem;
            padding: 0 1rem;
        }
        
        .admin-settings-sidebar ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .admin-nav-item {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            border: none;
            background: none;
            text-align: left;
            color: var(--text);
            font-size: 0.9375rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 0.25rem;
            position: relative;
        }
        
        .admin-nav-item:hover {
            background: var(--bg-alt);
        }
        
        .admin-nav-item.active {
            background: var(--primary);
            color: white;
            font-weight: 600;
        }
        
        .admin-nav-item.active i {
            color: white;
        }
        
        .admin-nav-item i {
            width: 1.25rem;
            height: 1.25rem;
            flex-shrink: 0;
            color: var(--text-light);
        }
        
        .admin-nav-item.active i {
            color: white;
        }
        
        .admin-nav-item .badge {
            margin-left: auto;
            background: var(--error);
            color: white;
            font-size: 0.75rem;
            padding: 0.125rem 0.5rem;
            border-radius: 10px;
            font-weight: 600;
            min-width: 1.25rem;
            text-align: center;
        }
        
        .admin-nav-item.active .badge {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .admin-settings-content {
            overflow-y: auto;
            padding-right: 1rem;
        }
        
        .admin-section {
            display: none;
        }
        
        .admin-section.active {
            display: block;
        }
        
        .admin-section-header {
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }
        
        .admin-section-header h2 {
            font-size: 1.5rem;
            font-weight: 700;
            margin: 0 0 0.5rem 0;
        }
        
        .admin-section-description {
            color: var(--text-light);
            font-size: 0.9375rem;
            margin: 0;
        }
        
        .admin-card {
            background: var(--bg-alt);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        .admin-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }
        
        .admin-card h3 {
            font-size: 1.125rem;
            font-weight: 600;
            margin: 0 0 0.5rem 0;
        }
        
        .admin-card p {
            color: var(--text-light);
            font-size: 0.9rem;
            margin: 0 0 1rem 0;
        }
        
        /* Ensure Save Settings button only appears in General tab */
        #saveSettingsButtonContainer {
            display: none;
        }
        
        #settingsTabGeneral[style*="display: block"] #saveSettingsButtonContainer {
            display: flex !important;
        }
        
        /* Hide button when General tab is hidden */
        #settingsTabGeneral[style*="display: none"] #saveSettingsButtonContainer,
        #settingsTabGeneral:not([style]) #saveSettingsButtonContainer {
            display: none !important;
        }
        
        /* Form Validation Styles */
        .form-group {
            position: relative;
            margin-bottom: 1.5rem;
        }
        
        .form-group label {
            display: block;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: var(--text);
            font-size: 0.9375rem;
        }
        
        .form-group label.required::after {
            content: " *";
            color: var(--error);
            font-weight: 600;
        }
        
        .form-group input[type="text"],
        .form-group input[type="date"],
        .form-group input[type="email"],
        .form-group select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            font-size: 1rem;
            transition: all 0.2s ease;
            background: white;
            color: var(--text);
        }
        
        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(30, 58, 95, 0.1);
        }
        
        .form-group input.invalid,
        .form-group select.invalid {
            border-color: var(--error);
            box-shadow: 0 0 0 3px rgba(185, 28, 28, 0.1);
        }
        
        .form-group input.valid,
        .form-group select.valid {
            border-color: var(--success);
        }
        
        .field-error {
            display: none;
            color: var(--error);
            font-size: 0.875rem;
            margin-top: 0.25rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .field-error.show {
            display: flex;
        }
        
        .field-error i {
            width: 14px;
            height: 14px;
            flex-shrink: 0;
        }
        
        .field-hint {
            font-size: 0.9rem;
            color: var(--text-light);
            margin-top: 0.5rem;
        }
        
        .form-group.optional label::after {
            content: " (Optional)";
            font-weight: 400;
            color: var(--text-light);
            font-size: 0.875rem;
        }
        
        /* Apple HIG: Enhanced select styling for Data Deletion Scope */
        #deletionScopeSection select:hover {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(30, 58, 95, 0.1);
        }
        
        #deletionScopeSection select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(30, 58, 95, 0.15);
        }
        
        #deletionScopeSection select:focus-visible {
            outline: 2px solid var(--focus-ring);
            outline-offset: 2px;
            border-color: var(--primary);
        }
        
        /* Apple HIG: Visual feedback for grouped settings containers */
        #deletionScopeSection > div > div[style*="background: var(--bg-alt)"]:hover {
            border-color: var(--primary);
            background: rgba(30, 58, 95, 0.02);
        }
        
        @media (max-width: 768px) {
            .admin-settings-container {
                grid-template-columns: 1fr;
            }
            
            .admin-settings-sidebar {
                border-right: none;
                border-bottom: 1px solid var(--border);
                padding-bottom: 1rem;
                margin-bottom: 1.5rem;
                position: static;
                max-height: none;
            }
            
            .admin-settings-sidebar ul {
                display: flex;
                overflow-x: auto;
                gap: 0.5rem;
            }
            
            .admin-nav-item {
                white-space: nowrap;
                flex-shrink: 0;
            }
        }
        
        .settings-section-heading {
            font-weight: 700;
            margin-bottom: 1rem;
        }
        .settings-section-subheading {
            margin-bottom: 1rem;
            color: var(--primary);
        }

        /* Support section tabs (Getting Started | User Manual | Technical Documentation) */
        .support-tablist {
            display: flex;
            gap: 0.25rem;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--border);
            padding-bottom: 0;
            flex-wrap: wrap;
        }
        .support-tab {
            padding: 0.75rem 1.25rem;
            border: none;
            background: none;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
            color: var(--text-light);
            font-weight: 500;
            font-size: 1rem;
            border-radius: 0.25rem 0.25rem 0 0;
            transition: background 0.2s, color 0.2s, border-color 0.2s;
        }
        .support-tab:hover {
            color: var(--text);
            background: rgba(0,0,0,0.04);
        }
        .support-tab-active {
            border-bottom-color: var(--primary);
            color: var(--primary);
            font-weight: 600;
        }
        .support-tier-badge {
            display: inline-block;
            font-size: 0.75rem;
            padding: 0.2rem 0.5rem;
            border-radius: 0.25rem;
            background: var(--bg-alt);
            color: var(--text-light);
            margin-left: 0.5rem;
        }
        .support-doc-panel { display: none; }
        .support-doc-panel.active { display: block; }
        #helpSection .support-doc-panel h3,
        #helpSection .support-doc-panel h3 .icon-with-text {
            font-family: var(--heading-font);
            font-weight: 700;
            font-size: 1.25rem;
            color: var(--primary);
        }

        /* Toast for analytics success */
        .analytics-toast {
            position: fixed;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            background: var(--primary);
            color: white;
            padding: 0.75rem 1.25rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 9999;
            font-size: 0.9rem;
            animation: analyticsToastIn 0.25s ease;
        }
        .analytics-toast a { color: #fff; text-decoration: underline; }
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        @media (prefers-reduced-motion: reduce) {
            @keyframes shimmer {
                0%, 100% { transform: translateX(0); }
            }
        }
        
        @keyframes analyticsToastIn {
            from { opacity: 0; transform: translateX(-50%) translateY(0.5rem); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        
        /* Evaluation Saved Popup Notification */
        .evaluation-saved-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 20px 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 280px;
            max-width: 400px;
            animation: evaluationSavedPopupIn 0.3s ease;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', sans-serif;
        }
        
        .evaluation-saved-popup.hidden {
            display: none;
        }
        
        .evaluation-saved-popup .icon-with-text {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 16px;
            font-weight: 500;
            color: var(--text);
            flex: 1;
        }
        
        .evaluation-saved-popup .icon-with-text i {
            width: 20px;
            height: 20px;
            color: var(--success);
            flex-shrink: 0;
        }
        
        .evaluation-saved-popup-dismiss {
            background: transparent;
            border: none;
            padding: 4px;
            cursor: pointer;
            color: var(--text-light);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
            min-width: 32px;
            min-height: 32px;
        }
        
        .evaluation-saved-popup-dismiss:hover {
            background: var(--bg-alt);
            color: var(--text);
        }
        
        .evaluation-saved-popup-dismiss i {
            width: 18px;
            height: 18px;
        }
        
        @keyframes evaluationSavedPopupIn {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        
        /* Persistent Evaluation Saved Indicator */
        .student-actions-menu {
            position: fixed !important;
            background: white !important;
            border: 1px solid var(--border) !important;
            border-radius: 0.5rem !important;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15) !important;
            z-index: 99999 !important;
            min-width: 180px !important;
            padding: 0.25rem 0 !important;
        }
        
        .student-actions-menu.hidden {
            display: none;
        }
        
        .evaluation-saved-indicator {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 1rem 1.25rem;
            border-radius: 0.5rem;
            margin-bottom: var(--space-lg);
            margin-top: 0;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
            animation: evaluationSavedIn 0.3s ease;
            position: relative;
            z-index: 1;
            width: 100%;
            box-sizing: border-box;
        }
        .evaluation-saved-indicator.hidden {
            display: none;
        }
        .evaluation-saved-indicator .icon-with-text {
            color: white;
            font-weight: 600;
            font-size: 1rem;
        }
        .evaluation-saved-indicator .icon-with-text i {
            color: white;
        }
        .evaluation-saved-dismiss {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 2rem;
            height: 2rem;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            transition: background 0.2s ease;
            flex-shrink: 0;
        }
        .evaluation-saved-dismiss:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        .evaluation-saved-dismiss i {
            width: 1rem;
            height: 1rem;
            color: white;
        }
        @keyframes evaluationSavedIn {
            from {
                opacity: 0;
                transform: translateY(-0.5rem);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Apple HIG: Dropdown animation */
        @keyframes dropdownSlideIn {
            from {
                opacity: 0;
                transform: translateY(-0.5rem);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @media (prefers-reduced-motion: reduce) {
            @keyframes dropdownSlideIn {
                from, to {
                    opacity: 1;
                    transform: none;
                }
            }
        }

        /* Account-wide search dropdown */
        .account-search-results {
            position: absolute;
            top: calc(100% + var(--space-xs));
            left: 0;
            right: 0;
            max-height: 360px;
            overflow-y: auto;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            box-shadow: var(--elevation-3);
            z-index: 1000;
            padding: var(--space-sm) 0;
            animation: dropdownSlideIn var(--motion-fast) var(--motion-ease-out);
        }
        .account-search-results.hidden { display: none !important; }
        .account-search-results .search-group-label {
            padding: 0.35rem 0.75rem;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-light);
            letter-spacing: 0.05em;
            border-bottom: 1px solid var(--border);
            margin-bottom: 0.25rem;
        }
        .account-search-results .search-result-item {
            display: block;
            width: 100%;
            padding: 0.5rem 0.75rem;
            text-align: left;
            border: none;
            background: none;
            font-size: 0.9rem;
            color: var(--text);
            cursor: pointer;
            transition: background 0.15s;
        }
        .account-search-results .search-result-item:hover,
        .account-search-results .search-result-item:focus {
            background: var(--bg-alt);
            outline: none;
        }
        .account-search-results .search-result-item .search-result-sub {
            font-size: 0.8rem;
            color: var(--text-light);
            margin-top: 0.15rem;
        }
        .account-search-results .search-no-results {
            padding: 1rem 0.75rem;
            font-size: 0.9rem;
            color: var(--text-light);
        }
        /* Expandable Search */
        .search-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }
        
        .search-icon-button {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 2.75rem;
            height: 2.75rem;
            background: transparent;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: var(--radius-md);
            transition: all var(--motion-normal) var(--motion-ease);
            flex-shrink: 0;
        }
        
        .search-icon-button:hover {
            background: rgba(255,255,255,0.12);
        }
        
        .search-icon-button:focus-visible {
            outline: 2px solid white;
            outline-offset: 2px;
        }
        
        .search-icon-button i {
            width: 1.25rem;
            height: 1.25rem;
        }
        
        .account-search-wrap {
            position: relative;
            flex: 1 1 auto;
            max-width: 280px;
            min-width: 180px;
            margin: 0 var(--space-md);
            cursor: text;
        }
        
        .account-search-wrap.search-expandable {
            position: absolute;
            right: 0;
            top: 0;
            max-width: 400px;
            min-width: 280px;
            margin: 0;
            opacity: 0;
            transform: scaleX(0.8);
            transform-origin: right;
            pointer-events: none;
            transition: opacity var(--motion-normal) var(--motion-ease), 
                        transform var(--motion-normal) var(--motion-ease);
            z-index: 1001;
        }
        
        .account-search-wrap.search-expandable:not(.hidden) {
            opacity: 1;
            transform: scaleX(1);
            pointer-events: all;
        }
        .account-search-input {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: 2px solid #d1d5db !important;
            border-radius: 0.5rem;
            font-size: 0.9rem;
            background: #ffffff !important;
            color: #1f2937 !important;
            position: relative;
            z-index: 1;
        }
        .account-search-input::placeholder {
            color: #6b7280 !important;
        }
        
        /* Theme Customizer (Settings Admin tab) */
        
        /* HTML Color Codes–style picker: 2D saturation/lightness + hue strip */
        .theme-color-picker-panel {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            box-shadow: 0 20px 60px rgba(0,0,0,0.2);
            padding: 1.25rem;
            min-width: 280px;
        }
        .theme-color-picker-panel.open { display: block; }
        .theme-color-picker-panel .picker-2d-wrap {
            position: relative;
            width: 240px;
            height: 160px;
            border-radius: 0.5rem;
            overflow: hidden;
            border: 1px solid var(--border);
            cursor: crosshair;
            touch-action: none;
        }
        .theme-color-picker-panel .picker-2d {
            width: 100%;
            height: 100%;
            background-image:
                linear-gradient(to bottom, #fff, transparent),
                linear-gradient(to top, #000, transparent),
                linear-gradient(to right, #808080, var(--picker-hue-color, #f00));
            background-size: 100% 100%;
        }
        .theme-color-picker-panel .picker-2d-marker {
            position: absolute;
            width: 14px;
            height: 14px;
            margin: -7px 0 0 -7px;
            border: 2px solid #fff;
            border-radius: 50%;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.4);
            pointer-events: none;
        }
        .theme-color-picker-panel .picker-hue-wrap {
            position: relative;
            width: 240px;
            height: 12px;
            margin-top: 0.75rem;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid var(--border);
            cursor: pointer;
            touch-action: none;
            background: linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00);
        }
        .theme-color-picker-panel .picker-hue-marker {
            position: absolute;
            top: 0;
            width: 4px;
            height: 100%;
            margin-left: -2px;
            background: #fff;
            border-radius: 2px;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.3);
            pointer-events: none;
        }
        .theme-color-picker-panel .picker-codes {
            margin-top: 0.75rem;
            display: flex;
            gap: 0.75rem;
            align-items: center;
            flex-wrap: wrap;
        }
        .theme-color-picker-panel .picker-codes label {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-light);
        }
        .theme-color-picker-panel .picker-codes input {
            padding: 0.35rem 0.5rem;
            border: 1px solid var(--border);
            border-radius: 0.25rem;
            font-size: 0.875rem;
            font-family: ui-monospace, monospace;
        }
        .theme-color-picker-panel .picker-preview {
            width: 36px;
            height: 36px;
            border-radius: 0.375rem;
            border: 1px solid var(--border);
            flex-shrink: 0;
        }
        .theme-color-picker-panel .picker-actions {
            margin-top: 1rem;
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
        }
        .theme-color-picker-panel .picker-backdrop {
            position: fixed;
            inset: 0;
            z-index: -1;
            background: rgba(0,0,0,0.35);
        }
        
        /* Upload Zone */
        .upload-zone {
            border: 3px dashed var(--border);
            border-radius: var(--radius-lg);
            padding: var(--space-2xl);
            text-align: center;
            cursor: pointer;
            transition: border-color var(--motion-normal) var(--motion-ease),
                        background-color var(--motion-normal) var(--motion-ease),
                        transform var(--motion-fast) var(--motion-ease);
            background: var(--bg-alt);
            min-height: 2.75rem;  /* Ensure touch target minimum */
        }
        
        .upload-zone:hover {
            border-color: var(--primary);
            background: white;
            transform: scale(1.01);
        }
        
        .upload-zone.drag-over {
            border-color: var(--primary);
            background: rgba(30, 58, 95, 0.05);
            transform: scale(1.02);
        }
        
        .upload-zone:focus-visible {
            outline: 2px solid var(--focus-ring);
            outline-offset: 2px;
        }
        
        .upload-icon {
            font-size: 3rem;
            margin-bottom: var(--space-md);
        }
        
        .file-info {
            background: var(--success);
            color: white;
            padding: var(--space-md);
            border-radius: var(--radius-md);
            margin-top: var(--space-md);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        /* Forms */
        .form-group {
            margin-bottom: 1.5rem;
        }
        
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--text);
        }
        
        input[type="text"],
        input[type="email"],
        input[type="date"],
        input[type="number"],
        input[type="password"],
        select,
        textarea {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--border);
            border-radius: 0.5rem;
            font-size: 1rem;
            font-family: var(--body-font);
            transition: border-color 0.3s;
        }
        
        input:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(30, 58, 95, 0.1);
        }
        
        /* Apple HIG: Enhanced focus states for accessibility */
        input:focus-visible,
        select:focus-visible,
        textarea:focus-visible {
            outline: 2px solid var(--focus-ring);
            outline-offset: var(--focus-ring-offset);
            border-color: var(--primary);
        }
        
        /* Apple HIG: Ensure links have proper contrast and focus states */
        a:not(.btn):not(.button):not(.nav-link) {
            color: var(--link);
            text-decoration: none;
            transition: color var(--motion-fast) var(--motion-ease);
        }
        
        a:not(.btn):not(.button):not(.nav-link):hover {
            color: var(--link-hover);
            text-decoration: underline;
        }
        
        a:not(.btn):not(.button):not(.nav-link):visited {
            color: var(--link-visited);
        }
        
        a:not(.btn):not(.button):not(.nav-link):focus-visible {
            outline: 2px solid var(--focus-ring);
            outline-offset: 2px;
            border-radius: 2px;
        }
        
        textarea {
            resize: vertical;
            min-height: 100px;
        }
        
        /* Buttons - Apple HIG: Clear affordances, proper feedback with enhanced visual appeal */
        button,
        .btn {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            padding: var(--space-md) var(--space-lg);
            border: none;
            border-radius: var(--radius-md);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--motion-normal) var(--motion-ease);
            display: inline-block;
            text-decoration: none;
            text-align: center;
            box-shadow: 0 2px 8px rgba(30, 58, 95, 0.2), 0 1px 3px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        button::before,
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }
        
        button:hover::before,
        .btn:hover::before {
            left: 100%;
        }
        
        button:hover,
        .btn:hover {
            background: linear-gradient(135deg, var(--primary-light) 0%, var(--primary) 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(30, 58, 95, 0.3), 0 2px 6px rgba(0, 0, 0, 0.15);
        }
        
        button:active,
        .btn:active {
            transform: translateY(0);
            box-shadow: var(--elevation-1);
        }
        
        button:focus-visible,
        .btn:focus-visible {
            outline: 2px solid var(--focus-ring);
            outline-offset: var(--focus-ring-offset);
        }
        
        .btn-icon-only {
            padding: 0.5rem;
            min-width: 2.75rem;
            min-height: 2.75rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .btn-icon-only [data-lucide] { width: 1.25em; height: 1.25em; }
        
        /* Apple HIG: Button variants with proper contrast */
        .btn-secondary {
            background: var(--secondary);
            color: white;
        }
        
        .btn-secondary:hover {
            background: #b89a6f;
            color: white;
        }
        
        .btn-success {
            background: var(--success);
            color: white;
        }
        
        .btn-success:hover {
            background: #047857;
            color: white;
        }
        
        .btn-danger {
            background: var(--error);
            color: white;
        }
        
        .btn-danger:hover {
            background: #991b1b;
            color: white;
        }
        
        .btn-warning {
            background: var(--warning);
            color: white;
        }
        
        .btn-warning:hover {
            background: #b45309;
            color: white;
        }
        
        .btn-info {
            background: var(--info);
            color: white;
        }
        
        .btn-info:hover {
            background: #0369a1;
            color: white;
        }
        
        /* Minimum touch target (Apple HIG: ~44pt) for primary actions */
        .btn:not(.btn-small):not(.btn-icon-only) {
            min-height: 2.75rem;
            min-width: 2.75rem;
            padding: 0.5rem 1rem;
        }
        
        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
        }
        
        /* UTK Torch: primary buttons only (exclude tabs) – white bg, orange border, blue text */
        html.theme-torch button:not(.btn-secondary):not(.btn-success):not(.btn-danger):not(.settings-tab):not(.support-tab):not(.instructor-dashboard-tab):not(.analytics-tab),
        html.theme-torch .btn:not(.btn-secondary):not(.btn-success):not(.btn-danger):not(.settings-tab):not(.support-tab):not(.instructor-dashboard-tab):not(.analytics-tab) {
            background: white !important;
            color: #1a73c5 !important;
            border: 2px solid var(--primary) !important;
        }
        html.theme-torch button:not(.btn-secondary):not(.btn-success):not(.btn-danger):not(.settings-tab):not(.support-tab):not(.instructor-dashboard-tab):not(.analytics-tab):hover,
        html.theme-torch .btn:not(.btn-secondary):not(.btn-success):not(.btn-danger):not(.settings-tab):not(.support-tab):not(.instructor-dashboard-tab):not(.analytics-tab):hover {
            background: #FFFBF7 !important;
            color: #0d47a1 !important;
            border-color: var(--primary-dark) !important;
        }
        /* UTK Torch: progress step circles – match Torch button style (white bg, orange border, blue number) */
        html.theme-torch .step.active .step-circle {
            background: white !important;
            color: #1a73c5 !important;
            border: 2px solid var(--primary) !important;
        }
        
        /* UTK Torch Theme: tab styling from utk-theme-preview.html (light gray bg, blue when active) */
        html.theme-utk-torch .settings-tab,
        html.theme-utk-torch .support-tab,
        html.theme-utk-torch .instructor-dashboard-tab,
        html.theme-utk-torch .analytics-tab {
            background: var(--bg-alt, #F0F0F0);
            border: 1px solid var(--border);
            border-bottom: none;
            border-radius: 0.25rem 0.25rem 0 0;
        }
        html.theme-utk-torch .settings-tab:hover,
        html.theme-utk-torch .support-tab:hover,
        html.theme-utk-torch .instructor-dashboard-tab:hover,
        html.theme-utk-torch .analytics-tab:hover {
            color: var(--link-blue, #1a73c5);
            background: var(--bg, #FAFAFA);
        }
        html.theme-utk-torch .settings-tab-active,
        html.theme-utk-torch .support-tab-active,
        html.theme-utk-torch .instructor-dashboard-tab-active,
        html.theme-utk-torch .analytics-tab-active {
            background: white;
            color: var(--link-blue, #1a73c5);
            border-color: var(--border);
            border-bottom: 2px solid white;
        }
        
        /* Progress Steps - Apple HIG: Proper spacing and motion */
        .progress-steps {
            display: flex;
            justify-content: space-between;
            margin-bottom: var(--space-xl);
            position: relative;
            gap: var(--space-md);
        }
        
        .progress-steps::before {
            content: '';
            position: absolute;
            top: 1.375rem;  /* Center of 2.75rem circle */
            left: 0;
            right: 0;
            height: 3px;
            background: var(--border);
            z-index: 1;
            transition: background-color var(--motion-normal) var(--motion-ease);
        }
        
        .step {
            flex: 1;
            text-align: center;
            position: relative;
            z-index: 2;
        }
        
        /* Apple HIG: Step circles with proper touch targets and motion */
        .step-circle {
            width: 2.75rem;  /* 44pt minimum touch target */
            height: 2.75rem;
            min-width: 2.75rem;
            min-height: 2.75rem;
            border-radius: 50%;
            background: var(--border);
            color: var(--text-light);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin: 0 auto var(--space-sm);
            transition: background-color var(--motion-normal) var(--motion-ease),
                        color var(--motion-normal) var(--motion-ease),
                        transform var(--motion-fast) var(--motion-ease);
            cursor: pointer;
        }
        
        .step-circle:hover {
            transform: scale(1.05);
        }
        
        .step-circle:focus-visible {
            outline: 2px solid var(--focus-ring);
            outline-offset: 2px;
        }
        
        .step.active .step-circle {
            background: var(--primary);
            color: white;
        }
        
        .step.completed .step-circle {
            background: var(--success);
            color: white;
        }
        
        .step-label {
            font-size: 0.9rem;
            color: var(--text-light);
            transition: color var(--motion-normal) var(--motion-ease),
                        font-weight var(--motion-normal) var(--motion-ease);
        }
        
        .step.active .step-label {
            color: var(--primary);
            font-weight: 600;
        }
        
        /* Classes Grid */
        .classes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: var(--space-lg);
            margin-top: var(--space-xl);
        }
        
        /* Data Table Styles */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            background: var(--card);
            border-radius: var(--radius-md);
            overflow: hidden;
            box-shadow: var(--elevation-1);
        }
        
        .data-table thead {
            background: var(--primary);
            color: white;
        }
        
        .data-table th {
            padding: 1rem;
            text-align: left;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
        }
        
        .data-table th:hover {
            background: rgba(0, 0, 0, 0.1);
        }
        
        .data-table tbody tr {
            border-bottom: 1px solid var(--border);
            transition: background 0.2s;
        }
        
        .data-table tbody tr {
            transition: background-color var(--motion-fast) var(--motion-ease);
        }
        
        .data-table tbody tr:hover {
            background: var(--bg-hover);
        }
        
        .data-table td {
            padding: var(--space-md) var(--space-md);
            color: var(--text);
            min-height: 2.75rem;  /* Touch target minimum for clickable rows */
        }
        
        .data-table td:last-child {
            text-align: center;
        }
        
        /* Filter Controls */
        .filter-controls {
            padding: 1rem;
            background: rgba(0, 0, 0, 0.02);
            border-radius: 0.5rem;
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
        }
        
        /* Apple HIG: Cards with proper elevation and spacing */
        .class-card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            padding: var(--space-lg);
            transition: all var(--motion-normal) var(--motion-ease);
            cursor: pointer;
            box-shadow: var(--elevation-1);
            position: relative;
            overflow: hidden;
        }
        
        .class-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(180deg, var(--primary) 0%, var(--primary-light) 100%);
            opacity: 0;
            transition: opacity var(--motion-normal) var(--motion-ease);
        }
        
        .class-card:hover {
            border-color: var(--primary);
            box-shadow: 0 8px 24px rgba(30, 58, 95, 0.12), 0 2px 8px rgba(0, 0, 0, 0.08);
            transform: translateY(-2px);
            background: linear-gradient(to bottom, #ffffff 0%, #fafbfc 100%);
        }
        
        .class-card:hover::before {
            opacity: 1;
        }
        
        .class-card:active {
            transform: translateY(0);
            box-shadow: var(--elevation-1);
        }
        
        .class-card:focus-visible {
            outline: 2px solid var(--focus-ring);
            outline-offset: 2px;
        }
        
        .course-actions-menu {
            display: none;
        }
        .course-actions-menu.hidden {
            display: none !important;
            visibility: hidden !important;
        }
        .course-actions-menu:not(.hidden) {
            display: block !important;
            visibility: visible !important;
        }
        
        .evaluation-actions-menu {
            display: none;
            position: fixed; /* Changed to fixed to escape overflow containers */
            background: white;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000; /* High z-index to ensure it's above everything */
            min-width: 200px;
            padding: 0.25rem 0;
        }
        /* Visual indicator arrow pointing to the button (on the right side since menu is to the left) */
        .evaluation-actions-menu::before {
            content: '';
            position: absolute;
            top: 50%;
            right: -6px;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-left: 6px solid white;
            z-index: 1001;
        }
        .evaluation-actions-menu::after {
            content: '';
            position: absolute;
            top: 50%;
            right: -7px;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-left: 6px solid var(--border);
            z-index: 1000;
        }
        .evaluation-actions-menu.hidden {
            display: none !important;
            visibility: hidden !important;
        }
        .evaluation-actions-menu:not(.hidden) {
            display: block !important;
            visibility: visible !important;
        }
        
        .student-menu {
            display: none;
        }
        .student-menu.hidden {
            display: none !important;
        }
        .student-menu:not(.hidden) {
            display: block !important;
        }
        
        .class-header {
            font-size: var(--text-headline-size);
            font-weight: var(--text-headline-weight);
            line-height: 1.35;
            color: var(--primary);
            margin-bottom: 0.5rem;
        }
        
        .class-meta {
            font-size: var(--text-caption-size);
            font-weight: 400;
            color: var(--text-light);
            line-height: 1.5;
            margin-bottom: var(--space-md);
        }
        
        .class-stats {
            display: flex;
            justify-content: space-between;
            padding-top: var(--space-md);
            border-top: 1px solid var(--border);
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-size: var(--text-title-size);
            font-weight: bold;
            color: var(--primary);
        }
        
        .stat-label {
            font-size: var(--text-caption-size);
            font-weight: 400;
            color: var(--text-light);
            line-height: 1.4;
        }
        
        /* Rubrics - Apple HIG: Proper spacing */
        .rubrics-list {
            display: grid;
            gap: var(--space-md);
        }
        
        .rubric-item {
            background: var(--bg-alt);
            padding: var(--space-md);
            border-radius: var(--radius-md);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color var(--motion-normal) var(--motion-ease),
                        box-shadow var(--motion-normal) var(--motion-ease),
                        transform var(--motion-fast) var(--motion-ease);
            cursor: pointer;
            min-height: 2.75rem;  /* Touch target minimum */
        }
        
        .rubric-item:hover {
            background: var(--bg-hover);
            box-shadow: var(--elevation-1);
            transform: translateX(2px);
        }
        
        .rubric-item:focus-visible {
            outline: 2px solid var(--focus-ring);
            outline-offset: 2px;
        }
        
        .rubric-info h4 {
            margin-bottom: var(--space-xs);
        }
        
        .rubric-info p {
            font-size: 0.9375rem;
            font-weight: 400;
            color: var(--text-light);
            line-height: 1.5;
        }
        
        .rubric-actions {
            display: flex;
            gap: var(--space-sm);
        }
        
        /* Apple HIG: Enhanced Loading States */
        .spinner {
            border: 3px solid var(--border);
            border-top: 3px solid var(--primary);
            border-radius: 50%;
            width: 48px;
            height: 48px;
            animation: spin var(--motion-slow) linear infinite;
            margin: var(--space-xl) auto;
            position: relative;
        }
        
        /* Apple HIG: Skeleton loading for content */
        .skeleton {
            background: linear-gradient(90deg, var(--bg-alt) 25%, var(--border) 50%, var(--bg-alt) 75%);
            background-size: 200% 100%;
            animation: skeleton-loading 1.5s ease-in-out infinite;
            border-radius: var(--radius-sm);
            min-height: 1rem;
        }
        
        @keyframes skeleton-loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .spin { 
            display: inline-block; 
            animation: spin var(--motion-slow) linear infinite; 
            vertical-align: middle; 
        }
        
        /* Apple HIG: Loading states with proper feedback */
        .loading-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--space-2xl);
            gap: var(--space-md);
            text-align: center;
        }
        
        .loading-state .spinner {
            margin: 0;
        }
        
        .loading-state-message {
            color: var(--text-light);
            font-size: var(--text-body-size);
            line-height: 1.5;
        }
        
        .loading-state-submessage {
            color: var(--text-light);
            font-size: var(--text-caption-size);
            margin-top: var(--space-xs);
        }
        
        @media (prefers-reduced-motion: reduce) {
            .spinner, .spin, .auth-loading-spinner, .skeleton { 
                animation: none; 
            }
            .spinner { 
                border-top-color: var(--primary); 
                opacity: 0.85; 
            }
            .skeleton {
                background: var(--bg-alt);
            }
        }

        /* Analytics dashboard — typography hierarchy */
        .dashboard-shell-title { font-size: var(--text-headline-size); font-weight: var(--text-headline-weight); line-height: 1.35; margin-bottom: 0.25rem; color: var(--text); }
        .dashboard-shell-subtitle { font-size: var(--text-caption-size); font-weight: 400; color: var(--text-light); line-height: 1.4; margin-bottom: 1.5rem; }
        .global-filter-bar {
            display: flex; flex-direction: column; gap: 0;
            padding: var(--space-md) var(--space-lg); margin-bottom: var(--space-lg);
            border: 1px solid var(--border); border-radius: var(--radius-lg); background: var(--bg-alt);
        }
        .global-filter-bar-row {
            display: flex; flex-wrap: nowrap; align-items: flex-end; gap: var(--space-md) var(--space-lg);
            overflow: visible; min-width: 0; padding-bottom: var(--space-xs);
        }
        .global-filter-bar-row > * { flex-shrink: 0; }
        .global-filter-bar label { display: flex; flex-direction: column; gap: 0.25rem; font-size: 0.75rem; color: var(--text-light); }
        .global-filter-bar select, .global-filter-bar input[type="date"] {
            padding: 0.5rem 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; font-size: 0.875rem; min-width: 8rem;
        }
        .global-filter-bar .filter-actions { margin-left: auto; padding-left: 1rem; border-left: 1px solid var(--border); display: flex; gap: 0.5rem; align-items: center; }
        .global-filter-bar .last-updated { font-size: 0.75rem; color: var(--text-light); margin-left: 0.5rem; }
        /* Custom multi-select filter dropdowns (match Sort dropdown look) */
        .filter-dropdown { position: relative; display: flex; flex-direction: column; gap: 0.25rem; }
        .filter-dropdown .filter-dropdown-trigger {
            padding: var(--space-sm) var(--space-md); border: 1px solid var(--border); border-radius: var(--radius-md); font-size: 0.875rem; min-width: 8rem;
            min-height: 2.75rem;  /* Touch target minimum */
            background: var(--bg); color: var(--text); text-align: left; cursor: pointer; display: flex; align-items: center; justify-content: space-between; gap: var(--space-sm);
            transition: border-color var(--motion-normal) var(--motion-ease),
                        background-color var(--motion-fast) var(--motion-ease);
        }
        .filter-dropdown .filter-dropdown-trigger:hover { 
            border-color: var(--primary);
            background: var(--bg-alt);
        }
        .filter-dropdown .filter-dropdown-trigger:focus-visible {
            outline: 2px solid var(--focus-ring);
            outline-offset: 2px;
        }
        .filter-dropdown .filter-dropdown-trigger::after { content: ''; border: 0.35rem solid transparent; border-top-color: currentColor; margin-left: auto; }
        .filter-dropdown .filter-dropdown-panel {
            display: none; position: absolute; top: 100%; left: 0; min-width: 100%; margin-top: var(--space-xs);
            background: var(--bg); border: 1px solid var(--border); border-radius: var(--radius-md); box-shadow: var(--elevation-3);
            max-height: 14rem; overflow-y: auto; z-index: 9999; padding: var(--space-xs) 0; min-height: 2rem;
            animation: dropdownSlideIn var(--motion-fast) var(--motion-ease-out);
        }
        .filter-dropdown.open .filter-dropdown-panel { display: block; }
        .filter-dropdown .filter-dropdown-item {
            padding: var(--space-sm) var(--space-md); 
            min-height: 2.75rem;  /* Touch target minimum */
            cursor: pointer; display: flex; align-items: center; gap: var(--space-sm); font-size: 0.875rem;
            transition: background-color var(--motion-fast) var(--motion-ease);
        }
        .filter-dropdown .filter-dropdown-item:hover { 
            background: var(--bg-hover);
        }
        .filter-dropdown .filter-dropdown-item:focus-visible {
            outline: 2px solid var(--focus-ring);
            outline-offset: -2px;
        }
        .filter-dropdown .filter-dropdown-item .filter-dropdown-check { width: 1rem; flex-shrink: 0; color: var(--primary); font-weight: bold; display: inline-flex; align-items: center; justify-content: center; }
        .filter-dropdown .filter-dropdown-item .filter-dropdown-check svg { width: 1rem; height: 1rem; }
        .filter-dropdown .filter-dropdown-item:not(.selected) .filter-dropdown-check { visibility: hidden; }
        /* Export preview + Evaluations table: header with sort + filter dropdown (inner flex keeps th as table-cell for column alignment) */
        #exportPreviewTable thead th .export-th-inner,
        #analyticsEvaluationsTable thead th .export-th-inner { display: flex; align-items: center; gap: 0.35rem; white-space: nowrap; }
        #exportPreviewTable thead th .export-th-sort,
        #analyticsEvaluationsTable thead th .export-th-sort { flex: 1; min-width: 0; cursor: pointer; user-select: none; }
        #exportPreviewTable thead th .export-th-filter,
        #analyticsEvaluationsTable thead th .export-th-filter {
            flex-shrink: 0; padding: 0.2rem 0.35rem; border: none; background: rgba(255,255,255,0.2); color: #fff;
            border-radius: 0.25rem; cursor: pointer; font-size: 0.7rem; line-height: 1;
        }
        #exportPreviewTable thead th .export-th-filter:hover,
        #analyticsEvaluationsTable thead th .export-th-filter:hover { background: rgba(255,255,255,0.35); }
        #exportPreviewTable thead th .export-th-filter.has-filter,
        #analyticsEvaluationsTable thead th .export-th-filter.has-filter { background: rgba(255,255,255,0.5); }
        /* Data Export tab: top bar stays on one line; ensure Export button is visible */
        #exportTabTopBar { flex-wrap: nowrap !important; white-space: nowrap !important; min-width: 0; overflow-x: auto; }
        #exportTabTopBar > * { flex-shrink: 0; }
        #analyticsExportBtn { display: inline-block !important; visibility: visible !important; min-width: 7rem; opacity: 1 !important; }
        #exportPreviewTable thead th.export-th-center .export-th-inner,
        #analyticsEvaluationsTable thead th.export-th-center .export-th-inner { justify-content: center; }
        .export-header-filter-panel {
            position: fixed; z-index: 200; background: var(--bg); border: 1px solid var(--border);
            border-radius: 0.5rem; box-shadow: 0 4px 16px rgba(0,0,0,0.2); max-height: 280px; min-width: 160px;
            overflow: hidden; display: flex; flex-direction: column;
        }
        .export-header-filter-panel .export-filter-toolbar { padding: 0.4rem 0.5rem; border-bottom: 1px solid var(--border); display: flex; gap: 0.5rem; flex-shrink: 0; font-size: 0.75rem; }
        .export-header-filter-panel .export-filter-toolbar a { color: var(--primary); cursor: pointer; text-decoration: underline; }
        .export-header-filter-panel .export-filter-list { overflow-y: auto; padding: 0.25rem 0; max-height: 220px; }
        .export-header-filter-panel .export-filter-item { display: flex; align-items: center; gap: 0.5rem; padding: 0.35rem 0.6rem; cursor: pointer; font-size: 0.8rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .export-header-filter-panel .export-filter-item:hover { background: var(--bg-alt); }
        .export-header-filter-panel .export-filter-item input { margin: 0; flex-shrink: 0; }
        .dashboard-kpi-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: var(--space-md); margin-bottom: var(--space-lg); }
        .kpi-card {
            border: 1px solid var(--border); border-radius: var(--radius-lg); padding: var(--space-lg); background: linear-gradient(to bottom, #ffffff 0%, var(--bg) 100%);
            box-shadow: var(--elevation-1);
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        .kpi-card::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, rgba(30, 58, 95, 0.05) 0%, transparent 70%);
            pointer-events: none;
        }
        .kpi-card:hover { 
            box-shadow: 0 6px 20px rgba(30, 58, 95, 0.12), 0 2px 8px rgba(0, 0, 0, 0.08); 
            border-color: var(--primary);
            transform: translateY(-2px);
            background: linear-gradient(to bottom, #ffffff 0%, #f8f9fa 100%);
        }
        .kpi-card .kpi-title { font-size: var(--text-caption-size); font-weight: 500; color: var(--text-light); margin-bottom: 0.5rem; letter-spacing: 0.01em; line-height: 1.4; }
        .kpi-card .kpi-value { font-size: var(--text-title-size); font-weight: 600; line-height: 1.2; letter-spacing: -0.02em; color: var(--text); }
        .kpi-card .kpi-subtext { font-size: var(--text-caption-size); font-weight: 400; color: var(--text-light); margin-top: 0.35rem; line-height: 1.4; }
        .kpi-card .kpi-meta { display: flex; justify-content: space-between; align-items: flex-start; gap: 0.5rem; margin-top: 0.75rem; flex-wrap: wrap; }
        .kpi-card .kpi-badge { font-size: 0.6875rem; font-weight: 600; padding: 0.25rem 0.5rem; border-radius: 6px; border: 1px solid; letter-spacing: 0.02em; }
        .kpi-card .kpi-badge.ok { background: rgba(16,185,129,0.12); color: var(--success); border-color: rgba(16,185,129,0.3); }
        .kpi-card .kpi-badge.limited { background: rgba(245,158,11,0.12); color: var(--warning); border-color: rgba(245,158,11,0.3); }
        .kpi-card .kpi-badge.insufficient { background: var(--bg-alt); color: var(--text-light); border-color: var(--border); }
        .kpi-card .kpi-footer { font-size: var(--text-caption-size); font-weight: 400; color: var(--text-light); margin-top: 0.5rem; line-height: 1.4; }
        .kpi-card .kpi-footer a { color: var(--primary); text-decoration: underline; cursor: pointer; }
        .kpi-card .kpi-title:hover, .chart-card .chart-title:hover { color: var(--primary); }
        /* Chart cards — HIG: focused, clear hierarchy */
        .chart-card {
            border: 1px solid var(--border); border-radius: var(--radius-lg); padding: var(--space-lg); background: linear-gradient(to bottom, #ffffff 0%, var(--bg) 100%);
            box-shadow: var(--elevation-1);
            min-width: 0; overflow: hidden;
            transition: all var(--motion-normal) var(--motion-ease);
            position: relative;
        }
        .chart-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, var(--primary) 0%, var(--primary-light) 50%, var(--primary) 100%);
            opacity: 0;
            transition: opacity var(--motion-normal) var(--motion-ease);
        }
        .chart-card:hover { 
            box-shadow: 0 8px 24px rgba(30, 58, 95, 0.12), 0 2px 8px rgba(0, 0, 0, 0.08);
            transform: translateY(-2px);
            border-color: rgba(30, 58, 95, 0.2);
        }
        .chart-card:hover::before {
            opacity: 1;
        }
        .chart-card .chart-title { font-size: var(--text-headline-size); font-weight: var(--text-headline-weight); margin-bottom: var(--space-xs); letter-spacing: -0.01em; color: var(--text); line-height: 1.35; }
        .chart-card .chart-subtitle { font-size: var(--text-caption-size); font-weight: 400; color: var(--text-light); margin-bottom: var(--space-xs); line-height: 1.4; }
        .chart-card .chart-description { font-size: var(--text-caption-size); font-weight: 400; color: var(--text); margin-bottom: var(--space-md); line-height: 1.45; }
        .chart-card .chart-body {
            min-height: 180px; border: 1px solid var(--border); border-radius: var(--radius-md);
            background: linear-gradient(to bottom, #ffffff 0%, var(--bg-alt) 100%); overflow-x: auto; padding: var(--space-md);
            position: relative;
        }
        
        /* Line chart styles */
        .chart-line-container {
            position: relative; height: 200px; width: 100%; padding: var(--space-md) 0;
        }
        .chart-line-svg {
            width: 100%; height: 100%; overflow: visible;
        }
        .chart-line-path {
            fill: none; stroke-width: 3; stroke-linecap: round; stroke-linejoin: round;
            transition: opacity 0.3s ease;
        }
        .chart-line-path.primary { stroke: var(--primary); }
        .chart-line-path.secondary { stroke: var(--primary-light); }
        .chart-line-area {
            opacity: 0.15; transition: opacity 0.3s ease;
        }
        .chart-line-dot {
            fill: var(--primary); stroke: white; stroke-width: 2; r: 11; /* Increased for 44pt touch target */
            transition: r 0.2s ease;
            cursor: pointer;
        }
        .chart-line-dot:hover { r: 13; }
        .chart-line-dot:focus {
            outline: 2px solid var(--focus-ring);
            outline-offset: 2px;
            r: 13;
        }
        .chart-line-grid {
            stroke: var(--border); stroke-width: 1; stroke-dasharray: 2,2; opacity: 0.5;
        }
        
        /* Donut/Pie chart styles */
        .chart-donut-container {
            position: relative; width: 100%; max-width: 280px; margin: 0 auto; padding: var(--space-md);
        }
        .chart-donut-svg {
            width: 100%; height: auto; transform: rotate(-90deg);
        }
        .chart-donut-segment {
            transition: opacity 0.3s ease, transform 0.3s ease;
            cursor: pointer;
        }
        .chart-donut-segment:hover {
            opacity: 0.8; transform: scale(1.05);
        }
        .chart-donut-segment:focus {
            outline: 2px solid var(--focus-ring);
            outline-offset: 2px;
            opacity: 0.8;
        }
        /* Larger hit area for donut segments (44pt minimum) */
        .chart-donut-hit-area {
            position: absolute;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: transparent;
            cursor: pointer;
            pointer-events: all;
        }
        .chart-donut-center {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; pointer-events: none;
        }
        .chart-donut-center-value {
            font-size: 2rem; font-weight: 700; color: var(--text); line-height: 1.2;
        }
        .chart-donut-center-label {
            font-size: 0.875rem; color: var(--text-light); margin-top: 0.25rem;
        }
        
        /* Distribution histogram */
        .chart-histogram {
            display: flex; align-items: flex-end; justify-content: space-around; gap: 4px;
            height: 200px; padding: var(--space-md) 0; border-bottom: 2px solid var(--border);
        }
        .chart-histogram-bar {
            flex: 1; background: linear-gradient(to top, var(--primary) 0%, var(--primary-light) 100%);
            border-radius: 4px 4px 0 0; min-height: 4px; transition: all 0.3s ease;
            position: relative; box-shadow: 0 2px 4px rgba(30, 58, 95, 0.2);
            cursor: pointer;
            min-width: 44px; /* Ensure touch target minimum */
        }
        .chart-histogram-bar:hover {
            background: linear-gradient(to top, var(--primary-light) 0%, var(--primary) 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(30, 58, 95, 0.3);
        }
        .chart-histogram-bar:focus {
            outline: 2px solid var(--focus-ring);
            outline-offset: 2px;
            transform: translateY(-2px);
        }
        .chart-histogram-label {
            position: absolute; bottom: -24px; left: 50%; transform: translateX(-50%);
            font-size: 0.75rem; color: var(--text-light); white-space: nowrap;
        }
        
        /* Respect prefers-reduced-motion for chart animations */
        @media (prefers-reduced-motion: reduce) {
            .chart-line-dot,
            .chart-donut-segment,
            .chart-histogram-bar {
                transition: none;
            }
            .chart-line-dot:hover,
            .chart-line-dot:focus,
            .chart-donut-segment:hover,
            .chart-donut-segment:focus,
            .chart-histogram-bar:hover,
            .chart-histogram-bar:focus {
                transform: none;
            }
        }
        
        /* Colorblind-friendly patterns for donut charts */
        .chart-donut-pattern-emissions {
            fill: url(#pattern-emissions);
        }
        .chart-donut-pattern-offset {
            fill: url(#pattern-offset);
        }
        .chart-card .chart-body .chart-bars { display: flex; flex-direction: column; gap: var(--space-md); }
        .chart-card .chart-body .chart-bar-row {
            display: flex; flex-direction: column; gap: 0.35rem;
        }
        .chart-card .chart-body .chart-bar-row [role="img"] { display: flex; flex-direction: column; gap: 0.35rem; }
        .chart-card .chart-body .chart-bar-label-row { display: flex; justify-content: space-between; align-items: baseline; font-size: 0.875rem; }
        .chart-card .chart-body .chart-bar-label { font-weight: 500; color: var(--text); }
        .chart-card .chart-body .chart-bar-value { font-variant-numeric: tabular-nums; font-weight: 600; color: var(--text); }
        .chart-card .chart-body .chart-bar-track {
            height: 12px; background: var(--bg-alt); border-radius: 8px; overflow: hidden; position: relative;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);
        }
        .chart-card .chart-body .chart-bar-fill {
            height: 100%; border-radius: 8px; transition: width 0.5s cubic-bezier(0.4, 0.0, 0.2, 1);
            position: relative; overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.15);
        }
        .chart-card .chart-body .chart-bar-fill::after {
            content: '';
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(90deg, rgba(255,255,255,0.2) 0%, transparent 50%);
            pointer-events: none;
        }
        .chart-card .chart-body .chart-bar-fill.data-high { 
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }
        .chart-card .chart-body .chart-bar-fill.data-medium { 
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        }
        .chart-card .chart-body .chart-bar-fill.data-low { 
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        }
        .chart-card .chart-body .chart-bar-row {
            transition: transform 0.2s ease;
        }
        .chart-card .chart-body .chart-bar-row:hover {
            transform: translateX(4px);
        }
        .chart-card .chart-body .data-table { width: 100%; table-layout: auto; border-collapse: collapse; font-size: 0.875rem; }
        .chart-card .chart-body .data-table caption { font-size: 0.8125rem; color: var(--text-light); text-align: left; padding: 0 0 0.5rem 0; }
        .chart-card .chart-body .data-table th {
            text-align: left; font-weight: 600; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.04em;
            color: var(--text-light); padding: 0.625rem 0.75rem; background: var(--bg-alt); border-bottom: 2px solid var(--border);
        }
        .chart-card .chart-body .data-table th[scope="col"]:first-child { border-radius: 6px 0 0 0; }
        .chart-card .chart-body .data-table th[scope="col"]:last-child { border-radius: 0 6px 0 0; }
        .chart-card .chart-body .data-table td { padding: 0.625rem 0.75rem; border-bottom: 1px solid var(--border); vertical-align: middle; }
        .chart-card .chart-body .data-table tbody tr:hover { background: rgba(0,0,0,0.02); }
        .chart-card .chart-body .data-table tbody tr:last-child td { border-bottom: none; }
        .chart-card .chart-body .data-table th.num, .chart-card .chart-body .data-table td.num { text-align: right; }
        .chart-card .chart-footer { font-size: 0.875rem; font-weight: 400; color: var(--text-light); margin-top: 0.75rem; line-height: 1.4; }
        .chart-card .chart-footer a { color: var(--primary); text-decoration: underline; cursor: pointer; }
        .dashboard-charts-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: var(--space-md); margin-bottom: var(--space-lg); }
        
        /* Score Display */
        .score-banner {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            padding: var(--space-xl);
            border-radius: var(--radius-lg);
            text-align: center;
            margin: 2rem 0;
        }
        
        .score-value {
            font-size: 3rem;
            font-weight: bold;
            margin: 1rem 0;
        }
        
        .score-percentage {
            font-size: 1.5rem;
            opacity: 0.9;
        }
        
        /* Footer */
        footer {
            font-family: var(--body-font);
            background: var(--primary);
            color: white;
            padding: 2rem 0;
            margin-top: 3rem;
        }
        
        .footer-content {
            text-align: center;
        }
        
        .footer-links {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-bottom: 1rem;
        }
        
        .footer-links a {
            color: white !important;
            text-decoration: none;
            opacity: 0.8;
            transition: opacity 0.3s;
        }
        
        .footer-links a:hover {
            opacity: 1;
        }
        
        /* Ensure all footer text is white */
        footer p,
        footer #footerCopyright,
        footer #footerAdditional {
            color: white !important;
        }
        
        footer a {
            color: white !important;
        }
        
        /* Modal / Overlay */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        .modal-overlay[hidden] { display: none !important; }
        /* Apple HIG: Modals with proper elevation and spacing */
        .modal-box {
            background: var(--card);
            padding: var(--space-xl) var(--space-2xl);
            border-radius: var(--radius-lg);
            max-width: 440px;
            width: 100%;
            box-shadow: var(--elevation-4);
            border: 1px solid var(--border);
        }
        .modal-box h3 {
            margin: 0 0 0.75rem 0;
            font-size: 1.25rem;
            font-weight: 600;
            line-height: 1.35;
            color: var(--primary);
        }
        .modal-box p { margin: 0 0 1rem 0; font-size: 0.9375rem; font-weight: 400; color: var(--text-light); line-height: 1.5; }
        .modal-box .modal-actions { margin-top: 1.25rem; }
        .info-box {
            background: var(--bg-alt);
            border-left: 4px solid var(--primary);
            padding: 1rem 1.25rem;
            border-radius: 0 0.5rem 0.5rem 0;
            margin-bottom: 1.5rem;
            font-size: 0.9375rem;
            font-weight: 400;
            color: var(--text);
            line-height: 1.5;
        }
        .consent-toolbar {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            align-items: flex-end;
            margin-bottom: 1.5rem;
        }
        .consent-toolbar .form-group { margin-bottom: 0; }
        .consent-toolbar select {
            min-width: 240px;
            padding: 0.6rem 0.75rem;
        }
        .consent-actions {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        
        /* Utility Classes */
        .skip-link {
            position: absolute;
            top: -3rem;
            left: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--primary);
            color: white;
            text-decoration: none;
            font-weight: 600;
            z-index: 10002;
            border-radius: 0 0 0.5rem 0;
            transition: top 0.2s;
        }
        .skip-link:focus {
            top: 0;
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }
        /* Keyboard focus visible (accessibility): clear focus ring for interactive elements */
        button:focus-visible,
        .btn:focus-visible,
        a:focus-visible,
        [role="button"]:focus-visible,
        [role="tab"]:focus-visible {
            outline: 2px solid var(--focus-ring);
            outline-offset: var(--focus-ring-offset);
        }
        .hidden {
            display: none !important;
        }
        /* Screen reader only - visually hidden but accessible to assistive tech */
        .sr-only,
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
        
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        .text-center {
            text-align: center;
        }
        
        .mt-2 {
            margin-top: 2rem;
        }
        
        .mb-2 {
            margin-bottom: 2rem;
        }
        
        /* Apple HIG: Alert styles with semantic colors and proper contrast */
        .alert {
            padding: var(--space-md) var(--space-lg);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-md);
            border-left: 4px solid;
        }
        
        .alert-success {
            background: var(--success-bg);
            color: var(--success-text);
            border-color: var(--success-border);
        }
        
        .alert-error {
            background: var(--error-bg);
            color: var(--error-text);
            border-color: var(--error-border);
        }
        
        .alert-warning {
            background: var(--warning-bg);
            color: var(--warning-text);
            border-color: var(--warning-border);
        }
        
        .alert-info {
            background: var(--info-bg);
            color: var(--info-text);
            border-color: var(--info-border);
        }
        
        /* Responsive - Tablet and below */
        @media (max-width: 1200px) {
            .app-title h1 {
                font-size: 1.5rem;
            }
            .tagline {
                font-size: 0.85rem;
            }
            .nav-link {
                padding: var(--space-sm) var(--space-md);
                font-size: 0.875rem;
            }
            .nav-link .icon-with-text i {
                width: 0.875rem;
                height: 0.875rem;
            }
        }
        
        @media (max-width: 1024px) {
            .header-content {
                gap: var(--space-sm);
            }
            .logo {
                width: 60px;
                height: 60px;
            }
            .app-title h1 {
                font-size: 1.35rem;
            }
            .account-search-wrap {
                max-width: 240px;
                min-width: 150px;
                margin: 0 var(--space-sm);
            }
            nav {
                gap: var(--space-sm);
            }
            .nav-link {
                padding: var(--space-xs) var(--space-sm);
                font-size: 0.875rem;
            }
        }
        
        @media (max-width: 900px) {
            .logo-section {
                flex: 0 0 auto;
            }
            .app-title h1 {
                font-size: 1.2rem;
            }
            .account-search-wrap {
                max-width: 200px;
                min-width: 120px;
            }
            .nav-link span.icon-with-text {
                display: flex;
            }
            .nav-link .icon-with-text i {
                margin-right: 0.25rem;
            }
            .account-dropdown-trigger {
                padding: var(--space-xs) var(--space-sm);
                font-size: 0.875rem;
            }
        }
        
        /* Mobile */
        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                gap: 1rem;
                align-items: stretch;
            }
            
            .header-left {
                flex-direction: column;
                align-items: stretch;
                gap: 1rem;
            }
            
            .logo-section {
                justify-content: center;
            }
            
            .primary-nav {
                flex-wrap: wrap;
                justify-content: center;
                gap: var(--space-sm);
            }
            
            .search-wrapper {
                order: 3;
            }
            
            .account-search-wrap.search-expandable {
                position: fixed;
                top: var(--space-lg);
                left: var(--space-md);
                right: var(--space-md);
                max-width: none;
                min-width: 0;
                width: auto;
            }
            
            .nav-link {
                padding: var(--space-sm) var(--space-md);
            }
            
            .header-right {
                justify-content: center;
            }
            
            .classes-grid {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 480px) {
            .logo {
                width: 50px;
                height: 50px;
            }
            .app-title h1 {
                font-size: 1.1rem;
            }
            .nav-link {
                font-size: 0.8125rem;
                padding: var(--space-xs) var(--space-sm);
            }
        }
        
        /* Edit functionality animations */
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
        
        /* Auth / Login page – theme colors and logo */
        .auth-screen {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            padding: 1rem;
        }
        .auth-card {
            background: var(--card);
            padding: 2.5rem 3rem;
            border-radius: 1rem;
            max-width: 440px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.2);
            border: 2px solid var(--border);
        }
        .auth-card .auth-logo {
            width: 120px;
            height: 120px;
            margin: 0 auto 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            overflow: hidden;
            background: var(--card);
            border: 2px solid var(--border);
        }
        
        /* Dark mode auth logo background */
        :root[data-theme="dark"] .auth-card .auth-logo,
        .theme-option7-dark .auth-card .auth-logo {
            background: #1a1a1a;
            border-color: var(--border);
        }
        .auth-card         .auth-logo img {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Scale to fit without cropping */
            object-position: center;
            padding: 10%; /* Add padding so logo doesn't touch edges */
        }
        .auth-card h2 {
            font-family: var(--heading-font);
            color: var(--primary);
            margin: 0;
            font-size: 1.75rem;
        }
        .auth-card .auth-tagline {
            color: var(--text-light);
            margin: 0.35rem 0 0 0;
            font-size: 0.95rem;
        }
        .auth-card .form-group label { color: var(--text); }
        .auth-divider {
            text-align: center;
            color: var(--text-light);
            margin: 1.25rem 0;
            font-size: 0.9rem;
        }
        .auth-card .btn-demo {
            width: 100%;
            padding: 0.75rem;
            font-size: 1rem;
            background: var(--secondary);
            color: var(--text);
            border: 2px solid var(--border);
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s, border-color 0.2s;
        }
        .auth-card .btn-demo:hover {
            background: var(--accent);
            border-color: var(--primary);
            color: var(--primary-dark);
        }
        /* Full-page loading overlay until auth check completes */
        #authLoadingOverlay {
            position: fixed;
            inset: 0;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
        }
        #authLoadingOverlay.hidden { display: none; }
        #authLoadingOverlay .auth-loading-spinner {
            width: 48px;
            height: 48px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #authLoadingOverlay p { margin: 0; font-size: 1rem; font-weight: 500; }
        @media (prefers-reduced-motion: reduce) {
            #authLoadingOverlay .auth-loading-spinner { animation: none; border-top-color: white; opacity: 0.9; }
        }
        /* Typography: use global hierarchy for empty states */
        .empty-state .empty-state-title { font-size: var(--text-headline-size); font-weight: var(--text-headline-weight); margin-bottom: 0.35rem; color: var(--text); line-height: 1.35; }
        .empty-state .empty-state-desc { font-size: var(--text-caption-size); font-weight: 400; color: var(--text-light); margin-bottom: 1.25rem; line-height: 1.45; }
        .empty-state {
            text-align: center; padding: 2.5rem 1.5rem; max-width: 22rem; margin: 0 auto;
        }
        .empty-state .empty-state-icon { width: 2.5rem; height: 2.5rem; margin: 0 auto 1rem; color: var(--text-light); display: block; }
        .empty-state .empty-state-action { margin-top: 0.5rem; }

        /* Lucide icons inline with text */
        [data-lucide] { width: 1.1em; height: 1.1em; vertical-align: -0.2em; stroke-width: 2; flex-shrink: 0; }
        .icon-with-text { display: inline-flex; align-items: center; gap: 0.35em; }
        /* Keep icon+text buttons from looking lopsided (icon left, text right, centered) */
        button .icon-with-text,
        .btn .icon-with-text { display: inline-flex; align-items: center; gap: 0.35em; }
    </style>
</head>
<body>
    <!-- Loading overlay: shown until checkAuth() completes so login page doesn't flash during reload -->
    <div id="authLoadingOverlay" class="auth-loading-overlay">
        <div class="auth-loading-spinner" aria-hidden="true"></div>
        <p>Loading…</p>
    </div>
    <!-- Login/Register Screen: visible by default so we don't flash main app before checkAuth() -->
    <div id="authScreen" class="auth-screen">
        <div id="configMissingBanner" class="hidden" style="max-width: 28rem; margin: 0 auto 1rem; padding: 1rem; background: var(--error); color: #fff; border-radius: 8px; font-size: 0.9rem; text-align: center;">
            <strong>Supabase not configured.</strong> Login will not work until the server has <code>SUPABASE_URL</code> and <code>SUPABASE_ANON_KEY</code> set. On Render: Dashboard → your service → Environment → add these variables, then redeploy.
        </div>
        <div class="auth-card">
            <div style="text-align: center; margin-bottom: 2rem;">
                <div class="auth-logo"><img id="authLogoImg" src="assets/3d-logo-transparent.png" alt="SpeechGradebook" /></div>
                <h2><span class="icon-with-text"><i data-lucide="graduation-cap" style="width:1.25em;height:1.25em;"></i> SpeechGradebook</span></h2>
                <p class="auth-tagline">Instructor-Informed Speech Assessment</p>
            </div>
            
            <!-- Login Form -->
            <div id="loginFormDiv">
                <form id="loginForm">
                    <div class="form-group">
                        <label for="loginEmail">Email</label>
                        <input type="email" id="loginEmail" required placeholder="you@example.com">
                    </div>
                    <div class="form-group">
                        <label for="loginPassword">Password</label>
                        <input type="password" id="loginPassword" required placeholder="••••••••">
                    </div>
                    <button type="submit" style="width: 100%; padding: var(--space-md) var(--space-lg); font-size: 1rem;"><span class="icon-with-text"><i data-lucide="log-in"></i> Login</span></button>
                </form>
                <p class="auth-divider">or</p>
                <button type="button" class="btn-demo" onclick="enterDemoMode();"><span class="icon-with-text"><i data-lucide="play"></i> Try demo</span></button>
                <p class="text-caption" style="text-align: center; margin-top: 1.5rem;">
                    Don't have an account? <a href="#" onclick="showRegisterForm(); return false;" style="color: var(--primary); font-weight: 600;" class="icon-with-text"><i data-lucide="user-plus"></i> Create one</a>
                </p>
            </div>
            
            <!-- Register Form -->
            <div id="registerFormDiv" class="hidden">
                <h3 style="margin-bottom: 1.5rem; color: var(--text);"><span class="icon-with-text"><i data-lucide="user-plus"></i> Create your account</span></h3>
                <p id="registerNonInvitedHint" class="text-body-secondary" style="margin-bottom: var(--space-md); padding: var(--space-md); background: var(--bg-alt); border-radius: var(--radius-md);">
                    Without an invitation link, you must use a <strong>.edu</strong> email and your request will need approval by an administrator after you confirm your email.
                </p>
                <form id="registerForm">
                    <div class="form-group">
                        <label for="registerName">Full Name</label>
                        <input type="text" id="registerName" required placeholder="John Doe">
                    </div>
                    <div class="form-group">
                        <label for="registerEmail">Email</label>
                        <input type="email" id="registerEmail" required placeholder="you@university.edu">
                        <small id="registerEmailHint" style="color: var(--text-light);">Use a .edu address if you don’t have an invitation.</small>
                    </div>
                    <div class="form-group" id="registerRoleGroup">
                        <label for="registerRole">Requested role</label>
                        <select id="registerRole" required>
                            <option value="instructor">Instructor</option>
                            <option value="admin">Admin</option>
                        </select>
                        <small style="color: var(--text-light);">Non-invited accounts require administrator approval.</small>
                    </div>
                    <div class="form-group">
                        <label for="registerPassword">Password</label>
                        <input type="password" id="registerPassword" required placeholder="••••••••" minlength="6">
                        <small style="color: var(--text-light);">At least 6 characters</small>
                    </div>
                    <button type="submit" style="width: 100%; padding: var(--space-md) var(--space-lg); font-size: 1rem;"><span class="icon-with-text"><i data-lucide="user-plus"></i> Create Account</span></button>
                </form>
                <p style="text-align: center; margin-top: 1.5rem; color: var(--text-light);">
                    Already have an account? <a href="#" onclick="showLoginForm(); return false;" class="text-caption icon-with-text" style="color: var(--primary); font-weight: 600;"><i data-lucide="log-in"></i> Login</a>
                </p>
            </div>
        </div>
    </div>

    <!-- Pending approval: shown when user is logged in but approval_status = pending_approval -->
    <div id="pendingApprovalScreen" style="display: none; min-height: 100vh; align-items: center; justify-content: center; padding: var(--space-lg);" class="auth-screen">
        <div class="auth-card" style="max-width: 28rem; width: 100%;">
            <h3 style="margin-bottom: var(--space-lg); color: var(--text); font-size: var(--text-title-size); font-weight: var(--text-title-weight); font-family: var(--heading-font); line-height: 1.3;">
                <span class="icon-with-text"><i data-lucide="clock"></i> Account pending approval</span>
            </h3>
            <div style="background: var(--info-bg); border: 1px solid var(--info-border); border-radius: var(--radius-md); padding: var(--space-md); margin-bottom: var(--space-lg); box-shadow: var(--elevation-1);">
                <p style="color: var(--info-text); margin: 0; font-size: var(--text-body-size); line-height: 1.6; font-family: var(--body-font);">
                    <strong style="font-weight: 600;">Your account is pending approval.</strong> You'll receive an email within 24 hours when your account has been approved by an administrator.
                </p>
            </div>
            <p style="color: var(--text-secondary); margin-bottom: var(--space-lg); font-size: var(--text-body-size); line-height: 1.6; font-family: var(--body-font);">
                Please confirm your email address (check your inbox) if you haven't already. Once your account is approved, you'll be able to access SpeechGradebook.
            </p>
            <div style="display: flex; flex-direction: column; gap: var(--space-md);">
                <button type="button" onclick="logout(); return false;" class="btn" style="width: 100%; min-height: 2.75rem; padding: var(--space-sm) var(--space-lg); font-size: var(--text-body-size); font-weight: 500; font-family: var(--body-font); transition: all var(--motion-normal) var(--motion-ease);">
                    <span class="icon-with-text"><i data-lucide="log-out"></i> Logout</span>
                </button>
                <a href="mailto:support@speechgradebook.com" 
                   style="text-align: center; color: var(--link); text-decoration: none; font-size: var(--text-body-size); padding: var(--space-sm) var(--space-md); border-radius: var(--radius-md); min-height: 2.75rem; display: flex; align-items: center; justify-content: center; transition: all var(--motion-normal) var(--motion-ease); font-family: var(--body-font);" 
                   onmouseover="this.style.backgroundColor='var(--bg-hover)'; this.style.textDecoration='underline'" 
                   onmouseout="this.style.backgroundColor='transparent'; this.style.textDecoration='none'"
                   onfocus="this.style.outline='2px solid var(--focus-ring)'; this.style.outlineOffset='var(--focus-ring-offset)'"
                   onblur="this.style.outline='none'">
                    <span class="icon-with-text"><i data-lucide="mail"></i> Contact administrator</span>
                </a>
            </div>
        </div>
    </div>

    <!-- Main App: hidden until checkAuth() confirms session -->
    <div id="mainApp" style="display: none;">
    <a href="#main-content" class="skip-link">Skip to main content</a>
    <!-- Covers main app until tier/theme/interface load (prevents flash of wrong theme or courses) -->
    <div id="mainAppLoadingOverlay" style="display: none; position: fixed; inset: 0; background: var(--bg, #1a1a2e); z-index: 9998; align-items: center; justify-content: center; flex-direction: column; gap: 1rem;">
        <div class="auth-loading-spinner" aria-hidden="true"></div>
        <p style="color: var(--text-light, #94a3b8); font-size: 1rem;">Loading…</p>
    </div>
    <!-- One-time instructor LLM consent (user agreement style) -->
    <div id="instructorConsentOverlay" class="modal-overlay" hidden>
        <div class="modal-box">
            <h3>Data use agreement</h3>
            <p>Your evaluation content may be used to improve the speech assessment model. This supports research and product improvement while keeping data anonymized where used for training.</p>
            <label style="display: flex; align-items: flex-start; gap: 0.5rem; cursor: pointer; margin-bottom: 1rem;">
                <input type="checkbox" id="instructorConsentCheckbox" style="margin-top: 0.2rem;">
                <span class="text-body-secondary">I agree that my evaluation content may be used for LLM training and research.</span>
            </label>
            <div class="modal-actions">
                <button type="button" id="instructorConsentSubmit" disabled class="btn">Continue</button>
            </div>
        </div>
    </div>
    <header>
        <div class="container">
            <div class="header-content">
                <!-- Left Section: Logo + Navigation -->
                <div class="header-left">
                    <div class="logo-section">
                        <div class="logo" id="appLogo" style="background-color: #ffffff;"><img src="assets/3d-logo-transparent.png" alt="SpeechGradebook" style="width: 100%; height: 100%; object-fit: contain; object-position: center; border-radius: 50%; padding: 12%;"></div>
                        <div class="app-title">
                            <h1 id="appName">SpeechGradebook</h1>
                            <div class="tagline" id="appTagline">Instructor-Informed Speech Assessment</div>
                        </div>
                    </div>
                    <!-- Primary Navigation: Core workflows -->
                    <nav class="primary-nav">
                        <a href="#" class="nav-link active" id="navDashboard" onclick="showDashboard(); return false;"><span class="icon-with-text"><i data-lucide="layout-dashboard"></i> Dashboard</span></a>
                        <a href="#" class="nav-link" id="navEvaluate" onclick="showEvaluate(); return false;"><span class="icon-with-text"><i data-lucide="mic"></i> Evaluate Speech</span></a>
                    </nav>
                </div>
                
                <!-- Right Section: Search and Account Menu -->
                <div class="header-right">
                    <!-- Expandable Search: Icon-triggered -->
                    <div class="search-wrapper">
                        <button class="search-icon-button" id="searchIconButton" onclick="toggleSearch(); return false;" aria-label="Search" aria-expanded="false">
                            <i data-lucide="search"></i>
                        </button>
                        <div id="accountSearchWrap" class="account-search-wrap search-expandable hidden">
                            <input type="text" id="accountSearchInput" placeholder="Search" 
                                   class="account-search-input"
                                   aria-label="Search courses, students, rubrics, and instructors" autocomplete="off">
                            <div id="accountSearchResults" class="account-search-results hidden" role="listbox" aria-label="Search results"></div>
                        </div>
                    </div>
                    
                    <!-- Account Dropdown -->
                    <div class="account-dropdown-wrapper">
                        <button class="account-dropdown-trigger" id="accountDropdownTrigger" onclick="toggleAccountDropdown(); return false;" aria-label="Account menu" aria-expanded="false" title="Account menu">
                            <!-- Apple HIG recommends user icon for account menus (hamburger is for navigation) -->
                            <i data-lucide="user" class="account-icon"></i>
                            <!-- Keep userDisplay hidden but available for screen readers -->
                            <span id="userDisplay" class="visually-hidden"></span>
                        </button>
                        <div class="account-dropdown-menu hidden" id="accountDropdownMenu" role="menu">
                            <div class="dropdown-header">
                                <span id="userDisplayDropdown" class="dropdown-user-name"></span>
                            </div>
                            <div class="dropdown-divider"></div>
                            <a href="#" class="dropdown-item" onclick="showSettings(); closeAccountDropdown(); return false;" role="menuitem">
                                <i data-lucide="settings"></i> Settings
                            </a>
                            <a href="#" class="dropdown-item" onclick="showHelp(); closeAccountDropdown(); return false;" role="menuitem">
                                <i data-lucide="help-circle"></i> Support
                            </a>
                            <div class="dropdown-divider"></div>
                            <a href="#" class="dropdown-item dropdown-item-logout" id="logoutLink" onclick="logout(); return false;" role="menuitem">
                                <i data-lucide="log-out"></i> Logout
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </header>
    <main id="main-content" class="container" tabindex="-1" style="margin-top: 0 !important; padding-top: 0 !important;">
        <!-- Evaluate Section -->
        <section id="evaluateSection" class="section" aria-label="Evaluate a speech">
            <div class="card">
                <div class="card-header" id="evaluateCardHeader"><span class="icon-with-text"><i data-lucide="mic"></i> Evaluate a Speech</span></div>
                
                <div class="progress-steps">
                    <div class="step active" id="step1">
                        <div class="step-circle">1</div>
                        <div class="step-label">Upload</div>
                    </div>
                    <div class="step" id="step2">
                        <div class="step-circle">2</div>
                        <div class="step-label">Details</div>
                    </div>
                    <div class="step" id="step3">
                        <div class="step-circle">3</div>
                        <div class="step-label">Evaluate</div>
                    </div>
                    <div class="step" id="step4">
                        <div class="step-circle">4</div>
                        <div class="step-label">Results</div>
                    </div>
                </div>

                <!-- Step 1: Upload -->
                <div id="uploadStep">
                    <!-- Upload Mode Toggle -->
                    <div style="display: flex; gap: 1rem; margin-bottom: 1.5rem; padding: 0.75rem; background: var(--bg-alt); border-radius: 0.5rem; border: 1px solid var(--border);">
                        <button type="button" id="singleUploadModeBtn" onclick="switchUploadMode('single')" class="btn" style="flex: 1; padding: 0.75rem 1rem; background: var(--primary); color: white; border: none; border-radius: 0.375rem; font-weight: 500; cursor: pointer;">
                            <span class="icon-with-text"><i data-lucide="upload"></i> Single Upload</span>
                        </button>
                        <button type="button" id="bulkUploadModeBtn" onclick="switchUploadMode('bulk')" class="btn-secondary" style="flex: 1; padding: 0.75rem 1rem; background: var(--card); color: var(--text); border: 1px solid var(--border); border-radius: 0.375rem; font-weight: 500; cursor: pointer;">
                            <span class="icon-with-text"><i data-lucide="folder-up"></i> Bulk Upload</span>
                        </button>
                    </div>

                    <!-- Single Upload Mode -->
                    <div id="singleUploadMode" class="upload-mode">
                        <div class="upload-zone" id="uploadZone">
                            <div class="upload-icon"><i data-lucide="upload" style="width:3rem;height:3rem;"></i></div>
                            <h3><span class="icon-with-text"><i data-lucide="mic"></i> Upload Speech Recording</span></h3>
                            <p>Click or drag & drop your audio/video file here</p>
                        <div style="background: var(--bg-alt); border: 1px solid var(--border); border-radius: 0.5rem; padding: 1rem; margin-top: 1rem;">
                            <p style="color: var(--text); font-size: 0.9rem; margin: 0 0 0.5rem 0; font-weight: 500;">
                                <i data-lucide="info" style="width:16px;height:16px;vertical-align:middle;margin-right:0.25rem;"></i> Supported Formats
                            </p>
                            <p style="color: var(--text-light); font-size: 0.875rem; margin: 0 0 0.75rem 0;">
                                Video: MP4, WebM, MOV, AVI, MKV<br>
                                Audio: MP3, WAV, M4A
                            </p>
                            <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.75rem; background: white; border: 2px solid var(--primary); border-radius: 0.375rem; margin-top: 0.5rem;">
                                <i data-lucide="alert-triangle" style="width:20px;height:20px;color:var(--primary);flex-shrink:0;"></i>
                                <div style="flex: 1;">
                                    <strong style="color: var(--primary); font-size: 0.9375rem;">Maximum file size: 50 MB</strong>
                                    <p style="color: var(--text-light); font-size: 0.8125rem; margin: 0.25rem 0 0 0;">
                                        Files over 50 MB will be automatically compressed. Very large files may take longer to process.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                        <input type="file" id="fileInput" accept="audio/*,video/*,image/*" style="display: none;">
                        <div id="fileInfo" class="file-info hidden">
                            <span id="fileName"></span>
                            <button onclick="removeFile()" class="btn-small btn-danger"><span class="icon-with-text"><i data-lucide="trash-2"></i> Remove</span></button>
                        </div>
                        
                        <!-- Optional: Assign to class/student on upload -->
                        <div id="continueButtonContainer" style="margin-top: 2rem; display: none;">
                            <button onclick="moveToStep(2)" id="continueToDetails"><span class="icon-with-text">Continue to Details <i data-lucide="arrow-right"></i></span></button>
                        </div>
                    </div>

                    <!-- Bulk Upload Mode -->
                    <div id="bulkUploadMode" class="upload-mode hidden">
                        <div style="background: var(--card); border: 1px solid var(--border); border-radius: 0.75rem; padding: 1.5rem; margin-bottom: 1.5rem;">
                            <h3 style="margin-top: 0; margin-bottom: 1rem; color: var(--primary);"><span class="icon-with-text"><i data-lucide="folder-up"></i> Bulk Upload Multiple Videos</span></h3>
                            <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">Upload multiple student videos at once. You'll match each video to a student before processing.</p>
                            
                            <!-- Bulk Upload Form Fields -->
                            <div class="form-group" style="margin-bottom: 1rem;">
                                <label for="bulkCourseSelect" class="required">Course</label>
                                <select id="bulkCourseSelect" required onchange="handleBulkCourseChange();" style="width: 100%; padding: 0.75rem; border: 2px solid var(--border); border-radius: 0.5rem; font-size: 1rem;">
                                    <option value="">-- Select Course --</option>
                                </select>
                                <p class="field-hint" style="margin-top: 0.5rem; color: var(--text-light); font-size: 0.875rem;">Select the course for all videos in this batch.</p>
                            </div>

                            <div class="form-group" style="margin-bottom: 1rem;">
                                <label for="bulkRubricSelect" class="required">Evaluation Rubric</label>
                                <select id="bulkRubricSelect" required onchange="validateBulkUploadForm();" style="width: 100%; padding: 0.75rem; border: 2px solid var(--border); border-radius: 0.5rem; font-size: 1rem;">
                                    <option value="">-- Select a Rubric --</option>
                                </select>
                                <p class="field-hint" style="margin-top: 0.5rem; color: var(--text-light); font-size: 0.875rem;">All videos will be evaluated using this rubric.</p>
                            </div>

                            <div class="form-group" style="margin-bottom: 1rem;">
                                <label for="bulkAssignmentType">Assignment Type</label>
                                <select id="bulkAssignmentType" onchange="validateBulkUploadForm(); updateBulkMatchingInterface();" style="width: 100%; padding: 0.75rem; border: 2px solid var(--border); border-radius: 0.5rem; font-size: 1rem;">
                                    <option value="Speech">Speech</option>
                                    <option value="Presentation">Presentation</option>
                                    <option value="Group Presentation">Group Presentation</option>
                                    <option value="Informative Speech">Informative Speech</option>
                                    <option value="Persuasive Speech">Persuasive Speech</option>
                                    <option value="Demonstration Speech">Demonstration Speech</option>
                                    <option value="Special Occasion Speech">Special Occasion Speech</option>
                                    <option value="Other">Other</option>
                                </select>
                                <p class="field-hint" style="margin-top: 0.5rem; color: var(--text-light); font-size: 0.875rem;">The assignment type for all videos in this batch. You can process different assignments in separate batches.</p>
                            </div>
                            
                            <div style="background: var(--info-bg); border-left: 4px solid var(--info); padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem;">
                                <p style="margin: 0; color: var(--info-text); font-size: 0.875rem;">
                                    <strong>💡 Tip:</strong> If you have videos for multiple assignments, process them in separate batches. Upload all videos for one assignment type (e.g., all Informative Speeches), match them to students, then process. Repeat for each assignment type.
                                </p>
                            </div>
                        </div>

                        <!-- Bulk File Upload Zone -->
                        <div class="upload-zone" id="bulkUploadZone" style="border: 2px dashed var(--border); border-radius: 0.75rem; padding: 2rem; text-align: center; background: var(--bg-alt); cursor: pointer; transition: all 0.2s;" onmouseover="this.style.borderColor='var(--primary)'; this.style.background='var(--card)'" onmouseout="this.style.borderColor='var(--border)'; this.style.background='var(--bg-alt)'">
                            <div class="upload-icon"><i data-lucide="folder-up" style="width:3rem;height:3rem;color:var(--primary);"></i></div>
                            <h3 style="margin: 1rem 0 0.5rem 0;"><span class="icon-with-text"><i data-lucide="video"></i> Upload Multiple Videos</span></h3>
                            <p style="color: var(--text-secondary); margin-bottom: 1rem;">Click or drag & drop multiple video files here</p>
                            <p style="color: var(--text-light); font-size: 0.875rem; margin: 0;">You can select multiple files at once</p>
                            <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border);">
                                <p style="color: var(--text-secondary); font-size: 0.875rem; margin-bottom: 0.5rem;"><strong>Or upload organized folders:</strong></p>
                                <p style="color: var(--text-light); font-size: 0.8125rem; margin: 0;">If you have folders organized by student (each folder contains multiple videos), you can upload the entire folder structure</p>
                            </div>
                        </div>
                        <input type="file" id="bulkFileInput" multiple accept="video/*,audio/*" style="display: none;">
                        <input type="file" id="bulkFolderInput" webkitdirectory directory multiple style="display: none;">
                        <div style="margin-top: 1rem; display: flex; gap: 0.5rem; justify-content: center;">
                            <button type="button" onclick="document.getElementById('bulkFileInput').click()" class="btn-secondary" style="padding: 0.75rem 1.5rem;"><span class="icon-with-text"><i data-lucide="file"></i> Select Files</span></button>
                            <button type="button" onclick="document.getElementById('bulkFolderInput').click()" class="btn-secondary" style="padding: 0.75rem 1.5rem;"><span class="icon-with-text"><i data-lucide="folder"></i> Select Folder</span></button>
                        </div>
                        <div id="bulkFileInfo" style="margin-top: 1rem; display: none;">
                            <div style="background: var(--card); border: 1px solid var(--border); border-radius: 0.5rem; padding: 1rem;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                                    <strong style="color: var(--text);"><span id="bulkFileCount">0</span> file(s) selected</strong>
                                    <button onclick="clearBulkFiles()" class="btn-small btn-danger" style="padding: 0.5rem 1rem; font-size: 0.875rem;"><span class="icon-with-text"><i data-lucide="trash-2"></i> Clear All</span></button>
                                </div>
                                <div id="bulkFileList" style="max-height: 200px; overflow-y: auto;"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Bulk Upload: Student Matching Step -->
                <div id="bulkMatchingStep" class="hidden">
                    <div style="background: var(--card); border: 1px solid var(--border); border-radius: 0.75rem; padding: 1.5rem; margin-bottom: 1.5rem;">
                        <h3 style="margin-top: 0; margin-bottom: 0.5rem; color: var(--primary);"><span class="icon-with-text"><i data-lucide="users"></i> Match Videos to Students</span></h3>
                        <p style="color: var(--text-secondary); margin-bottom: 1rem;">Select the student for each video. All videos will be processed with the same rubric and assignment type.</p>
                        
                        <div id="bulkMatchingTableContainer" style="overflow-x: auto;">
                            <table id="bulkMatchingTable" style="width: 100%; border-collapse: collapse; margin-top: 1rem;">
                                <thead>
                                    <tr style="background: var(--bg-alt); border-bottom: 2px solid var(--border);">
                                        <th style="padding: 0.75rem; text-align: left; font-weight: 600; color: var(--text);">Video File</th>
                                        <th style="padding: 0.75rem; text-align: left; font-weight: 600; color: var(--text);">Size</th>
                                        <th style="padding: 0.75rem; text-align: left; font-weight: 600; color: var(--text);">Student <span style="color: var(--error);">*</span></th>
                                        <th style="padding: 0.75rem; text-align: left; font-weight: 600; color: var(--text);">Status</th>
                                        <th style="padding: 0.75rem; text-align: center; font-weight: 600; color: var(--text);">Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="bulkMatchingTableBody">
                                    <!-- Rows will be populated by JavaScript -->
                                </tbody>
                            </table>
                        </div>
                        
                        <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid var(--border); display: flex; gap: 1rem; justify-content: flex-end;">
                            <button type="button" onclick="switchUploadMode('bulk'); document.getElementById('bulkMatchingStep').classList.add('hidden');" class="btn-secondary"><span class="icon-with-text"><i data-lucide="arrow-left"></i> Back</span></button>
                            <button type="button" id="startBulkProcessingBtn" onclick="startBulkProcessing()" class="btn" disabled><span class="icon-with-text">Start Processing <i data-lucide="play"></i></span></button>
                        </div>
                    </div>
                </div>

                <!-- Bulk Upload: Processing Step -->
                <div id="bulkProcessingStep" class="hidden">
                    <div style="background: var(--card); border: 1px solid var(--border); border-radius: 0.75rem; padding: 1.5rem;">
                        <h3 style="margin-top: 0; margin-bottom: 1rem; color: var(--primary);"><span class="icon-with-text"><i data-lucide="loader"></i> Processing Videos</span></h3>
                        
                        <!-- Overall Progress -->
                        <div style="margin-bottom: 1.5rem;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                                <span style="font-weight: 600; color: var(--text);">Overall Progress</span>
                                <span id="bulkOverallProgress" style="color: var(--text-secondary);">0 of 0</span>
                            </div>
                            <div style="width: 100%; height: 8px; background: var(--bg-alt); border-radius: 4px; overflow: hidden;">
                                <div id="bulkOverallProgressBar" style="height: 100%; background: var(--primary); width: 0%; transition: width 0.3s;"></div>
                            </div>
                        </div>

                        <!-- Current Video Status -->
                        <div id="bulkCurrentVideoStatus" style="background: var(--bg-alt); padding: 1rem; border-radius: 0.5rem; margin-bottom: 1.5rem; display: none;">
                            <div style="display: flex; align-items: center; gap: 0.75rem;">
                                <div class="spinner" style="width: 20px; height: 20px;"></div>
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; color: var(--text);" id="bulkCurrentVideoName">Processing...</div>
                                    <div style="font-size: 0.875rem; color: var(--text-light);" id="bulkCurrentVideoMessage">Starting evaluation...</div>
                                </div>
                            </div>
                        </div>

                        <!-- Video List with Status -->
                        <div style="max-height: 400px; overflow-y: auto;">
                            <table style="width: 100%; border-collapse: collapse;">
                                <thead style="position: sticky; top: 0; background: var(--card); z-index: 10;">
                                    <tr style="border-bottom: 2px solid var(--border);">
                                        <th style="padding: 0.75rem; text-align: left; font-weight: 600; color: var(--text); font-size: 0.875rem;">Video</th>
                                        <th style="padding: 0.75rem; text-align: left; font-weight: 600; color: var(--text); font-size: 0.875rem;">Student</th>
                                        <th style="padding: 0.75rem; text-align: center; font-weight: 600; color: var(--text); font-size: 0.875rem;">Status</th>
                                    </tr>
                                </thead>
                                <tbody id="bulkProcessingTableBody">
                                    <!-- Rows will be populated by JavaScript -->
                                </tbody>
                            </table>
                        </div>

                        <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid var(--border); display: flex; justify-content: flex-end;">
                            <button type="button" id="cancelBulkProcessingBtn" onclick="cancelBulkProcessing()" class="btn-secondary"><span class="icon-with-text"><i data-lucide="x"></i> Cancel</span></button>
                        </div>
                    </div>
                </div>

                <!-- Bulk Upload: Completion Summary -->
                <div id="bulkCompletionStep" class="hidden">
                    <div style="background: var(--card); border: 1px solid var(--border); border-radius: 0.75rem; padding: 1.5rem;">
                        <h3 style="margin-top: 0; margin-bottom: 1rem; color: var(--primary);"><span class="icon-with-text"><i data-lucide="check-circle"></i> Processing Complete</span></h3>
                        
                        <div id="bulkCompletionSummary" style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-alt); border-radius: 0.5rem;">
                            <div style="display: flex; gap: 2rem; flex-wrap: wrap;">
                                <div>
                                    <div style="font-size: 2rem; font-weight: 700; color: var(--success);" id="bulkSuccessCount">0</div>
                                    <div style="color: var(--text-secondary); font-size: 0.875rem;">Successful</div>
                                </div>
                                <div>
                                    <div style="font-size: 2rem; font-weight: 700; color: var(--error);" id="bulkErrorCount">0</div>
                                    <div style="color: var(--text-secondary); font-size: 0.875rem;">Failed</div>
                                </div>
                                <div>
                                    <div style="font-size: 2rem; font-weight: 700; color: var(--text);" id="bulkTotalCount">0</div>
                                    <div style="color: var(--text-secondary); font-size: 0.875rem;">Total</div>
                                </div>
                            </div>
                        </div>

                        <div style="margin-bottom: 1rem; display: flex; gap: 1rem; justify-content: flex-end;">
                            <button type="button" onclick="removeFailedBulkEvaluations()" class="btn-secondary" style="font-size: 0.875rem;"><span class="icon-with-text"><i data-lucide="x-circle"></i> Remove Failed</span></button>
                            <button type="button" onclick="selectAllBulkEvaluations()" class="btn-secondary" style="font-size: 0.875rem;"><span class="icon-with-text"><i data-lucide="check-square"></i> Select All</span></button>
                            <button type="button" id="bulkMoveSelectedBtn" onclick="openBulkMoveModal()" class="btn" disabled><span class="icon-with-text"><i data-lucide="move"></i> Move Selected</span></button>
                        </div>

                        <div style="overflow-x: auto; max-height: 500px; overflow-y: auto;">
                            <table style="width: 100%; border-collapse: collapse;">
                                <thead style="position: sticky; top: 0; background: var(--card); z-index: 10;">
                                    <tr style="border-bottom: 2px solid var(--border); background: var(--bg-alt);">
                                        <th style="padding: 0.75rem; text-align: center; width: 40px;"><input type="checkbox" id="bulkSelectAllCheckbox" onchange="toggleAllBulkEvaluations(this.checked)"></th>
                                        <th style="padding: 0.75rem; text-align: left; font-weight: 600; color: var(--text);">Video File</th>
                                        <th style="padding: 0.75rem; text-align: left; font-weight: 600; color: var(--text);">Student</th>
                                        <th style="padding: 0.75rem; text-align: center; font-weight: 600; color: var(--text);">Status</th>
                                        <th style="padding: 0.75rem; text-align: center; font-weight: 600; color: var(--text);">Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="bulkCompletionTableBody">
                                    <!-- Rows will be populated by JavaScript -->
                                </tbody>
                            </table>
                        </div>

                        <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid var(--border); display: flex; gap: 1rem; justify-content: flex-end;">
                            <button type="button" onclick="resetBulkUpload()" class="btn-secondary"><span class="icon-with-text"><i data-lucide="refresh-cw"></i> Upload More</span></button>
                            <button type="button" onclick="showDashboard()" class="btn"><span class="icon-with-text">View Dashboard <i data-lucide="arrow-right"></i></span></button>
                        </div>
                    </div>
                </div>

                <!-- Step 2: Details -->
                <div id="detailsStep" class="hidden">
                    <form id="studentForm">
                        <div class="form-group optional">
                            <label for="evalClassSelect">Class</label>
                            <select id="evalClassSelect" onchange="loadEvalStudents(); updateRubricSelectorForClass(); validateEvalForm();">
                                <option value="">-- None --</option>
                                <option value="other">Other</option>
                            </select>
                            <p class="field-hint">
                                Select a class to assign this evaluation, or choose "None" if not applicable.
                            </p>
                            <div class="field-error" id="evalClassSelect-error">
                                <i data-lucide="alert-circle"></i>
                                <span></span>
                            </div>
                        </div>
                        <div class="form-group optional">
                            <label for="evalStudentSelect">Student</label>
                            <select id="evalStudentSelect" onchange="validateEvalForm();">
                                <option value="">-- None --</option>
                            </select>
                            <p class="field-hint">
                                Select a student from the chosen class, or choose "None" if not applicable.
                            </p>
                            <div class="field-error" id="evalStudentSelect-error">
                                <i data-lucide="alert-circle"></i>
                                <span></span>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="rubricSelect" class="required">Evaluation Rubric</label>
                            <div style="display: flex; gap: 0.5rem; align-items: flex-start;">
                                <select id="rubricSelect" required onchange="validateEvalForm(); updateRubricPreview(); saveLastUsedRubric();" style="flex: 1;">
                                    <option value="">-- Select a Rubric --</option>
                                </select>
                                <button type="button" id="previewRubricBtn" onclick="previewSelectedRubric()" class="btn-secondary" style="padding: 0.75rem 1rem; white-space: nowrap; opacity: 0.6; cursor: not-allowed;" disabled title="Select a rubric to preview">
                                    <i data-lucide="eye" style="width:16px;height:16px;"></i> Preview
                                </button>
                            </div>
                            <p class="field-hint">
                                Choose which rubric to use for evaluation. <a href="#" onclick="showDashboard(); return false;" style="color: var(--primary);">Manage rubrics</a>
                            </p>
                            <div class="field-error" id="rubricSelect-error">
                                <i data-lucide="alert-circle"></i>
                                <span>Please select a rubric to continue.</span>
                            </div>
                        </div>
                        <div class="form-group optional">
                            <label for="speechDate">Speech Date</label>
                            <input type="date" id="speechDate" onchange="validateEvalForm();">
                            <p class="field-hint">
                                The date when the speech was delivered.
                            </p>
                        </div>
                        <div class="form-group optional">
                            <label for="assignmentType">Assignment Type</label>
                            <select id="assignmentType" onchange="validateEvalForm();">
                                <option value="Speech">Speech</option>
                                <option value="Presentation">Presentation</option>
                                <option value="Group Presentation">Group Presentation</option>
                                <option value="Other">Other</option>
                            </select>
                            <p class="field-hint">
                                The type of assignment being evaluated.
                            </p>
                        </div>
                        <div style="display: flex; gap: 1rem;">
                            <button type="button" onclick="moveToStep(1)" class="btn-secondary"><span class="icon-with-text"><i data-lucide="arrow-left"></i> Back</span></button>
                            <button type="submit" id="submitEvaluationBtn"><span class="icon-with-text">Continue to Evaluation <i data-lucide="arrow-right"></i></span></button>
                        </div>
                    </form>
                </div>

                <!-- Step 3: Processing - Apple HIG: Clear loading state with feedback -->
                <div id="processingStep" class="hidden loading-state">
                    <div class="spinner" aria-label="Loading"></div>
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 var(--space-sm) 0; color: var(--text);">
                            <span class="icon-with-text"><i data-lucide="loader"></i> Evaluating Speech</span>
                        </h3>
                        <p id="processingMessage" class="loading-state-message">Analyzing content and delivery</p>
                        <p id="processingSubmessage" class="loading-state-submessage" style="display: none;"></p>
                        <div id="processingStages" style="margin-top: 1.5rem; display: none;">
                            <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                                <div class="processing-stage" data-stage="upload" style="display: flex; align-items: center; gap: 0.75rem; padding: 0.75rem; background: var(--bg-alt); border-radius: 0.5rem; opacity: 0.5;">
                                    <i data-lucide="upload" style="width:18px;height:18px;flex-shrink:0;"></i>
                                    <span style="flex: 1;">Uploading file</span>
                                    <i data-lucide="check" class="stage-complete" style="width:18px;height:18px;display:none;color:var(--success);"></i>
                                </div>
                                <div class="processing-stage" data-stage="transcribe" style="display: flex; align-items: center; gap: 0.75rem; padding: 0.75rem; background: var(--bg-alt); border-radius: 0.5rem; opacity: 0.5;">
                                    <i data-lucide="file-text" style="width:18px;height:18px;flex-shrink:0;"></i>
                                    <span style="flex: 1;">Transcribing speech</span>
                                    <i data-lucide="check" class="stage-complete" style="width:18px;height:18px;display:none;color:var(--success);"></i>
                                </div>
                                <div class="processing-stage" data-stage="analyze" style="display: flex; align-items: center; gap: 0.75rem; padding: 0.75rem; background: var(--bg-alt); border-radius: 0.5rem; opacity: 0.5;">
                                    <i data-lucide="brain" style="width:18px;height:18px;flex-shrink:0;"></i>
                                    <span style="flex: 1;">Analyzing content and delivery</span>
                                    <i data-lucide="check" class="stage-complete" style="width:18px;height:18px;display:none;color:var(--success);"></i>
                                </div>
                                <div class="processing-stage" data-stage="score" style="display: flex; align-items: center; gap: 0.75rem; padding: 0.75rem; background: var(--bg-alt); border-radius: 0.5rem; opacity: 0.5;">
                                    <i data-lucide="award" style="width:18px;height:18px;flex-shrink:0;"></i>
                                    <span style="flex: 1;">Calculating scores</span>
                                    <i data-lucide="check" class="stage-complete" style="width:18px;height:18px;display:none;color:var(--success);"></i>
                                </div>
                            </div>
                        </div>
                        <div id="processingETA" style="margin-top: 1rem; color: var(--text-light); font-size: 0.875rem; display: none;">
                            Estimated time remaining: <span id="processingETAText">Calculating...</span>
                        </div>
                    </div>
                    <div id="uploadProgressContainer" style="margin-top: var(--space-lg); max-width: 500px; width: 100%; display: none; padding: var(--space-md); background: var(--card); border: 1px solid var(--border); border-radius: var(--radius-lg); box-shadow: var(--elevation-1);">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: var(--space-sm);">
                            <span id="uploadProgressText" style="font-size: var(--text-body-size); font-weight: 500; color: var(--text); font-family: var(--body-font);">Uploading file</span>
                            <span id="uploadProgressPercent" style="font-size: var(--text-body-size); color: var(--primary); font-weight: 600; font-family: var(--body-font);">0%</span>
                        </div>
                        <div style="background: var(--bg-alt); height: 8px; border-radius: var(--radius-sm); overflow: hidden; position: relative;">
                            <div id="uploadProgressBar" style="width: 0%; height: 100%; background: linear-gradient(90deg, var(--primary), var(--primary-dark)); transition: width var(--motion-normal) var(--motion-ease); border-radius: var(--radius-sm); position: relative;">
                                <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent); animation: shimmer 2s infinite; pointer-events: none;"></div>
                            </div>
                        </div>
                        <div id="uploadProgressDetails" style="display: flex; justify-content: space-between; align-items: center; margin-top: var(--space-sm); font-size: var(--text-caption-size); color: var(--text-light); font-family: var(--body-font); line-height: 1.5; flex-wrap: wrap; gap: var(--space-xs);">
                            <span id="uploadProgressMB" style="flex: 1; min-width: 120px;">0 MB / 0 MB</span>
                            <span id="uploadProgressSpeed" style="display: none; margin-left: var(--space-sm);"></span>
                            <span id="uploadProgressETA" style="display: none; margin-left: var(--space-sm);"></span>
                        </div>
                    </div>
                    <div style="margin-top: var(--space-xl); display: flex; justify-content: center;">
                        <button onclick="confirmCancelEvaluation()" class="btn-secondary" id="cancelEvaluationBtn" style="padding: 0.75rem 1.5rem; font-size: 0.9375rem; background: var(--error-bg); color: var(--error); border: 1px solid var(--error-border);"><span class="icon-with-text"><i data-lucide="x"></i> Cancel Evaluation</span></button>
                    </div>
                </div>

                <!-- Step 4: Results -->
                <div id="resultsStep" class="hidden">
                    <!-- Evaluation Saved Popup Notification (hidden by default) -->
                    <div id="evaluationSavedPopup" class="evaluation-saved-popup hidden">
                        <span class="icon-with-text"><i data-lucide="check-circle"></i> <span id="evaluationSavedPopupMessage">Evaluation saved</span></span>
                        <button onclick="hideEvaluationSavedPopup()" class="evaluation-saved-popup-dismiss" aria-label="Dismiss" title="Dismiss">
                            <i data-lucide="x"></i>
                        </button>
                    </div>
                    
                    <!-- Persistent Evaluation Saved Indicator (hidden by default) -->
                    <div id="evaluationSavedIndicator" class="evaluation-saved-indicator hidden" style="display: none !important;">
                        <span class="icon-with-text"><i data-lucide="check-circle"></i> <span id="evaluationSavedMessage">Evaluation saved</span></span>
                        <button onclick="hideEvaluationSavedIndicator()" class="evaluation-saved-dismiss" aria-label="Dismiss" title="Dismiss">
                            <i data-lucide="x"></i>
                        </button>
                    </div>
                    <div id="resultsContent"></div>
                    <div id="resultsActionButtons" style="display: flex; gap: 12px; margin-top: 24px; flex-wrap: wrap; padding: 16px 0;">
                        <!-- Buttons will be dynamically inserted here -->
                    </div>
                </div>
            </div>
        </section>

        <!-- Save Modal -->
        <div id="saveModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
            <div style="background:white;padding:2rem;border-radius:1rem;max-width:500px;width:90%;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                <h3 style="margin-top:0;color:var(--primary);"><span class="icon-with-text"><i data-lucide="save"></i> Save Evaluation</span></h3>
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">Class:</label>
                    <select id="saveClassSel" onchange="loadSaveStudents()" style="width:100%;padding:0.75rem;font-size:1rem;border:2px solid #ddd;border-radius:0.5rem;">
                        <option value="">-- Select Class --</option>
                    </select>
                </div>
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">Student:</label>
                    <select id="saveStudentSel" style="width:100%;padding:0.75rem;font-size:1rem;border:2px solid #ddd;border-radius:0.5rem;">
                        <option value="">-- Select Student --</option>
                    </select>
                </div>
                <div style="display:flex;gap:1rem;justify-content:flex-end;margin-top:2rem;">
                    <button onclick="closeSaveModal()" id="saveModalCancelBtn" style="padding:0.75rem 1.5rem;background:#6c757d;color:white;border:none;border-radius:0.5rem;cursor:pointer;display:flex;align-items:center;justify-content:center;min-width:44px;min-height:44px;" title="Cancel"><i data-lucide="x" style="width:1.25rem;height:1.25rem;"></i></button>
                    <button onclick="doSaveEval()" id="saveModalSaveBtn" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;font-weight:600;display:flex;align-items:center;justify-content:center;min-width:44px;min-height:44px;" title="Save"><i data-lucide="save" style="width:1.25rem;height:1.25rem;"></i></button>
                </div>
            </div>
        </div>

        <!-- Move Evaluation Modal -->
        <div id="moveEvalModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
            <div style="background:white;padding:2rem;border-radius:1rem;max-width:500px;width:90%;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                <h3 style="margin-top:0;color:var(--primary);"><span class="icon-with-text"><i data-lucide="move"></i> Move</span></h3>
                <p style="color:var(--text-light);font-size:0.9rem;margin-bottom:1.5rem;">Move this evaluation to a different class and/or student. This is useful if an evaluation was accidentally saved to the wrong student.</p>
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">New Class:</label>
                    <select id="moveClassSel" onchange="loadMoveStudents()" style="width:100%;padding:0.75rem;font-size:1rem;border:2px solid #ddd;border-radius:0.5rem;">
                        <option value="">-- Select Class --</option>
                    </select>
                </div>
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">New Student:</label>
                    <select id="moveStudentSel" style="width:100%;padding:0.75rem;font-size:1rem;border:2px solid #ddd;border-radius:0.5rem;">
                        <option value="">-- Select Student --</option>
                    </select>
                </div>
                <div style="display:flex;gap:1rem;justify-content:flex-end;margin-top:2rem;">
                    <button onclick="closeMoveEvalModal()" style="padding:0.75rem 1.5rem;background:#6c757d;color:white;border:none;border-radius:0.5rem;cursor:pointer;"><span class="icon-with-text"><i data-lucide="x"></i> Cancel</span></button>
                    <button onclick="doMoveEval()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;font-weight:600;"><span class="icon-with-text"><i data-lucide="check"></i> Move</span></button>
                </div>
            </div>
        </div>

        <!-- Edit Section Modal -->
        <div id="editSectionModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
            <div style="background:white;padding:2rem;border-radius:1rem;max-width:700px;width:90%;box-shadow:0 10px 40px rgba(0,0,0,0.3);max-height:90vh;overflow-y:auto;">
                <h3 style="margin-top:0;color:var(--primary);"><span class="icon-with-text"><i data-lucide="edit-2"></i> Edit <span id="editSectionName"></span></span></h3>
                
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">Overall Section Score:</label>
                    <div style="display:flex;gap:1rem;align-items:center;">
                        <input type="number" id="editSectionScore" min="0" style="width:80px;padding:0.5rem;font-size:1rem;border:2px solid #ddd;border-radius:0.5rem;" readonly disabled>
                        <span style="font-weight:600;">/ <span id="editSectionMaxScore"></span></span>
                        <span style="color:#999;font-size:0.9rem;">(Auto-calculated from subcategories)</span>
                    </div>
                </div>
                
                <!-- Subcategories Section -->
                <div id="editSubcategoriesContainer" style="margin:1.5rem 0;">
                    <!-- Subcategories will be populated here -->
                </div>
                
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">AI Feedback:</label>
                    <div style="background:#f8f9fa;padding:1rem;border-radius:0.5rem;border-left:4px solid #6c757d;margin-bottom:1rem;">
                        <p id="editSectionAIFeedback" style="margin:0;color:#555;font-size:0.9rem;"></p>
                    </div>
                </div>
                
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">Your Feedback (optional):</label>
                    <textarea id="editSectionFeedback" rows="4" style="width:100%;padding:0.75rem;font-size:1rem;border:2px solid #ddd;border-radius:0.5rem;resize:vertical;" placeholder="Add or modify feedback for the student"></textarea>
                </div>
                
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">Why are you making changes? (helps improve AI):</label>
                    <textarea id="editSectionReason" rows="3" style="width:100%;padding:0.75rem;font-size:1rem;border:2px solid #ddd;border-radius:0.5rem;resize:vertical;" placeholder="e.g., 'AI didn't notice student was reading from notes'"></textarea>
                </div>
                
                <div style="display:flex;gap:1rem;justify-content:flex-end;margin-top:2rem;">
                    <button onclick="closeEditSectionModal()" style="padding:0.75rem 1.5rem;background:#6c757d;color:white;border:none;border-radius:0.5rem;cursor:pointer;">Cancel</button>
                    <button onclick="saveEditedSection()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;font-weight:600;">Save Changes</button>
                </div>
            </div>
        </div>

        <!-- Edit Overall Comments Modal -->
        <div id="editCommentsModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
            <div style="background:white;padding:2rem;border-radius:1rem;max-width:600px;width:90%;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                <h3 style="margin-top:0;color:var(--primary);"><span class="icon-with-text"><i data-lucide="edit-2"></i> Edit Overall Comments</span></h3>
                
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">AI Comments:</label>
                    <div style="background:#f8f9fa;padding:1rem;border-radius:0.5rem;border-left:4px solid #6c757d;margin-bottom:1rem;">
                        <p id="editCommentsAI" style="margin:0;color:#555;font-size:0.9rem;"></p>
                    </div>
                </div>
                
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">Your Comments:</label>
                    <textarea id="editCommentsText" rows="6" style="width:100%;padding:0.75rem;font-size:1rem;border:2px solid #ddd;border-radius:0.5rem;resize:vertical;"></textarea>
                </div>
                
                <div style="margin:1.5rem 0;">
                    <label style="display:block;font-weight:600;margin-bottom:0.5rem;">Reason for changes (optional, for AI training):</label>
                    <textarea id="editCommentsReason" rows="2" style="width:100%;padding:0.75rem;font-size:1rem;border:2px solid #ddd;border-radius:0.5rem;resize:vertical;" placeholder="What did the AI miss or get wrong?"></textarea>
                </div>
                
                <div style="display:flex;gap:1rem;justify-content:flex-end;margin-top:2rem;">
                    <button onclick="closeEditCommentsModal()" style="padding:0.75rem 1.5rem;background:#6c757d;color:white;border:none;border-radius:0.5rem;cursor:pointer;">Cancel</button>
                    <button onclick="saveEditedComments()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;font-weight:600;">Save Changes</button>
                </div>
            </div>
        </div>

        <!-- Edit Timeline Markers Modal -->
        <div id="editMarkersModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
            <div style="background:white;padding:2rem;border-radius:1rem;max-width:700px;width:90%;max-height:90vh;overflow-y:auto;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                <h3 style="margin-top:0;color:var(--primary);"><span class="icon-with-text"><i data-lucide="edit-2"></i> Edit Timeline Markers</span></h3>
                
                <div id="editMarkersList" style="margin:1.5rem 0;">
                    <!-- Markers will be populated here -->
                </div>
                <div id="editMarkersRecurrenceSummary" style="font-size:0.85rem;color:var(--text-light);margin-bottom:0.5rem;"></div>
                <button onclick="addNewMarker()" style="width:100%;padding:0.75rem;background:#28a745;color:white;border:none;border-radius:0.5rem;cursor:pointer;font-weight:600;margin:1rem 0;"><span class="icon-with-text"><i data-lucide="plus"></i> Add New Marker</span></button>
                
                <div style="display:flex;gap:1rem;justify-content:flex-end;margin-top:2rem;">
                    <button onclick="closeEditMarkersModal()" style="padding:0.75rem 1.5rem;background:#6c757d;color:white;border:none;border-radius:0.5rem;cursor:pointer;">Cancel</button>
                    <button onclick="saveEditedMarkers()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;font-weight:600;">Save All Changes</button>
                </div>
            </div>
        </div>

        <!-- Correction History Modal -->
        <div id="correctionHistoryModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
            <div style="background:white;padding:2rem;border-radius:1rem;max-width:800px;width:90%;max-height:90vh;overflow-y:auto;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                <h3 style="margin-top:0;color:var(--primary);"><span class="icon-with-text"><i data-lucide="clipboard-list"></i> Instructor Corrections History</span></h3>
                <p style="color:var(--text-light);font-size:0.9rem;margin-bottom:1.5rem;">
                    This log shows all changes made to the AI's evaluation. This data helps improve future evaluations.
                </p>
                
                <div id="correctionHistoryContent" style="margin:1.5rem 0;">
                    <!-- Corrections will be populated here -->
                </div>
                
                <div style="display:flex;gap:1rem;justify-content:flex-end;margin-top:2rem;">
                    <button onclick="closeCorrectionHistoryModal()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;font-weight:600;">Close</button>
                </div>
            </div>
        </div>

        <!-- Dashboard Section (home view) -->
        <section id="dashboardSection" class="section active" aria-label="Dashboard">
            <!-- Instructor-only: tab bar for Courses | Rubrics | Course Insights -->
            <div id="instructorDashboardTabBar" style="display: none; margin-bottom: 0;" role="tablist" aria-label="Dashboard sections">
                <button type="button" id="instructorTabBtnCourses" class="instructor-dashboard-tab instructor-dashboard-tab-active" role="tab" aria-selected="true" aria-controls="instructorTabPanelCourses"><span class="icon-with-text"><i data-lucide="book-open"></i> Courses</span></button>
                <button type="button" id="instructorTabBtnRubrics" class="instructor-dashboard-tab" role="tab" aria-selected="false" aria-controls="instructorTabPanelRubrics"><span class="icon-with-text"><i data-lucide="list-checks"></i> Rubrics</span></button>
                <button type="button" id="instructorTabBtnInsights" class="instructor-dashboard-tab" role="tab" aria-selected="false" aria-controls="instructorTabPanelInsights"><span class="icon-with-text"><i data-lucide="bar-chart-2"></i> Course Insights</span></button>
                </div>
            
            <!-- Unified Search Bar (Apple HIG: Persistent, always visible) -->
            <div id="unifiedSearchBar" style="display: none; margin-top: 1rem; margin-bottom: 1rem;">
                <div style="position: relative;">
                    <input 
                        type="text" 
                        id="unifiedSearchInput" 
                        placeholder="Search..." 
                        style="width: 100%; padding: 0.75rem 2.5rem 0.75rem 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; font-size: 0.9375rem; transition: all 0.2s ease; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif; background: var(--card);"
                        oninput="handleUnifiedSearch(this.value)"
                        onfocus="this.style.borderColor='var(--primary)'; this.style.outline='none'; this.style.boxShadow='0 0 0 4px rgba(0, 122, 255, 0.1)'"
                        onblur="this.style.borderColor='var(--border)'; this.style.boxShadow='none'"
                        aria-label="Search"
                    >
                    <i data-lucide="search" style="position: absolute; right: 0.75rem; top: 50%; transform: translateY(-50%); width: 1.125rem; height: 1.125rem; color: var(--text-light); pointer-events: none;"></i>
                            </div>
                
                <!-- Compact Filter Toolbar (Always visible, below search) -->
                <div id="instructorFiltersToolbar" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: var(--bg-alt); border-radius: 0.5rem; border: 1px solid var(--border);">
                    <div style="display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap;">
                        <div class="filter-group" style="display: flex; align-items: center; gap: 0.5rem;">
                            <label for="instructorFilterCourse" style="font-size: 0.875rem; font-weight: 500; color: var(--text); white-space: nowrap;">Course:</label>
                            <select id="instructorFilterCourse" onchange="onInstructorCourseFilterChange()" style="padding: 0.5rem 0.75rem; border: 1px solid var(--border); border-radius: 0.375rem; font-size: 0.875rem; background: white; color: var(--text); min-width: 180px; cursor: pointer; transition: border-color 0.2s ease;" onfocus="this.style.borderColor='var(--primary)'; this.style.outline='none'" onblur="this.style.borderColor='var(--border)'">
                                <option value="">All Courses</option>
                                <!-- Populated dynamically -->
                            </select>
                            </div>
                        
                        <div class="filter-group" style="display: flex; align-items: center; gap: 0.5rem;">
                            <label for="instructorFilterSemester" style="font-size: 0.875rem; font-weight: 500; color: var(--text); white-space: nowrap;">Term:</label>
                            <select id="instructorFilterSemester" onchange="onInstructorSemesterFilterChange()" style="padding: 0.5rem 0.75rem; border: 1px solid var(--border); border-radius: 0.375rem; font-size: 0.875rem; background: white; color: var(--text); min-width: 120px; cursor: pointer; transition: border-color 0.2s ease;" onfocus="this.style.borderColor='var(--primary)'; this.style.outline='none'" onblur="this.style.borderColor='var(--border)'">
                                <option value="">All Terms</option>
                                <option value="Spring">Spring</option>
                                <option value="Summer">Summer</option>
                                <option value="Fall">Fall</option>
                                <option value="Winter">Winter</option>
                            </select>
                        </div>
                        
                        <div class="filter-group" style="display: flex; align-items: center; gap: 0.5rem;">
                            <label for="instructorFilterYear" style="font-size: 0.875rem; font-weight: 500; color: var(--text); white-space: nowrap;">Year:</label>
                            <select id="instructorFilterYear" onchange="onInstructorYearFilterChange()" style="padding: 0.5rem 0.75rem; border: 1px solid var(--border); border-radius: 0.375rem; font-size: 0.875rem; background: white; color: var(--text); min-width: 100px; cursor: pointer; transition: border-color 0.2s ease;" onfocus="this.style.borderColor='var(--primary)'; this.style.outline='none'" onblur="this.style.borderColor='var(--border)'">
                                <option value="">All Years</option>
                                <option value="2026">2026</option>
                                <option value="2025">2025</option>
                                <option value="2024">2024</option>
                            </select>
                            </div>
                        
                        <div class="filter-group" style="margin-left: auto;">
                            <button onclick="clearInstructorFilters()" class="btn-secondary" style="padding: 0.5rem 0.75rem; font-size: 0.875rem; white-space: nowrap; display: inline-flex; align-items: center; gap: 0.375rem;" onmouseover="this.style.backgroundColor='var(--bg-alt)'" onmouseout="this.style.backgroundColor='white'">
                                <i data-lucide="x" style="width:0.875rem;height:0.875rem;"></i> Clear Filters
                    </button>
                            </div>
                            </div>
                        </div>
            </div>

            <!-- Courses card - at top for instructors; hidden for admin/super admin -->
            <div id="mainCoursesCard" class="card" style="margin-top: 1.5rem;" data-instructor-panel="courses">
                <div class="card-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                    <span class="icon-with-text"><i data-lucide="book-open"></i> Courses</span>
                    <div style="position: relative;">
                        <button type="button" onclick="toggleAddMenu()" aria-label="Add Course or Tab" title="Add Course or Tab" class="icon-button-add" style="padding: 0.5rem; background: transparent; color: var(--text); border: none; border-radius: 0.5rem; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; width: 2.75rem; height: 2.75rem; flex-shrink: 0; min-width: 2.75rem; min-height: 2.75rem;" onmouseover="this.style.background='var(--bg-alt)'; this.style.color='var(--primary)'" onmouseout="this.style.background='transparent'; this.style.color='var(--text)'" ontouchstart="this.style.background='var(--bg-alt)'; this.style.color='var(--primary)'" ontouchend="setTimeout(() => { this.style.background='transparent'; this.style.color='var(--text)'; }, 150)">
                            <i data-lucide="plus" style="width:1.25rem;height:1.25rem;stroke-width:2;"></i>
                        </button>
                        <div id="addMenuDropdown" class="add-menu-dropdown hidden" style="position: absolute; top: 100%; right: 0; margin-top: 0.5rem; background: white; border: 1px solid var(--border); border-radius: 0.5rem; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; min-width: 180px; overflow: hidden;">
                            <button type="button" onclick="showCreateClass(); closeAddMenu();" style="width: 100%; text-align: left; padding: 0.75rem 1rem; border: none; background: none; cursor: pointer; font-size: 0.9375rem; color: var(--text); display: flex; align-items: center; gap: 0.75rem; transition: background 0.15s;" onmouseover="this.style.background='var(--bg-alt)'" onmouseout="this.style.background='white'">
                                <i data-lucide="book-open" style="width: 1.125rem; height: 1.125rem;"></i> Add Course
                            </button>
                            <button type="button" onclick="addNewTab(); closeAddMenu();" style="width: 100%; text-align: left; padding: 0.75rem 1rem; border: none; background: none; cursor: pointer; font-size: 0.9375rem; color: var(--text); display: flex; align-items: center; gap: 0.75rem; transition: background 0.15s; border-top: 1px solid var(--border);" onmouseover="this.style.background='var(--bg-alt)'" onmouseout="this.style.background='white'">
                                <i data-lucide="folder-plus" style="width: 1.125rem; height: 1.125rem;"></i> Add Tab
                            </button>
                            <button type="button" onclick="showManageTabsModal(); closeAddMenu();" style="width: 100%; text-align: left; padding: 0.75rem 1rem; border: none; background: none; cursor: pointer; font-size: 0.9375rem; color: var(--text); display: flex; align-items: center; gap: 0.75rem; transition: background 0.15s; border-top: 1px solid var(--border);" onmouseover="this.style.background='var(--bg-alt)'" onmouseout="this.style.background='white'">
                                <i data-lucide="settings" style="width: 1.125rem; height: 1.125rem;"></i> Manage Tabs
                            </button>
                        </div>
                    </div>
                </div>
                <!-- Instructor: Current vs Previous courses tabs -->
                <div id="coursesCurrentPreviousTabs" style="display: none; margin-bottom: 1rem; border-bottom: 1px solid var(--border); padding-bottom: 0.5rem;">
                    <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
                        <button type="button" id="coursesTabCurrent" class="instructor-dashboard-tab instructor-dashboard-tab-active" style="margin-right: 0.5rem;">Current</button>
                        <button type="button" id="coursesTabPrevious" class="instructor-dashboard-tab">Previous</button>
                        <div id="customTabsContainer" style="display: flex; gap: 0.5rem; flex-wrap: wrap;"></div>
                    </div>
                </div>
                <!-- Course scope filter (admin and super admin only) -->
                <div id="courseScopeFilterRow" class="filter-controls" style="display: none; margin-bottom: 1.5rem; flex-wrap: wrap; gap: 1rem; align-items: flex-end;">
                    <div class="filter-group">
                        <label for="courseScopeSelect" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Show</label>
                        <select id="courseScopeSelect" onchange="onCourseScopeChange()" style="padding: 0.5rem 0.75rem; border: 2px solid var(--border); border-radius: 0.5rem; min-width: 180px;">
                            <option value="own">My Courses</option>
                            <option value="institution" id="courseScopeInstitutionOption">Department</option>
                        </select>
                    </div>
                    <div id="courseScopeInstitutionWrap" class="filter-group" style="display: none;">
                        <label for="courseScopeInstitution" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Institution</label>
                        <select id="courseScopeInstitution" onchange="onCourseScopeInstitutionChange()" style="padding: 0.5rem 0.75rem; border: 2px solid var(--border); border-radius: 0.5rem; min-width: 200px;">
                            <option value="">Select institution</option>
                        </select>
                    </div>
                    <div id="courseScopeInstructorWrap" class="filter-group" style="display: none;">
                        <label for="courseScopeInstructor" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Instructor</label>
                        <select id="courseScopeInstructor" onchange="onCourseScopeInstructorChange()" style="padding: 0.5rem 0.75rem; border: 2px solid var(--border); border-radius: 0.5rem; min-width: 200px;">
                            <option value="">All instructors</option>
                        </select>
                    </div>
                </div>
                <div id="classesGrid" class="classes-grid"></div>
            </div>

            <!-- Rubrics - at top for instructors; hidden for admin/super admin -->
            <div id="dashboardRubricsWrap" style="display: none; margin-top: 1.5rem;" data-instructor-panel="rubrics">
                <div class="card">
                    <div class="card-header"><span class="icon-with-text"><i data-lucide="list-checks"></i> Rubrics</span></div>
                    <div style="margin-bottom: 1rem;">
                        <label for="courseFilter" style="font-weight: 500; margin-bottom: 0.5rem; display: block;">Filter by Course:</label>
                        <select id="courseFilter" onchange="filterRubricsByCourse()" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                            <option value="">All Courses</option>
                        </select>
                    </div>
                    <div style="margin-bottom: 1.5rem; display: flex; gap: 1rem;">
                        <button onclick="showCreateRubric()"><span class="icon-with-text"><i data-lucide="plus"></i> Create Custom Rubric</span></button>
                        <button onclick="showUploadRubric()" style="background: var(--secondary);"><span class="icon-with-text"><i data-lucide="file-up"></i> Import Rubric from File</span></button>
                    </div>
                    <div id="rubricsList" class="rubrics-list"></div>
                </div>
                <div id="createRubricCard" class="card hidden">
                    <div class="card-header" id="rubricFormHeader">Create Custom Rubric</div>
                    <form id="createRubricForm">
                        <input type="hidden" id="editingRubricId" value="">
                        <input type="hidden" id="editingRubricSupabaseId" value="">
                        <h4 style="margin-bottom: 1rem; color: var(--primary);">Basic Information</h4>
                        <div class="form-group">
                            <label for="rubricName">Rubric Name *</label>
                            <input type="text" id="rubricName" placeholder="e.g., Persuasive Speech" required>
                        </div>
                        <div class="form-group">
                            <label for="rubricDescription">Description</label>
                            <textarea id="rubricDescription" placeholder="Brief description of this rubric"></textarea>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                            <div class="form-group">
                                <label for="rubricTotalPoints">Total Points *</label>
                                <input type="number" id="rubricTotalPoints" value="50" min="1" required
                                       oninput="updateRubricPoints(); updateRubricPreview();">
                            </div>
                            <div class="form-group">
                                <label for="rubricSpeechType">Speech Type</label>
                                <input type="text" id="rubricSpeechType" placeholder="e.g., Persuasive, Informative">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Associated Courses (Optional)</label>
                            <p style="font-size: 0.9rem; color: var(--text-light); margin-bottom: 0.5rem;">Select one or more courses/sections.</p>
                            <div id="rubricCoursesContainer" style="max-height: 200px; overflow-y: auto; border: 1px solid var(--border); border-radius: 0.25rem; padding: 0.75rem; background: white;">
                                <p style="color: var(--text-light); text-align: center;">No courses available. Create courses in "My Classes" first.</p>
                            </div>
                        </div>
                        <h4 style="margin: 1.5rem 0 1rem; color: var(--primary);">Grade Scale</h4>
                        <p style="font-size: 0.9rem; color: var(--text-light); margin-bottom: 1rem;">Define what percentage of maximum points each grade represents:</p>
                        <div style="display: grid; gap: 0.5rem; margin-bottom: 1.5rem;">
                            <div style="display: grid; grid-template-columns: auto 1fr 1fr 1fr; gap: 0.5rem; align-items: center;">
                                <strong style="font-size: 0.9rem;">Grade</strong>
                                <strong style="font-size: 0.9rem;">Label</strong>
                                <strong style="font-size: 0.9rem;">Percentage</strong>
                                <strong style="font-size: 0.9rem;">Range</strong>
                            </div>
                            <div style="display: grid; grid-template-columns: auto 1fr 1fr 1fr; gap: 0.5rem; align-items: center;">
                                <span style="font-weight: 600;">A</span>
                                <input type="text" id="gradeA_label" value="Professional" style="padding: 0.4rem;">
                                <input type="number" id="gradeA_pct" value="100" min="0" max="100" style="padding: 0.4rem;">
                                <input type="text" id="gradeA_range" value="100-91" style="padding: 0.4rem;">
                            </div>
                            <div style="display: grid; grid-template-columns: auto 1fr 1fr 1fr; gap: 0.5rem; align-items: center;">
                                <span style="font-weight: 600;">B</span>
                                <input type="text" id="gradeB_label" value="Proficient" style="padding: 0.4rem;">
                                <input type="number" id="gradeB_pct" value="90" min="0" max="100" style="padding: 0.4rem;">
                                <input type="text" id="gradeB_range" value="90-81" style="padding: 0.4rem;">
                            </div>
                            <div style="display: grid; grid-template-columns: auto 1fr 1fr 1fr; gap: 0.5rem; align-items: center;">
                                <span style="font-weight: 600;">C</span>
                                <input type="text" id="gradeC_label" value="Developing" style="padding: 0.4rem;">
                                <input type="number" id="gradeC_pct" value="80" min="0" max="100" style="padding: 0.4rem;">
                                <input type="text" id="gradeC_range" value="80-71" style="padding: 0.4rem;">
                            </div>
                            <div style="display: grid; grid-template-columns: auto 1fr 1fr 1fr; gap: 0.5rem; align-items: center;">
                                <span style="font-weight: 600;">D</span>
                                <input type="text" id="gradeD_label" value="Unprofessional" style="padding: 0.4rem;">
                                <input type="number" id="gradeD_pct" value="70" min="0" max="100" style="padding: 0.4rem;">
                                <input type="text" id="gradeD_range" value="70-61" style="padding: 0.4rem;">
                            </div>
                            <div style="display: grid; grid-template-columns: auto 1fr 1fr 1fr; gap: 0.5rem; align-items: center;">
                                <span style="font-weight: 600;">F</span>
                                <input type="text" id="gradeF_label" value="Unacceptable" style="padding: 0.4rem;">
                                <input type="number" id="gradeF_pct" value="60" min="0" max="100" style="padding: 0.4rem;">
                                <input type="text" id="gradeF_range" value="60-0" style="padding: 0.4rem;">
                            </div>
                        </div>
                        <h4 style="margin: 1.5rem 0 1rem; color: var(--primary);">Categories & Subcategories</h4>
                        <!-- Rubric Builder Helper: Point Distribution -->
                        <div id="rubricPointHelper" style="background: var(--bg-alt); padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem; border-left: 4px solid var(--primary);">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                                <div style="font-weight: 600; color: var(--text); font-size: 0.9375rem;">
                                    <span class="icon-with-text"><i data-lucide="calculator" style="width:1rem;height:1rem;"></i> Point Distribution</span>
                                </div>
                                <span id="rubricPointsRemaining" style="font-size: 0.875rem; color: var(--text-light);">Total: <strong id="rubricTotalPointsDisplay">50</strong> points</span>
                            </div>
                            <div style="font-size: 0.875rem; color: var(--text-light);">
                                <span id="rubricPointsAssigned">0</span> assigned, <span id="rubricPointsUnassigned">50</span> remaining
                            </div>
                            <div id="rubricPointWarning" style="display: none; margin-top: 0.5rem; padding: 0.5rem; background: rgba(251, 191, 36, 0.1); border-radius: 0.25rem; color: var(--warning); font-size: 0.875rem;">
                                <i data-lucide="alert-triangle" style="width:0.875rem;height:0.875rem;display:inline-block;vertical-align:middle;"></i> Points don't match total. Adjust point values to equal <strong id="rubricPointWarningTotal">50</strong> points.
                            </div>
                        </div>
                        <div id="categoriesContainer"></div>
                        <div style="display: flex; gap: 0.75rem; margin-top: 1rem; flex-wrap: wrap;">
                            <button type="button" onclick="addCategory()" class="btn-secondary"><span class="icon-with-text"><i data-lucide="plus"></i> Add Category</span></button>
                            <button type="button" onclick="showRubricTemplates()" class="btn-secondary" style="background: var(--secondary);"><span class="icon-with-text"><i data-lucide="sparkles"></i> Use Template</span></button>
                        </div>
                        <!-- Rubric Preview -->
                        <div id="rubricPreviewSection" style="margin-top: 2rem; padding-top: 1.5rem; border-top: 2px solid var(--border); display: none;">
                            <h4 style="margin-bottom: 1rem; color: var(--primary);"><span class="icon-with-text"><i data-lucide="eye"></i> Preview</span></h4>
                            <div id="rubricPreviewContent" style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; border: 1px solid var(--border);"></div>
                        </div>
                        <h4 style="margin: 1.5rem 0 1rem; color: var(--primary);">Example Videos (Optional)</h4>
                        <p style="font-size: 0.9rem; color: var(--text-light); margin-bottom: 0.75rem;">Add URLs to example videos (YouTube, Vimeo, or direct links) that show what good or poor performances look like. The AI can reference these when scoring.</p>
                        <div id="exampleVideosContainer" style="display: flex; flex-direction: column; gap: 0.5rem;"></div>
                        <button type="button" onclick="addExampleVideo()" class="btn-secondary" style="margin-top: 0.5rem;"><span class="icon-with-text"><i data-lucide="video"></i> Add Example Video</span></button>
                        <h4 style="margin: 1.5rem 0 1rem; color: var(--primary);">Textbook (Optional)</h4>
                        <p style="font-size: 0.9rem; color: var(--text-light); margin-bottom: 0.5rem;">Link a textbook so the AI uses its content when evaluating. Textbook must be ingested first (see docs).</p>
                        <div class="form-group" style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
                            <div>
                                <label for="rubricTextbook">Textbook</label>
                                <select id="rubricTextbook" style="max-width: 24rem; display: block;">
                                    <option value="">None</option>
                                </select>
                            </div>
                            <button type="button" id="suggestFromTextbookBtn" onclick="suggestDescriptionsFromTextbook()" class="btn-secondary" style="margin-top: 1.5rem;"><span class="icon-with-text"><i data-lucide="sparkles"></i> Suggest descriptions from textbook</span></button>
                        </div>
                        <div style="display: flex; gap: 1rem; margin-top: 2rem; padding-top: 1.5rem; border-top: 2px solid var(--border);">
                            <button type="button" onclick="cancelCreateRubric()" class="btn-secondary">Cancel</button>
                            <button type="submit" id="rubricSubmitBtn">Create Rubric</button>
                        </div>
                    </form>
                </div>
            </div>

            <!-- Analytics dashboard (Course Insights for instructor; Department/Institution for admin) -->
            <div id="analyticsSection" style="margin-top: 0; margin-bottom: 2rem;" data-instructor-panel="insights">
                <div class="card">
                    <div class="card-header text-title" id="analyticsSectionTitle"><span class="icon-with-text"><i data-lucide="bar-chart-2"></i> Course Insights</span></div>
                    <!-- Global filter bar (Overview / Course Insights) -->
                    <div id="analyticsGlobalFilterBar" class="global-filter-bar">
                        <div class="global-filter-bar-row">
                        <div class="filter-dropdown" id="filter-dropdown-institution" data-select-id="analyticsGlobalInstitution" style="display: none;">
                            <label class="filter-dropdown-label" style="font-size: 0.75rem; color: var(--text-light);">Institution</label>
                            <button type="button" class="filter-dropdown-trigger" id="filter-trigger-institution" aria-expanded="false" aria-haspopup="listbox" aria-label="Select institutions" style="min-width: 12rem;">All institutions</button>
                            <div class="filter-dropdown-panel" id="filter-panel-institution" role="listbox" aria-hidden="true"></div>
                            <select id="analyticsGlobalInstitution" multiple aria-hidden="true" style="position:absolute;left:-9999px;width:1px;height:1px;opacity:0;"><option value="">All institutions</option></select>
                        </div>
                        <div class="filter-dropdown" id="filter-dropdown-instructor" data-select-id="analyticsGlobalInstructor">
                            <label class="filter-dropdown-label" style="font-size: 0.75rem; color: var(--text-light);">Instructor</label>
                            <button type="button" class="filter-dropdown-trigger" id="filter-trigger-instructor" aria-expanded="false" aria-haspopup="listbox" aria-label="Select instructors" style="min-width: 12rem;">All instructors</button>
                            <div class="filter-dropdown-panel" id="filter-panel-instructor" role="listbox" aria-hidden="true"></div>
                            <select id="analyticsGlobalInstructor" multiple aria-hidden="true" style="position:absolute;left:-9999px;width:1px;height:1px;opacity:0;"><option value="">All instructors</option></select>
                        </div>
                        <div class="filter-dropdown" id="filter-dropdown-course" data-select-id="analyticsGlobalCourse">
                            <label class="filter-dropdown-label" style="font-size: 0.75rem; color: var(--text-light);">Course</label>
                            <button type="button" class="filter-dropdown-trigger" id="filter-trigger-course" aria-expanded="false" aria-haspopup="listbox" aria-label="Select courses" style="min-width: 12rem;">All courses</button>
                            <div class="filter-dropdown-panel" id="filter-panel-course" role="listbox" aria-hidden="true"></div>
                            <select id="analyticsGlobalCourse" multiple aria-hidden="true" style="position:absolute;left:-9999px;width:1px;height:1px;opacity:0;"><option value="">All courses</option></select>
                        </div>
                        <div class="filter-actions" style="margin-left: auto;">
                            <button type="button" id="analyticsGlobalReset" class="btn-secondary" style="padding: 0.5rem 0.75rem; font-size: 0.875rem; min-width: 80px; height: 2.25rem; box-sizing: border-box;" aria-label="Reset filters">Reset</button>
                            <button type="button" id="analyticsGlobalApply" class="btn" style="padding: 0.5rem 0.75rem; font-size: 0.875rem; background: var(--primary); color: white; min-width: 80px; height: 2.25rem; box-sizing: border-box;" aria-label="Apply filters">Apply</button>
                            <span id="analyticsLastUpdated" class="last-updated" style="align-self: center;"></span>
                        </div>
                        </div>
                        <div class="global-filter-bar-row" style="margin-top: 0.75rem;">
                        <div class="filter-date-range" style="display: flex; flex-direction: column; gap: 0.25rem;">
                            <span class="filter-dropdown-label" style="font-size: 0.75rem; color: var(--text-light);">Date range</span>
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <input type="date" id="analyticsStartDate" aria-label="Start date" style="padding: 0.5rem 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; font-size: 0.875rem; min-width: 8rem;">
                                <span style="color: var(--text-light); font-size: 0.875rem;">to</span>
                                <input type="date" id="analyticsEndDate" aria-label="End date" style="padding: 0.5rem 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; font-size: 0.875rem; min-width: 8rem;">
                            </div>
                        </div>
                        </div>
                        <div id="activeFiltersDisplay" style="display: none; flex-wrap: wrap; gap: 0.5rem; padding-top: 0.75rem; border-top: 1px solid var(--border);"></div>
                        <div id="analyticsFilterHint" style="display: none; margin-top: 0.75rem; padding: 0.75rem 1rem; background: var(--bg-alt); border-radius: 0.5rem; border-left: 4px solid var(--primary); font-size: 0.85rem; color: var(--text);"></div>
                    </div>
                <div style="display: flex; align-items: flex-end; gap: 0.5rem; margin-bottom: 1.5rem; border-bottom: 2px solid var(--border); flex-wrap: wrap;">
                    <div id="analyticsTablist" role="tablist" class="analytics-tablist" style="display: flex; gap: 0.5rem; overflow: visible; flex: 1; min-width: 0;"></div>
                </div>
                <div id="analyticsPanelsWrapper">
                <div id="analyticsOverviewTab" data-dashboard-id="overview" role="tabpanel" style="display: block;">
                    <!-- Overview Stats (moved from Dashboard) -->
                    <div id="dashboardOverviewStats" class="card" style="margin-top: 0; margin-bottom: 1.5rem; display: none;" data-instructor-panel="overview">
                        <div class="card-header" style="display: flex; justify-content: space-between; align-items: center;">
                            <span class="icon-with-text"><i data-lucide="activity"></i> Overview</span>
                            <button type="button" onclick="refreshDashboardStats()" class="btn-icon-only" aria-label="Refresh stats" title="Refresh" style="padding: 0.375rem; background: transparent; color: var(--text-light); border: 1px solid var(--border); border-radius: 0.375rem; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='var(--bg-alt)'; this.style.color='var(--primary)'" onmouseout="this.style.background='transparent'; this.style.color='var(--text-light)'">
                                <i data-lucide="refresh-cw" style="width:1rem;height:1rem;"></i>
                            </button>
                        </div>
                        <div id="dashboardStatsContent" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; padding: 1rem;">
                            <button type="button" onclick="navigateToStatSection('courses')" class="stat-card-button" style="all: unset; display: block; padding: 1rem; background: var(--bg-alt); border-radius: 0.5rem; border-left: 4px solid var(--primary); cursor: pointer; transition: all 0.2s ease; text-align: left; width: 100%; box-sizing: border-box;" onmouseover="this.style.background='rgba(0, 122, 255, 0.05)'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)'" onmouseout="this.style.background='var(--bg-alt)'; this.style.transform='translateY(0)'; this.style.boxShadow='none'" aria-label="View courses">
                                <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.5rem;">
                                    <div style="width: 2.5rem; height: 2.5rem; border-radius: 0.5rem; background: rgba(0, 122, 255, 0.1); display: flex; align-items: center; justify-content: center; flex-shrink: 0;">
                                        <i data-lucide="book-open" style="width:1.25rem;height:1.25rem;color:var(--primary);"></i>
                                    </div>
                                    <div style="flex: 1; min-width: 0;">
                                        <div style="font-size: 0.875rem; color: var(--text-light); font-weight: 500;">Total Courses</div>
                                        <div id="statTotalCourses" style="font-size: 1.5rem; font-weight: 600; color: var(--text);">—</div>
                                    </div>
                                    <i data-lucide="chevron-right" style="width:1rem;height:1rem;color:var(--text-light);flex-shrink:0;"></i>
                                </div>
                            </button>
                            <button type="button" onclick="navigateToStatSection('students')" class="stat-card-button" style="all: unset; display: block; padding: 1rem; background: var(--bg-alt); border-radius: 0.5rem; border-left: 4px solid var(--success); cursor: pointer; transition: all 0.2s ease; text-align: left; width: 100%; box-sizing: border-box;" onmouseover="this.style.background='rgba(34, 197, 94, 0.05)'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)'" onmouseout="this.style.background='var(--bg-alt)'; this.style.transform='translateY(0)'; this.style.boxShadow='none'" aria-label="View students">
                                <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.5rem;">
                                    <div style="width: 2.5rem; height: 2.5rem; border-radius: 0.5rem; background: rgba(34, 197, 94, 0.1); display: flex; align-items: center; justify-content: center; flex-shrink: 0;">
                                        <i data-lucide="users" style="width:1.25rem;height:1.25rem;color:var(--success);"></i>
                                    </div>
                                    <div style="flex: 1; min-width: 0;">
                                        <div style="font-size: 0.875rem; color: var(--text-light); font-weight: 500;">Total Students</div>
                                        <div id="statTotalStudents" style="font-size: 1.5rem; font-weight: 600; color: var(--text);">—</div>
                                    </div>
                                    <i data-lucide="chevron-right" style="width:1rem;height:1rem;color:var(--text-light);flex-shrink:0;"></i>
                                </div>
                            </button>
                            <button type="button" onclick="navigateToStatSection('evaluations')" class="stat-card-button" style="all: unset; display: block; padding: 1rem; background: var(--bg-alt); border-radius: 0.5rem; border-left: 4px solid var(--warning); cursor: pointer; transition: all 0.2s ease; text-align: left; width: 100%; box-sizing: border-box;" onmouseover="this.style.background='rgba(251, 191, 36, 0.05)'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)'" onmouseout="this.style.background='var(--bg-alt)'; this.style.transform='translateY(0)'; this.style.boxShadow='none'" aria-label="View evaluations">
                                <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.5rem;">
                                    <div style="width: 2.5rem; height: 2.5rem; border-radius: 0.5rem; background: rgba(251, 191, 36, 0.1); display: flex; align-items: center; justify-content: center; flex-shrink: 0;">
                                        <i data-lucide="file-check" style="width:1.25rem;height:1.25rem;color:var(--warning);"></i>
                                    </div>
                                    <div style="flex: 1; min-width: 0;">
                                        <div style="font-size: 0.875rem; color: var(--text-light); font-weight: 500;">Total Evaluations</div>
                                        <div id="statTotalEvaluations" style="font-size: 1.5rem; font-weight: 600; color: var(--text);">—</div>
                                    </div>
                                    <i data-lucide="chevron-right" style="width:1rem;height:1rem;color:var(--text-light);flex-shrink:0;"></i>
                                </div>
                            </button>
                            <button type="button" onclick="navigateToStatSection('rubrics')" class="stat-card-button" style="all: unset; display: block; padding: 1rem; background: var(--bg-alt); border-radius: 0.5rem; border-left: 4px solid var(--secondary); cursor: pointer; transition: all 0.2s ease; text-align: left; width: 100%; box-sizing: border-box;" onmouseover="this.style.background='rgba(139, 92, 246, 0.05)'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)'" onmouseout="this.style.background='var(--bg-alt)'; this.style.transform='translateY(0)'; this.style.boxShadow='none'" aria-label="View rubrics">
                                <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.5rem;">
                                    <div style="width: 2.5rem; height: 2.5rem; border-radius: 0.5rem; background: rgba(139, 92, 246, 0.1); display: flex; align-items: center; justify-content: center; flex-shrink: 0;">
                                        <i data-lucide="list-checks" style="width:1.25rem;height:1.25rem;color:var(--secondary);"></i>
                                    </div>
                                    <div style="flex: 1; min-width: 0;">
                                        <div style="font-size: 0.875rem; color: var(--text-light); font-weight: 500;">Total Rubrics</div>
                                        <div id="statTotalRubrics" style="font-size: 1.5rem; font-weight: 600; color: var(--text);">—</div>
                                    </div>
                                    <i data-lucide="chevron-right" style="width:1rem;height:1rem;color:var(--text-light);flex-shrink:0;"></i>
                                </div>
                            </button>
                        </div>
                    </div>
                    <div id="overviewDepartmentCoursesWrap" style="display: none; margin-bottom: 1.5rem;"></div>
                    <div id="overviewAllInstitutionsWrap" style="display: none; margin-bottom: 1.5rem;"></div>
                    <div id="overviewStatsContainer"><p style="color: var(--text-light);">Loading analytics…</p><div class="spinner" style="margin: 1rem auto;" aria-hidden="true"></div></div>
                    <div id="overviewActionsWrap" style="display: flex; justify-content: flex-end; gap: 0.5rem; margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--border);">
                        <button type="button" id="analyticsEditCardsBtn" class="btn-secondary" style="padding: 0.35rem 0.75rem; font-size: 0.8rem;" title="Choose which cards appear on this tab">Edit cards</button>
                        <button type="button" id="analyticsCustomizeDashboardsBtn" class="btn-secondary" style="padding: 0.35rem 0.75rem; font-size: 0.8rem;" title="Show or hide tabs, reorder, add custom dashboards">Customize tabs</button>
                    </div>
                </div>
                <div id="analyticsComparisonsTab" data-dashboard-id="comparisons" role="tabpanel" style="display: none;"><p style="color: var(--text-light);">Comparison data will appear here...</p></div>
                <div id="analyticsEvaluationsTab" data-dashboard-id="evaluations" role="tabpanel" style="display: none;"><p style="color: var(--text-light);">Evaluation list will appear here...</p></div>
                <div id="analyticsExportTab" data-dashboard-id="export" role="tabpanel" style="display: none;">
                    <div class="card" data-widget-id="export-unified" style="margin-bottom: 0;">
                        <div id="exportTabTopBar" style="padding: 0.75rem 1rem; border-bottom: 1px solid var(--border); background: var(--bg-alt); display: flex; align-items: center; gap: 1rem; flex-wrap: nowrap;">
                            <span style="font-size: 0.85rem; color: var(--text-light); flex-shrink: 0;"><span id="exportPreviewCount">0</span> evaluations</span>
                            <button type="button" id="analyticsExportBtn" onclick="exportDepartmentData()" class="btn" style="background: var(--primary); color: white; padding: 0.5rem 1rem; font-size: 0.875rem; margin-left: auto;"><span class="icon-with-text"><i data-lucide="download"></i> Export CSV</span></button>
                        </div>
                        <div style="overflow-x: auto; max-height: 500px; overflow-y: auto;">
                            <table id="exportPreviewTable" class="data-table" style="width: 100%; min-width: 560px;">
                                <thead style="position: sticky; top: 0; background: var(--primary); color: #fff; z-index: 1;">
                                    <tr>
                                        <th data-sort="date" style="text-align: left; padding: 0.75rem; color: #fff; font-weight: 600;" title="Click label to sort; click ▾ to filter"><div class="export-th-inner"><span class="export-th-sort">Date</span><button type="button" class="export-th-filter" data-sort="date" aria-label="Filter Date">▾</button></div></th>
                                        <th data-sort="student" style="text-align: left; padding: 0.75rem; color: #fff; font-weight: 600;" title="Click label to sort; click ▾ to filter"><div class="export-th-inner"><span class="export-th-sort">Student</span><button type="button" class="export-th-filter" data-sort="student" aria-label="Filter Student">▾</button></div></th>
                                        <th data-sort="course" style="text-align: left; padding: 0.75rem; color: #fff; font-weight: 600;" title="Click label to sort; click ▾ to filter"><div class="export-th-inner"><span class="export-th-sort">Course</span><button type="button" class="export-th-filter" data-sort="course" aria-label="Filter Course">▾</button></div></th>
                                        <th data-sort="instructor" style="text-align: left; padding: 0.75rem; color: #fff; font-weight: 600;" title="Click label to sort; click ▾ to filter"><div class="export-th-inner"><span class="export-th-sort">Instructor</span><button type="button" class="export-th-filter" data-sort="instructor" aria-label="Filter Instructor">▾</button></div></th>
                                        <th data-sort="score" class="export-th-center" style="text-align: center; padding: 0.75rem; color: #fff; font-weight: 600;" title="Click label to sort; click ▾ to filter"><div class="export-th-inner"><span class="export-th-sort">Score %</span><button type="button" class="export-th-filter" data-sort="score" aria-label="Filter Score">▾</button></div></th>
                                        <th data-sort="rubric" style="text-align: left; padding: 0.75rem; color: #fff; font-weight: 600;" title="Click label to sort; click ▾ to filter"><div class="export-th-inner"><span class="export-th-sort">Rubric</span><button type="button" class="export-th-filter" data-sort="rubric" aria-label="Filter Rubric">▾</button></div></th>
                                        <th data-sort="assignmentType" style="text-align: left; padding: 0.75rem; color: #fff; font-weight: 600;" title="Click label to sort; click ▾ to filter"><div class="export-th-inner"><span class="export-th-sort">Assignment Type</span><button type="button" class="export-th-filter" data-sort="assignmentType" aria-label="Filter Assignment Type">▾</button></div></th>
                                    </tr>
                                </thead>
                                <tbody id="exportPreviewTableBody">
                                    <tr>
                                        <td colspan="7" style="text-align: center; padding: 2rem; color: var(--text-light);">Load data to see preview</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p style="margin: 0; padding: 0.75rem 1rem; font-size: 0.8rem; color: var(--text-light); border-top: 1px solid var(--border);">Exports only include evaluations from students who have granted data-use consent. Column filters (▾) apply to the export. <a href="javascript:void(0)" onclick="exportDepartmentData(); return false;" style="color: var(--primary); font-weight: 600; text-decoration: underline;">Export CSV</a></p>
                    </div>
                </div>
                <div id="analyticsCustomPanelsContainer"></div>
                </div>
                </div>
            </div>

            <!-- Metric Definition Modal -->
            <div id="metricDefinitionModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;" role="dialog" aria-labelledby="metricDefinitionTitle" aria-modal="true" onclick="if (event.target === this) closeMetricDefinition();">
                <div style="background: var(--bg); border: 1px solid var(--border); border-radius: 1rem; padding: 2rem; max-width: 600px; width: 90%; max-height: 85vh; overflow-y: auto; box-shadow: 0 10px 40px rgba(0,0,0,0.2);" onclick="event.stopPropagation();">
                    <h3 id="metricDefinitionTitle" class="text-title" style="margin: 0 0 1rem 0; color: var(--primary);"></h3>
                    <div id="metricDefinitionContent" style="margin-bottom: 1.5rem; color: var(--text); line-height: 1.6;"></div>
                    <div id="metricDefinitionLinks" style="padding: 1rem; background: var(--bg-alt); border-radius: 0.5rem; margin-bottom: 1.5rem;">
                        <p style="font-weight: 600; margin: 0 0 0.5rem 0; font-size: 0.9rem;">Learn more:</p>
                        <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                            <a href="#" onclick="return false;" style="color: var(--primary); text-decoration: underline; font-size: 0.875rem;" class="icon-with-text"><i data-lucide="bar-chart-2"></i> How this is measured</a>
                            <a href="#" onclick="switchAnalyticsTab('evaluations'); closeMetricDefinition(); return false;" style="color: var(--primary); text-decoration: underline; font-size: 0.875rem;" class="icon-with-text"><i data-lucide="search"></i> View evidence in Evaluations</a>
                            <a href="#" onclick="switchAnalyticsTab('evaluations'); closeMetricDefinition(); return false;" style="color: var(--primary); text-decoration: underline; font-size: 0.875rem;" class="icon-with-text"><i data-lucide="search"></i> View in Evaluations</a>
                        </div>
                    </div>
                    <button type="button" onclick="closeMetricDefinition()" class="btn" style="width: 100%; background: var(--primary); color: white;">Close</button>
                </div>
            </div>

            <!-- Customize Dashboards modal -->
            <div id="customizeDashboardsModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;" role="dialog" aria-labelledby="customizeDashboardsTitle" aria-modal="true" onclick="if (event.target === this) closeCustomizeDashboardsModal();">
                <div style="background: var(--bg); border: 1px solid var(--border); border-radius: 1rem; padding: 1.5rem; max-width: 480px; width: 90%; max-height: 85vh; overflow-y: auto; box-shadow: 0 10px 40px rgba(0,0,0,0.2);" onclick="event.stopPropagation();">
                    <h3 id="customizeDashboardsTitle" class="text-headline" style="margin: 0 0 0.5rem 0;">Customize tabs</h3>
                    <p class="text-caption" style="margin-bottom: 1rem;">Choose which tabs appear in the dashboard bar: <strong>Show</strong> / <strong>Hide</strong> to toggle, <strong>↑</strong> <strong>↓</strong> to reorder. To change which cards appear on a tab, close this and click <strong>Edit cards</strong> on that tab.</p>
                    <ul id="customizeDashboardsList" style="list-style: none; margin: 0 0 1rem 0; padding: 0;"></ul>
                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                        <button type="button" id="customizeDashboardsAdd" class="btn" style="background: var(--primary); color: white;">+ Add custom tab</button>
                        <button type="button" id="customizeDashboardsClose" class="btn-secondary">Done</button>
                    </div>
                </div>
            </div>

            <!-- Edit cards (widgets per tab) modal -->
            <div id="editCardsModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10001; align-items: center; justify-content: center;" role="dialog" aria-labelledby="editCardsTitle" aria-modal="true" onclick="if (event.target === this) closeEditCardsModal();">
                <div style="background: var(--bg); border: 1px solid var(--border); border-radius: 1rem; padding: 1.5rem; max-width: 480px; width: 90%; max-height: 85vh; overflow-y: auto; box-shadow: 0 10px 40px rgba(0,0,0,0.2);" onclick="event.stopPropagation();">
                    <h3 id="editCardsTitle" class="text-headline" style="margin: 0 0 0.5rem 0;">Edit Overview cards</h3>
                    <p class="text-caption" style="margin-bottom: 1rem;">Choose which cards appear on this tab: <strong>Remove</strong> / <strong>Add</strong> to hide or show a card, <strong>↑</strong> <strong>↓</strong> to reorder. Changes are saved automatically.</p>
                    <ul id="editCardsWidgetList" style="list-style: none; margin: 0 0 1rem 0; padding: 0;"></ul>
                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 1rem;">
                        <button type="button" id="editCardsAddNewSection" class="btn" style="background: var(--primary); color: white; font-size: 0.875rem;">+ Add custom card</button>
                    </div>
                    <button type="button" id="editCardsClose" class="btn-secondary">Done</button>
                </div>
            </div>

            <!-- ALL INSTITUTIONS SECTION (Super Admin only) -->
            <div id="allInstitutionsSection" class="card" style="display: none; margin-top: 2rem;">
                <div class="card-header"><span class="icon-with-text"><i data-lucide="globe"></i> All Institutions</span></div>
                
                <!-- Filter Controls -->
                <div id="superAdminFilters" class="filter-controls" style="display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 1.5rem;">
                    <div class="filter-group">
                        <label for="filterInstitution" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Institution</label>
                        <select id="filterInstitution" onchange="onInstitutionFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; min-width: 200px;">
                            <option value="">All Institutions</option>
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="filterInstructor" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Instructor</label>
                        <select id="filterInstructor" onchange="onInstructorFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; min-width: 200px;">
                            <option value="">All Instructors</option>
                            <!-- Populated dynamically based on institution -->
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="filterYear" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Year</label>
                        <select id="filterYear" onchange="onYearFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                            <option value="">All Years</option>
                            <option value="2026">2026</option>
                            <option value="2025">2025</option>
                            <option value="2024">2024</option>
                            <option value="2023">2023</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="filterSemester" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Term</label>
                        <select id="filterSemester" onchange="onSemesterFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                            <option value="">All Terms</option>
                            <option value="Spring">Spring</option>
                            <option value="Summer">Summer</option>
                            <option value="Fall">Fall</option>
                            <option value="Winter">Winter</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="filterModality" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Modality</label>
                        <select id="filterModality" onchange="onModalityFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                            <option value="">All Modalities</option>
                            <option value="in-person">In-Person</option>
                            <option value="online">Online</option>
                            <option value="hybrid">Hybrid</option>
                        </select>
                    </div>
                    
                    <div class="filter-group" style="flex-grow: 1;">
                        <label for="filterSearch" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Search</label>
                        <input type="text" id="filterSearch" oninput="onSearchFilterChange()" placeholder="Search courses" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; width: 100%;">
                    </div>
                    
                    <div class="filter-group" style="align-self: flex-end;">
                        <button onclick="clearAllFilters()" class="btn-secondary" style="padding: 0.5rem 1rem;">Clear Filters</button>
                    </div>
                    
                    <div id="superAdminTestTableBtnWrap" class="filter-group" style="align-self: flex-end; display: none;">
                        <button onclick="testTableRenderingWithMockData()" style="padding: 0.5rem 1rem; background: #28a745; color: white; border: none; border-radius: 0.25rem; cursor: pointer;"><span class="icon-with-text"><i data-lucide="flask-conical"></i> Test Table</span></button>
                    </div>
                </div>
                
                <!-- Results Info -->
                <div id="filterResultsInfo" style="margin-bottom: 1rem; color: var(--text-light); font-size: 0.9rem;">
                    Select filters to view courses
                </div>
                
                <!-- Data Table -->
                <div id="coursesTableContainer" style="overflow-x: auto;">
                    <table id="coursesTable" class="data-table" style="display: none;">
                        <thead>
                            <tr>
                                <th onclick="sortTableBy('name')">Course Name</th>
                                <th onclick="sortTableBy('code')">Code</th>
                                <th onclick="sortTableBy('instructor')">Instructor</th>
                                <th onclick="sortTableBy('institution')">Institution</th>
                                <th onclick="sortTableBy('semester')">Term/Year</th>
                                <th onclick="sortTableBy('modality')">Modality</th>
                                <th onclick="sortTableBy('students')">Students</th>
                                <th onclick="sortTableBy('evaluations')">Evaluations</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="coursesTableBody">
                            <!-- Populated dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- DEPARTMENT COURSES SECTION (Admin only) -->
            <div id="departmentCoursesSection" class="card" style="display: none; margin-top: 2rem;">
                <div class="card-header"><span class="icon-with-text"><i data-lucide="building-2"></i> Department Courses</span></div>
                
                <!-- Admin Filter Controls -->
                <div id="adminFilters" class="filter-controls" style="display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 1.5rem;">
                    <div class="filter-group">
                        <label for="adminFilterInstructor" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Instructor</label>
                        <select id="adminFilterInstructor" onchange="onAdminInstructorFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; min-width: 200px;">
                            <option value="">All Instructors</option>
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="adminFilterYear" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Year</label>
                        <select id="adminFilterYear" onchange="onAdminYearFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                            <option value="">All Years</option>
                            <option value="2026">2026</option>
                            <option value="2025">2025</option>
                            <option value="2024">2024</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="adminFilterSemester" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Term</label>
                        <select id="adminFilterSemester" onchange="onAdminSemesterFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                            <option value="">All Terms</option>
                            <option value="Spring">Spring</option>
                            <option value="Summer">Summer</option>
                            <option value="Fall">Fall</option>
                            <option value="Winter">Winter</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label for="adminFilterModality" style="display: block; font-weight: 500; margin-bottom: 0.5rem;">Modality</label>
                        <select id="adminFilterModality" onchange="onAdminModalityFilterChange()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                            <option value="">All Modalities</option>
                            <option value="in-person">In-Person</option>
                            <option value="online">Online</option>
                            <option value="hybrid">Hybrid</option>
                        </select>
                    </div>
                    
                    <div class="filter-group" style="align-self: flex-end;">
                        <button onclick="clearAdminFilters()" class="btn-secondary" style="padding: 0.5rem 1rem;">Clear Filters</button>
                    </div>
                    
                    <div id="adminTestTableBtnWrap" class="filter-group" style="align-self: flex-end; display: none;">
                        <button onclick="testTableRenderingWithMockData()" style="padding: 0.5rem 1rem; background: #28a745; color: white; border: none; border-radius: 0.25rem; cursor: pointer;"><span class="icon-with-text"><i data-lucide="flask-conical"></i> Test Table</span></button>
                    </div>
                </div>
                
                <!-- Admin Results Info -->
                <div id="adminFilterResultsInfo" style="margin-bottom: 1rem; color: var(--text-light); font-size: 0.9rem;">
                    Loading department courses...
                </div>
                
                <!-- Admin Data Table -->
                <div id="adminCoursesTableContainer" style="overflow-x: auto;">
                    <table id="adminCoursesTable" class="data-table">
                        <thead>
                            <tr>
                                <th onclick="sortAdminTableBy('name')">Course Name</th>
                                <th onclick="sortAdminTableBy('code')">Code</th>
                                <th onclick="sortAdminTableBy('instructor')">Instructor</th>
                                <th onclick="sortAdminTableBy('semester')">Term/Year</th>
                                <th onclick="sortAdminTableBy('modality')">Modality</th>
                                <th onclick="sortAdminTableBy('students')">Students</th>
                                <th onclick="sortAdminTableBy('evaluations')">Evaluations</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="adminCoursesTableBody">
                            <!-- Populated dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- INSTRUCTOR FILTERS SECTION (Removed - now in compact toolbar above) -->

            <!-- Create Class Form -->
            <div id="createClassCard" class="card hidden">
                <div class="card-header">Create New Class</div>
                <form id="createClassForm">
                    <div class="form-group">
                        <label for="className">Class Name *</label>
                        <input type="text" id="className" required placeholder="e.g., CMST 210">
                    </div>
                    <div class="form-group">
                        <label for="classSemester">Term</label>
                        <select id="classSemester">
                            <option value="Spring">Spring</option>
                            <option value="Summer">Summer</option>
                            <option value="Fall" selected>Fall</option>
                            <option value="Winter">Winter</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="classSection">Section</label>
                        <input type="text" id="classSection" placeholder="e.g., 001">
                    </div>
                    <div class="form-group">
                        <label for="classYear">Year</label>
                        <input type="number" id="classYear" value="2026">
                    </div>
                    <div class="form-group">
                        <label for="classNotes">Notes</label>
                        <textarea id="classNotes" placeholder="Optional notes about this class"></textarea>
                    </div>
                    <div style="display: flex; gap: 1rem;">
                        <button type="button" onclick="cancelCreateClass()" class="btn-secondary">Cancel</button>
                        <button type="submit">Create Class</button>
                    </div>
                </form>
            </div>

            <!-- Edit Course Modal -->
            <div id="editCourseModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.4); z-index: 9999; align-items: center; justify-content: center; backdrop-filter: blur(4px);" role="dialog" aria-labelledby="editCourseModalTitle" aria-modal="true" onclick="if(event.target===this)closeEditCourseModal();">
                <div style="background: white; border-radius: 1rem; max-width: 500px; width: 90%; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);" onclick="event.stopPropagation();">
                    <div style="padding: 1.5rem 1.5rem 1rem 1.5rem; border-bottom: 0.5px solid rgba(0, 0, 0, 0.1); display: flex; justify-content: space-between; align-items: center;">
                        <h2 id="editCourseModalTitle" style="margin: 0; font-size: 1.25rem; font-weight: 600; color: var(--text);">Edit Course</h2>
                        <button type="button" onclick="closeEditCourseModal()" aria-label="Close" style="background: none; border: none; padding: 0.5rem; cursor: pointer; color: var(--text-light); border-radius: 0.5rem; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='rgba(0,0,0,0.05)'" onmouseout="this.style.backgroundColor='transparent'">
                            <i data-lucide="x" style="width: 1.25rem; height: 1.25rem;"></i>
                        </button>
                    </div>
                    <form id="editCourseForm" style="padding: 1.5rem; overflow-y: auto; flex: 1;">
                        <input type="hidden" id="editCourseId" value="">
                        <div class="form-group" style="margin-bottom: 1.25rem;">
                            <label for="editCourseName" style="display: block; font-weight: 500; margin-bottom: 0.5rem; color: var(--text); font-size: 0.9375rem;">Class Name *</label>
                            <input type="text" id="editCourseName" required style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; font-size: 1rem; transition: border-color 0.2s;" onfocus="this.style.borderColor='var(--primary)'" onblur="this.style.borderColor='var(--border)'">
                        </div>
                        <div class="form-group" style="margin-bottom: 1.25rem;">
                            <label for="editCourseSemester" style="display: block; font-weight: 500; margin-bottom: 0.5rem; color: var(--text); font-size: 0.9375rem;">Term</label>
                            <select id="editCourseSemester" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; font-size: 1rem; transition: border-color 0.2s;" onfocus="this.style.borderColor='var(--primary)'" onblur="this.style.borderColor='var(--border)'">
                                <option value="Spring">Spring</option>
                                <option value="Summer">Summer</option>
                                <option value="Fall">Fall</option>
                                <option value="Winter">Winter</option>
                            </select>
                        </div>
                        <div class="form-group" style="margin-bottom: 1.25rem;">
                            <label for="editCourseSection" style="display: block; font-weight: 500; margin-bottom: 0.5rem; color: var(--text); font-size: 0.9375rem;">Section</label>
                            <input type="text" id="editCourseSection" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; font-size: 1rem; transition: border-color 0.2s;" onfocus="this.style.borderColor='var(--primary)'" onblur="this.style.borderColor='var(--border)'">
                        </div>
                        <div class="form-group" style="margin-bottom: 1.25rem;">
                            <label for="editCourseYear" style="display: block; font-weight: 500; margin-bottom: 0.5rem; color: var(--text); font-size: 0.9375rem;">Year</label>
                            <input type="number" id="editCourseYear" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; font-size: 1rem; transition: border-color 0.2s;" onfocus="this.style.borderColor='var(--primary)'" onblur="this.style.borderColor='var(--border)'">
                        </div>
                        <div class="form-group" style="margin-bottom: 1.5rem;">
                            <label for="editCourseNotes" style="display: block; font-weight: 500; margin-bottom: 0.5rem; color: var(--text); font-size: 0.9375rem;">Notes</label>
                            <textarea id="editCourseNotes" rows="3" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; font-size: 1rem; resize: vertical; transition: border-color 0.2s;" onfocus="this.style.borderColor='var(--primary)'" onblur="this.style.borderColor='var(--border)'"></textarea>
                        </div>
                    </form>
                    <div style="padding: 1rem 1.5rem; border-top: 0.5px solid rgba(0, 0, 0, 0.1); display: flex; gap: 0.75rem; justify-content: flex-end;">
                        <button type="button" onclick="closeEditCourseModal()" class="btn-secondary" style="padding: 0.625rem 1.25rem; font-size: 0.9375rem; font-weight: 500; border-radius: 0.5rem;">Cancel</button>
                        <button type="button" onclick="saveEditedCourse()" style="padding: 0.625rem 1.25rem; background: var(--primary); color: white; border: none; border-radius: 0.5rem; font-size: 0.9375rem; font-weight: 500; cursor: pointer; transition: opacity 0.2s;" onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">
                            <span class="icon-with-text"><i data-lucide="check" style="width:1em;height:1em;"></i> Save Changes</span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Move Course Modal -->
            <div id="moveCourseModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.4); z-index: 9999; align-items: center; justify-content: center; backdrop-filter: blur(4px);" role="dialog" aria-labelledby="moveCourseModalTitle" aria-modal="true" onclick="if(event.target===this)closeMoveCourseModal();">
                <div style="background: white; border-radius: 1rem; max-width: 600px; width: 90%; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);" onclick="event.stopPropagation();">
                    <div style="padding: 1.5rem 1.5rem 1rem 1.5rem; border-bottom: 0.5px solid rgba(0, 0, 0, 0.1); display: flex; justify-content: space-between; align-items: center;">
                        <h2 id="moveCourseModalTitle" style="margin: 0; font-size: 1.25rem; font-weight: 600; color: var(--text);">Move Students</h2>
                        <button type="button" onclick="closeMoveCourseModal()" aria-label="Close" style="background: none; border: none; padding: 0.5rem; cursor: pointer; color: var(--text-light); border-radius: 0.5rem; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='rgba(0,0,0,0.05)'" onmouseout="this.style.backgroundColor='transparent'">
                            <i data-lucide="x" style="width: 1.25rem; height: 1.25rem;"></i>
                        </button>
                    </div>
                    <div style="padding: 1.5rem; overflow-y: auto; flex: 1;">
                        <p style="color: var(--text-light); font-size: 0.9rem; margin-bottom: 1.5rem;">Move students from this course to another course. This will transfer all selected students to the target course.</p>
                        <div class="form-group" style="margin-bottom: 1.5rem;">
                            <label for="moveCourseSource" style="display: block; font-weight: 500; margin-bottom: 0.5rem; color: var(--text); font-size: 0.9375rem;">From Course</label>
                            <input type="text" id="moveCourseSource" readonly style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; font-size: 1rem; background: var(--bg-alt);">
                        </div>
                        <div class="form-group" style="margin-bottom: 1.5rem;">
                            <label for="moveCourseTarget" style="display: block; font-weight: 500; margin-bottom: 0.5rem; color: var(--text); font-size: 0.9375rem;">To Course *</label>
                            <select id="moveCourseTarget" required style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; font-size: 1rem; transition: border-color 0.2s;" onfocus="this.style.borderColor='var(--primary)'" onblur="this.style.borderColor='var(--border)'">
                                <option value="">-- Select Course --</option>
                            </select>
                        </div>
                        <div class="form-group" style="margin-bottom: 1.5rem;">
                            <label style="display: block; font-weight: 500; margin-bottom: 0.5rem; color: var(--text); font-size: 0.9375rem;">Students to Move</label>
                            <div id="moveCourseStudentsList" style="max-height: 200px; overflow-y: auto; border: 1px solid var(--border); border-radius: 0.5rem; padding: 0.75rem; background: white;">
                                <p style="color: var(--text-light); text-align: center;">Loading students...</p>
                            </div>
                        </div>
                    </div>
                    <div style="padding: 1rem 1.5rem; border-top: 0.5px solid rgba(0, 0, 0, 0.1); display: flex; gap: 0.75rem; justify-content: flex-end;">
                        <button type="button" onclick="closeMoveCourseModal()" class="btn-secondary" style="padding: 0.625rem 1.25rem; font-size: 0.9375rem; font-weight: 500; border-radius: 0.5rem;">Cancel</button>
                        <button type="button" onclick="executeMoveCourse()" style="padding: 0.625rem 1.25rem; background: var(--primary); color: white; border: none; border-radius: 0.5rem; font-size: 0.9375rem; font-weight: 500; cursor: pointer; transition: opacity 0.2s;" onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">
                            <span class="icon-with-text"><i data-lucide="move" style="width:1em;height:1em;"></i> Move Students</span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Admin panel content moved here by JS for admin/super admin -->
            <div id="dashboardAdminContainer" style="display: none; margin-top: 2rem;"></div>
        </section>

        <!-- Settings Section -->
        <section id="settingsSection" class="section" aria-label="Settings">
            <div class="card">
                <div class="card-header"><span class="icon-with-text"><i data-lucide="settings"></i> Settings</span></div>
                <div class="card-body" style="padding: 1.25rem;">
                <div id="settingsTablist" role="tablist" class="settings-tablist" aria-label="Settings sections">
                    <button type="button" id="settingsTabBtnGeneral" class="settings-tab settings-tab-active" role="tab" aria-selected="true" aria-controls="settingsTabGeneral" onclick="switchSettingsTab('general')"><span class="icon-with-text"><i data-lucide="settings"></i> General</span></button>
                    <button type="button" id="settingsTabBtnAdmin" class="settings-tab" role="tab" aria-selected="false" aria-controls="settingsTabAdmin" onclick="switchSettingsTab('admin')" style="display: none;"><span class="icon-with-text"><i data-lucide="shield"></i> Admin</span></button>
                    <button type="button" id="settingsTabBtnDemo" class="settings-tab" role="tab" aria-selected="false" aria-controls="settingsTabDemo" onclick="switchSettingsTab('demo')" style="display: none;"><span class="icon-with-text"><i data-lucide="palette"></i> Demo Theme Customizer</span></button>
                </div>

                <!-- General: API keys, Save -->
                <div id="settingsTabGeneral" role="tabpanel" aria-labelledby="settingsTabBtnGeneral" style="display: block;">
                    <div class="general-settings-container">
                        <!-- Sidebar Navigation -->
                        <nav class="general-settings-sidebar" aria-label="General settings navigation">
                            <h4>Settings</h4>
                            <ul>
                                <li>
                                    <button type="button" class="general-nav-item active" data-section="appearance" onclick="switchGeneralSection('appearance')" aria-label="Appearance">
                                        <i data-lucide="palette"></i>
                                        <span>Appearance</span>
                                    </button>
                                </li>
                                <li>
                                    <button type="button" class="general-nav-item" data-section="consent" onclick="switchGeneralSection('consent')" aria-label="Consent Management">
                                        <i data-lucide="clipboard-check"></i>
                                        <span>Consent Management</span>
                                    </button>
                                </li>
                            </ul>
                        </nav>

                        <!-- Content Area -->
                        <div class="general-settings-content">
                            <!-- Appearance Section -->
                            <section id="generalSectionAppearance" class="general-section active">
                                <div class="general-section-header">
                                    <h2>Appearance</h2>
                                    <p class="general-section-description">Customize the look and feel of the application</p>
                                </div>

                                <div class="general-card">
                                    <div class="form-group">
                                        <label for="tenantSelect">University / Theme</label>
                                        <select id="tenantSelect" onchange="switchTenant(this.value)">
                                            <option value="default">Generic / Default</option>
                                            <option value="utk">University of Tennessee, Knoxville</option>
                                        </select>
                                    </div>

                                    <div class="form-group" style="margin-top: 1.5rem;">
                                        <label style="display: flex; align-items: center; gap: 0.75rem; cursor: pointer;">
                                            <input type="checkbox" id="darkModeToggle" onchange="toggleDarkMode(this.checked)" style="width: 1.25rem; height: 1.25rem; cursor: pointer;">
                                            <span class="icon-with-text"><i data-lucide="moon"></i> Dark Mode</span>
                                        </label>
                                        <p style="font-size: 0.85rem; color: var(--text-light); margin-top: 0.5rem; margin-left: 2rem;">Switch between light and dark themes</p>
                                    </div>
                                </div>

                                <div id="settingsMessage" class="hidden" style="margin-top: 2rem;"></div>
                                
                                <!-- Save Settings button - only visible in General tab -->
                                <div id="saveSettingsButtonContainer" style="gap: 1rem; margin-top: 2rem; padding-top: 1.5rem; border-top: 1px solid var(--border);">
                                    <button onclick="saveSettings()"><span class="icon-with-text"><i data-lucide="save"></i> Save Settings</span></button>
                                </div>
                            </section>
                            
                            <!-- Consent Section -->
                            <section id="generalSectionConsent" class="general-section">
                                <div class="general-section-header">
                                    <h2>Consent Management</h2>
                                    <p class="general-section-description">Generate unique consent links for students and manage data use consent</p>
                                </div>

                                <div class="general-card">
                                    <p style="color: var(--text-light); margin-bottom: 1rem;">Generate unique consent links for students. Email each student their link; when they open it and submit, their response is saved in the database.</p>
                                    <div class="info-box">
                                        One consent covers: grading, platform and AI improvement, research, and potential sharing or licensing of data to third parties. Students who do not consent can still be evaluated; their data stays on your device only.
                                    </div>
                                    <div class="consent-toolbar">
                                        <div class="form-group">
                                            <label for="consentCourseSelect">Course</label>
                                            <select id="consentCourseSelect">
                                                <option value="">Select a course</option>
                                            </select>
                                        </div>
                                        <button id="consentGenerateBtn" onclick="generateConsentLinks()" class="btn">Generate links for all students</button>
                                    </div>
                                    <div id="consentLinksMessage" style="margin-bottom: 1rem; color: var(--text-light); font-size: 0.9rem;"></div>
                                    <div id="consentLinksContainer" class="hidden">
                                        <div class="consent-actions">
                                            <button type="button" onclick="sendAllConsentEmails()" class="btn btn-small"><span class="icon-with-text"><i data-lucide="mail"></i> Send all emails</span></button>
                                            <button type="button" onclick="copyAllConsentLinks()" class="btn-secondary btn-small">Copy all links</button>
                                            <button type="button" onclick="downloadConsentCSV()" class="btn-secondary btn-small">Download CSV</button>
                                        </div>
                                        <div style="overflow-x: auto;">
                                            <table class="data-table" id="consentLinksTable">
                                                <thead>
                                                    <tr><th>Student</th><th>Email</th><th>Consent link</th><th>Actions</th></tr>
                                                </thead>
                                                <tbody id="consentLinksTableBody"></tbody>
                                            </table>
                                        </div>
                                    </div>
                                </div>
                            </section>
                        </div>
                    </div>
                </div><!-- /settingsTabGeneral -->

                <!-- Tab: Energy & Sustainability -->
                <!-- Tab: Demo Theme Customizer (Demo only; resets on logout) -->
                <div id="settingsTabDemo" role="panel" aria-labelledby="settingsTabBtnDemo" style="display: none; padding-top: 1.5rem;">
                    <h3 class="settings-section-heading"><span class="icon-with-text"><i data-lucide="palette"></i> Demo Theme Customizer</span></h3>
                    <p style="color: var(--text-light); margin-bottom: 1rem;">Customize colors, logo, and font for this session. All changes reset when you log out.</p>
                    <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 1.5rem;">
                        <h4 class="settings-section-subheading" style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="package"></i> Branding Package</span></h4>
                        <p style="font-size: 0.9rem; color: var(--text-light); margin-bottom: 1rem;">Load a preset to preview a theme. You can then tweak colors below.</p>
                        <div class="form-group" style="max-width: 400px; margin-bottom: 1rem;">
                            <select id="demoBrandingPackageSelect" onchange="onDemoBrandingPackageChange(this.value)" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                <option value="default">SpeechGradebook Default</option>
                                <option value="utk-wds">UTK WDS (University of Tennessee, Knoxville)</option>
                                <option value="option4">Option 4: Sophisticated Navy</option>
                                <option value="option7">Option 7: Current Primary Refined</option>
                                <option value="option7-apple">Option 7: Current Primary Refined (Apple-aligned)</option>
                                <option value="option7-dark">Option 7: Dark Theme</option>
                                <option value="option8">Option 8: Ideal Apple HIG</option>
                            </select>
                        </div>
                        <h4 class="settings-section-subheading" style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="palette"></i> Theme colors</span></h4>
                        <p style="font-size: 0.85rem; color: var(--text-light); margin-bottom: 1rem;">Use the color swatch, hex field, or "Color picker…" for the 2D hue/saturation picker.</p>
                        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 1rem;">
                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Primary</label>
                                <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                                    <input type="color" id="demoThemePrimary" value="#1e3a5f" style="width: 2.5rem; height: 2rem; border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">
                                    <input type="text" id="demoThemePrimaryText" value="#1e3a5f" maxlength="7" placeholder="#1e3a5f" style="width: 5.5rem; padding: 0.35rem; border: 1px solid var(--border); border-radius: 0.25rem; font-family: ui-monospace, monospace; font-size: 0.85rem;">
                                    <button type="button" onclick="openThemeColorPicker('demoThemePrimary','demoThemePrimaryText','Primary')" style="padding: 0.35rem 0.5rem; font-size: 0.75rem; background: var(--bg); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">Color picker…</button>
                                </div>
                            </div>
                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Header / Primary dark</label>
                                <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                                    <input type="color" id="demoThemePrimaryDark" value="#142940" style="width: 2.5rem; height: 2rem; border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">
                                    <input type="text" id="demoThemePrimaryDarkText" value="#142940" maxlength="7" placeholder="#142940" style="width: 5.5rem; padding: 0.35rem; border: 1px solid var(--border); border-radius: 0.25rem; font-family: ui-monospace, monospace; font-size: 0.85rem;">
                                    <button type="button" onclick="openThemeColorPicker('demoThemePrimaryDark','demoThemePrimaryDarkText','Header')" style="padding: 0.35rem 0.5rem; font-size: 0.75rem; background: var(--bg); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">Color picker…</button>
                                </div>
                            </div>
                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Secondary</label>
                                <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                                    <input type="color" id="demoThemeSecondary" value="#c8a882" style="width: 2.5rem; height: 2rem; border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">
                                    <input type="text" id="demoThemeSecondaryText" value="#c8a882" maxlength="7" placeholder="#c8a882" style="width: 5.5rem; padding: 0.35rem; border: 1px solid var(--border); border-radius: 0.25rem; font-family: ui-monospace, monospace; font-size: 0.85rem;">
                                    <button type="button" onclick="openThemeColorPicker('demoThemeSecondary','demoThemeSecondaryText','Secondary')" style="padding: 0.35rem 0.5rem; font-size: 0.75rem; background: var(--bg); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">Color picker…</button>
                                </div>
                            </div>
                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Accent</label>
                                <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                                    <input type="color" id="demoThemeAccent" value="#d4af37" style="width: 2.5rem; height: 2rem; border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">
                                    <input type="text" id="demoThemeAccentText" value="#d4af37" maxlength="7" placeholder="#d4af37" style="width: 5.5rem; padding: 0.35rem; border: 1px solid var(--border); border-radius: 0.25rem; font-family: ui-monospace, monospace; font-size: 0.85rem;">
                                    <button type="button" onclick="openThemeColorPicker('demoThemeAccent','demoThemeAccentText','Accent')" style="padding: 0.35rem 0.5rem; font-size: 0.75rem; background: var(--bg); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">Color picker…</button>
                                </div>
                            </div>
                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Text</label>
                                <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                                    <input type="color" id="demoThemeText" value="#2c3e50" style="width: 2.5rem; height: 2rem; border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">
                                    <input type="text" id="demoThemeTextText" value="#2c3e50" maxlength="7" placeholder="#2c3e50" style="width: 5.5rem; padding: 0.35rem; border: 1px solid var(--border); border-radius: 0.25rem; font-family: ui-monospace, monospace; font-size: 0.85rem;">
                                    <button type="button" onclick="openThemeColorPicker('demoThemeText','demoThemeTextText','Text')" style="padding: 0.35rem 0.5rem; font-size: 0.75rem; background: var(--bg); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">Color picker…</button>
                                </div>
                            </div>
                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Text light</label>
                                <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                                    <input type="color" id="demoThemeTextLight" value="#6c757d" style="width: 2.5rem; height: 2rem; border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">
                                    <input type="text" id="demoThemeTextLightText" value="#6c757d" maxlength="7" placeholder="#6c757d" style="width: 5.5rem; padding: 0.35rem; border: 1px solid var(--border); border-radius: 0.25rem; font-family: ui-monospace, monospace; font-size: 0.85rem;">
                                    <button type="button" onclick="openThemeColorPicker('demoThemeTextLight','demoThemeTextLightText','Text light')" style="padding: 0.35rem 0.5rem; font-size: 0.75rem; background: var(--bg); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">Color picker…</button>
                                </div>
                            </div>
                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Background</label>
                                <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                                    <input type="color" id="demoThemeBg" value="#fafbfc" style="width: 2.5rem; height: 2rem; border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">
                                    <input type="text" id="demoThemeBgText" value="#fafbfc" maxlength="7" placeholder="#fafbfc" style="width: 5.5rem; padding: 0.35rem; border: 1px solid var(--border); border-radius: 0.25rem; font-family: ui-monospace, monospace; font-size: 0.85rem;">
                                    <button type="button" onclick="openThemeColorPicker('demoThemeBg','demoThemeBgText','Background')" style="padding: 0.35rem 0.5rem; font-size: 0.75rem; background: var(--bg); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">Color picker…</button>
                                </div>
                            </div>
                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Background alt</label>
                                <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                                    <input type="color" id="demoThemeBgAlt" value="#f1f4f7" style="width: 2.5rem; height: 2rem; border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">
                                    <input type="text" id="demoThemeBgAltText" value="#f1f4f7" maxlength="7" placeholder="#f1f4f7" style="width: 5.5rem; padding: 0.35rem; border: 1px solid var(--border); border-radius: 0.25rem; font-family: ui-monospace, monospace; font-size: 0.85rem;">
                                    <button type="button" onclick="openThemeColorPicker('demoThemeBgAlt','demoThemeBgAltText','Background alt')" style="padding: 0.35rem 0.5rem; font-size: 0.75rem; background: var(--bg); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">Color picker…</button>
                                </div>
                            </div>
                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Card</label>
                                <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                                    <input type="color" id="demoThemeCard" value="#ffffff" style="width: 2.5rem; height: 2rem; border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">
                                    <input type="text" id="demoThemeCardText" value="#ffffff" maxlength="7" placeholder="#ffffff" style="width: 5.5rem; padding: 0.35rem; border: 1px solid var(--border); border-radius: 0.25rem; font-family: ui-monospace, monospace; font-size: 0.85rem;">
                                    <button type="button" onclick="openThemeColorPicker('demoThemeCard','demoThemeCardText','Card')" style="padding: 0.35rem 0.5rem; font-size: 0.75rem; background: var(--bg); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">Color picker…</button>
                                </div>
                            </div>
                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Border</label>
                                <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                                    <input type="color" id="demoThemeBorder" value="#e1e8ed" style="width: 2.5rem; height: 2rem; border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">
                                    <input type="text" id="demoThemeBorderText" value="#e1e8ed" maxlength="7" placeholder="#e1e8ed" style="width: 5.5rem; padding: 0.35rem; border: 1px solid var(--border); border-radius: 0.25rem; font-family: ui-monospace, monospace; font-size: 0.85rem;">
                                    <button type="button" onclick="openThemeColorPicker('demoThemeBorder','demoThemeBorderText','Border')" style="padding: 0.35rem 0.5rem; font-size: 0.75rem; background: var(--bg); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">Color picker…</button>
                                </div>
                            </div>
                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Success</label>
                                <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                                    <input type="color" id="demoThemeSuccess" value="#059669" style="width: 2.5rem; height: 2rem; border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">
                                    <input type="text" id="demoThemeSuccessText" value="#059669" maxlength="7" placeholder="#059669" style="width: 5.5rem; padding: 0.35rem; border: 1px solid var(--border); border-radius: 0.25rem; font-family: ui-monospace, monospace; font-size: 0.85rem;">
                                    <button type="button" onclick="openThemeColorPicker('demoThemeSuccess','demoThemeSuccessText','Success')" style="padding: 0.35rem 0.5rem; font-size: 0.75rem; background: var(--bg); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">Color picker…</button>
                                </div>
                            </div>
                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Warning</label>
                                <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                                    <input type="color" id="demoThemeWarning" value="#d97706" style="width: 2.5rem; height: 2rem; border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">
                                    <input type="text" id="demoThemeWarningText" value="#d97706" maxlength="7" placeholder="#d97706" style="width: 5.5rem; padding: 0.35rem; border: 1px solid var(--border); border-radius: 0.25rem; font-family: ui-monospace, monospace; font-size: 0.85rem;">
                                    <button type="button" onclick="openThemeColorPicker('demoThemeWarning','demoThemeWarningText','Warning')" style="padding: 0.35rem 0.5rem; font-size: 0.75rem; background: var(--bg); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">Color picker…</button>
                                </div>
                            </div>
                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Error</label>
                                <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                                    <input type="color" id="demoThemeError" value="#b91c1c" style="width: 2.5rem; height: 2rem; border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">
                                    <input type="text" id="demoThemeErrorText" value="#b91c1c" maxlength="7" placeholder="#b91c1c" style="width: 5.5rem; padding: 0.35rem; border: 1px solid var(--border); border-radius: 0.25rem; font-family: ui-monospace, monospace; font-size: 0.85rem;">
                                    <button type="button" onclick="openThemeColorPicker('demoThemeError','demoThemeErrorText','Error')" style="padding: 0.35rem 0.5rem; font-size: 0.75rem; background: var(--bg); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;">Color picker…</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 1.5rem;">
                        <p style="font-size: 0.9rem; color: var(--text-light); margin-bottom: 1rem;">The SpeechGradebook logo is used for all themes.</p>
                    </div>
                    <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 1.5rem;">
                        <h4 class="settings-section-subheading" style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="type"></i> Font</span></h4>
                        <div style="margin-bottom: 1rem;">
                            <label for="demoFontSelect" style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Built-in font</label>
                            <select id="demoFontSelect" style="width: 100%; max-width: 280px; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                <option value="">Default (Crimson Pro / Work Sans)</option>
                                <option value="'Crimson Pro', serif">Crimson Pro (serif)</option>
                                <option value="'Work Sans', sans-serif">Work Sans</option>
                                <option value="'Montserrat', sans-serif">Montserrat</option>
                                <option value="'Roboto', sans-serif">Roboto</option>
                                <option value="'Open Sans', sans-serif">Open Sans</option>
                                <option value="'Georgia', serif">Georgia</option>
                                <option value="__custom__">Upload my own font</option>
                            </select>
                        </div>
                        <div id="demoCustomFontWrap" style="display: none; margin-top: 1rem; padding: 1rem; border: 2px dashed var(--border); border-radius: 0.5rem;">
                            <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Custom font file</label>
                            <p style="font-size: 0.85rem; color: var(--text-light); margin-bottom: 0.5rem;">WOFF2, WOFF, TTF, or OTF. One file (Regular weight).</p>
                            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center;">
                                <input type="text" id="demoCustomFontName" placeholder="Font family name" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; min-width: 180px;">
                                <input type="file" id="demoCustomFontFile" accept=".woff2,.woff,.ttf,.otf" style="padding: 0.5rem;">
                            </div>
                            <p id="demoCustomFontStatus" style="font-size: 0.85rem; margin-top: 0.5rem; color: var(--text-light);"></p>
                        </div>
                    </div>
                    <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 1.5rem;">
                        <h4 class="settings-section-subheading" style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="type"></i> Tagline</span></h4>
                        <input type="text" id="demoTagline" placeholder="Instructor-Informed Speech Assessment" style="width: 100%; max-width: 400px; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                    </div>
                    <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                        <button type="button" onclick="applyDemoThemeFromForm()" style="background: var(--primary); color: white;"><span class="icon-with-text"><i data-lucide="check"></i> Apply</span></button>
                        <button type="button" onclick="resetDemoThemeAndForm()" class="btn-secondary"><span class="icon-with-text"><i data-lucide="refresh-cw"></i> Reset to default</span></button>
                    </div>
                    <p id="demoThemeStatus" style="margin-top: 1rem; font-size: 0.9rem; color: var(--text-light);"></p>
                </div><!-- /settingsTabDemo -->

                <!-- Tab: Admin (Admin Panel with Sidebar Navigation) -->
                <div id="settingsTabAdmin" role="tabpanel" aria-labelledby="settingsTabBtnAdmin" style="display: none; padding-top: 1.5rem;">
                    <div class="admin-settings-container">
                        <!-- Left Sidebar: Category Navigation -->
                        <nav class="admin-settings-sidebar" aria-label="Admin settings navigation">
                            <h4>Admin Settings</h4>
                            <ul>
                                <li data-admin-only="true" style="display: none;">
                                    <button type="button" class="admin-nav-item active" data-section="institution" onclick="switchAdminSection('institution')" aria-label="Institution Management">
                                        <i data-lucide="building-2"></i>
                                        <span>Institution</span>
                                    </button>
                                </li>
                                <li data-admin-only="true" style="display: none;">
                                    <button type="button" class="admin-nav-item" data-section="users" onclick="switchAdminSection('users')" aria-label="User Management">
                                        <i data-lucide="users"></i>
                                        <span>Users</span>
                                        <span class="badge" id="usersBadge" style="display: none;">0</span>
                                    </button>
                                </li>
                                <li data-admin-only="true" style="display: none;">
                                    <button type="button" class="admin-nav-item" data-section="branding" onclick="switchAdminSection('branding')" aria-label="Branding & Theme">
                                        <i data-lucide="palette"></i>
                                        <span>Branding</span>
                                    </button>
                                </li>
                                <li data-admin-only="true" style="display: none;">
                                    <button type="button" class="admin-nav-item" data-section="system" onclick="switchAdminSection('system')" aria-label="Data Management">
                                        <i data-lucide="database"></i>
                                        <span>Data Management</span>
                                    </button>
                                </li>
                                <li>
                                    <button type="button" class="admin-nav-item" data-section="monitoring" onclick="switchAdminSection('monitoring')" aria-label="Monitoring & Analytics">
                                        <i data-lucide="bar-chart-2"></i>
                                        <span>Monitoring</span>
                                    </button>
                                </li>
                                <li data-admin-only="true" style="display: none;">
                                    <button type="button" class="admin-nav-item" data-section="compliance" onclick="switchAdminSection('compliance')" aria-label="Compliance & Testing">
                                        <i data-lucide="shield-check"></i>
                                        <span>Compliance</span>
                                    </button>
                                </li>
                            </ul>
                        </nav>
                        
                        <!-- Right Panel: Content Area -->
                        <div class="admin-settings-content">
                            
                            <!-- Institution Section -->
                            <section id="adminSectionInstitution" class="admin-section active">
                                <div class="admin-section-header">
                                    <h2>Institution Management</h2>
                                    <p class="admin-section-description">Create and manage institutions</p>
                                </div>
                                
                <!-- Create new institution (Super Admin only) -->
                                <div id="createInstitutionWrap" class="admin-card" style="display: none;">
                                    <h3><span class="icon-with-text"><i data-lucide="building-2"></i> Create New Institution</span></h3>
                                    <p>Add a new institution so you can assign users and create themes for it.</p>
                    <div style="display: flex; gap: 1rem; align-items: flex-end; flex-wrap: wrap;">
                        <div class="form-group" style="margin-bottom: 0; flex: 1; min-width: 200px;">
                            <label for="newInstitutionName"><strong>Institution name</strong></label>
                            <input type="text" id="newInstitutionName" placeholder="e.g. State University" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem;">
                        </div>
                        <button type="button" onclick="createNewInstitution()" class="btn" style="background: var(--primary); color: white;"><span class="icon-with-text"><i data-lucide="plus"></i> Create institution</span></button>
                    </div>
                    <div id="createInstitutionStatus" style="margin-top: 1rem;"></div>
                </div>
                            </section>
                            
                            <!-- Users Section -->
                            <section id="adminSectionUsers" class="admin-section">
                                <div class="admin-section-header">
                                    <h2>User Management</h2>
                                    <p class="admin-section-description">Approve users and manage roles</p>
                                </div>
                                
                                <!-- Pending User Approvals (Super Admin only) -->
                                <div id="pendingUsersSection" class="admin-card" style="display: none; margin-bottom: 2rem;">
                                    <h3><span class="icon-with-text"><i data-lucide="clock"></i> Pending User Approvals</span></h3>
                                    <p style="margin-bottom: 1rem; color: var(--text-light);">
                                        Review and approve or reject pending user account requests.
                                    </p>
                                    <div id="pendingUsersContainer">
                                        <p style="color: var(--text-light);">Loading pending users...</p>
                                    </div>
                                </div>
                                
                                <!-- Department Instructors Section (for Admins) -->
                                <div id="departmentInstructorsSection" class="admin-card" style="display: none; margin-bottom: 2rem;">
                                    <h3><span class="icon-with-text"><i data-lucide="users"></i> Department Instructors</span></h3>
                                    <p style="margin-bottom: 1rem; color: var(--text-light);">
                                        View and manage instructors in your department.
                                    </p>
                                    <div style="margin-bottom: 2rem; display: flex; gap: 1rem; align-items: center;">
                                        <button onclick="loadDepartmentInstructors()"><span class="icon-with-text"><i data-lucide="refresh-cw"></i> Refresh Instructors</span></button>
                                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                                            <label for="semesterFilter" style="font-weight: 600;">Filter by Term:</label>
                                            <select id="semesterFilter" onchange="filterBySemester()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                                <option value="all">All Terms</option>
                                                <option value="Fall 2024">Fall 2024</option>
                                                <option value="Spring 2025">Spring 2025</option>
                                                <option value="Fall 2025">Fall 2025</option>
                                                <option value="Spring 2026">Spring 2026</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div id="departmentInstructorsContainer">
                                        <p style="color: var(--text-light);">Click "Refresh Instructors" to load your department's instructors...</p>
                                    </div>
                                </div>
                                
                                <!-- User Management Section (for Super Admins) -->
                                <div id="userManagementSection" class="admin-card" style="display: none;">
                                    <h3><span class="icon-with-text"><i data-lucide="user-cog"></i> User Management</span></h3>
                                    <p style="margin-bottom: 1rem; color: var(--text-light);">
                                        Manage user account tiers and research partner access.
                                    </p>
                                    <div style="margin-bottom: 2rem;">
                                        <button onclick="loadAllUsers()" style="margin-right: 1rem;"><span class="icon-with-text"><i data-lucide="refresh-cw"></i> Refresh Users</span></button>
                                        <button onclick="showInviteForm()" style="background: var(--success);"><span class="icon-with-text"><i data-lucide="user-plus"></i> Invite Research Partner</span></button>
                                    </div>
                                    <div id="usersListContainer">
                                        <p style="color: var(--text-light);">Click "Refresh Users" to load user list...</p>
                                    </div>
                                </div>
                                
                                <!-- Invite Form (hidden by default) -->
                                <div id="inviteFormCard" class="admin-card hidden" style="margin-top: 2rem; display: none;">
                                    <h3>Invite New Research Partner</h3>
                                    <form id="inviteForm" onsubmit="sendInvite(event)">
                                        <div class="form-group">
                                            <label for="inviteEmail">Email Address *</label>
                                            <input type="email" id="inviteEmail" required placeholder="instructor@university.edu">
                                        </div>
                                        <div class="form-group">
                                            <label for="inviteName">Name</label>
                                            <input type="text" id="inviteName" placeholder="Dr. Jane Smith">
                                        </div>
                                        <div class="form-group">
                                            <label for="inviteInstitution">Institution</label>
                                            <input type="text" id="inviteInstitution" placeholder="University Name">
                                        </div>
                                        <div class="form-group">
                                            <label>
                                                <input type="checkbox" id="inviteAutoApprove" checked>
                                                Automatically grant Research Partner access
                                            </label>
                                        </div>
                                        <div style="display: flex; gap: 1rem;">
                                            <button type="button" onclick="cancelInvite()" class="btn-secondary">Cancel</button>
                                            <button type="submit">Send Invitation</button>
                                        </div>
                                    </form>
                                </div>
                            </section>
                            
                            <!-- Branding Section -->
                            <section id="adminSectionBranding" class="admin-section">
                                <div class="admin-section-header">
                                    <h2>Branding & Theme</h2>
                                    <p class="admin-section-description">Customize your institution's appearance</p>
                                </div>

                <!-- Theme Customizer (admins/super admins only) -->
                                <div id="themeCustomizerWrap" class="admin-card" style="display: none;">
                                    <h3><span class="icon-with-text"><i data-lucide="palette"></i> Theme Customizer</span></h3>
                                    <p>Customize your institution's colors, branding, and typography. Changes apply to all users in your institution.</p>
                    <div id="themeCustomizerSection" style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem;">
                        <!-- Super Admin: select which institution's theme to edit or create -->
                        <div id="themeInstitutionRow" style="display: none; margin-bottom: 1.5rem; padding-bottom: 1.5rem; border-bottom: 1px solid var(--border);">
                            <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Institution</label>
                            <select id="themeInstitutionSelect" style="width: 100%; max-width: 400px; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                <option value="">Select institution…</option>
                            </select>
                            <p style="margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-light);">Choose an institution to edit its theme or create a new theme for new institutions.</p>
                        </div>
                        <!-- Super Admin: assign (copy) a theme from one institution to another -->
                        <div id="assignThemeWrap" style="display: none; margin-bottom: 1.5rem; padding-bottom: 1.5rem; border-bottom: 1px solid var(--border);">
                            <h4 class="settings-section-subheading"><span class="icon-with-text"><i data-lucide="copy"></i> Assign theme to institution</span></h4>
                            <p style="margin-bottom: 1rem; font-size: 0.9rem; color: var(--text-light);">Copy an existing institution's theme (colors, logo, fonts) to another institution.</p>
                            <div style="display: flex; gap: 1rem; align-items: flex-end; flex-wrap: wrap;">
                                <div class="form-group" style="margin-bottom: 0; flex: 1; min-width: 180px;">
                                    <label for="assignThemeSourceSelect" style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Copy theme from</label>
                                    <select id="assignThemeSourceSelect" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                        <option value="">Select institution…</option>
                                    </select>
                                </div>
                                <div class="form-group" style="margin-bottom: 0; flex: 1; min-width: 180px;">
                                    <label for="assignThemeTargetSelect" style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Assign to institution</label>
                                    <select id="assignThemeTargetSelect" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                        <option value="">Select institution…</option>
                                    </select>
                                </div>
                                <button type="button" id="assignThemeBtn" onclick="assignThemeToInstitution()" class="btn" style="background: var(--primary); color: white; flex-shrink: 0;"><span class="icon-with-text"><i data-lucide="copy"></i> Assign theme</span></button>
                            </div>
                            <div id="assignThemeStatus" style="margin-top: 0.75rem;"></div>
                        </div>
                        <!-- Branding Package – load template colors from UTK WDS or default -->
                        <div style="margin-bottom: 2rem; padding-bottom: 2rem; border-bottom: 1px solid var(--border);">
                            <h4 class="settings-section-subheading"><span class="icon-with-text"><i data-lucide="package"></i> Branding Package</span></h4>
                            <p style="margin-bottom: 1rem; font-size: 0.9rem; color: var(--text-light);">Load a template to populate colors and fonts. You can change any value before saving.</p>
                            <div class="form-group" style="max-width: 400px;">
                                <label for="brandingPackageSelect" style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Package</label>
                                <select id="brandingPackageSelect" onchange="onBrandingPackageChange(this.value)" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                    <option value="default">SpeechGradebook Default</option>
                                    <option value="utk-wds">UTK WDS (University of Tennessee, Knoxville)</option>
                                </select>
                            </div>
                        </div>
                        <!-- Institution Logo -->
                        <div style="margin-bottom: 2rem; padding-bottom: 2rem; border-bottom: 1px solid var(--border);">
                            <h4 class="settings-section-subheading"><span class="icon-with-text"><i data-lucide="image"></i> Institution Logo</span></h4>
                            <p style="font-size: 0.9rem; color: var(--text-light);">The SpeechGradebook logo is used for all themes.</p>
                        </div>
                        <!-- Color Settings -->
                        <div style="margin-bottom: 2rem; padding-bottom: 2rem; border-bottom: 1px solid var(--border);">
                            <h4 class="settings-section-subheading"><span class="icon-with-text"><i data-lucide="palette"></i> Institution Colors</span></h4>
                                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem;">
                                        <div>
                                            <label style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Primary Color (Buttons)</label>
                                            <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                                                <input type="color" id="themePrimaryColor" value="#1e3a5f" style="width: 60px; height: 40px; border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;" title="Pick color">
                                                <input type="text" id="themePrimaryText" value="#1e3a5f" style="flex: 1; min-width: 6rem; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;" placeholder="#000000" maxlength="7" title="Hex code">
                                                <button type="button" onclick="openThemeColorPicker('themePrimaryColor','themePrimaryText','Primary')" style="padding: 0.35rem 0.6rem; font-size: 0.8rem; background: var(--bg-alt); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer; color: var(--primary);">Color picker…</button>
                                            </div>
                                        </div>
                                        <div>
                                            <label style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Header Background</label>
                                            <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                                                <input type="color" id="themeHeaderColor" value="#142940" style="width: 60px; height: 40px; border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;" title="Pick color">
                                                <input type="text" id="themeHeaderText" value="#142940" style="flex: 1; min-width: 6rem; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;" placeholder="#000000" maxlength="7" title="Hex code">
                                                <button type="button" onclick="openThemeColorPicker('themeHeaderColor','themeHeaderText','Header')" style="padding: 0.35rem 0.6rem; font-size: 0.8rem; background: var(--bg-alt); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer; color: var(--primary);">Color picker…</button>
                                            </div>
                                        </div>
                                        <div>
                                            <label style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Secondary Color</label>
                                            <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                                                <input type="color" id="themeSecondaryColor" value="#8b9dc3" style="width: 60px; height: 40px; border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;" title="Pick color">
                                                <input type="text" id="themeSecondaryText" value="#8b9dc3" style="flex: 1; min-width: 6rem; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;" placeholder="#000000" maxlength="7" title="Hex code">
                                                <button type="button" onclick="openThemeColorPicker('themeSecondaryColor','themeSecondaryText','Secondary')" style="padding: 0.35rem 0.6rem; font-size: 0.8rem; background: var(--bg-alt); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer; color: var(--primary);">Color picker…</button>
                                            </div>
                                        </div>
                                        <div>
                                            <label style="display: block; font-weight: 600; margin-bottom: 0.35rem;">Primary Text</label>
                                            <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                                                <input type="color" id="themeTextColor" value="#2c3e50" style="width: 60px; height: 40px; border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer;" title="Pick color">
                                                <input type="text" id="themeTextText" value="#2c3e50" style="flex: 1; min-width: 6rem; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;" placeholder="#000000" maxlength="7" title="Hex code">
                                                <button type="button" onclick="openThemeColorPicker('themeTextColor','themeTextText','Primary Text')" style="padding: 0.35rem 0.6rem; font-size: 0.8rem; background: var(--bg-alt); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer; color: var(--primary);">Color picker…</button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                        <!-- Typography Settings -->
                        <div style="margin-bottom: 2rem; padding-bottom: 2rem; border-bottom: 1px solid var(--border);">
                            <h4 class="settings-section-subheading"><span class="icon-with-text"><i data-lucide="type"></i> Typography</span></h4>
                                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin-bottom: 1.5rem;">
                                        <div>
                                            <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Heading Font</label>
                                            <select id="themeHeadingFont" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                                <option value="'Inter', -apple-system, sans-serif">Inter (Default)</option>
                                                <option value="'Crimson Pro', serif">Crimson Pro (Serif)</option>
                                                <option value="'Montserrat', sans-serif">Montserrat</option>
                                                <option value="'Roboto', sans-serif">Roboto</option>
                                                <option value="'Open Sans', sans-serif">Open Sans</option>
                                                <option value="'Lato', sans-serif">Lato</option>
                                                <option value="'Poppins', sans-serif">Poppins</option>
                                                <option value="'Raleway', sans-serif">Raleway</option>
                                                <option value="'Playfair Display', serif">Playfair Display</option>
                                                <option value="'Georgia', serif">Georgia</option>
                                            </select>
                                        </div>
                                        <div>
                                            <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Body Font</label>
                                            <select id="themeBodyFont" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                                <option value="'Inter', -apple-system, sans-serif">Inter (Default)</option>
                                                <option value="'Work Sans', sans-serif">Work Sans</option>
                                                <option value="'Roboto', sans-serif">Roboto</option>
                                                <option value="'Open Sans', sans-serif">Open Sans</option>
                                                <option value="'Lato', sans-serif">Lato</option>
                                                <option value="'Source Sans Pro', sans-serif">Source Sans Pro</option>
                                                <option value="'Source Sans 3', -apple-system, sans-serif">Source Sans 3</option>
                                                <option value="'Noto Sans', sans-serif">Noto Sans</option>
                                                <option value="'Georgia', serif">Georgia</option>
                                                <option value="'Times New Roman', serif">Times New Roman</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div style="background: var(--bg); padding: 1.5rem; border-radius: 0.5rem; border: 2px dashed var(--border);">
                                        <h5 style="margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;"><span class="icon-with-text"><i data-lucide="package" style="width:1.1em;height:1.1em;"></i> Custom Font Packages</span></h5>
                                        <p style="font-size: 0.9rem; color: var(--text-light); margin-bottom: 1rem;">Upload your institution's official font files. Supported formats: WOFF2, WOFF, TTF, OTF</p>
                                        <div style="margin-bottom: 1rem;">
                                            <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Font Family Name</label>
                                            <input type="text" id="customFontName" placeholder="e.g., UT Volunteer" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                            <p style="font-size: 0.85rem; color: var(--text-light); margin-top: 0.25rem;">This is the display name that will appear in the font selector.</p>
                                        </div>
                                        <div style="margin-bottom: 1rem;">
                                            <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Font Files</label>
                                            <input type="file" id="customFontFiles" accept=".woff2,.woff,.ttf,.otf" multiple style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                                            <p style="font-size: 0.85rem; color: var(--text-light); margin-top: 0.25rem;">Select a folder or multiple font files. The system will automatically find and use only the Regular variant.</p>
                                            <div style="margin-top: 0.75rem; padding: 0.75rem; background: #fff3cd; border: 1px solid #ffc107; border-radius: 0.25rem;">
                                                <strong style="color: #856404;"><span class="icon-with-text"><i data-lucide="info" style="width:1em;height:1em;"></i> Storage Optimization:</span></strong>
                                                <span style="color: #856404; font-size: 0.85rem;">Only the <strong>Regular</strong> (normal weight) font file will be saved to the database. All Bold, Italic, and other variants will be discarded to save storage space.</span>
                                            </div>
                                        </div>
                                        <button onclick="uploadCustomFont()" style="background: var(--secondary);"><span class="icon-with-text"><i data-lucide="upload"></i> Upload Font Package</span></button>
                                        <div id="customFontsList" style="margin-top: 1rem; display: none;">
                                            <h6 style="margin-bottom: 0.5rem; font-weight: 600;">Installed Custom Fonts:</h6>
                                            <div id="customFontsContainer" style="display: flex; flex-direction: column; gap: 0.5rem;"></div>
                                        </div>
                                    </div>
                                </div>
                                <div style="display: flex; gap: 1rem; padding-top: 2rem; border-top: 1px solid var(--border); flex-wrap: wrap;">
                                    <button type="button" onclick="createNewTheme()" style="background: var(--primary); color: white;"><span class="icon-with-text"><i data-lucide="plus"></i> Create new theme</span></button>
                                    <button onclick="previewTheme()" style="background: var(--secondary);"><span class="icon-with-text"><i data-lucide="eye"></i> Preview</span></button>
                                    <button onclick="saveInstitutionTheme()" style="background: var(--success);"><span class="icon-with-text"><i data-lucide="save"></i> Save Theme</span></button>
                                    <button onclick="resetThemeForm()" style="background: var(--error);"><span class="icon-with-text"><i data-lucide="refresh-cw"></i> Reset</span></button>
                                </div>
                                <div id="themeStatus" style="margin-top: 1rem;"></div>
                    </div>
                </div>
                
                <!-- Shared HTML Color Codes–style color picker (2D + hue + hex/RGB) -->
                <div id="themeColorPickerPanel" class="theme-color-picker-panel" role="dialog" aria-label="Color picker" aria-modal="true">
                    <div class="picker-backdrop" onclick="closeThemeColorPicker()"></div>
                    <div>
                        <p style="margin: 0 0 0.75rem; font-weight: 600; font-size: 1rem;" id="themeColorPickerTitle">Pick color</p>
                        <div class="picker-2d-wrap" id="themePicker2dWrap">
                            <div class="picker-2d" id="themePicker2d"></div>
                            <div class="picker-2d-marker" id="themePicker2dMarker"></div>
                        </div>
                        <div class="picker-hue-wrap" id="themePickerHueWrap">
                            <div class="picker-hue-marker" id="themePickerHueMarker"></div>
                        </div>
                        <div class="picker-codes">
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <div class="picker-preview" id="themePickerPreview"></div>
                                <div>
                                    <label for="themePickerHex">Hex</label>
                                    <input type="text" id="themePickerHex" value="#1e3a5f" maxlength="7" placeholder="#000000" style="width: 7rem; margin-left: 0.35rem;">
                                </div>
                            </div>
                            <div>
                                <label>RGB</label>
                                <span id="themePickerRgb" style="font-family: ui-monospace, monospace; font-size: 0.875rem; margin-left: 0.35rem;">30, 58, 95</span>
                            </div>
                        </div>
                        <div class="picker-actions">
                            <button type="button" onclick="closeThemeColorPicker()" class="btn-secondary">Cancel</button>
                            <button type="button" id="themePickerApply" class="btn" style="background: var(--primary); color: white;">Apply</button>
                        </div>
                    </div>
                            </section>
                            
                            <!-- System Section -->
                            <section id="adminSectionSystem" class="admin-section">
                                <div class="admin-section-header">
                                    <h2>Data Management</h2>
                                    <p class="admin-section-description">Manage data exports, recovery, and deletion scope</p>
                                </div>
                                
                                <!-- Qwen Service URL -->
                                <div id="apiKeysSectionSuperAdminOnly" class="admin-card" style="margin-bottom: 2rem; display: none;">
                                    <h3><span class="icon-with-text"><i data-lucide="key"></i> Qwen Service URL</span></h3>
                                    <p style="font-size: 0.9rem; color: var(--text-light); margin-bottom: 1.5rem;">
                                        Set your SpeechGradebook Text + Video Model (Qwen) service URL. Qwen runs on Modal (serverless GPU). Set <code>QWEN_API_URL</code> on Render to your Modal URL. See <code>RECOMMENDED_SETUP.md</code> for setup instructions.
                                    </p>

                                    <div class="form-group">
                                        <p style="font-size: 0.85rem; color: var(--text-light); margin-bottom: 0.5rem;">Set this to your Modal URL (e.g. <code>https://yourname--qwen-speechgradebook.modal.run</code>). See <code>llm_training/QWEN_MODAL_SETUP.md</code> for deployment instructions.</p>
                                        <label for="savedQwenUrl"><strong>SpeechGradebook Text + Video Model (Qwen) Service URL</strong></label>
                                        <input type="text" id="savedQwenUrl" placeholder="https://yourname--qwen-speechgradebook.modal.run" style="width: 100%; padding: 0.75rem; border: 2px solid var(--border); border-radius: 0.5rem; font-size: 1rem;">
                                        <p style="font-size: 0.875rem; color: var(--text-light); margin-top: 0.5rem;">
                                            <strong>Use case:</strong> Rubric extraction from PDF/images, video analysis (body movement, eye contact)<br>
                                            <strong>Setup:</strong> Deploy Qwen on Modal and configure the service URL. A new training method is being set up to replace the previous ISAAC-based workflow.
                                        </p>
                                        <div style="margin-top: 0.75rem; display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap;">
                                            <button type="button" id="qwenStatusBtn" onclick="checkQwenStatus()" class="btn-secondary" style="padding: 0.5rem 1rem;">Check Qwen status</button>
                                            <span id="qwenStatusResult" style="font-size: 0.9rem;"></span>
                                        </div>
                                        <p style="font-size: 0.85rem; color: var(--text-light); margin-top: 0.5rem;">
                                            <strong>Note:</strong> The previous ISAAC-based training workflow is no longer in use. A new training method is being configured. For now, use Modal for Qwen service deployment. See <code>llm_training/QWEN_MODAL_SETUP.md</code> for current setup instructions.
                                        </p>
                                        <p style="font-size: 0.85rem; color: var(--text-light); margin-top: 0.5rem;">
                                            <strong>Can't connect to the Modal URL?</strong> (1) Verify your Modal deployment is running and accessible. (2) Use <strong>Check Qwen status</strong> above to verify connectivity. (3) If the app runs on Render, set <code>QWEN_API_URL</code> in Render dashboard environment variables and redeploy so the app uses the correct URL.
                                        </p>
                                    </div>
                                </div>

                                <!-- Recover Deleted Items -->
                                <div class="admin-card" style="margin-bottom: 2rem;">
                                    <h3><span class="icon-with-text"><i data-lucide="rotate-ccw"></i> Recover Deleted Items</span></h3>
                                    <p style="margin-bottom: 1rem; color: var(--text-light);">
                                        Restore students, evaluations, or courses you removed with Delete/Remove (does not recover items permanently deleted by a super admin).
                                    </p>
                                    <button onclick="showRecoverDeletedModal()" class="btn"><span class="icon-with-text"><i data-lucide="rotate-ccw"></i> Recover deleted items</span></button>
                                </div>
                                
                                <!-- LLM Training Data Export (Super Admin only) -->
                                <div id="llmTrainingSettingsWrap" class="admin-card" style="display: none; margin-bottom: 2rem;">
                                    <h3><span class="icon-with-text"><i data-lucide="cpu"></i> LLM Training Data Export</span> <span class="support-tier-badge" data-tier="super_admin">Super Admin</span></h3>
                                    <p style="margin-bottom: 1rem; color: var(--text-light);">Export consented evaluations to train the <strong>SpeechGradebook Text Model (Mistral)</strong> and the <strong>SpeechGradebook Text + Video Model (Qwen)</strong>.</p>
                                    
                                    <div style="display: flex; gap: 1rem; align-items: center; flex-wrap: wrap; margin-bottom: 0.75rem;">
                                        <button type="button" onclick="downloadLLMTrainingData()" class="btn" style="background: var(--primary); color: white;"><span class="icon-with-text"><i data-lucide="download"></i> Export for Mistral (exported.json)</span></button>
                                        <span id="llmTrainingSettingsStatus" style="font-size: 0.85rem; color: var(--text-light);"></span>
                                    </div>
                                    
                                    <p style="margin-bottom: 0.5rem; font-size: 0.85rem; font-weight: 600; color: var(--text);">Qwen (Video model)</p>
                                    <div style="display: flex; gap: 1rem; align-items: center; flex-wrap: wrap; margin-bottom: 1.5rem;">
                                        <button type="button" onclick="downloadQwenManifest()" class="btn" style="background: var(--primary); color: white;"><span class="icon-with-text"><i data-lucide="download"></i> Export for Qwen (train_qwen.jsonl)</span></button>
                                        <span id="llmQwenExportStatus" style="font-size: 0.85rem; color: var(--text-light);"></span>
                                    </div>
                                    
                                    <div style="border-top: 1px solid var(--border); padding-top: 1.5rem; margin-top: 1.5rem;">
                                        <h4 style="margin: 0 0 0.75rem 0; font-size: 1rem; font-weight: 600; color: var(--text);"><span class="icon-with-text"><i data-lucide="file-text"></i> SpeechGradebook Text Model (Mistral)</span> <span style="font-size: 0.7rem; font-weight: 500; color: var(--text-light); background: var(--bg-alt); padding: 0.15rem 0.5rem; border-radius: 0.25rem;">Backup</span></h4>
                                        <p style="margin: 0 0 0.75rem 0; font-size: 0.85rem; color: var(--text-light);">Transcript + video notes. Save the downloaded file as <code>exported.json</code> in your repo root.</p>
                                        <p style="margin: 0 0 0.35rem 0; font-size: 0.8rem; font-weight: 600; color: var(--text);">Terminal commands (from repo root):</p>
                                        <pre style="margin: 0 0 0.75rem 0; padding: 0.75rem 1rem; background: var(--bg-alt); border: 1px solid var(--border); border-radius: 0.5rem; font-size: 0.8rem; overflow-x: auto; white-space: pre-wrap; word-break: break-all;"><code>node llm_training/export_to_jsonl.js exported.json --split 0.9

python llm_training/train_lora.py --train_file train.jsonl --validation_file validation.jsonl --output_dir llm_training/mistral7b-speech-lora</code></pre>
                                        <p style="margin: 0; font-size: 0.75rem; color: var(--text-light);">Hugging Face token: <code>export HF_TOKEN=your_token</code>. For lower VRAM add <code>--load_in_8bit</code>. Serve: <code>python llm_training/serve_model.py --model_path llm_training/mistral7b-speech-lora</code></p>
                                    </div>
                                    
                                    <div style="border-top: 1px solid var(--border); padding-top: 1.5rem; margin-top: 1.5rem;">
                                        <h4 style="margin: 0 0 0.75rem 0; font-size: 1rem; font-weight: 600; color: var(--text);"><span class="icon-with-text"><i data-lucide="video"></i> SpeechGradebook Text + Video Model (Qwen)</span> <span style="font-size: 0.7rem; font-weight: 500; color: var(--primary); background: var(--bg-alt); padding: 0.15rem 0.5rem; border-radius: 0.25rem;">Primary</span></h4>
                                        <p style="margin: 0 0 0.75rem 0; font-size: 0.85rem; color: var(--text-light);">Evaluations saved with video (Supabase <code>evaluation-media</code> bucket). Save as <code>train_qwen.jsonl</code>.</p>
                                        <p style="margin: 0 0 0.35rem 0; font-size: 0.8rem; font-weight: 600; color: var(--text);">Terminal commands (from repo root):</p>
                                        <pre style="margin: 0 0 0.75rem 0; padding: 0.75rem 1rem; background: var(--bg-alt); border: 1px solid var(--border); border-radius: 0.5rem; font-size: 0.8rem; overflow-x: auto; white-space: pre-wrap; word-break: break-all;"><code>python llm_training/train_qwen_vl.py --manifest train_qwen.jsonl --output_dir llm_training/qwen2.5vl-speech-lora --validate_only</code></pre>
                                        <p style="margin: 0 0 0.75rem 0; font-size: 0.75rem; color: var(--text-light);">See <code>llm_training/DUAL_MODEL_TRAINING.md</code> for full training instructions.</p>
                                        
                                        <div style="border-top: 1px solid var(--border); padding-top: 0.75rem; margin-top: 0.75rem;">
                                            <p style="margin: 0 0 0.5rem 0; font-size: 0.95rem; font-weight: 600; color: var(--text);"><span class="icon-with-text"><i data-lucide="git-branch"></i> Optional Qwen exports</span></p>
                                            <p style="margin: 0 0 0.75rem 0; font-size: 0.85rem; color: var(--text-light);"><strong>Comparison pairs:</strong> same student, two speeches. <strong>Correction pairs:</strong> AI vs instructor scores. See <code>llm_training/COMPARISON_AND_CORRECTIONS_TRAINING.md</code>.</p>
                                            <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
                                                <button type="button" onclick="downloadQwenComparisonPairs()" class="btn" style="background: var(--bg-alt); color: var(--primary); border: 1px solid var(--primary);"><span class="icon-with-text"><i data-lucide="git-compare"></i> Comparison pairs (JSONL)</span></button>
                                                <button type="button" onclick="downloadQwenCorrectionPairs()" class="btn" style="background: var(--bg-alt); color: var(--primary); border: 1px solid var(--primary);"><span class="icon-with-text"><i data-lucide="edit-2"></i> Correction pairs (JSONL)</span></button>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div style="border-top: 1px solid var(--border); padding-top: 1rem; margin-top: 1.5rem;">
                                        <p style="margin: 0 0 0.5rem 0; font-size: 0.85rem; font-weight: 600; color: var(--text);"><span class="icon-with-text"><i data-lucide="info"></i> Training Method Update</span></p>
                                        <p style="margin: 0; font-size: 0.85rem; color: var(--text-light);">The previous ISAAC-based training workflow is no longer in use. A new training method is being configured. For now, export the data above and refer to <a href="llm_training/TRAINING_REQUIREMENTS.md" target="_blank" style="color: var(--primary);">TRAINING_REQUIREMENTS.md</a> for training setup options.</p>
                                    </div>
                                    
                                    <div style="border-top: 1px solid var(--border); padding-top: 1rem; margin-top: 1rem;">
                                        <p style="margin: 0; font-size: 0.85rem;"><strong><span class="icon-with-text"><i data-lucide="book-open"></i> Guides:</span></strong> <a href="llm_training/TRAINING_REQUIREMENTS.md" target="_blank" style="color: var(--primary); text-decoration: underline;">TRAINING_REQUIREMENTS.md</a> — Consent, export flow, scripts. <a href="LLM_TRAINING_QUICKSTART.md" target="_blank" style="color: var(--primary); text-decoration: underline;">LLM Training Quickstart</a> — Prerequisites and setup.</p>
                                    </div>
                                </div>
                                
                                <!-- Data Deletion Scope (Super Admin only) - Redesigned per Apple HIG -->
                                <div id="deletionScopeSection" class="admin-card" style="display: none;">
                                    <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.5rem;">
                                        <h3 style="margin: 0; flex: 1;"><span class="icon-with-text"><i data-lucide="trash-2"></i> Data Deletion Scope</span></h3>
                                        <span class="support-tier-badge" data-tier="super_admin">Super Admin</span>
                                    </div>
                                    
                                    <p style="margin-bottom: 1.5rem; color: var(--text-light); line-height: 1.6;">
                                        When you delete data, choose where the deletion applies. Admins and Instructors always delete only from SpeechGradebook (local). Super Admins can choose per entity.
                                    </p>
                                    
                                    <!-- Apple HIG: Grouped settings with clear visual hierarchy -->
                                    <div style="display: flex; flex-direction: column; gap: 1.25rem;">
                                        <!-- Rubrics -->
                                        <div style="display: flex; flex-direction: column; gap: 0.5rem; padding: 1rem; background: var(--bg-alt); border-radius: 0.75rem; border: 1px solid var(--border); transition: border-color 0.2s ease;">
                                            <label for="deletionScopeRubrics" style="display: flex; align-items: center; gap: 0.5rem; font-weight: 600; font-size: 0.9375rem; color: var(--text); margin-bottom: 0.25rem;">
                                                <i data-lucide="file-text" style="width: 1rem; height: 1rem; color: var(--primary);"></i>
                                                Rubrics
                                            </label>
                                            <select id="deletionScopeRubrics" onchange="saveDeletionScope('rubrics')" style="width: 100%; padding: 0.75rem; border: 2px solid var(--border); border-radius: 0.5rem; font-size: 0.9375rem; background: white; color: var(--text); cursor: pointer; transition: border-color 0.2s ease, box-shadow 0.2s ease;">
                                                <option value="local">SpeechGradebook only</option>
                                                <option value="supabase">Supabase only</option>
                                                <option value="both">Both</option>
                                            </select>
                                        </div>
                                        
                                        <!-- Students -->
                                        <div style="display: flex; flex-direction: column; gap: 0.5rem; padding: 1rem; background: var(--bg-alt); border-radius: 0.75rem; border: 1px solid var(--border); transition: border-color 0.2s ease;">
                                            <label for="deletionScopeStudents" style="display: flex; align-items: center; gap: 0.5rem; font-weight: 600; font-size: 0.9375rem; color: var(--text); margin-bottom: 0.25rem;">
                                                <i data-lucide="users" style="width: 1rem; height: 1rem; color: var(--primary);"></i>
                                                Students
                                            </label>
                                            <select id="deletionScopeStudents" onchange="saveDeletionScope('students')" style="width: 100%; padding: 0.75rem; border: 2px solid var(--border); border-radius: 0.5rem; font-size: 0.9375rem; background: white; color: var(--text); cursor: pointer; transition: border-color 0.2s ease, box-shadow 0.2s ease;">
                                                <option value="local">SpeechGradebook only</option>
                                                <option value="supabase">Supabase only</option>
                                                <option value="both">Both</option>
                                            </select>
                                        </div>
                                        
                                        <!-- Courses -->
                                        <div style="display: flex; flex-direction: column; gap: 0.5rem; padding: 1rem; background: var(--bg-alt); border-radius: 0.75rem; border: 1px solid var(--border); transition: border-color 0.2s ease;">
                                            <label for="deletionScopeCourses" style="display: flex; align-items: center; gap: 0.5rem; font-weight: 600; font-size: 0.9375rem; color: var(--text); margin-bottom: 0.25rem;">
                                                <i data-lucide="book-open" style="width: 1rem; height: 1rem; color: var(--primary);"></i>
                                                Courses
                                            </label>
                                            <select id="deletionScopeCourses" onchange="saveDeletionScope('courses')" style="width: 100%; padding: 0.75rem; border: 2px solid var(--border); border-radius: 0.5rem; font-size: 0.9375rem; background: white; color: var(--text); cursor: pointer; transition: border-color 0.2s ease, box-shadow 0.2s ease;">
                                                <option value="local">SpeechGradebook only</option>
                                                <option value="supabase">Supabase only</option>
                                                <option value="both">Both</option>
                                            </select>
                                        </div>
                                        
                                        <!-- Evaluations -->
                                        <div style="display: flex; flex-direction: column; gap: 0.5rem; padding: 1rem; background: var(--bg-alt); border-radius: 0.75rem; border: 1px solid var(--border); transition: border-color 0.2s ease;">
                                            <label for="deletionScopeEvaluations" style="display: flex; align-items: center; gap: 0.5rem; font-weight: 600; font-size: 0.9375rem; color: var(--text); margin-bottom: 0.25rem;">
                                                <i data-lucide="clipboard-list" style="width: 1rem; height: 1rem; color: var(--primary);"></i>
                                                Evaluations
                                            </label>
                                            <select id="deletionScopeEvaluations" onchange="saveDeletionScope('evaluations')" style="width: 100%; padding: 0.75rem; border: 2px solid var(--border); border-radius: 0.5rem; font-size: 0.9375rem; background: white; color: var(--text); cursor: pointer; transition: border-color 0.2s ease, box-shadow 0.2s ease;">
                                                <option value="local">SpeechGradebook only</option>
                                                <option value="supabase">Supabase only</option>
                                                <option value="both">Both</option>
                                            </select>
                                        </div>
                                    </div>
                                    
                                    <!-- Apple HIG: Helpful footer text with proper hierarchy -->
                                    <div style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--border);">
                                        <p style="margin: 0; font-size: 0.8125rem; color: var(--text-light); line-height: 1.5; display: flex; align-items: flex-start; gap: 0.5rem;">
                                            <i data-lucide="info" style="width: 1rem; height: 1rem; color: var(--text-light); flex-shrink: 0; margin-top: 0.125rem;"></i>
                                            <span>These settings apply only to your own delete actions as Super Admin. They are stored in this browser.</span>
                                        </p>
                                    </div>
                                </div>
                            </section>
                            
                            <!-- Monitoring Section -->
                            <section id="adminSectionMonitoring" class="admin-section">
                                <div class="admin-section-header">
                                    <h2>Monitoring & Analytics</h2>
                                    <p class="admin-section-description">Track costs and system health</p>
                                </div>
                                
                                <!-- Cost Tracking (Admin and Super Admin only) -->
                                <div id="costTrackingSection" class="admin-card" style="display: none;">
                                    <h3><span class="icon-with-text"><i data-lucide="dollar-sign"></i> Cost Tracking</span></h3>
                                    <p style="margin-bottom: 1.5rem; font-size: 0.9rem; color: var(--text-light);">Monitor GPU costs for evaluations. Track spending by instructor, institution, and over time.</p>
                                    
                                    <!-- Cost Summary Cards -->
                                    <div id="costTrackingSummary" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
                                        <div class="card" style="padding: 1rem; text-align: center;">
                                            <div style="font-size: 2rem; font-weight: 700; color: var(--primary); margin-bottom: 0.5rem;" id="costTotalSpent">$0.00</div>
                                            <div style="font-size: 0.85rem; color: var(--text-light);">Total Spent (Current Month)</div>
                                        </div>
                                        <div class="card" style="padding: 1rem; text-align: center;">
                                            <div style="font-size: 2rem; font-weight: 700; color: var(--primary); margin-bottom: 0.5rem;" id="costAvgPerEval">$0.00</div>
                                            <div style="font-size: 0.85rem; color: var(--text-light);">Avg Cost per Evaluation</div>
                                        </div>
                                        <div class="card" style="padding: 1rem; text-align: center;">
                                            <div style="font-size: 2rem; font-weight: 700; color: var(--primary); margin-bottom: 0.5rem;" id="costTotalEvaluations">0</div>
                                            <div style="font-size: 0.85rem; color: var(--text-light);">Total Evaluations</div>
                                        </div>
                                        <div class="card" style="padding: 1rem; text-align: center;">
                                            <div style="font-size: 2rem; font-weight: 700; color: var(--primary); margin-bottom: 0.5rem;" id="costTotalGPUSeconds">0</div>
                                            <div style="font-size: 0.85rem; color: var(--text-light);">Total GPU Seconds</div>
                                        </div>
                                    </div>
                                    
                                    <!-- Cost by Instructor Table -->
                                    <div style="margin-bottom: 2rem;">
                                        <h4 class="settings-section-subheading"><span class="icon-with-text"><i data-lucide="users"></i> Cost by Instructor (Current Month)</span></h4>
                                        <div style="overflow-x: auto;">
                                            <table class="data-table" id="costTrackingInstructorTable">
                                                <thead>
                                                    <tr>
                                                        <th>Instructor</th>
                                                        <th>Evaluations</th>
                                                        <th>Total Cost</th>
                                                        <th>Avg Cost/Eval</th>
                                                        <th>GPU Seconds</th>
                                                    </tr>
                                                </thead>
                                                <tbody id="costTrackingInstructorTableBody">
                                                    <tr><td colspan="5" style="text-align: center; color: var(--text-light); padding: 2rem;">Loading cost data...</td></tr>
                                                </tbody>
                                            </table>
                                        </div>
                                    </div>
                                    
                                    <!-- Cost by Institution Table (Super Admin only) -->
                                    <div id="costTrackingInstitutionSection" style="margin-bottom: 2rem; display: none;">
                                        <h4 class="settings-section-subheading"><span class="icon-with-text"><i data-lucide="building"></i> Cost by Institution (Current Month)</span></h4>
                                        <div style="overflow-x: auto;">
                                            <table class="data-table" id="costTrackingInstitutionTable">
                                                <thead>
                                                    <tr>
                                                        <th>Institution</th>
                                                        <th>Evaluations</th>
                                                        <th>Total Cost</th>
                                                        <th>Avg Cost/Eval</th>
                                                        <th>GPU Seconds</th>
                                                    </tr>
                                                </thead>
                                                <tbody id="costTrackingInstitutionTableBody">
                                                    <tr><td colspan="5" style="text-align: center; color: var(--text-light); padding: 2rem;">Loading cost data...</td></tr>
                                                </tbody>
                                            </table>
                                        </div>
                                    </div>
                                    
                                    <!-- Cost Trends Chart Placeholder -->
                                    <div style="margin-bottom: 2rem;">
                                        <h4 class="settings-section-subheading"><span class="icon-with-text"><i data-lucide="trending-up"></i> Cost Trends (Last 30 Days)</span></h4>
                                        <div class="card" style="padding: 1.5rem; min-height: 200px; display: flex; align-items: center; justify-content: center; color: var(--text-light);" id="costTrackingChart">
                                            <div>Cost trend chart will appear here</div>
                                        </div>
                                    </div>
                                    
                                    <!-- Alert Threshold -->
                                    <div class="card" style="padding: 1rem; background: var(--bg-alt); border: 1px solid var(--border);">
                                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                            <i data-lucide="bell" style="width: 1rem; height: 1rem;"></i>
                                            <strong style="font-size: 0.9rem;">Cost Alert Threshold</strong>
                                        </div>
                                        <p style="margin: 0; font-size: 0.85rem; color: var(--text-light);">
                                            Monthly cost alert will trigger when spending exceeds $100. Configure alerts in Sentry dashboard.
                                        </p>
                                    </div>
                                </div>
                                
                                <!-- Energy & Sustainability (All user tiers) -->
                                <div id="energyTrackingSection" class="admin-card" style="margin-top: 2rem;">
                                    <h3><span class="icon-with-text"><i data-lucide="zap"></i> Energy & Sustainability</span></h3>
                                    <p style="margin-bottom: 1.5rem; font-size: 0.9rem; color: var(--text-light);">Track energy consumption, CO₂ emissions, and make carbon offset donations. View your individual impact or institution-wide metrics.</p>
                                    
                                    <div id="energyDashboardContent">
                                        <p style="color: var(--text-light);">Loading energy data…</p>
                                        <div class="spinner" style="margin: 1rem auto;" aria-hidden="true"></div>
                                    </div>
                                </div>
                            </section>
                            
                            <!-- Compliance Section -->
                            <section id="adminSectionCompliance" class="admin-section">
                                <div class="admin-section-header">
                                    <h2>Compliance & Testing</h2>
                                    <p class="admin-section-description">Verify RLS policies and audit logs</p>
                                </div>
                                
                                <!-- Compliance Testing (Admins and Super Admins only; visibility set in JS) -->
                                <div id="complianceTestingWrap" class="admin-card" style="display: none;">
                                    <h3><span class="icon-with-text"><i data-lucide="lock"></i> Compliance & Testing</span></h3>
                                    <p style="margin-bottom: 1rem; color: var(--text-light);">
                                        Verify RLS policies and audit logging for FERPA compliance. Run tests as different roles (instructor, admin, super admin) to confirm access is correct.
                                    </p>
                                    <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem;">
                                        <div style="display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 1rem;">
                                            <button type="button" onclick="testRLSPolicies()" class="btn-secondary"><span class="icon-with-text"><i data-lucide="shield-check"></i> Test RLS policies</span></button>
                                            <button type="button" onclick="verifyAuditLogs()" class="btn-secondary"><span class="icon-with-text"><i data-lucide="file-text"></i> Check audit logs</span></button>
                                        </div>
                                        <div style="padding-top: 1rem; border-top: 1px solid var(--border);">
                                            <p style="margin: 0; font-size: 0.9rem; color: var(--text-light); line-height: 1.6;">
                                                <strong>RLS test</strong> checks that you can see your own courses/evaluations and (as instructor) cannot see others'. <strong>Audit logs</strong> shows your recent access entries; if read is restricted, check the <code>audit_logs</code> table in Supabase Dashboard.
                                            </p>
                                        </div>
                                    </div>
                                </div>
                            </section>
                            
                        </div><!-- /admin-settings-content -->
                    </div><!-- /admin-settings-container -->
                </div><!-- /settingsTabAdmin -->

                <!-- Admin Panel (Admins and Super Admins only; visibility set in JS) -->
                <!-- settingsAdminPanelWrap is now empty - content moved to Data Management section -->
                <div id="settingsAdminPanelWrap" style="display: none;"></div>
                
                </div><!-- /card-body -->
            </div><!-- /card -->
        </section><!-- /settingsSection -->

        <!-- Class Detail Section (Simple) -->
        <section id="classDetailSection" class="section" aria-label="Class details" style="padding-top: 0 !important; margin-top: 0 !important;">
            <div class="card" style="padding: 0 var(--space-xl) var(--space-xl) var(--space-xl); margin-top: 0 !important; padding-top: 0 !important; border-top-left-radius: 0 !important; border-top-right-radius: 0 !important;">
                <div class="card-header" style="display: flex; flex-wrap: wrap; align-items: center; gap: 0.75rem; margin-bottom: 0.5rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border); padding-top: 0.5rem !important; margin-top: 0 !important;">
                    <button type="button" onclick="showDashboard()" class="btn-icon-only" aria-label="Back to Dashboard" title="Back to Dashboard" style="flex-shrink: 0;"><i data-lucide="arrow-left"></i></button>
                    <span id="classDetailTitle">Class Details</span>
                    <div id="classDetailHeaderActions" style="display: inline-flex; align-items: center; gap: 0.5rem; margin-left: auto;"></div>
                </div>
                
                <div id="classDetailContent" style="margin-top: 0; padding-top: 0;"></div>
            </div>
            
            <!-- Add Student Form -->
            <div id="addStudentCard" class="card hidden">
                <div class="card-header"><span class="icon-with-text"><i data-lucide="user-plus"></i> Add Student</span></div>
                <form id="addStudentForm">
                    <div class="form-group">
                        <label for="studentFirstName">First Name *</label>
                        <input type="text" id="studentFirstName" required>
                    </div>
                    <div class="form-group">
                        <label for="studentLastName">Last Name *</label>
                        <input type="text" id="studentLastName" required>
                    </div>
                    <div class="form-group">
                        <label for="studentEmailAdd">Email</label>
                        <input type="email" id="studentEmailAdd">
                    </div>
                    <div class="form-group">
                        <label for="studentIdAdd">Student ID (optional)</label>
                        <input type="text" id="studentIdAdd">
                    </div>
                    <div style="display: flex; gap: 1rem;">
                        <button type="button" onclick="cancelAddStudent()" class="btn-secondary"><span class="icon-with-text"><i data-lucide="x"></i> Cancel</span></button>
                        <button type="submit"><span class="icon-with-text"><i data-lucide="user-plus"></i> Add Student</span></button>
                    </div>
                </form>
            </div>
        </section>

        <!-- Edit Student Modal (Apple HIG style) -->
        <div id="editStudentModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.4); z-index: 9999; align-items: center; justify-content: center; backdrop-filter: blur(4px);" role="dialog" aria-labelledby="editStudentModalTitle" aria-modal="true">
            <div style="background: white; border-radius: 1rem; max-width: 500px; width: 90%; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);">
                <!-- Header -->
                <div style="padding: 1.5rem 1.5rem 1rem 1.5rem; border-bottom: 0.5px solid rgba(0, 0, 0, 0.1); display: flex; justify-content: space-between; align-items: center; gap: 1rem;">
                    <button type="button" onclick="deleteStudentFromEditModal();" aria-label="Delete student" style="background: none; border: none; padding: 0.5rem; cursor: pointer; color: var(--error, #dc2626); border-radius: 0.5rem; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center;" onmouseover="this.style.backgroundColor='rgba(220,38,38,0.1)'" onmouseout="this.style.backgroundColor='transparent'" title="Remove Student">
                        <i data-lucide="trash-2" style="width: 1.25rem; height: 1.25rem;"></i>
                    </button>
                    <h2 id="editStudentModalTitle" style="margin: 0; font-size: 1.25rem; font-weight: 600; color: var(--text); flex: 1;">Edit Student</h2>
                    <button type="button" onclick="closeEditStudentModal()" aria-label="Close" style="background: none; border: none; padding: 0.5rem; cursor: pointer; color: var(--text-light); border-radius: 0.5rem; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='rgba(0,0,0,0.05)'" onmouseout="this.style.backgroundColor='transparent'">
                        <i data-lucide="x" style="width: 1.25rem; height: 1.25rem;"></i>
                    </button>
                </div>
                
                <!-- Form Content -->
                <div style="padding: 1.5rem; overflow-y: auto; flex: 1;">
                    <form id="editStudentForm">
                        <div class="form-group" style="margin-bottom: 1.25rem;">
                            <label for="editStudentFirstName" style="display: block; font-weight: 500; margin-bottom: 0.5rem; color: var(--text); font-size: 0.9375rem;">First Name *</label>
                            <input type="text" id="editStudentFirstName" required style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; font-size: 1rem; transition: border-color 0.2s;" onfocus="this.style.borderColor='var(--primary)'" onblur="this.style.borderColor='var(--border)'">
                        </div>
                        <div class="form-group" style="margin-bottom: 1.25rem;">
                            <label for="editStudentLastName" style="display: block; font-weight: 500; margin-bottom: 0.5rem; color: var(--text); font-size: 0.9375rem;">Last Name *</label>
                            <input type="text" id="editStudentLastName" required style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; font-size: 1rem; transition: border-color 0.2s;" onfocus="this.style.borderColor='var(--primary)'" onblur="this.style.borderColor='var(--border)'">
                        </div>
                        <div class="form-group" style="margin-bottom: 1.25rem;">
                            <label for="editStudentEmail" style="display: block; font-weight: 500; margin-bottom: 0.5rem; color: var(--text); font-size: 0.9375rem;">Email</label>
                            <input type="email" id="editStudentEmail" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; font-size: 1rem; transition: border-color 0.2s;" onfocus="this.style.borderColor='var(--primary)'" onblur="this.style.borderColor='var(--border)'">
                        </div>
                        <div class="form-group" style="margin-bottom: 1.5rem;">
                            <label for="editStudentId" style="display: block; font-weight: 500; margin-bottom: 0.5rem; color: var(--text); font-size: 0.9375rem;">Student ID</label>
                            <input type="text" id="editStudentId" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; font-size: 1rem; transition: border-color 0.2s;" onfocus="this.style.borderColor='var(--primary)'" onblur="this.style.borderColor='var(--border)'">
                            <p style="margin: 0.5rem 0 0 0; font-size: 0.8125rem; color: var(--text-light);">Optional identifier for this student</p>
                        </div>
                        <div class="form-group" style="margin-bottom: 1.5rem;">
                            <label for="editStudentCourse" style="display: block; font-weight: 500; margin-bottom: 0.5rem; color: var(--text); font-size: 0.9375rem;">Course</label>
                            <select id="editStudentCourse" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; font-size: 1rem; transition: border-color 0.2s;" onfocus="this.style.borderColor='var(--primary)'" onblur="this.style.borderColor='var(--border)'">
                                <option value="">-- Select Course --</option>
                            </select>
                            <p style="margin: 0.5rem 0 0 0; font-size: 0.8125rem; color: var(--text-light);">Select a different course to move this student</p>
                        </div>
                    </form>
                </div>
                
                <!-- Footer Actions (Apple HIG style) -->
                <div style="padding: 1rem 1.5rem; border-top: 0.5px solid rgba(0, 0, 0, 0.1); display: flex; gap: 0.75rem; justify-content: flex-end;">
                    <button type="button" onclick="closeEditStudentModal()" class="btn-secondary" style="padding: 0.625rem 1.25rem; font-size: 0.9375rem; font-weight: 500; border-radius: 0.5rem;">Cancel</button>
                    <button type="button" onclick="saveEditedStudent()" style="padding: 0.625rem 1.25rem; background: var(--primary); color: white; border: none; border-radius: 0.5rem; font-size: 0.9375rem; font-weight: 500; cursor: pointer; transition: opacity 0.2s;" onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">
                        <span class="icon-with-text"><i data-lucide="check" style="width:1em;height:1em;"></i> Save</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Recover deleted items modal -->
        <div id="recoverDeletedModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 9998; align-items: center; justify-content: center;" role="dialog" aria-labelledby="recoverDeletedModalTitle" aria-modal="true">
            <div style="background: white; border-radius: 1rem; max-width: 640px; width: 95%; max-height: 85vh; overflow: hidden; display: flex; flex-direction: column; box-shadow: 0 10px 40px rgba(0,0,0,0.2);">
                <div style="padding: 1.25rem 1.5rem; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center;">
                    <h2 id="recoverDeletedModalTitle" style="margin: 0; font-size: 1.25rem;">Recover deleted items</h2>
                    <button type="button" onclick="closeRecoverDeletedModal()" aria-label="Close" style="background: none; border: none; padding: 0.5rem; cursor: pointer; color: var(--text-light);"><i data-lucide="x" style="width:1.25rem;height:1.25rem;"></i></button>
                </div>
                <div id="recoverDeletedContent" style="padding: 1.5rem; overflow: auto; flex: 1;">
                    <p style="color: var(--text-light);">Loading…</p>
                </div>
            </div>
        </div>

        <!-- Upload Rubric Form -->
        <div id="uploadRubricCard" class="card hidden" style="margin-top: 2rem;">
            <div class="card-header"><span class="icon-with-text"><i data-lucide="file-up"></i> Import Rubric from File</span></div>
            <div style="background: #e3f2fd; padding: 1rem; border-radius: 0.5rem; margin-bottom: 1.5rem; border-left: 4px solid #2196f3;">
                <strong><span class="icon-with-text"><i data-lucide="clipboard-list" style="width:1em;height:1em;"></i> How it works:</span></strong>
                <p style="margin: 0.5rem 0 0 0;">Upload a PDF, image, Excel spreadsheet, or Word document of your rubric (including <strong>blank</strong> rubrics—PNG, PDF, Google Sheets exported as XLSX/CSV), and AI will extract the categories, criteria, and point values to create a digital rubric. You can also create rubrics manually in Dashboard → Rubrics.</p>
            </div>
            
            <form id="uploadRubricForm">
                <div class="form-group">
                    <label for="uploadRubricFile">Upload Rubric File *</label>
                    <input 
                        type="file" 
                        id="uploadRubricFile" 
                        accept=".pdf,.png,.jpg,.jpeg,.webp,.xlsx,.xls,.csv,.doc,.docx" 
                        required
                        style="width: 100%; padding: 0.75rem; border: 2px dashed var(--border); border-radius: 0.5rem; background: var(--bg);"
                    >
                    <small style="color: var(--text-light); display: block; margin-top: 0.5rem;">
                        Supported formats: PDF, Images (PNG/JPG), Excel (XLSX/XLS/CSV), Word (DOC/DOCX) - max 10MB<br>
                        <strong>Tip:</strong> For best results with Excel/Word, use Gemini or Claude
                    </small>
                </div>
                
                <div class="form-group">
                    <label for="uploadRubricName">Rubric Name *</label>
                    <input 
                        type="text" 
                        id="uploadRubricName" 
                        placeholder="e.g., Persuasive Speech Rubric" 
                        required
                    >
                </div>
                
                <p style="font-size: 0.875rem; color: var(--text-light); margin-bottom: 1rem;">
                    Extraction uses the SpeechGradebook Text + Video Model (Qwen). Super Admin configures the service URL in Settings.<br>
                    <strong>Blank rubrics:</strong> Upload a blank rubric (PNG, PDF, Excel, or export Google Sheets as XLSX/CSV) and extract structure, or create the rubric manually in Dashboard → Rubrics.
                </p>
                
                <div id="uploadProgress" class="hidden" style="margin: 1.5rem 0; padding: 1rem; background: var(--bg); border-radius: 0.5rem;">
                    <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem;">
                        <div class="spinner"></div>
                        <span id="uploadProgressText">Processing rubric</span>
                    </div>
                    <div style="background: white; height: 8px; border-radius: 4px; overflow: hidden;">
                        <div id="uploadProgressBar" style="width: 0%; height: 100%; background: var(--primary); transition: width 0.3s;"></div>
                    </div>
                </div>
                
                <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                    <button type="button" onclick="cancelUploadRubric()">Cancel</button>
                    <button type="submit" style="background: var(--primary);"><span class="icon-with-text"><i data-lucide="rocket"></i> Extract & Create Rubric</span></button>
                </div>
            </form>
        </div>

        <!-- Support Section -->
        <section id="helpSection" class="section">
            <div class="card">
                <div class="card-header"><span class="icon-with-text"><i data-lucide="help-circle"></i> Support</span></div>
                <div class="card-body" style="padding: 1.25rem;">
                    <p id="supportVersionBanner" style="margin-bottom: 1.5rem; padding: 0.75rem 1rem; background: var(--bg-alt); border-radius: 0.5rem; font-size: 0.95rem; color: var(--text-light);">
                        <strong style="color: var(--primary);">SpeechGradebook</strong> <span id="supportVersionText">v3.0</span> <span id="supportVersionLabel"></span>
                    </p>

                    <div id="supportDocTablist" role="tablist" class="support-tablist" aria-label="Support documentation">
                        <button type="button" id="supportTabBtnGettingStarted" class="support-tab support-tab-active" role="tab" aria-selected="true" aria-controls="supportPanelGettingStarted" onclick="switchSupportDocTab('getting-started')"><span class="icon-with-text"><i data-lucide="rocket"></i> Getting Started</span></button>
                        <button type="button" id="supportTabBtnUserManual" class="support-tab" role="tab" aria-selected="false" aria-controls="supportPanelUserManual" onclick="switchSupportDocTab('user-manual')"><span class="icon-with-text"><i data-lucide="book-open"></i> User Manual</span></button>
                        <button type="button" id="supportTabBtnTechnical" class="support-tab" role="tab" aria-selected="false" aria-controls="supportPanelTechnical" onclick="switchSupportDocTab('technical')"><span class="icon-with-text"><i data-lucide="file-code"></i> Technical Documentation</span></button>
                    </div>

                    <!-- Panel: Getting Started (detailed procedures) -->
                    <div id="supportPanelGettingStarted" class="support-doc-panel active" role="tabpanel" aria-labelledby="supportTabBtnGettingStarted">
                        <p style="margin-bottom: 1.5rem; color: var(--text-light);">
                            Step-by-step guides for the main areas of SpeechGradebook. Content below is relevant to your role where noted.
                        </p>

                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="mic"></i> How to Evaluate a Speech</span></h3>
                        <p style="margin-bottom: 0.5rem;">Run an AI evaluation on a student's audio or video recording.</p>
                        <ol style="margin-bottom: 1.5rem; padding-left: 1.5rem;">
                            <li style="margin-bottom: 0.5rem;">Click <strong>Evaluate Speech</strong> in the navigation.</li>
                            <li style="margin-bottom: 0.5rem;">Upload an audio or video file (MP3, MP4, MOV/QuickTime, WAV, M4A, WebM; for GPT-4o, image/screenshot also supported). Videos over 50 MB are compressed automatically.</li>
                            <li style="margin-bottom: 0.5rem;">Select or create a course and student (or enter details). Choose a rubric.</li>
                            <li style="margin-bottom: 0.5rem;">Choose an API provider in the evaluation flow (Gemini, GPT-4o, Claude, SpeechGradebook Text Model (Mistral), or SpeechGradebook Text + Video Model (Qwen)) and ensure the key or server URL is set in <strong>Settings</strong>.</li>
                            <li style="margin-bottom: 0.5rem;">Click <strong>Continue to Evaluation</strong> and wait for analysis.</li>
                            <li style="margin-bottom: 0.5rem;">Review results, download PDF, or email to student.</li>
                        </ol>

                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="key"></i> Getting API Keys</span></h3>
                        <p style="margin-bottom: 0.5rem;">Save provider keys or the SpeechGradebook Text Model (Mistral) server URL in <strong>Settings → General → API Keys</strong> so you don't re-enter them each time.</p>
                        <ul style="margin-bottom: 1.5rem; padding-left: 1.5rem;">
                            <li style="margin-bottom: 0.5rem;"><strong>Google Gemini</strong> (recommended): <a href="https://aistudio.google.com/app/apikey" target="_blank" style="color: var(--primary);">aistudio.google.com/app/apikey</a></li>
                            <li style="margin-bottom: 0.5rem;"><strong>OpenAI GPT-4o</strong>: <a href="https://platform.openai.com/api-keys" target="_blank" style="color: var(--primary);">platform.openai.com/api-keys</a></li>
                            <li style="margin-bottom: 0.5rem;"><strong>Anthropic Claude</strong>: <a href="https://console.anthropic.com" target="_blank" style="color: var(--primary);">console.anthropic.com</a></li>
                            <li style="margin-bottom: 0.5rem;"><strong>SpeechGradebook Text Model (Mistral)</strong>: Enter your evaluation server URL (e.g. your Render or local server).</li>
                        </ul>

                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="video"></i> How to Start Qwen (Text + Video Model)</span> <span class="support-tier-badge" data-tier="super_admin">Super Admin</span></h3>
                        <p style="margin-bottom: 0.5rem;">The <strong>SpeechGradebook Text + Video Model (Qwen)</strong> runs on your own infrastructure (e.g. ISAAC). Set the <strong>Qwen Service URL</strong> in <strong>Settings → General</strong> (select SpeechGradebook Text + Video Model (Qwen), enter the URL, Save). Use <strong>Check Qwen status</strong> there to see if the service is reachable.</p>
                        <ul style="margin-bottom: 1.5rem; padding-left: 1.5rem;">
                            <li style="margin-bottom: 0.5rem;"><strong>Quick tunnel (URL changes each time):</strong> On an ISAAC compute node, run Qwen and <code>cloudflared tunnel --url http://localhost:8001</code>; copy the <code>https://….trycloudflare.com</code> URL into Settings and on Render as <code>QWEN_API_URL</code>. See <code>llm_training/START_QWEN_FOR_RENDER.md</code>.</li>
                            <li style="margin-bottom: 0.5rem;"><strong>Stable URL (named tunnel):</strong> Create a Cloudflare named tunnel and a fixed hostname (e.g. <code>https://qwen.yourdomain.com</code>). Set that URL on Render once. Steps: <code>llm_training/QWEN_NAMED_TUNNEL.md</code>.</li>
                        </ul>

                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="book-open"></i> Managing Courses</span> <span class="support-tier-badge" data-tier="instructor">Instructor</span></h3>
                        <p style="margin-bottom: 0.5rem;">From the Dashboard, create and manage courses. Add students, run evaluations, and view history. Data is stored in the cloud (Supabase) for your institution.</p>
                        <ol style="margin-bottom: 1.5rem; padding-left: 1.5rem;">
                            <li style="margin-bottom: 0.5rem;">Open <strong>Dashboard</strong> and use the <strong>Courses</strong> tab.</li>
                            <li style="margin-bottom: 0.5rem;">Create a course (name, term, year, modality). Add students to the course.</li>
                            <li style="margin-bottom: 0.5rem;">Evaluations are linked to course and student; view and filter from the course or from Course Insights.</li>
                        </ol>

                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="list-checks"></i> Custom Rubrics</span> <span class="support-tier-badge" data-tier="instructor">Instructor</span></h3>
                        <p style="margin-bottom: 0.5rem;">Create rubrics tailored to your assignments. The AI scores and comments using your criteria.</p>
                        <ol style="margin-bottom: 1.5rem; padding-left: 1.5rem;">
                            <li style="margin-bottom: 0.5rem;">Dashboard → <strong>Rubrics</strong>. Create a new rubric or use an existing one.</li>
                            <li style="margin-bottom: 0.5rem;">Define categories, subcategories, and point values. For <strong>blank rubrics</strong> (PNG, PDF, Google Sheets, or Excel): use <strong>Import Rubric from File</strong> (Extract & Create Rubric), or create the rubric manually in the UI.</li>
                            <li style="margin-bottom: 0.5rem;">Select the rubric when starting an evaluation.</li>
                        </ol>

                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="bar-chart-2"></i> Course Insights (Analytics)</span> <span class="support-tier-badge" data-tier="instructor">Instructor</span></h3>
                        <p style="margin-bottom: 1.5rem;">View overview metrics, comparisons, and evaluation lists. Export data from the Export tab. <span class="support-tier-badge" data-tier="admin">Admin</span> and <span class="support-tier-badge" data-tier="super_admin">Super Admin</span> see department- or institution-wide dashboards and filters.</p>

                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="clipboard-check"></i> Consent</span></h3>
                        <p style="margin-bottom: 1.5rem;">In <strong>Settings → Consent</strong>, generate student consent links per course. Students open the link and submit consent; evaluations for consenting students can be stored in the cloud. Instructor LLM consent is requested once at first use.</p>

                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="shield"></i> Admin &amp; Institution Management</span> <span class="support-tier-badge" data-tier="admin">Admin</span> <span class="support-tier-badge" data-tier="super_admin">Super Admin</span></h3>
                        <p style="margin-bottom: 1.5rem;">Admins see <strong>Settings → Admin</strong>: manage API keys for the institution, view all courses (with filters). Super Admins can manage institutions, themes, fonts, and global settings.</p>
                    </div>

                    <!-- Panel: User Manual (technical how-to) -->
                    <div id="supportPanelUserManual" class="support-doc-panel" role="tabpanel" aria-labelledby="supportTabBtnUserManual">
                        <p style="margin-bottom: 1.5rem; color: var(--text-light);">Technical reference for using SpeechGradebook features and workflows.</p>
                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="compass"></i> Navigation &amp; Sections</span></h3>
                        <p style="margin-bottom: 1rem;">The header shows the app name, main navigation links, and the logged-in user's <strong>name</strong> (from your profile) next to <strong>Logout</strong>. Main sections: <strong>Evaluate Speech</strong> (run evaluations), <strong>Dashboard</strong> (Courses, Rubrics, Course Insights), <strong>Settings</strong> (General, Consent, Admin if applicable), <strong>Support</strong> (this area). Visibility of Dashboard tabs and Settings tabs depends on your account tier (instructor, admin, super_admin).</p>
                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="git-branch"></i> Evaluation Flow</span></h3>
                        <p style="margin-bottom: 1rem;">Multi-step wizard: upload file → course/student/rubric → API provider → run evaluation → results. You can download a PDF report or email the student from the results step. Supported media: MP3, MP4, MOV/QuickTime, WAV, M4A, WebM; GPT-4o also accepts image/screenshot (JPG, PNG).</p>
                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="layout-dashboard"></i> Dashboard</span></h3>
                        <p style="margin-bottom: 1rem;"><strong>Courses:</strong> Create/edit courses, add students, see evaluations per course. <strong>Rubrics:</strong> Create and edit rubrics; use extract-from-PDF to build criteria. <strong>Course Insights:</strong> Overview, comparisons, evaluation list, and export. Admins see institution/department scope and instructor filters.</p>
                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="settings"></i> Settings</span></h3>
                        <p style="margin-bottom: 1rem;"><strong>General:</strong> Tenant/theme selector, API keys (Gemini, OpenAI, Anthropic, SpeechGradebook Text Model (Mistral) URL, SpeechGradebook Text + Video Model (Qwen) URL). <strong>Consent:</strong> Generate student consent links; view consent status. <strong>Admin:</strong> (Admin/Super Admin only) Institution API keys, course filters, and (Super Admin) institution list, theme customizer, font packages.</p>
                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="palette"></i> Themes &amp; Branding</span></h3>
                        <p style="margin-bottom: 1rem;">Institutions can have a custom theme (colors, logo, fonts). Super Admins configure themes per institution in Settings → Admin → theme customizer. Users in an institution see that theme when selected.</p>
                    </div>

                    <!-- Panel: Technical Documentation -->
                    <div id="supportPanelTechnical" class="support-doc-panel" role="tabpanel" aria-labelledby="supportTabBtnTechnical">
                        <p style="margin-bottom: 1.5rem; color: var(--text-light);">Data management, LLM training, change history, and legal information.</p>

                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="cpu"></i> LLM Training Guide</span> <span class="support-tier-badge" data-tier="super_admin">Super Admin</span></h3>
                        <p style="margin-bottom: 0.5rem;">Train your own custom speech evaluation model using your institution's evaluation data. This gives you complete privacy, no per-evaluation API costs, and a model trained on your specific rubrics and grading style.</p>
                        <div style="background: var(--bg-alt); border: 1px solid var(--border); border-radius: 0.5rem; padding: 1rem; margin-bottom: 1.5rem;">
                            <p style="margin: 0 0 0.75rem 0; font-weight: 600;"><span class="icon-with-text"><i data-lucide="book-open"></i> Complete Guides:</span></p>
                            <ul style="margin: 0; padding-left: 1.5rem; list-style: none;">
                                <li style="margin-bottom: 0.5rem;"><span style="color: var(--primary);">▸</span> <strong><a href="LLM_TRAINING_QUICKSTART.md" target="_blank" style="color: var(--primary); text-decoration: underline;">LLM Training Quickstart</a></strong> — Step-by-step guide with all prerequisites, installation, and troubleshooting</li>
                                <li style="margin-bottom: 0.5rem;"><span style="color: var(--primary);">▸</span> <strong><a href="llm_training/README.md" target="_blank" style="color: var(--primary); text-decoration: underline;">LLM Training README</a></strong> — Quick reference for export, convert, train, and serve commands</li>
                                <li style="margin-bottom: 0;"><span style="color: var(--primary);">▸</span> <strong><a href="llm_training/IMPLEMENTATION_GUIDE.md" target="_blank" style="color: var(--primary); text-decoration: underline;">Implementation Guide</a></strong> — Detailed technical documentation for advanced users</li>
                            </ul>
                            <p style="margin: 0.75rem 0 0 0; padding-top: 0.75rem; border-top: 1px solid var(--border); font-size: 0.85rem; color: var(--text-light);"><strong>Quick access:</strong> Go to Settings → Admin → Data Management to export training data.</p>
                        </div>

                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="database"></i> How Data Is Managed</span></h3>
                        <p style="margin-bottom: 0.5rem;">SpeechGradebook uses <strong>Supabase</strong> for authentication and database. Data is stored per institution with row-level security (RLS):</p>
                        <ul style="margin-bottom: 1rem; padding-left: 1.5rem;">
                            <li style="margin-bottom: 0.5rem;"><strong>Instructors</strong> see only their own courses, students, rubrics, and evaluations.</li>
                            <li style="margin-bottom: 0.5rem;"><strong>Admins</strong> see data for their department/institution; they can filter by instructor and view analytics across courses.</li>
                            <li style="margin-bottom: 0.5rem;"><strong>Super Admins</strong> can manage institutions, themes, and (where configured) view cross-institution data.</li>
                            <li style="margin-bottom: 0.5rem;">Student consent is recorded in <code>consent_forms</code>; evaluations for non-consenting students are not stored in the cloud (local-only behavior when applicable).</li>
                            <li style="margin-bottom: 0.5rem;">Access to student data is logged in <strong>audit_logs</strong> for FERPA and compliance (purpose, justification, IP, user agent).</li>
                        </ul>

                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="history"></i> Change Log</span></h3>
                        <p style="margin-bottom: 0.5rem;">Recent changes to SpeechGradebook. For the full history, see <code>CHANGELOG.md</code> in the project.</p>
                        <div id="supportChangelogContent" style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-alt); border-radius: 0.5rem; font-size: 0.9rem; white-space: pre-wrap;"></div>

                        <h3 style="margin-bottom: 0.75rem;"><span class="icon-with-text"><i data-lucide="scale"></i> Licensing &amp; Legal</span></h3>
                        <p style="margin-bottom: 0.5rem;">SpeechGradebook is provided for educational use. By using the application you agree to your institution's terms and any applicable privacy policies. Student data is processed in accordance with FERPA and your institution's data agreements. For third-party AI providers (e.g. Google, OpenAI, Anthropic), their respective terms and privacy policies apply to API usage.</p>
                        <p style="margin-bottom: 0.5rem;"><strong>Custom / fine-tuned LLM:</strong> The optional fine-tuned evaluation model is based on <strong>Mistral 7B Instruct</strong> (Apache 2.0). If you <strong>distribute</strong> the model, adapter weights, or training/serving code that includes that model, you must include the Apache 2.0 license and any required attribution (e.g. Mistral AI, and PEFT if applicable). See <code>llm_training/LICENSE</code> in the project for the Apache 2.0 text and third-party notices. Internal use only (no redistribution) does not require including the license in the app UI.</p>
                        <p style="margin-bottom: 0.5rem;">Contact your institution or the support email below for licensing and legal questions.</p>
                    </div>

                    <hr style="margin: 1.5rem 0; border: none; border-top: 1px solid var(--border);">
                    <h3 style="margin-bottom: 0.5rem;"><span class="icon-with-text"><i data-lucide="mail"></i> Contact Support</span></h3>
                    <p>
                        For questions or technical support, contact: <strong id="supportEmail"><a href="mailto:speechgradebook@proton.me">speechgradebook@proton.me</a></strong>
                    </p>
                </div>
            </div>
        </section>

    </main>

    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-links" id="footerLinks">
                    <a href="privacy.html">Privacy Policy</a>
                    <a href="terms.html">Terms of Service</a>
                </div>
                <p id="footerCopyright">© 2026 SpeechGradebook</p>
                <p id="footerAdditional" style="opacity: 0.8; font-size: 0.9rem;"></p>
            </div>
        </div>
    </footer>

    <script>
        // Validate script is loading correctly
        if (typeof console !== 'undefined') console.log('SpeechGradebook script loading...');
        
        // ===== CONFIGURATION =====
        // Note: In production, these should be loaded from environment variables or a secure endpoint
        const CONFIG = {
            // Supabase credentials must be set via environment variables (loaded from /config.js)
            // Do NOT hardcode credentials here
            SUPABASE_URL: window.SUPABASE_URL || '',
            SUPABASE_ANON_KEY: window.SUPABASE_ANON_KEY || '',
            DEBUG: window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1',
            appVersion: '3.0',
            appVersionLabel: 'Supabase Edition'
        };
        
        // Warn if Supabase is not configured (config.js not loaded or env vars not set)
        if (!CONFIG.SUPABASE_URL || !CONFIG.SUPABASE_ANON_KEY) {
            console.warn('⚠️ Supabase credentials not configured. Set SUPABASE_URL and SUPABASE_ANON_KEY environment variables on your server.');
        }
        
        // Legacy constants for backward compatibility
        const SUPABASE_URL = CONFIG.SUPABASE_URL;
        const SUPABASE_ANON_KEY = CONFIG.SUPABASE_ANON_KEY;

        // ===== SEARCH AND FILTER UTILITIES =====
        // Provides search functionality for lists
        const SearchFilter = {
            // Generic search function that filters an array based on search query
            search: function(items, query, searchFields) {
                if (!query || query.trim() === '') return items;
                
                const searchTerm = query.toLowerCase().trim();
                return items.filter(item => {
                    return searchFields.some(field => {
                        const value = this.getNestedValue(item, field);
                        if (value === null || value === undefined) return false;
                        return String(value).toLowerCase().includes(searchTerm);
                    });
                });
            },
            
            // Get nested value from object (e.g., 'student.name' from {student: {name: 'John'}})
            getNestedValue: function(obj, path) {
                return path.split('.').reduce((current, prop) => current && current[prop], obj);
            },
            
            // Create search input HTML
            createSearchInput: function(id, placeholder, onInput) {
                return `
                    <div style="position: relative; margin-bottom: 1rem;">
                        <input 
                            type="text" 
                            id="${id}" 
                            placeholder="${placeholder || 'Search...'}" 
                            style="width: 100%; padding: 0.75rem 2.5rem 0.75rem 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; font-size: 0.9375rem; transition: all 0.2s ease; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;"
                            oninput="${onInput}"
                            onfocus="this.style.borderColor='var(--primary)'; this.style.outline='none'; this.style.boxShadow='0 0 0 4px rgba(0, 122, 255, 0.1)'"
                            onblur="this.style.borderColor='var(--border)'; this.style.boxShadow='none'"
                            aria-label="${placeholder || 'Search'}"
                        >
                        <i data-lucide="search" style="position: absolute; right: 0.75rem; top: 50%; transform: translateY(-50%); width: 1.125rem; height: 1.125rem; color: var(--text-light); pointer-events: none;"></i>
                    </div>
                `;
            },
            
            // Clear search input
            clearSearch: function(inputId) {
                const input = document.getElementById(inputId);
                if (input) {
                    input.value = '';
                    // Trigger input event to update filtered results
                    input.dispatchEvent(new Event('input', { bubbles: true }));
                }
            }
        };

        // ===== URL ROUTING SYSTEM =====
        // Handles deep linking to evaluations, courses, and dashboard sections
        const Router = {
            // Parse path-based route (e.g., /courses/123/students/456/evaluations/789)
            parseRoute: function() {
                if (typeof window === 'undefined') return null;
                
                const path = window.location.pathname;
                const parts = path.split('/').filter(p => p);
                
                // Handle root path
                if (parts.length === 0) {
                    return { type: 'home' };
                }
                
                // Route patterns:
                // /courses/[id]
                // /courses/[id]/students/[id]
                // /courses/[id]/students/[id]/evaluations/[id]
                // /dashboard
                // /evaluate
                // /settings
                // /help
                
                if (parts[0] === 'courses' && parts.length >= 2) {
                    const courseId = parts[1];
                    if (parts.length >= 4 && parts[2] === 'students') {
                        const studentId = parts[3];
                        if (parts.length >= 6 && parts[4] === 'evaluations') {
                            const evaluationId = parts[5];
                            return {
                                type: 'evaluation',
                                courseId: courseId,
                                studentId: studentId,
                                evaluationId: evaluationId
                            };
                        }
                        return {
                            type: 'student',
                            courseId: courseId,
                            studentId: studentId
                        };
                    }
                    return {
                        type: 'course',
                        courseId: courseId
                    };
                }
                
                // Simple routes
                const simpleRoutes = ['dashboard', 'evaluate', 'settings', 'help', 'analytics'];
                if (simpleRoutes.includes(parts[0])) {
                    return { type: parts[0] };
                }
                
                // Fallback: check query params for backward compatibility
                const queryParams = this.getQueryParams();
                if (queryParams.view) {
                    return this.parseQueryRoute(queryParams);
                }
                
                return { type: 'home' };
            },
            
            // Parse query-based route (backward compatibility)
            parseQueryRoute: function(params) {
                if (params.view === 'evaluation' && params.eval) {
                    return {
                        type: 'evaluation',
                        evaluationId: params.eval,
                        studentId: params.student || null,
                        edit: params.edit === 'true'
                    };
                } else if (params.view === 'course' && params.course) {
                    return {
                        type: 'course',
                        courseId: params.course
                    };
                } else if (params.view) {
                    return { type: params.view };
                }
                return { type: 'home' };
            },
            
            // Get query parameters (for backward compatibility)
            getQueryParams: function() {
                if (typeof window === 'undefined') return {};
                const params = new URLSearchParams(window.location.search);
                const result = {};
                for (const [key, value] of params.entries()) {
                    result[key] = value;
                }
                return result;
            },
            
            // Update URL with path-based routing
            updateURL: function(route, replace = false) {
                if (typeof window === 'undefined' || !window.history) return;
                
                let path = '/';
                
                if (route.type === 'evaluation' && route.evaluationId) {
                    // /courses/[id]/students/[id]/evaluations/[id]
                    if (route.courseId && route.studentId) {
                        path = `/courses/${encodeURIComponent(route.courseId)}/students/${encodeURIComponent(route.studentId)}/evaluations/${encodeURIComponent(route.evaluationId)}`;
                    } else {
                        // Fallback: use query params if course/student not available
                        path = `/?view=evaluation&eval=${encodeURIComponent(route.evaluationId)}`;
                        if (route.studentId) path += `&student=${encodeURIComponent(route.studentId)}`;
                        if (route.edit) path += '&edit=true';
                    }
                } else if (route.type === 'student' && route.courseId && route.studentId) {
                    path = `/courses/${encodeURIComponent(route.courseId)}/students/${encodeURIComponent(route.studentId)}`;
                } else if (route.type === 'course' && route.courseId) {
                    path = `/courses/${encodeURIComponent(route.courseId)}`;
                } else if (['dashboard', 'evaluate', 'settings', 'help', 'analytics'].includes(route.type)) {
                    path = `/${route.type}`;
                } else {
                    path = '/';
                }
                
                // Add query params if needed (for edit mode, etc.)
                const queryParams = new URLSearchParams();
                if (route.edit) queryParams.set('edit', 'true');
                if (route.tab) queryParams.set('tab', route.tab);
                const queryString = queryParams.toString();
                if (queryString) {
                    path += `?${queryString}`;
                }
                
                // Update URL
                if (replace) {
                    window.history.replaceState({ route: route }, '', path);
                } else {
                    window.history.pushState({ route: route }, '', path);
                }
            },
            
            // Legacy: Update URL with query params (backward compatibility)
            updateURLWithParams: function(params, replace = false) {
                if (typeof window === 'undefined' || !window.history) return;
                
                const url = new URL(window.location.href);
                url.search = '';
                
                Object.keys(params).forEach(key => {
                    if (params[key] !== null && params[key] !== undefined && params[key] !== '') {
                        url.searchParams.set(key, params[key]);
                    }
                });
                
                if (replace) {
                    window.history.replaceState({}, '', url.toString());
                } else {
                    window.history.pushState({}, '', url.toString());
                }
            },
            
            // Get specific parameter (from query string, for backward compatibility)
            getParam: function(key, defaultValue = null) {
                const params = this.getQueryParams();
                return params[key] || defaultValue;
            },
            
            // Navigate to evaluation (new path-based)
            navigateToEvaluation: function(evaluationId, studentId = null, courseId = null, edit = false) {
                // Try to get courseId from evaluation if not provided
                if (!courseId && typeof getEvaluationCourseId === 'function') {
                    courseId = getEvaluationCourseId(evaluationId);
                }
                
                this.updateURL({
                    type: 'evaluation',
                    evaluationId: evaluationId,
                    studentId: studentId,
                    courseId: courseId,
                    edit: edit
                });
            },
            
            // Navigate to student
            navigateToStudent: function(courseId, studentId) {
                this.updateURL({
                    type: 'student',
                    courseId: courseId,
                    studentId: studentId
                });
            },
            
            // Navigate to course
            navigateToCourse: function(courseId) {
                this.updateURL({
                    type: 'course',
                    courseId: courseId
                });
            },
            
            // Navigate to dashboard section
            navigateToSection: function(section, tab = null) {
                this.updateURL({
                    type: section,
                    tab: tab
                });
            },
            
            // Clear URL (navigate to home)
            clearURL: function() {
                if (typeof window === 'undefined') return;
                window.history.replaceState({}, '', '/');
            },
            
            // Handle route on page load
            handleRoute: async function() {
                // Wait for page to be ready
                if (document.readyState === 'loading') {
                    await new Promise(resolve => {
                        if (document.readyState === 'loading') {
                            document.addEventListener('DOMContentLoaded', resolve);
                        } else {
                            resolve();
                        }
                    });
                }
                
                // Additional wait for auth to complete
                await new Promise(resolve => setTimeout(resolve, 500));
                
                try {
                    const route = this.parseRoute();
                    
                    if (!route || route.type === 'home') {
                        // Default: show dashboard or evaluate section
                        return;
                    }
                    
                if (route.type === 'evaluation' && route.evaluationId) {
                    const evaluationId = route.evaluationId;
                    const studentId = route.studentId || null;
                    const courseId = route.courseId || null;
                    const edit = route.edit === true || this.getParam('edit') === 'true';
                    
                    // If we have courseId, ensure course is loaded first (for proper context)
                    if (courseId && typeof viewCourse === 'function') {
                        await viewCourse(courseId);
                        // Small delay to ensure course UI is ready
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                        
                        // Check if editSavedEvaluation function exists
                        if (typeof editSavedEvaluation === 'function') {
                            await editSavedEvaluation(evaluationId, studentId);
                            // If edit mode requested, ensure we're in edit mode
                            if (edit && editingEvaluationId !== evaluationId) {
                                // Re-trigger edit if needed
                                setTimeout(() => {
                                    if (typeof editSavedEvaluation === 'function') {
                                        editSavedEvaluation(evaluationId, studentId);
                                    }
                                }, 1000);
                            }
                        }
                    } else if (route.type === 'student' && route.courseId && route.studentId) {
                        // Navigate to student view within course
                        // First, ensure we're viewing the course and set currentClassId
                        if (typeof viewCourse === 'function') {
                            // Set currentClassId before calling viewCourse
                            if (typeof currentClassId !== 'undefined') {
                                currentClassId = route.courseId;
                            }
                            await viewCourse(route.courseId);
                            // Then navigate to student evaluations after course loads
                            setTimeout(() => {
                                if (typeof viewStudentEvals === 'function') {
                                    viewStudentEvals(route.studentId);
                                }
                            }, 800);
                        } else if (typeof showDashboard === 'function') {
                            // Fallback: show dashboard
                            showDashboard();
                        }
                    } else if (route.type === 'course' && route.courseId) {
                        // Navigate to course view
                        if (typeof viewCourse === 'function') {
                            await viewCourse(route.courseId);
                        } else if (typeof showDashboard === 'function') {
                            // Fallback: show dashboard and switch to courses tab
                            showDashboard();
                            setTimeout(() => {
                                const tabBtn = document.getElementById('instructorTabBtnCourses');
                                if (tabBtn && typeof switchInstructorDashboardTab === 'function') {
                                    switchInstructorDashboardTab('courses');
                                }
                            }, 300);
                        }
                    } else if (route.type === 'dashboard') {
                        if (typeof showDashboard === 'function') {
                        showDashboard();
                            // Handle tab parameter if present
                            const tab = this.getParam('tab');
                            if (tab) {
                                setTimeout(() => {
                                    if (tab === 'insights' && typeof switchInstructorDashboardTab === 'function') {
                                        switchInstructorDashboardTab('insights');
                                    } else if (tab === 'rubrics' && typeof switchInstructorDashboardTab === 'function') {
                                        switchInstructorDashboardTab('rubrics');
                                    }
                                }, 300);
                            }
                        }
                    } else if (route.type === 'evaluate' && typeof showEvaluate === 'function') {
                        showEvaluate();
                    } else if (route.type === 'settings' && typeof showSettings === 'function') {
                        showSettings();
                        // Handle tab parameter if present
                        const tab = this.getParam('tab');
                        if (tab) {
                            setTimeout(() => {
                                if (typeof switchSettingsTab === 'function') {
                                    switchSettingsTab(tab);
                                }
                            }, 300);
                        }
                    } else if (route.type === 'analytics' && typeof showAnalytics === 'function') {
                        showAnalytics();
                    } else if (route.type === 'help' && typeof showHelp === 'function') {
                        showHelp();
                    }
                } catch (error) {
                    console.error('Error handling route:', error);
                }
            }
        };
        
        // Handle browser back/forward buttons
        window.addEventListener('popstate', function(event) {
            Router.handleRoute();
        });

        /** Predefined behaviors from example videos (see llm_training/qwen_behavior_references.json). */
        const BEHAVIOR_LABELS = ['Hands in pockets', 'Hands clasped (in front)', 'Hands clasped behind', 'Swaying', 'Tapping hands', 'Vocalized pause', 'Purpose statement', 'Eye contact with camera', 'Reading from notes or screen', 'Professional setup'];
        const BEHAVIOR_OTHER = 'Other (Custom)';

        /** Set marker.behavior when marker.issue exactly matches a predefined behavior (so AI-generated markers show the behavior tag). */
        function normalizeMarkerBehaviors(markers) {
            if (!markers || !Array.isArray(markers)) return;
            markers.forEach(function (m) {
                if (m && m.issue && BEHAVIOR_LABELS.indexOf(m.issue) !== -1) m.behavior = m.issue;
            });
        }

        /** Ensure every marker has a stable id (for recurrence grouping and edits). */
        function ensureMarkerIds(markers) {
            if (!markers || !Array.isArray(markers)) return;
            markers.forEach(function (m, i) {
                if (m && !m.id) m.id = 'm_' + Date.now() + '_' + i + '_' + Math.random().toString(36).slice(2, 9);
            });
        }

        /** Key for grouping recurring markers (same issue/behavior = same key). */
        function markerRecurrenceKey(m) {
            var s = (m.behavior || (m.issue || '').trim());
            return s ? s.toLowerCase() : ('_id_' + (m.id || m.seconds || ''));
        }
        
        // Parse timestamp string (e.g., "1:23" or "0:45") to seconds
        function parseTimestampToSeconds(timestamp) {
            if (!timestamp || typeof timestamp !== 'string') return 0;
            const parts = timestamp.trim().split(':');
            if (parts.length === 2) {
                const minutes = parseInt(parts[0]) || 0;
                const seconds = parseInt(parts[1]) || 0;
                return minutes * 60 + seconds;
            } else if (parts.length === 1) {
                // Just seconds
                return parseInt(parts[0]) || 0;
            }
            return 0;
        }
        
        // Format seconds to MM:SS timestamp
        function formatTimestamp(seconds) {
            if (typeof seconds !== 'number' || isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        // Add timeline marker at current video time
        function addTimelineMarkerFromVideo() {
            try {
                const videoPlayer = document.getElementById('evaluationVideoPlayer');
                if (!videoPlayer) {
                    console.error('Video player not found');
                    showNotification('Video player not found. Please ensure the video is loaded.', 'error', 3000);
                    return;
                }
                
                // Wait for video to be ready
                if (videoPlayer.readyState < 2) {
                    showNotification('Video is still loading. Please wait...', 'info', 2000);
                    videoPlayer.addEventListener('loadedmetadata', function handler() {
                        videoPlayer.removeEventListener('loadedmetadata', handler);
                        addTimelineMarkerFromVideo();
                    }, { once: true });
                    return;
                }
                
                if (videoPlayer.currentTime === undefined || videoPlayer.currentTime === null || isNaN(videoPlayer.currentTime)) {
                    console.error('Video currentTime not available');
                    showNotification('Video is not ready. Please wait for the video to load.', 'error', 3000);
                    return;
                }
                
                const currentTime = videoPlayer.currentTime;
                console.log('Adding marker at current time:', currentTime);
                
                const timestamp = formatTimestamp(currentTime);
                console.log('Formatted timestamp:', timestamp);
                addTimelineMarkerWithSelector(timestamp);
                // Don't show notification here - it will show after marker is actually added
            } catch (error) {
                console.error('Error in addTimelineMarkerFromVideo:', error);
                showNotification('Error adding marker: ' + (error.message || 'Unknown error'), 'error', 3000);
            }
        }
        
        
        // Add timeline marker at clicked video time
        function addTimelineMarkerAtVideoTime(event) {
            try {
                console.log('addTimelineMarkerAtVideoTime called', event);
                
                // Find the video element
                let videoPlayer = document.getElementById('evaluationVideoPlayer');
                
                if (!videoPlayer) {
                    console.log('Video player not found');
                    showNotification('Video player not found', 'error', 2000);
                    return;
                }
                
                if (!videoPlayer.duration || videoPlayer.duration === 0 || isNaN(videoPlayer.duration)) {
                    console.log('Video player not ready, duration:', videoPlayer.duration);
                    showNotification('Video is not ready. Please wait for it to load.', 'error', 2000);
                    return;
                }
                
                // Get click position relative to video
                const rect = videoPlayer.getBoundingClientRect();
                if (!event || !event.clientX || !event.clientY) {
                    console.log('Invalid event data, using video center');
                    // Fallback: use current video time
                    const currentTime = videoPlayer.currentTime || 0;
                    const timestamp = formatTimestamp(currentTime);
                    addTimelineMarkerWithSelector(timestamp);
                    return;
                }
                
                const clickX = event.clientX - rect.left;
                const clickY = event.clientY - rect.top;
                const width = rect.width;
                const height = rect.height;
                
                console.log('Click position:', { clickX, clickY, width, height, rect });
                
                // Don't add marker if clicking on controls area (bottom ~80px to be safe)
                const controlsHeight = 80;
                if (clickY > height - controlsHeight) {
                    console.log('Clicked on controls area (y:', clickY, 'height:', height, '), using current time instead');
                    // Instead of ignoring, use current playback time
                    const currentTime = videoPlayer.currentTime || 0;
                    const timestamp = formatTimestamp(currentTime);
                    addTimelineMarkerWithSelector(timestamp);
                    return;
                }
                
                // Calculate time based on click position on the video timeline
                const clickRatio = Math.max(0, Math.min(1, clickX / width));
                const duration = videoPlayer.duration || 0;
                const clickedTime = clickRatio * duration;
                
                console.log('Calculated time:', { clickRatio, duration, clickedTime });
                
                // Add marker at clicked time
                if (clickedTime >= 0 && clickedTime <= duration && !isNaN(clickedTime) && isFinite(clickedTime)) {
                    console.log('Adding marker at clicked time:', clickedTime, 'seconds');
                    const timestamp = formatTimestamp(clickedTime);
                    // Also seek to that time for visual feedback (if not already there)
                    if (Math.abs(videoPlayer.currentTime - clickedTime) > 0.5) {
                        videoPlayer.currentTime = clickedTime;
                    }
                    // Show behavior selector
                    addTimelineMarkerWithSelector(timestamp);
                } else {
                    console.log('Invalid time calculated, using current time instead');
                    // Fallback: use current time
                    const currentTime = videoPlayer.currentTime || 0;
                    const timestamp = formatTimestamp(currentTime);
                    addTimelineMarkerWithSelector(timestamp);
                }
            } catch (error) {
                console.error('Error in addTimelineMarkerAtVideoTime:', error);
                showNotification('Error adding marker: ' + (error.message || 'Unknown error'), 'error', 3000);
            }
        }
        
        // Set up video click listener for adding markers
        function setupVideoMarkerListener() {
            const videoPlayer = document.getElementById('evaluationVideoPlayer');
            if (!videoPlayer) {
                console.log('Video player not found for marker listener setup');
                return;
            }
            
            // Check if we're in editing mode (same logic as displayResults)
            const isEditing = editingEvaluationId !== null && editingEvaluationId !== undefined && editingEvaluationId !== '';
            if (!isEditing) {
                console.log('Not in editing mode, skipping marker listener setup');
                // Remove listener if it was previously attached
                if (videoPlayer.dataset.markerListenerAttached === 'true') {
                    videoPlayer.dataset.markerListenerAttached = 'false';
                }
                return;
            }
            
            // Check if listener is already attached
            if (videoPlayer.dataset.markerListenerAttached === 'true') {
                console.log('Marker listener already attached');
                return;
            }
            
            // Mark that listener is attached
            videoPlayer.dataset.markerListenerAttached = 'true';
            
            // Use double-click to add markers (won't interfere with single-click play/pause)
            const markerDblClickHandler = function(event) {
                console.log('Video double-clicked!', { event, target: event.target, editingEvaluationId });
                
                // Check editing mode
                const stillEditing = editingEvaluationId !== null && editingEvaluationId !== undefined && editingEvaluationId !== '';
                if (!stillEditing) {
                    console.log('Not in editing mode, removing listener');
                    videoPlayer.removeEventListener('dblclick', markerDblClickHandler);
                    videoPlayer.dataset.markerListenerAttached = 'false';
                    return;
                }
                
                // Prevent default double-click behavior (fullscreen)
                event.preventDefault();
                event.stopPropagation();
                
                console.log('Processing double-click to add marker...');
                
                // Process the click to add marker - will show behavior selector
                addTimelineMarkerAtVideoTime(event);
            };
            
            // Add double-click listener
            videoPlayer.addEventListener('dblclick', markerDblClickHandler, false);
            
            console.log('Video marker listener set up successfully - double-click video to add marker');
        }
        
        // Show behavior selector modal for new marker
        function showMarkerBehaviorSelector(timestamp, callback) {
            // Escape timestamp for display
            const safeTimestamp = typeof escapeHtml === 'function' ? escapeHtml(timestamp) : timestamp.replace(/</g, '&lt;').replace(/>/g, '&gt;');
            
            // Create modal HTML with properly escaped values
            let behaviorButtons = '';
            BEHAVIOR_LABELS.forEach(behavior => {
                const safeBehavior = typeof escapeHtml === 'function' ? escapeHtml(behavior) : behavior.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/'/g, '&#39;');
                behaviorButtons += `
                    <button onclick="window.selectMarkerBehavior('${safeBehavior.replace(/'/g, "\\'")}')" style="text-align: left; padding: 0.75rem 1rem; border: 2px solid var(--border); border-radius: 0.375rem; background: white; color: var(--text-dark); cursor: pointer; transition: all 0.2s; font-size: 0.9375rem; width: 100%;" onmouseover="this.style.borderColor='var(--primary)'; this.style.background='rgba(0, 122, 255, 0.05)'" onmouseout="this.style.borderColor='var(--border)'; this.style.background='white'">
                        ${safeBehavior}
                    </button>
                `;
            });
            
            const safeOther = typeof escapeHtml === 'function' ? escapeHtml(BEHAVIOR_OTHER) : BEHAVIOR_OTHER.replace(/</g, '&lt;').replace(/>/g, '&gt;');
            
            const modalHTML = `
                <div id="markerBehaviorModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;">
                    <div style="background: white; border-radius: 0.5rem; padding: 2rem; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 10px 40px rgba(0,0,0,0.2);">
                        <h3 style="margin: 0 0 1rem 0; color: var(--primary);">Add Marker at ${safeTimestamp}</h3>
                        <p style="color: var(--text-light); margin-bottom: 1.5rem; font-size: 0.875rem;">Select the reason for this marker:</p>
                        <div style="display: grid; gap: 0.5rem; margin-bottom: 1.5rem;">
                            ${behaviorButtons}
                            <button onclick="window.selectMarkerBehavior('${safeOther.replace(/'/g, "\\'")}')" style="text-align: left; padding: 0.75rem 1rem; border: 2px dashed var(--border); border-radius: 0.375rem; background: white; color: var(--text-light); cursor: pointer; transition: all 0.2s; font-size: 0.9375rem; font-style: italic; width: 100%;" onmouseover="this.style.borderColor='var(--primary)'; this.style.background='rgba(0, 122, 255, 0.05)'" onmouseout="this.style.borderColor='var(--border)'; this.style.background='white'">
                                ${safeOther}
                            </button>
                        </div>
                        <div style="display: flex; gap: 0.5rem; justify-content: flex-end;">
                            <button onclick="window.closeMarkerBehaviorModal()" style="padding: 0.5rem 1rem; border: 1px solid var(--border); border-radius: 0.375rem; background: white; color: var(--text-dark); cursor: pointer;">Cancel</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Remove existing modal if any
            const existingModal = document.getElementById('markerBehaviorModal');
            if (existingModal) existingModal.remove();
            
            // Add modal to body
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            
            // Store callback and timestamp
            window._markerBehaviorCallback = callback;
            window._markerBehaviorTimestamp = timestamp;
        }
        
        function selectMarkerBehavior(behavior) {
            const callback = window._markerBehaviorCallback;
            const timestamp = window._markerBehaviorTimestamp || '0:00';
            closeMarkerBehaviorModal();
            if (callback) {
                const selectedBehavior = behavior === BEHAVIOR_OTHER ? null : behavior;
                console.log('Calling marker callback with timestamp:', timestamp, 'behavior:', selectedBehavior);
                callback(timestamp, selectedBehavior);
            }
        }
        
        function closeMarkerBehaviorModal() {
            const modal = document.getElementById('markerBehaviorModal');
            if (modal) modal.remove();
            window._markerBehaviorCallback = null;
            window._markerBehaviorTimestamp = null;
        }
        
        // Add a new timeline marker
        function addTimelineMarker(timestamp = '0:00', selectedBehavior = null) {
            try {
                console.log('addTimelineMarker called with timestamp:', timestamp, 'behavior:', selectedBehavior);
                
                if (!evaluationResults) {
                    console.error('evaluationResults not available');
                    alert('Cannot add marker: Evaluation data not loaded.');
                    return;
                }
                
                if (!evaluationResults.timeline_markers) {
                    console.log('Initializing timeline_markers array');
                    evaluationResults.timeline_markers = [];
                }
                
                // Determine category based on behavior
                let category = 'Other';
                if (selectedBehavior) {
                    if (selectedBehavior.includes('Eye contact') || selectedBehavior.includes('Hands') || selectedBehavior.includes('Swaying') || selectedBehavior.includes('Tapping')) {
                        category = 'Delivery - Nonverbal';
                    } else if (selectedBehavior.includes('Vocalized pause')) {
                        category = 'Delivery - Verbal';
                    } else if (selectedBehavior.includes('Purpose statement')) {
                        category = 'Content - Introduction';
                    } else if (selectedBehavior.includes('Reading')) {
                        category = 'Delivery - Verbal';
                    }
                }
                
                // Create new marker
                const newMarker = {
                    id: `temp-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    timestamp: timestamp,
                    issue: selectedBehavior || 'New marker',
                    note: '',
                    category: category,
                    severity: 'minor',
                    behavior: selectedBehavior || null
                };
                
                console.log('Created new marker:', newMarker);
                console.log('Marker timestamp:', newMarker.timestamp);
                evaluationResults.timeline_markers.push(newMarker);
                console.log('Total markers now:', evaluationResults.timeline_markers.length);
                console.log('All markers:', evaluationResults.timeline_markers);
                
                // Re-render the evaluation to show the new marker
                if (typeof displayResults === 'function') {
                    console.log('=== RE-RENDERING AFTER ADDING MARKER ===');
                    console.log('evaluationResults.timeline_markers:', evaluationResults.timeline_markers);
                    console.log('evaluationResults.timeline_markers.length:', evaluationResults.timeline_markers ? evaluationResults.timeline_markers.length : 0);
                    console.log('editingEvaluationId:', editingEvaluationId);
                    
                    // Verify markers are actually in the object
                    if (!evaluationResults.timeline_markers || !Array.isArray(evaluationResults.timeline_markers)) {
                        console.error('ERROR: timeline_markers is missing or not an array!');
                        evaluationResults.timeline_markers = [];
                    }
                    
                    // Check if we're in dropdown view - find the dropdown containing this evaluation
                    // Strategy: Find the video player first, then traverse up to find the dropdown
                    let dropdownContent = null;
                    let evalDropdown = null;
                    if (editingEvaluationId) {
                        // First, try to find the video player - if it exists, we're in dropdown view
                        const videoPlayer = document.getElementById('evaluationVideoPlayer');
                        if (videoPlayer) {
                            // Traverse up the DOM to find the eval-* container
                            let current = videoPlayer.parentElement;
                            while (current && current !== document.body) {
                                if (current.id && current.id.startsWith('eval-')) {
                                    evalDropdown = current;
                                    console.log('Found dropdown via video player:', current.id);
                                    break;
                                }
                                current = current.parentElement;
                            }
                            
                            // If we found the dropdown, get the content div
                            if (evalDropdown) {
                                const dropdownContentDiv = document.getElementById(evalDropdown.id);
                                dropdownContent = dropdownContentDiv ? dropdownContentDiv.querySelector('div[style*="padding-top: 1rem"]') : null;
                                console.log('Found dropdown content:', !!dropdownContent);
                                // Make sure it's expanded
                                if (dropdownContentDiv && dropdownContentDiv.classList.contains('hidden')) {
                                    dropdownContentDiv.classList.remove('hidden');
                                    const arrow = document.getElementById(evalDropdown.id + '-arrow');
                                    if (arrow) arrow.textContent = '▲';
                                }
                            }
                        }
                        
                        // Fallback: Try the original method if video player method didn't work
                        if (!evalDropdown) {
                            const allEvalDropdowns = document.querySelectorAll('[id^="eval-"]');
                            console.log('Fallback: Searching for dropdown, found', allEvalDropdowns.length, 'dropdowns');
                            for (let i = 0; i < allEvalDropdowns.length; i++) {
                                const dropdown = allEvalDropdowns[i];
                                // Check if this dropdown contains a button that references this evaluationId
                                const editButton = dropdown.querySelector(`button[onclick*="editSavedEvaluation('${editingEvaluationId}'"]`);
                                if (editButton) {
                                    evalDropdown = dropdown;
                                    console.log('Found matching dropdown via button:', dropdown.id);
                                    const dropdownContentDiv = document.getElementById(dropdown.id);
                                    dropdownContent = dropdownContentDiv ? dropdownContentDiv.querySelector('div[style*="padding-top: 1rem"]') : null;
                                    console.log('Found dropdown for evaluation:', editingEvaluationId, 'container:', dropdown.id, 'dropdownContent:', !!dropdownContent);
                                    if (dropdownContentDiv && dropdownContentDiv.classList.contains('hidden')) {
                                        dropdownContentDiv.classList.remove('hidden');
                                        const arrow = document.getElementById(dropdown.id + '-arrow');
                                        if (arrow) arrow.textContent = '▲';
                                    }
                                    break;
                                }
                            }
                        }
                        
                        if (!evalDropdown) {
                            console.log('No dropdown found for evaluation:', editingEvaluationId, '- will render to main view');
                        }
                    }
                    
                    if (dropdownContent) {
                        // We're in dropdown view - render to temp container then inject
                        console.log('Re-rendering in dropdown view with', evaluationResults.timeline_markers.length, 'markers');
                        const tempContainer = document.createElement('div');
                        tempContainer.id = 'resultsContent';
                        tempContainer.style.display = 'none';
                        document.body.appendChild(tempContainer);
                        
                        const originalResultsContent = document.getElementById('resultsContent');
                        let originalParent = null;
                        if (originalResultsContent && originalResultsContent !== tempContainer) {
                            originalParent = originalResultsContent.parentElement;
                            if (originalParent) {
                                originalParent.replaceChild(tempContainer, originalResultsContent);
                            }
                        }
                        
                        // Render to temp container - pass evaluationResults directly
                        console.log('Calling displayResults with', evaluationResults.timeline_markers.length, 'markers');
                        displayResults(evaluationResults);
                        
                        // Extract and inject into dropdown
                        const renderedHTML = tempContainer.innerHTML;
                        console.log('Rendered HTML length:', renderedHTML.length);
                        console.log('Rendered HTML contains "Timeline Markers":', renderedHTML.includes('Timeline Markers'));
                        console.log('Rendered HTML contains "data-marker-id":', renderedHTML.includes('data-marker-id'));
                        console.log('Rendered HTML contains marker timestamp:', renderedHTML.includes(timestamp));
                        
                        if (!renderedHTML.includes('Timeline Markers')) {
                            console.error('ERROR: Timeline Markers section not found in rendered HTML!');
                            console.log('HTML sample (first 2000 chars):', renderedHTML.substring(0, 2000));
                        }
                        
                        dropdownContent.innerHTML = renderedHTML;
                        console.log('Injected HTML into dropdown');
                        
                        // Restore original resultsContent
                        if (originalResultsContent && originalResultsContent !== tempContainer && originalParent) {
                            originalParent.replaceChild(originalResultsContent, tempContainer);
                        } else {
                            tempContainer.remove();
                        }
                        
                        // Re-initialize icons in dropdown
                        if (typeof lucide !== 'undefined' && lucide.createIcons) {
                            lucide.createIcons({ root: dropdownContent });
                        }
                        
                        // Set up video marker listener again
                        if (typeof setupVideoMarkerListener === 'function') {
                            setTimeout(() => {
                                setupVideoMarkerListener();
                            }, 100);
                        }
                    } else {
                        // Main view - render normally
                        console.log('Re-rendering in main view with', evaluationResults.timeline_markers.length, 'markers');
                        displayResults(evaluationResults);
                    }
                    
                    // Show success notification after rendering
                    showNotification('Marker added at ' + timestamp, 'success', 2000);
                } else {
                    console.error('displayResults function not available');
                    alert('Cannot re-render: displayResults function not found.');
                    return;
                }
                
                // Scroll to the new marker after a short delay
                setTimeout(() => {
                    const markerElement = document.querySelector(`[data-marker-id="${newMarker.id}"]`);
                    console.log('Looking for marker element with id:', newMarker.id);
                    if (markerElement) {
                        markerElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // Focus on the issue input if it's "Other"
                        if (!selectedBehavior || selectedBehavior === BEHAVIOR_OTHER) {
                            const issueInput = markerElement.querySelector('input[id^="marker-issue-"]');
                            if (issueInput) {
                                setTimeout(() => {
                                    issueInput.focus();
                                    issueInput.select();
                                }, 100);
                            }
                        }
                    } else {
                        console.warn('Marker element not found after render, trying again...');
                        // Try again after a longer delay
                        setTimeout(() => {
                            const markerElement2 = document.querySelector(`[data-marker-id="${newMarker.id}"]`);
                            if (markerElement2) {
                                markerElement2.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                        }, 500);
                    }
                }, 300);
            } catch (error) {
                console.error('Error in addTimelineMarker:', error);
                alert('Error adding marker: ' + error.message);
            }
        }
        
        // Wrapper function to show behavior selector first
        function addTimelineMarkerWithSelector(timestamp = '0:00') {
            console.log('addTimelineMarkerWithSelector called with timestamp:', timestamp);
            showMarkerBehaviorSelector(timestamp, function(timestampFromCallback, selectedBehavior) {
                console.log('Behavior selector callback called with timestamp:', timestampFromCallback, 'behavior:', selectedBehavior);
                addTimelineMarker(timestampFromCallback || timestamp, selectedBehavior);
            });
        }
        
        // Delete a timeline marker
        function deleteTimelineMarker(markerId) {
            console.log('=== deleteTimelineMarker called ===');
            console.log('markerId:', markerId);
            console.log('markerId type:', typeof markerId);
            
            if (!evaluationResults || !evaluationResults.timeline_markers) {
                console.error('evaluationResults or timeline_markers not available');
                return;
            }
            
            console.log('Current markers:', evaluationResults.timeline_markers);
            console.log('Marker IDs:', evaluationResults.timeline_markers.map(m => m.id));
            
            if (!confirm('Are you sure you want to delete this timeline marker?')) {
                return;
            }
            
            // Remove marker from array - try multiple matching strategies
            let index = evaluationResults.timeline_markers.findIndex(m => {
                if (!m.id) return false;
                // Exact match
                if (m.id === markerId) return true;
                // String comparison
                if (m.id.toString() === markerId.toString()) return true;
                // Case-insensitive string comparison
                if (String(m.id).toLowerCase() === String(markerId).toLowerCase()) return true;
                return false;
            });
            
            console.log('Found index by ID:', index);
            
            if (index === -1) {
                // Try to find by data attribute from DOM
                console.log('Trying to find marker by DOM element...');
                const markerElement = document.querySelector(`[data-marker-id="${markerId}"]`);
                if (markerElement) {
                    console.log('Found marker element in DOM');
                    const markerIndexAttr = markerElement.getAttribute('data-marker-index');
                    const markerIndex = markerIndexAttr !== null ? parseInt(markerIndexAttr) : -1;
                    console.log('Marker index from DOM:', markerIndex);
                    
                    if (markerIndex >= 0 && markerIndex < evaluationResults.timeline_markers.length) {
                        // Use the index directly
                        index = markerIndex;
                        console.log('Using index from DOM:', index);
                    } else {
                        // Try to find by category and position
                        const category = markerElement.getAttribute('data-marker-category');
                        console.log('Trying to find by category:', category);
                        // Count how many markers of this category come before this one in the DOM
                        let categoryCount = 0;
                        const allMarkers = markerElement.parentElement.querySelectorAll(`[data-marker-category="${category}"]`);
                        for (let i = 0; i < allMarkers.length; i++) {
                            if (allMarkers[i] === markerElement) {
                                break;
                            }
                            categoryCount++;
                        }
                        // Find the marker in the array
                        let foundInArray = false;
                        evaluationResults.timeline_markers.forEach((m, i) => {
                            if (m.category === category && !foundInArray) {
                                if (categoryCount === 0) {
                                    index = i;
                                    foundInArray = true;
                                } else {
                                    categoryCount--;
                                }
                            }
                        });
                        console.log('Found index by category:', index);
                    }
                } else {
                    console.error('Marker element not found in DOM for ID:', markerId);
                    console.log('Available marker elements:', document.querySelectorAll('[data-marker-id]'));
                }
            }
            
            if (index === -1) {
                console.error('Could not find marker to delete:', markerId);
                alert('Could not find the marker to delete. Please refresh the page and try again.');
                return;
            }
            
            console.log('Deleting marker at index:', index);
            const deletedMarker = evaluationResults.timeline_markers[index];
            console.log('Deleted marker:', deletedMarker);
            evaluationResults.timeline_markers.splice(index, 1);
            console.log('Remaining markers:', evaluationResults.timeline_markers.length);
            
            // Re-render the evaluation - handle dropdown view same as adding markers
            if (typeof displayResults === 'function') {
                console.log('=== RE-RENDERING AFTER DELETING MARKER ===');
                console.log('evaluationResults.timeline_markers.length:', evaluationResults.timeline_markers ? evaluationResults.timeline_markers.length : 0);
                console.log('editingEvaluationId:', editingEvaluationId);
                
                // Check if we're in dropdown view - find the dropdown containing this evaluation
                // Strategy: Find the video player first, then traverse up to find the dropdown
                let dropdownContent = null;
                let evalDropdown = null;
                if (editingEvaluationId) {
                    // First, try to find the video player - if it exists, we're in dropdown view
                    const videoPlayer = document.getElementById('evaluationVideoPlayer');
                    if (videoPlayer) {
                        // Traverse up the DOM to find the eval-* container
                        let current = videoPlayer.parentElement;
                        while (current && current !== document.body) {
                            if (current.id && current.id.startsWith('eval-')) {
                                evalDropdown = current;
                                console.log('Found dropdown via video player:', current.id);
                                break;
                            }
                            current = current.parentElement;
                        }
                        
                        // If we found the dropdown, get the content div
                        if (evalDropdown) {
                            const dropdownContentDiv = document.getElementById(evalDropdown.id);
                            dropdownContent = dropdownContentDiv ? dropdownContentDiv.querySelector('div[style*="padding-top: 1rem"]') : null;
                            console.log('Found dropdown content:', !!dropdownContent);
                            // Make sure it's expanded
                            if (dropdownContentDiv && dropdownContentDiv.classList.contains('hidden')) {
                                dropdownContentDiv.classList.remove('hidden');
                                const arrow = document.getElementById(evalDropdown.id + '-arrow');
                                if (arrow) arrow.textContent = '▲';
                            }
                        }
                    }
                    
                    // Fallback: Try the original method if video player method didn't work
                    if (!evalDropdown) {
                        const allEvalDropdowns = document.querySelectorAll('[id^="eval-"]');
                        console.log('Fallback: Searching for dropdown, found', allEvalDropdowns.length, 'dropdowns');
                        for (let i = 0; i < allEvalDropdowns.length; i++) {
                            const dropdown = allEvalDropdowns[i];
                            // Check if this dropdown contains a button that references this evaluationId
                            const editButton = dropdown.querySelector(`button[onclick*="editSavedEvaluation('${editingEvaluationId}'"]`);
                            if (editButton) {
                                evalDropdown = dropdown;
                                console.log('Found matching dropdown via button:', dropdown.id);
                                const dropdownContentDiv = document.getElementById(dropdown.id);
                                dropdownContent = dropdownContentDiv ? dropdownContentDiv.querySelector('div[style*="padding-top: 1rem"]') : null;
                                console.log('Found dropdown for evaluation:', editingEvaluationId, 'container:', dropdown.id, 'dropdownContent:', !!dropdownContent);
                                if (dropdownContentDiv && dropdownContentDiv.classList.contains('hidden')) {
                                    dropdownContentDiv.classList.remove('hidden');
                                    const arrow = document.getElementById(dropdown.id + '-arrow');
                                    if (arrow) arrow.textContent = '▲';
                                }
                                break;
                            }
                        }
                    }
                    
                    if (!evalDropdown) {
                        console.log('No dropdown found for evaluation:', editingEvaluationId, '- will render to main view');
                    }
                }
                
                if (dropdownContent) {
                    // We're in dropdown view - render to temp container then inject
                    console.log('Re-rendering in dropdown view with', evaluationResults.timeline_markers.length, 'markers');
                    const tempContainer = document.createElement('div');
                    tempContainer.id = 'resultsContent';
                    tempContainer.style.display = 'none';
                    document.body.appendChild(tempContainer);
                    
                    const originalResultsContent = document.getElementById('resultsContent');
                    let originalParent = null;
                    if (originalResultsContent && originalResultsContent !== tempContainer) {
                        originalParent = originalResultsContent.parentElement;
                        if (originalParent) {
                            originalParent.replaceChild(tempContainer, originalResultsContent);
                        }
                    }
                    
                    // Render to temp container - pass evaluationResults directly
                    console.log('Calling displayResults with', evaluationResults.timeline_markers.length, 'markers');
                    displayResults(evaluationResults);
                    
                    // Extract and inject into dropdown
                    const renderedHTML = tempContainer.innerHTML;
                    console.log('Rendered HTML length:', renderedHTML.length);
                    console.log('Rendered HTML contains "Timeline Markers":', renderedHTML.includes('Timeline Markers'));
                    console.log('Rendered HTML contains "data-marker-id":', renderedHTML.includes('data-marker-id'));
                    
                    if (!renderedHTML.includes('Timeline Markers')) {
                        console.error('ERROR: Timeline Markers section not found in rendered HTML!');
                        console.log('HTML sample (first 2000 chars):', renderedHTML.substring(0, 2000));
                    }
                    
                    dropdownContent.innerHTML = renderedHTML;
                    console.log('Injected HTML into dropdown');
                    
                    // Restore original resultsContent
                    if (originalResultsContent && originalResultsContent !== tempContainer && originalParent) {
                        originalParent.replaceChild(originalResultsContent, tempContainer);
                    } else {
                        tempContainer.remove();
                    }
                    
                    // Re-initialize icons in dropdown
                    if (typeof lucide !== 'undefined' && lucide.createIcons) {
                        lucide.createIcons({ root: dropdownContent });
                    }
                    
                    // Set up video marker listener again
                    if (typeof setupVideoMarkerListener === 'function') {
                        setTimeout(() => {
                            setupVideoMarkerListener();
                        }, 100);
                    }
                } else {
                    // Main view - render normally
                    console.log('Re-rendering in main view with', evaluationResults.timeline_markers.length, 'markers');
                    displayResults(evaluationResults);
                }
            }
            
            showNotification('Timeline marker deleted', 'success', 2000);
        }
        
        // Make functions globally available
        try {
            window.addTimelineMarker = addTimelineMarker;
            window.addTimelineMarkerWithSelector = addTimelineMarkerWithSelector;
            window.deleteTimelineMarker = deleteTimelineMarker;
            window.addTimelineMarkerFromVideo = addTimelineMarkerFromVideo;
            window.addTimelineMarkerAtVideoTime = addTimelineMarkerAtVideoTime;
            window.setupVideoMarkerListener = setupVideoMarkerListener;
            window.formatTimestamp = formatTimestamp;
            window.selectMarkerBehavior = selectMarkerBehavior;
            window.closeMarkerBehaviorModal = closeMarkerBehaviorModal;
        } catch (e) {
            console.error('Error making timeline marker functions globally available:', e);
        }
        
        // Jump video player to specific timestamp
        function jumpToTimestamp(seconds) {
            const videoPlayer = document.getElementById('evaluationVideoPlayer');
            if (!videoPlayer) {
                console.warn('Video player not found');
                return;
            }
            
            // Always jump to timestamp, whether playing or paused
                videoPlayer.currentTime = seconds;
            
            // If paused, briefly highlight the video to show the jump
            videoPlayer.style.transition = 'box-shadow 0.3s ease';
            videoPlayer.style.boxShadow = '0 0 0 4px rgba(0, 122, 255, 0.5)';
            setTimeout(() => {
                videoPlayer.style.boxShadow = '';
                setTimeout(() => {
                    videoPlayer.style.transition = '';
                }, 300);
            }, 300);
            
            // Optionally play if user wants (but don't force autoplay)
            // videoPlayer.play().catch(e => console.log('Could not autoplay:', e));
        }
        
        // Insert current video timestamp into comments
        function insertTimestampIntoComments() {
            const videoPlayer = document.getElementById('evaluationVideoPlayer');
            const commentsTextarea = document.getElementById('overall-comments-text');
            
            if (!videoPlayer || !commentsTextarea) {
                showNotification('Video player or comments field not found', 'error', 3000);
                return;
            }
            
            if (videoPlayer.readyState < 2) {
                showNotification('Video is not ready. Please wait for it to load.', 'error', 3000);
                return;
            }
            
            const currentTime = videoPlayer.currentTime || 0;
            const minutes = Math.floor(currentTime / 60);
            const seconds = Math.floor(currentTime % 60);
            const timestamp = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            // Get cursor position
            const cursorPos = commentsTextarea.selectionStart || commentsTextarea.value.length;
            const textBefore = commentsTextarea.value.substring(0, cursorPos);
            const textAfter = commentsTextarea.value.substring(cursorPos);
            
            // Insert timestamp with brackets for clarity
            const timestampText = `[${timestamp}]`;
            commentsTextarea.value = textBefore + timestampText + textAfter;
            
            // Set cursor position after inserted timestamp
            const newCursorPos = cursorPos + timestampText.length;
            commentsTextarea.setSelectionRange(newCursorPos, newCursorPos);
            commentsTextarea.focus();
            
            // Trigger input event to ensure any change handlers fire
            commentsTextarea.dispatchEvent(new Event('input', { bubbles: true }));
        }

        /** Return { key -> display label, key -> count } for current markers. */
        function getRecurrenceSummary(markers) {
            var summary = {};
            if (!markers || !markers.length) return summary;
            markers.forEach(function (m) {
                var key = markerRecurrenceKey(m);
                var label = (m.behavior || m.issue || 'Unknown').trim();
                if (!summary[key]) summary[key] = { label: label, count: 0 };
                summary[key].count += 1;
            });
            return summary;
        }
        
        // ===== SECURITY UTILITIES =====
        
        /**
         * Fetch with timeout - prevents hanging requests to external APIs
         * @param {string} url - URL to fetch
         * @param {Object} options - Fetch options
         * @param {number} timeoutMs - Timeout in milliseconds (default: 60000 = 60s)
         * @returns {Promise<Response>} Fetch response
         */
        async function fetchWithTimeout(url, options = {}, timeoutMs = 60000) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
            
            try {
                const response = await fetch(url, {
                    ...options,
                    signal: controller.signal
                });
                return response;
            } catch (error) {
                if (error.name === 'AbortError') {
                    throw new Error(`Request timed out after ${timeoutMs / 1000} seconds`);
                }
                throw error;
            } finally {
                clearTimeout(timeoutId);
            }
        }
        
        /**
         * Escapes HTML special characters to prevent XSS attacks
         * @param {string} text - Text to escape
         * @returns {string} Escaped HTML-safe text
         */
        /* Apple HIG: Spacing utility functions for consistent inline styles */
        // Get CSS spacing variable value (for use in inline styles)
        function getSpacing(size) {
            const spacingMap = {
                'xs': 'var(--space-xs)',
                'sm': 'var(--space-sm)',
                'md': 'var(--space-md)',
                'lg': 'var(--space-lg)',
                'xl': 'var(--space-xl)',
                '2xl': 'var(--space-2xl)',
                '3xl': 'var(--space-3xl)'
            };
            return spacingMap[size] || size;
        }
        
        // Generate spacing style string (e.g., "padding: var(--space-md); margin: var(--space-lg);")
        function spacingStyle(props) {
            const styles = [];
            if (props.p) styles.push(`padding: ${getSpacing(props.p)}`);
            if (props.pt) styles.push(`padding-top: ${getSpacing(props.pt)}`);
            if (props.pr) styles.push(`padding-right: ${getSpacing(props.pr)}`);
            if (props.pb) styles.push(`padding-bottom: ${getSpacing(props.pb)}`);
            if (props.pl) styles.push(`padding-left: ${getSpacing(props.pl)}`);
            if (props.px) styles.push(`padding-left: ${getSpacing(props.px)}; padding-right: ${getSpacing(props.px)}`);
            if (props.py) styles.push(`padding-top: ${getSpacing(props.py)}; padding-bottom: ${getSpacing(props.py)}`);
            if (props.m) styles.push(`margin: ${getSpacing(props.m)}`);
            if (props.mt) styles.push(`margin-top: ${getSpacing(props.mt)}`);
            if (props.mr) styles.push(`margin-right: ${getSpacing(props.mr)}`);
            if (props.mb) styles.push(`margin-bottom: ${getSpacing(props.mb)}`);
            if (props.ml) styles.push(`margin-left: ${getSpacing(props.ml)}`);
            if (props.mx) styles.push(`margin-left: ${getSpacing(props.mx)}; margin-right: ${getSpacing(props.mx)}`);
            if (props.my) styles.push(`margin-top: ${getSpacing(props.my)}; margin-bottom: ${getSpacing(props.my)}`);
            if (props.gap) styles.push(`gap: ${getSpacing(props.gap)}`);
            return styles.join('; ');
        }
        
        // Common spacing patterns as shortcuts
        const space = {
            // Padding shortcuts
            p: (size) => `padding: ${getSpacing(size)}`,
            px: (size) => `padding-left: ${getSpacing(size)}; padding-right: ${getSpacing(size)}`,
            py: (size) => `padding-top: ${getSpacing(size)}; padding-bottom: ${getSpacing(size)}`,
            // Margin shortcuts
            m: (size) => `margin: ${getSpacing(size)}`,
            mx: (size) => `margin-left: ${getSpacing(size)}; margin-right: ${getSpacing(size)}`,
            my: (size) => `margin-top: ${getSpacing(size)}; margin-bottom: ${getSpacing(size)}`,
            mb: (size) => `margin-bottom: ${getSpacing(size)}`,
            mt: (size) => `margin-top: ${getSpacing(size)}`,
            // Gap
            gap: (size) => `gap: ${getSpacing(size)}`,
            // Combined common patterns
            card: () => `padding: ${getSpacing('lg')}; margin-bottom: ${getSpacing('lg')}`,
            section: () => `padding: ${getSpacing('xl')} 0; margin-bottom: ${getSpacing('xl')}`,
            button: () => `padding: ${getSpacing('md')} ${getSpacing('lg')}`,
            input: () => `padding: ${getSpacing('md')}`,
            modal: () => `padding: ${getSpacing('xl')} ${getSpacing('2xl')}`
        };
        
        // Chart accessibility helper functions
        function showChartPointDetails(element) {
            const title = element.getAttribute('title') || element.getAttribute('aria-label') || 'Chart point';
            alert(title); // In a production app, this could show a tooltip or modal
        }
        
        function showChartSegmentDetails(element) {
            const title = element.getAttribute('title') || element.getAttribute('aria-label') || 'Chart segment';
            alert(title); // In a production app, this could show a tooltip or modal
        }
        
        function escapeHtml(text) {
            if (text == null) return '';
            const str = String(text);
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return str.replace(/[&<>"']/g, m => map[m]);
        }
        
        /** Returns HTML for "Deleted locally on [date]" tag when deleted_locally_at is set (for Admin/Super Admin dashboards). */
        function formatDeletedLocallyTag(deleted_locally_at) {
            if (!deleted_locally_at) return '';
            const date = new Date(deleted_locally_at);
            const label = isNaN(date.getTime()) ? '' : date.toLocaleDateString(undefined, { dateStyle: 'medium' });
            if (!label) return '';
            return ' <span style="font-size: 0.75rem; color: var(--text-light); font-weight: 500;" title="Deleted locally by Instructor/Admin">Deleted locally on ' + escapeHtml(label) + '</span>';
        }
        
        /**
         * Safely sets innerHTML with escaped content
         * @param {HTMLElement|string} element - Element or element ID
         * @param {string} html - HTML content (will be escaped if needed)
         * @param {boolean} allowHtml - If true, allows HTML (use with caution)
         */
        function safeSetInnerHTML(element, html, allowHtml = false) {
            const el = typeof element === 'string' ? document.getElementById(element) : element;
            if (!el) {
                if (CONFIG.DEBUG) console.warn('Element not found for safeSetInnerHTML:', element);
                return;
            }
            el.innerHTML = allowHtml ? html : escapeHtml(String(html));
        }
        
        // ===== INPUT VALIDATION =====
        
        /**
         * Validates API key format based on provider
         * @param {string} key - API key to validate
         * @param {string} provider - Provider name ('gemini', 'gpt4o', 'claude')
         * @returns {boolean} True if format is valid
         */
        function validateApiKeyFormat(key, provider) {
            if (!key || typeof key !== 'string' || key.trim().length === 0) {
                return false;
            }
            
            const trimmedKey = key.trim();
            
            switch (provider) {
                case 'gemini':
                    return trimmedKey.startsWith('AIza') && trimmedKey.length >= 35;
                case 'gpt4o':
                case 'openai':
                    return trimmedKey.startsWith('sk-') && trimmedKey.length >= 20;
                case 'claude':
                case 'anthropic':
                    return trimmedKey.startsWith('sk-ant-') && trimmedKey.length >= 20;
                default:
                    return trimmedKey.length > 0; // Basic non-empty check
            }
        }
        
        /**
         * Validates file type for upload
         * @param {File} file - File object to validate
         * @param {string[]} allowedTypes - Array of allowed MIME types
         * @returns {object} {valid: boolean, error: string}
         */
        function validateFileType(file, allowedTypes = []) {
            if (!file) {
                return { valid: false, error: 'No file provided' };
            }
            
            if (allowedTypes.length > 0 && !allowedTypes.includes(file.type)) {
                return { 
                    valid: false, 
                    error: `File type ${file.type} not allowed. Allowed types: ${allowedTypes.join(', ')}` 
                };
            }
            
            return { valid: true };
        }
        
        /**
         * Validates file size
         * @param {File} file - File object to validate
         * @param {number} maxSizeBytes - Maximum size in bytes
         * @returns {object} {valid: boolean, error: string}
         */
        function validateFileSize(file, maxSizeBytes) {
            if (!file) {
                return { valid: false, error: 'No file provided' };
            }
            
            if (file.size > maxSizeBytes) {
                const sizeMB = (file.size / 1024 / 1024).toFixed(2);
                const limitMB = (maxSizeBytes / 1024 / 1024).toFixed(0);
                return { 
                    valid: false, 
                    error: `File size (${sizeMB} MB) exceeds limit (${limitMB} MB)` 
                };
            }
            
            return { valid: true };
        }
        
        /**
         * Validates email format
         * @param {string} email - Email to validate
         * @returns {boolean} True if valid email format
         */
        function validateEmail(email) {
            if (!email || typeof email !== 'string') return false;
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            return emailRegex.test(email.trim());
        }
        
        /**
         * Sanitizes string input (removes potentially dangerous characters)
         * @param {string} input - Input to sanitize
         * @param {number} maxLength - Maximum length (optional)
         * @returns {string} Sanitized string
         */
        function sanitizeInput(input, maxLength = null) {
            if (input == null) return '';
            let sanitized = String(input).trim();
            
            // Remove null bytes and control characters (except newlines/tabs)
            sanitized = sanitized.replace(/[\x00-\x08\x0B-\x0C\x0E-\x1F\x7F]/g, '');
            
            if (maxLength && sanitized.length > maxLength) {
                sanitized = sanitized.substring(0, maxLength);
            }
            
            return sanitized;
        }
        
        // ===== DEBUG LOGGING =====
        
        /**
         * Debug logging wrapper - only logs in development mode
         */
        const log = {
            debug: CONFIG.DEBUG ? console.log.bind(console) : () => {},
            warn: CONFIG.DEBUG ? console.warn.bind(console) : () => {},
            error: console.error.bind(console), // Always log errors
            info: CONFIG.DEBUG ? console.info.bind(console) : () => {}
        };
        
        // Initialize Supabase client
        let supabaseClient = null;
        
        try {
            if (window.supabase) {
                supabaseClient = window.supabase.createClient(CONFIG.SUPABASE_URL, CONFIG.SUPABASE_ANON_KEY);
                log.debug('✓ Supabase client initialized');
            } else {
                log.warn('⚠️ Supabase library not loaded - using localStorage fallback');
            }
        } catch (error) {
            log.error('❌ Supabase initialization failed:', error);
            log.debug('Using localStorage fallback mode');
        }
        
        // Test Supabase connection
        async function testSupabaseConnection() {
            if (!supabaseClient) {
                log.debug('Supabase not available - running in offline mode');
                return false;
            }
            
            try {
                log.debug('Testing Supabase connection...');
                const { data, error } = await supabaseClient
                    .from('organizations')
                    .select('name')
                    .limit(1);
                
                if (error) {
                    log.error('❌ Supabase connection failed:', error.message);
                    return false;
                } else {
                    log.debug('✅ Supabase connected successfully!');
                    if (data && data.length > 0) {
                        log.debug('   Organization:', data[0].name);
                    }
                    return true;
                }
            } catch (error) {
                log.error('❌ Supabase test error:', error);
                return false;
            }
        }
        
        // ===== AUTHENTICATION FUNCTIONS =====
        
        let currentUser = null;
        let userTier = 'demo'; // 'demo', 'instructor', 'admin', or 'super_admin'
        let currentViewMode = 'own'; // 'own' (default), 'institution' (admin), 'all' (super_admin), 'demo'
        let demoViewAs = 'instructor'; // 'instructor' | 'admin' — for demo mode dashboard view switcher
        let currentInstitution = null;
        let currentInstitutionTheme = null; // Store loaded theme
        let cachedDepartmentInstructors = []; // Cache for semester filtering
        let cachedInstitutionApiKeys = null;  // Cache for institution api_keys (instructor fallback)
        let cachedDepartmentApiKeys = null;   // Cache for department api_keys (assigned instructors only)
        let currentFilterInstitutionId = null; // Super admin: filter courses by this institution
        let currentFilterInstructorId = null;  // Admin/super admin: filter courses by this instructor when viewing institution
        
        // ===== AUDIT LOGGING FOR FERPA COMPLIANCE =====
        /**
         * Log access to student data for FERPA compliance
         * @param {string} action - 'view', 'create', 'update', 'delete', 'export', 'print'
         * @param {string} tableName - Name of table accessed
         * @param {string|null} recordId - ID of specific record (if applicable)
         * @param {string|null} studentId - ID of student whose data was accessed
         * @param {object} metadata - Additional context information
         */
        async function logAccess(action, tableName, recordId = null, studentId = null, metadata = {}) {
            if (!supabaseClient || !currentUser) {
                log.debug('Cannot log access: No Supabase client or user');
                return;
            }
            try {
                let accessPurpose = '';
                let educationalInterest = '';
                if (userTier === 'instructor') {
                    accessPurpose = 'Grading and evaluation purposes';
                    educationalInterest = 'Instructor needs access to evaluate student performance and provide feedback';
                } else if (userTier === 'admin') {
                    accessPurpose = 'Department-wide analytics and oversight';
                    educationalInterest = 'Administrator needs access for department-wide analytics and oversight';
                } else if (userTier === 'super_admin') {
                    accessPurpose = 'System administration and LLM training data preparation';
                    educationalInterest = 'System administrator needs access for system maintenance and LLM training data preparation';
                } else {
                    accessPurpose = 'Educational purposes';
                    educationalInterest = 'Access required for educational purposes';
                }
                let clientIP = null;
                try {
                    const response = await fetch('https://api.ipify.org?format=json');
                    const data = await response.json();
                    clientIP = data.ip;
                } catch (e) {
                    log.debug('Could not detect IP address');
                }
                const auditEntry = {
                    user_id: currentUser.id,
                    action: action,
                    table_name: tableName,
                    record_id: recordId,
                    student_id: studentId,
                    access_purpose: accessPurpose,
                    educational_interest_justification: educationalInterest,
                    ip_address: clientIP,
                    user_agent: navigator.userAgent,
                    metadata: metadata
                };
                const { error } = await supabaseClient
                    .from('audit_logs')
                    .insert([auditEntry]);
                if (error) {
                    log.error('Failed to log access:', error);
                } else {
                    log.debug('✓ Logged ' + action + ' access to ' + tableName);
                }
            } catch (error) {
                log.error('Error in logAccess:', error);
            }
        }
        
        // ===== LLM TRAINING DATA COLLECTION =====
        // Captures AI interactions for training a multi-task SpeechGradebook LLM
        
        /**
         * Log an AI interaction for potential training use.
         * This captures the input, AI output, and (later) any user corrections.
         * 
         * @param {string} taskType - 'rubric_extraction', 'evaluation', 'video_analysis', 'transcription'
         * @param {Object} inputData - The input sent to the AI
         * @param {Object} aiOutput - What the AI generated
         * @param {string} aiProvider - 'gemini', 'claude', 'gpt4o'
         * @param {string} aiModel - Specific model name
         * @param {number} processingTimeMs - How long the request took
         * @returns {string|null} - The interaction ID (for later updating with corrections)
         */
        async function logLLMInteraction(taskType, inputData, aiOutput, aiProvider, aiModel, processingTimeMs = null) {
            if (!supabaseClient || !currentUser) {
                console.log('Cannot log LLM interaction: No Supabase client or user');
                return null;
            }
            
            // Check if user has given consent for training data
            const consentGiven = await hasLLMTrainingConsent();
            
            try {
                const { data, error } = await supabaseClient
                    .from('llm_training_interactions')
                    .insert([{
                        task_type: taskType,
                        user_id: currentUser.id,
                        institution_id: currentUser.institution_id || null,
                        input_data: inputData,
                        ai_output: aiOutput,
                        ai_provider: aiProvider,
                        ai_model: aiModel,
                        processing_time_ms: processingTimeMs,
                        consent_given: consentGiven,
                        was_modified: false
                    }])
                    .select('id')
                    .single();
                
                if (error) {
                    // Table might not exist yet - that's okay
                    if (error.code === '42P01') {
                        console.log('llm_training_interactions table not yet created');
                        return null;
                    }
                    console.error('Failed to log LLM interaction:', error);
                    return null;
                }
                
                console.log('✓ Logged LLM interaction:', taskType, data.id);
                return data.id;
            } catch (error) {
                console.error('Error logging LLM interaction:', error);
                return null;
            }
        }
        
        /**
         * Update an LLM interaction with user's final corrected output.
         * Call this when user saves after editing AI-generated content.
         * 
         * @param {string} interactionId - The interaction ID from logLLMInteraction
         * @param {Object} userFinalOutput - The user's corrected/edited version
         */
        async function updateLLMInteractionWithCorrection(interactionId, userFinalOutput) {
            if (!supabaseClient || !interactionId) return;
            
            try {
                const { error } = await supabaseClient
                    .from('llm_training_interactions')
                    .update({
                        user_final_output: userFinalOutput,
                        was_modified: true,
                        modified_at: new Date().toISOString()
                    })
                    .eq('id', interactionId);
                
                if (error) {
                    console.error('Failed to update LLM interaction:', error);
                } else {
                    console.log('✓ Updated LLM interaction with user correction');
                }
            } catch (error) {
                console.error('Error updating LLM interaction:', error);
            }
        }
        
        /**
         * Add feedback to an LLM interaction.
         * 
         * @param {string} interactionId - The interaction ID
         * @param {string} thumbs - 'up' or 'down'
         * @param {number} rating - 1-5 rating (optional)
         * @param {string} comment - User comment (optional)
         */
        async function addLLMInteractionFeedback(interactionId, thumbs = null, rating = null, comment = null) {
            if (!supabaseClient || !interactionId) return;
            
            try {
                const updates = { modified_at: new Date().toISOString() };
                if (thumbs) updates.feedback_thumbs = thumbs;
                if (rating) updates.feedback_rating = rating;
                if (comment) updates.feedback_comment = comment;
                
                const { error } = await supabaseClient
                    .from('llm_training_interactions')
                    .update(updates)
                    .eq('id', interactionId);
                
                if (error) {
                    console.error('Failed to add feedback:', error);
                }
            } catch (error) {
                console.error('Error adding feedback:', error);
            }
        }
        
        /**
         * Check if user has consented to LLM training data use.
         * This checks both the instructor_llm_training_consent field and consent_forms.
         */
        async function hasLLMTrainingConsent() {
            if (!supabaseClient || !currentUser) return false;
            
            try {
                // Check instructor consent flag
                if (currentUser.instructor_llm_training_consent === true) {
                    return true;
                }
                
                // Check consent_forms table for explicit LLM consent
                const { data, error } = await supabaseClient
                    .from('consent_forms')
                    .select('consent_given')
                    .eq('user_id', currentUser.id)
                    .eq('consent_type', 'llm_training')
                    .eq('consent_given', true)
                    .limit(1);
                
                if (!error && data && data.length > 0) {
                    return true;
                }
                
                return false;
            } catch (error) {
                console.error('Error checking LLM consent:', error);
                return false;
            }
        }
        
        // Track the current LLM interaction ID for rubric extraction
        let currentRubricExtractionInteractionId = null;
        
        /**
         * Show a quick feedback widget for AI-generated content.
         * Returns a promise that resolves when user provides feedback or dismisses.
         * 
         * @param {string} interactionId - The LLM interaction ID
         * @param {string} context - What the feedback is for (shown in UI)
         * @param {HTMLElement} container - Where to show the widget
         */
        function showAIFeedbackWidget(interactionId, context, container) {
            if (!interactionId || !container) return;
            
            const widget = document.createElement('div');
            widget.className = 'ai-feedback-widget';
            widget.style.cssText = 'display: flex; align-items: center; gap: 0.75rem; padding: 0.75rem 1rem; background: var(--bg-alt); border-radius: 0.5rem; margin-top: 1rem; font-size: 0.85rem;';
            widget.innerHTML = `
                <span style="color: var(--text-light);">Was this ${escapeHtml(context)} helpful?</span>
                <button type="button" class="feedback-btn" data-feedback="up" style="padding: 0.25rem 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; background: var(--bg); cursor: pointer;" title="Good result"><i data-lucide="thumbs-up" style="width:1rem;height:1rem;"></i></button>
                <button type="button" class="feedback-btn" data-feedback="down" style="padding: 0.25rem 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; background: var(--bg); cursor: pointer;" title="Needs improvement"><i data-lucide="thumbs-down" style="width:1rem;height:1rem;"></i></button>
                <button type="button" class="feedback-dismiss" style="margin-left: auto; padding: 0.25rem 0.5rem; border: none; background: none; color: var(--text-light); cursor: pointer; font-size: 0.8rem;">Dismiss</button>
            `;
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: widget });
            
            // Handle feedback clicks
            widget.querySelectorAll('.feedback-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    const feedback = btn.dataset.feedback;
                    await addLLMInteractionFeedback(interactionId, feedback);
                    
                    // Visual confirmation
                    widget.innerHTML = `<span style="color: var(--success);"><i data-lucide="check" style="width:1rem;height:1rem;vertical-align:middle;"></i> Thanks for your feedback!</span>`;
                    if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: widget });
                    setTimeout(() => widget.remove(), 2000);
                });
            });
            
            // Handle dismiss
            widget.querySelector('.feedback-dismiss').addEventListener('click', () => {
                widget.remove();
            });
            
            container.appendChild(widget);
        }
        
        // Phase 4: Test RLS policies (courses, evaluations visibility by role)
        async function testRLSPolicies() {
            if (!supabaseClient || !currentUser) {
                alert('Cannot test: Not logged in.');
                return;
            }
            const results = { canViewOwnCourses: false, canViewOwnEvaluations: false, cannotViewOtherCourses: true, cannotViewOtherEvaluations: true };
            try {
                // Courses: instructors must see at least one course they teach; admins/super_admins must see at least one course (any they are allowed to see)
                if (userTier === 'instructor') {
                    const { data: ownCourses, error: e1 } = await supabaseClient.from('courses').select('id, name').eq('instructor_id', currentUser.id).limit(1);
                    results.canViewOwnCourses = !e1 && ownCourses && ownCourses.length > 0;
                } else {
                    const { data: anyCourses, error: e1 } = await supabaseClient.from('courses').select('id, name').limit(1);
                    results.canViewOwnCourses = !e1 && anyCourses && anyCourses.length > 0;
                }
                const { data: ownEvals, error: e2 } = await supabaseClient.from('evaluations').select('id').eq('instructor_id', currentUser.id).limit(1);
                // Pass if query ran without RLS error; empty result is OK (e.g. admin with no evaluations yet)
                results.canViewOwnEvaluations = !e2;
                if (userTier === 'instructor') {
                    const { data: otherCourses } = await supabaseClient.from('courses').select('id, name, instructor_id').neq('instructor_id', currentUser.id).limit(1);
                    results.cannotViewOtherCourses = !otherCourses || otherCourses.length === 0;
                    const { data: otherEvals } = await supabaseClient.from('evaluations').select('id').neq('instructor_id', currentUser.id).limit(1);
                    results.cannotViewOtherEvaluations = !otherEvals || otherEvals.length === 0;
                }
                const ok = results.canViewOwnCourses && results.canViewOwnEvaluations && results.cannotViewOtherCourses && results.cannotViewOtherEvaluations;
                console.log('RLS Policy Test Results:', results);
                alert('RLS Test Results:\n' + JSON.stringify(results, null, 2) + '\n\n' + (ok ? 'All checks passed.' : 'Review failed checks.'));
            } catch (err) {
                log.error('Error testing RLS:', err);
                alert('Error testing RLS: ' + (err && err.message ? err.message : String(err)));
            }
        }
        
        // Phase 4: Verify audit logs (recent entries for current user; may require RLS allowing read)
        async function verifyAuditLogs() {
            if (!supabaseClient || !currentUser) {
                alert('Cannot verify: Not logged in.');
                return;
            }
            try {
                const { data, error } = await supabaseClient
                    .from('audit_logs')
                    .select('id, action, table_name, created_at')
                    .eq('user_id', currentUser.id)
                    .order('created_at', { ascending: false })
                    .limit(10);
                if (error) {
                    alert('Audit logs: Could not read (RLS may restrict read).\n\nCheck Supabase Dashboard → Table Editor → audit_logs to verify entries after you load/save evaluations.');
                    return;
                }
                const count = (data || []).length;
                const msg = count === 0
                    ? 'No recent audit entries for your user. Perform an action (e.g. load courses, view evaluations, save an evaluation) then try again.'
                    : 'Recent audit entries for you: ' + count + '\n\nLast: ' + (data[0] ? data[0].action + ' on ' + data[0].table_name + ' at ' + (data[0].created_at || '').slice(0, 19) : '—') + '\n\nFull list in browser console.';
                console.log('Recent audit_logs for current user:', data);
                alert(msg);
            } catch (err) {
                log.error('Error verifying audit logs:', err);
                alert('Error: ' + (err && err.message ? err.message : String(err)));
            }
        }
        
        // User-scoped localStorage helpers
        // These ensure each user's data is isolated
        function getUserStorageKey(key) {
            if (!currentUser || !currentUser.id) {
                return `guest_${key}`; // Fallback for non-logged-in users
            }
            return `user_${currentUser.id}_${key}`;
        }
        
        function getUserItem(key) {
            return localStorage.getItem(getUserStorageKey(key));
        }
        
        function setUserItem(key, value) {
            return localStorage.setItem(getUserStorageKey(key), value);
        }
        
        function removeUserItem(key) {
            return localStorage.removeItem(getUserStorageKey(key));
        }
        
        /** Persist locally-deleted IDs so they stay hidden after logout/login (user-scoped). */
        function getDeletedIds(key) {
            try {
                const raw = getUserItem(key);
                return raw ? JSON.parse(raw) : [];
            } catch (e) { return []; }
        }
        function addDeletedId(key, id) {
            const ids = getDeletedIds(key);
            if (id != null && id !== '' && !ids.includes(id)) {
                ids.push(id);
                setUserItem(key, JSON.stringify(ids));
            }
        }
        function isDeletedId(key, id) {
            return id != null && id !== '' && getDeletedIds(key).includes(String(id));
        }
        /** Remove an id from the locally-deleted list so the item can reappear (for undo). */
        function removeDeletedId(key, id) {
            const ids = getDeletedIds(key);
            const str = String(id);
            const idx = ids.indexOf(str);
            if (idx !== -1) {
                ids.splice(idx, 1);
                setUserItem(key, JSON.stringify(ids));
            }
        }
        
        // Switch view mode (admin and super admin only)
        function switchViewMode(mode) {
            if (!canManageUsers()) {
                alert('Only administrators can switch views');
                return;
            }
            
            log.debug('=== SWITCHING VIEW MODE ===');
            log.debug('From:', currentViewMode);
            log.debug('To:', mode);
            log.debug('User tier:', userTier);
            log.debug('Institution:', currentInstitution?.name);
            
            currentViewMode = mode;
            
            // Save preference
            localStorage.setItem('adminViewMode', mode);
            
            log.debug('✓ View mode updated to:', currentViewMode);
            
            // Update UI based on mode
            updateViewMode();
            
            // Show notification
            const modeNames = {
                'own': 'My Courses',
                'institution': 'Institution View',
                'all': 'All Institutions',
                'demo': 'Demo Mode'
            };
            showNotification(`Switched to ${modeNames[mode]}`, 'success');
            
            log.debug('=== VIEW MODE SWITCH COMPLETE ===');
        }
        
        // Update UI based on current view mode
        function updateViewMode() {
            // Remove any existing mode banner
            const existingBanner = document.getElementById('viewModeBanner');
            if (existingBanner) {
                existingBanner.remove();
            }
            
            // Add mode banner for non-default views
            const header = document.querySelector('header .container');
            if (header && currentViewMode !== 'own') {
                const banner = document.createElement('div');
                banner.id = 'viewModeBanner';
                banner.style.cssText = 'background: var(--primary); color: white; padding: 0.75rem; text-align: center; font-weight: 600; border-radius: 0.5rem; margin-top: 0.5rem;';
                
                const modeInfo = {
                    'demo': 'DEMO MODE — Testing functionality (localStorage only, no database)',
                    'institution': `INSTITUTION VIEW — Viewing all courses at ${currentInstitution?.name || 'your institution'}`,
                    'all': 'ALL INSTITUTIONS — System-wide view (Super Admin)'
                };
                
                banner.innerHTML = modeInfo[currentViewMode] || '';
                header.appendChild(banner);
            }
            
            // Reload data for current view
            loadClasses();
        }
        
        // ===== FILTER HANDLER FUNCTIONS (PHASE 2) =====
        
        // Super Admin Filter Handlers
        function onInstitutionFilterChange() {
            const value = document.getElementById('filterInstitution')?.value;
            log.debug('🔍 Institution filter changed:', value || 'All Institutions');
            
            // PHASE 5: Reload instructors for selected institution
            loadInstructorsForFilter(value);
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForSuperAdmin();
        }
        
        function onInstructorFilterChange() {
            const value = document.getElementById('filterInstructor')?.value;
            log.debug('🔍 Instructor filter changed:', value || 'All Instructors');
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForSuperAdmin();
        }
        
        function onYearFilterChange() {
            const value = document.getElementById('filterYear')?.value;
            log.debug('🔍 Year filter changed:', value || 'All Years');
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForSuperAdmin();
        }
        
        function onSemesterFilterChange() {
            const value = document.getElementById('filterSemester')?.value;
            log.debug('🔍 Semester filter changed:', value || 'All Semesters');
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForSuperAdmin();
        }
        
        function onModalityFilterChange() {
            const value = document.getElementById('filterModality')?.value;
            log.debug('🔍 Modality filter changed:', value || 'All Modalities');
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForSuperAdmin();
        }
        
        function onSearchFilterChange() {
            const value = document.getElementById('filterSearch')?.value;
            log.debug('🔍 Search filter changed:', value || '(empty)');
            
            // PHASE 5: Reload courses with new filter (with debounce would be better, but simple for now)
            loadFilteredCoursesForSuperAdmin();
        }
        
        function clearAllFilters() {
            log.debug('🧹 Clearing all super admin filters');
            const fi = document.getElementById('filterInstitution');
            if (fi) fi.value = '';
            const fInstr = document.getElementById('filterInstructor');
            if (fInstr) fInstr.value = '';
            const fy = document.getElementById('filterYear');
            if (fy) fy.value = '';
            const fs = document.getElementById('filterSemester');
            if (fs) fs.value = '';
            const fm = document.getElementById('filterModality');
            if (fm) fm.value = '';
            const fSearch = document.getElementById('filterSearch');
            if (fSearch) fSearch.value = '';
            
            // PHASE 5: Reset instructor dropdown and reload all instructors
            loadInstructorsForFilter('');
            
            // PHASE 5: Reload courses without filters
            loadFilteredCoursesForSuperAdmin();
        }
        
        // Admin Filter Handlers
        function onAdminInstructorFilterChange() {
            const value = document.getElementById('adminFilterInstructor')?.value;
            log.debug('🔍 Admin instructor filter changed:', value || 'All Instructors');
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForAdmin();
        }
        
        function onAdminYearFilterChange() {
            const value = document.getElementById('adminFilterYear')?.value;
            log.debug('🔍 Admin year filter changed:', value || 'All Years');
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForAdmin();
        }
        
        function onAdminSemesterFilterChange() {
            const value = document.getElementById('adminFilterSemester')?.value;
            log.debug('🔍 Admin semester filter changed:', value || 'All Semesters');
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForAdmin();
        }
        
        function onAdminModalityFilterChange() {
            const value = document.getElementById('adminFilterModality')?.value;
            log.debug('🔍 Admin modality filter changed:', value || 'All Modalities');
            
            // PHASE 5: Reload courses with new filter
            loadFilteredCoursesForAdmin();
        }
        
        function clearAdminFilters() {
            log.debug('🧹 Clearing admin filters');
            const ai = document.getElementById('adminFilterInstructor');
            if (ai) ai.value = '';
            const ay = document.getElementById('adminFilterYear');
            if (ay) ay.value = '';
            const as = document.getElementById('adminFilterSemester');
            if (as) as.value = '';
            const am = document.getElementById('adminFilterModality');
            if (am) am.value = '';
            
            // PHASE 5: Reload all courses
            loadFilteredCoursesForAdmin();
        }
        
        /** Current term: Fall (Aug–Dec), Spring (Jan–May), Summer (Jun–Jul). Returns { semester, year }. */
        function getCurrentSemesterYear() {
            const d = new Date();
            const month = d.getMonth() + 1;
            const year = d.getFullYear().toString();
            if (month >= 8) return { semester: 'Fall', year };
            if (month >= 6) return { semester: 'Summer', year };
            return { semester: 'Spring', year };
        }
        /** Instructor courses tab: 'current', 'previous', or custom tab ID */
        var _coursesViewTab = 'current';
        /** Custom tabs storage */
        function getCustomTabs() {
            try {
                const stored = getUserItem('customCourseTabs');
                return stored ? JSON.parse(stored) : [];
            } catch (e) {
                return [];
            }
        }
        function saveCustomTabs(tabs) {
            setUserItem('customCourseTabs', JSON.stringify(tabs));
        }
        /** Course-to-tab assignments */
        function getCourseTabAssignments() {
            try {
                const stored = getUserItem('courseTabAssignments');
                return stored ? JSON.parse(stored) : {};
            } catch (e) {
                return {};
            }
        }
        function saveCourseTabAssignments(assignments) {
            setUserItem('courseTabAssignments', JSON.stringify(assignments));
        }
        function assignCourseToTab(courseId, tabId) {
            const assignments = getCourseTabAssignments();
            if (tabId === 'current' || tabId === 'previous') {
                // Remove assignment for default tabs (they use automatic logic)
                delete assignments[courseId];
            } else {
                assignments[courseId] = tabId;
            }
            saveCourseTabAssignments(assignments);
        }
        function getCourseTab(courseId) {
            const assignments = getCourseTabAssignments();
            return assignments[courseId] || null;
        }
        /** Cache for rendered course grids to avoid re-rendering on tab switch */
        var _coursesGridCache = {
            current: { html: null, dataHash: null },
            previous: { html: null, dataHash: null }
        };
        /** Generate a simple hash of course data for cache invalidation */
        function hashCoursesData(courses) {
            if (!courses || courses.length === 0) return 'empty';
            if (Array.isArray(courses) && courses[0] && typeof courses[0].label === 'string') {
                // Grouped format
                return courses.map(g => g.label + ':' + (g.courses || []).map(c => c.id).join(',')).join('|');
            }
            return courses.map(c => c.id).join(',');
        }
        function getInstructorFilteredClasses() {
            const courseId = document.getElementById('instructorFilterCourse')?.value || '';
            const semester = document.getElementById('instructorFilterSemester')?.value || '';
            const year = document.getElementById('instructorFilterYear')?.value || '';
            return (_instructorCoursesAll || []).filter(cls => {
                if (courseId && cls.id !== courseId) return false;
                if (semester && (cls.semester || '') !== semester) return false;
                if (year && (cls.year || '').toString() !== year) return false;
                return true;
            });
        }
        /** For instructor: filter by Current tab (current term only), Previous (grouped by semester/year), or custom tab. */
        function getCoursesForCurrentTab() {
            const filtered = getInstructorFilteredClasses();
            const current = getCurrentSemesterYear();
            const assignments = getCourseTabAssignments();
            const customTabs = getCustomTabs();
            
            // Custom tab
            if (_coursesViewTab !== 'current' && _coursesViewTab !== 'previous') {
                const customTab = customTabs.find(t => t.id === _coursesViewTab);
                if (customTab) {
                    // Get courses assigned to this custom tab
                    const assignedCourseIds = Object.keys(assignments).filter(cid => assignments[cid] === _coursesViewTab);
                    const customTabCourses = filtered.filter(cls => assignedCourseIds.includes(cls.id));
                    return customTabCourses;
                }
            }
            
            // Current tab: current term courses that aren't assigned to custom tabs
            if (_coursesViewTab === 'current') {
                return filtered.filter(cls => {
                    const courseTab = getCourseTab(cls.id);
                    // Only show if not assigned to a custom tab
                    if (courseTab && courseTab !== 'current' && courseTab !== 'previous') return false;
                    return (cls.semester || '') === current.semester && (cls.year || '').toString() === current.year;
                });
            }
            
            // Previous tab: non-current term courses that aren't assigned to custom tabs
            const previous = filtered.filter(cls => {
                const courseTab = getCourseTab(cls.id);
                // Only show if not assigned to a custom tab
                if (courseTab && courseTab !== 'current' && courseTab !== 'previous') return false;
                return (cls.semester || '') !== current.semester || (cls.year || '').toString() !== current.year;
            });
            const byTerm = {};
            previous.forEach(cls => {
                const label = (cls.semester || '') + ' ' + (cls.year || '').toString();
                if (!byTerm[label]) byTerm[label] = [];
                byTerm[label].push(cls);
            });
            const order = { Fall: 0, Summer: 1, Spring: 2 };
            return Object.keys(byTerm).sort((a, b) => {
                const [semA, yearA] = a.split(' ');
                const [semB, yearB] = b.split(' ');
                if (yearB !== yearA) return parseInt(yearB, 10) - parseInt(yearA, 10);
                return (order[semB] || 0) - (order[semA] || 0);
            }).map(label => ({ label, courses: byTerm[label] }));
        }
        function populateInstructorFilterDropdowns(classes) {
            const sel = document.getElementById('instructorFilterCourse');
            if (!sel) return;
            const courseId = sel.value;
            sel.innerHTML = '<option value="">All Courses</option>' + (classes || []).map(cls =>
                '<option value="' + escapeHtml(cls.id) + '">' + escapeHtml(cls.name) + '</option>'
            ).join('');
            if (courseId) sel.value = courseId;
        }
        /** Helper to attach event listeners to course cards */
        function attachCourseCardListeners(container) {
            if (!container) return;
            container.querySelectorAll('.class-card').forEach(card => {
                card.addEventListener('click', async function(e) {
                    // Don't navigate if clicking on the menu button or menu
                    if (e.target.closest('.course-actions-menu-trigger') || e.target.closest('.course-actions-menu')) {
                        return;
                    }
                    const classId = this.getAttribute('data-class-id');
                    await viewClass(classId);
                });
            });
            // Initialize icons in course cards
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons({ root: container });
            }
        }
        /** Switch to a specific tab */
        function switchToTab(tabId) {
            _coursesViewTab = tabId;
            
            // Update tab button states
            const tabCurrent = document.getElementById('coursesTabCurrent');
            const tabPrevious = document.getElementById('coursesTabPrevious');
            const customTabs = getCustomTabs();
            
            // Remove active from all tabs
            if (tabCurrent) tabCurrent.classList.remove('instructor-dashboard-tab-active');
            if (tabPrevious) tabPrevious.classList.remove('instructor-dashboard-tab-active');
            document.querySelectorAll('.custom-tab-btn').forEach(btn => btn.classList.remove('instructor-dashboard-tab-active'));
            
            // Add active to selected tab
            if (tabId === 'current' && tabCurrent) {
                tabCurrent.classList.add('instructor-dashboard-tab-active');
            } else if (tabId === 'previous' && tabPrevious) {
                tabPrevious.classList.add('instructor-dashboard-tab-active');
            } else {
                const customTabBtn = document.querySelector(`.custom-tab-btn[data-tab-id="${tabId}"]`);
                if (customTabBtn) customTabBtn.classList.add('instructor-dashboard-tab-active');
            }
            
            // Use requestAnimationFrame for smoother transition
            requestAnimationFrame(() => {
                if (typeof applyInstructorFilters === 'function') applyInstructorFilters();
            });
        }
        
        /** Render custom tabs in the UI */
        function renderCustomTabs() {
            const container = document.getElementById('customTabsContainer');
            if (!container) return;
            
            const customTabs = getCustomTabs();
            container.innerHTML = customTabs.map(tab => {
                const isActive = _coursesViewTab === tab.id;
                return `<button type="button" class="custom-tab-btn instructor-dashboard-tab ${isActive ? 'instructor-dashboard-tab-active' : ''}" data-tab-id="${tab.id}" onclick="switchToTab('${tab.id}')" style="margin-right: 0.5rem;">${escapeHtml(tab.name)}</button>`;
            }).join('');
            
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons({ root: container });
            }
        }
        
        // Helper function to apply tab filtering to a list of courses
        function applyTabFilteringToCourses(courses) {
            const current = getCurrentSemesterYear();
            const assignments = getCourseTabAssignments();
            const customTabs = getCustomTabs();
            
            // Custom tab
            if (_coursesViewTab !== 'current' && _coursesViewTab !== 'previous') {
                const customTab = customTabs.find(t => t.id === _coursesViewTab);
                if (customTab) {
                    const assignedCourseIds = Object.keys(assignments).filter(cid => assignments[cid] === _coursesViewTab);
                    return courses.filter(cls => assignedCourseIds.includes(cls.id));
                }
            }
            
            // Current tab: current term courses that aren't assigned to custom tabs
            if (_coursesViewTab === 'current') {
                return courses.filter(cls => {
                    const courseTab = getCourseTab(cls.id);
                    if (courseTab && courseTab !== 'current' && courseTab !== 'previous') return false;
                    return (cls.semester || '') === current.semester && (cls.year || '').toString() === current.year;
                });
            }
            
            // Previous tab: non-current term courses that aren't assigned to custom tabs
            const previous = courses.filter(cls => {
                const courseTab = getCourseTab(cls.id);
                if (courseTab && courseTab !== 'current' && courseTab !== 'previous') return false;
                return (cls.semester || '') !== current.semester || (cls.year || '').toString() !== current.year;
            });
            const byTerm = {};
            previous.forEach(cls => {
                const label = (cls.semester || '') + ' ' + (cls.year || '').toString();
                if (!byTerm[label]) byTerm[label] = [];
                byTerm[label].push(cls);
            });
            const order = { Fall: 0, Summer: 1, Spring: 2 };
            return Object.keys(byTerm).sort((a, b) => {
                const [semA, yearA] = a.split(' ');
                const [semB, yearB] = b.split(' ');
                if (yearB !== yearA) return parseInt(yearB, 10) - parseInt(yearA, 10);
                return (order[semB] || 0) - (order[semA] || 0);
            }).map(label => ({ label, courses: byTerm[label] }));
        }
        
        function applyInstructorFilters() {
            // Step 1: Get courses with dropdown filters applied (but not tab filters yet)
            let courses = getInstructorFilteredClasses();
            
            // Step 2: Check if search is active
            const unifiedSearchInput = document.getElementById('unifiedSearchInput');
            const isCoursesTab = document.getElementById('instructorTabBtnCourses')?.classList.contains('instructor-dashboard-tab-active');
            const hasSearchTerm = unifiedSearchInput && unifiedSearchInput.value.trim() && isCoursesTab;
            
            // Step 3: Apply search filter if active (searches across all filtered courses, regardless of tab)
            if (hasSearchTerm) {
                const searchTerm = unifiedSearchInput.value.toLowerCase().trim();
                courses = courses.filter(course => {
                    const name = (course.name || '').toLowerCase();
                    const code = (course.section || '').toLowerCase();
                    const semester = (course.semester || '').toLowerCase();
                    const year = (course.year || '').toString().toLowerCase();
                    const instructor = (course.instructor_name || '').toLowerCase();
                    return name.includes(searchTerm) || 
                           code.includes(searchTerm) || 
                           semester.includes(searchTerm) || 
                           year.includes(searchTerm) ||
                           instructor.includes(searchTerm);
                });
            }
            
            // Step 4: Apply tab filtering ONLY if there's no active search
            // When searching, show results from all tabs (grouped by tab if needed)
            if (!hasSearchTerm) {
                // No search: apply normal tab filtering
                courses = applyTabFilteringToCourses(courses);
            } else {
                // Search active: show all matching courses, but organize them by tab for display
                // Group search results by their tab (Current vs Previous) for better UX
                const current = getCurrentSemesterYear();
                const currentTermCourses = courses.filter(cls => {
                    const courseTab = getCourseTab(cls.id);
                    if (courseTab && courseTab !== 'current' && courseTab !== 'previous') return false;
                    return (cls.semester || '') === current.semester && (cls.year || '').toString() === current.year;
                });
                const previousTermCourses = courses.filter(cls => {
                    const courseTab = getCourseTab(cls.id);
                    if (courseTab && courseTab !== 'current' && courseTab !== 'previous') return false;
                    return (cls.semester || '') !== current.semester || (cls.year || '').toString() !== current.year;
                });
                
                // If we have courses from both tabs, organize them
                if (currentTermCourses.length > 0 && previousTermCourses.length > 0) {
                    // Group previous courses by term
                    const byTerm = {};
                    previousTermCourses.forEach(cls => {
                        const label = (cls.semester || '') + ' ' + (cls.year || '').toString();
                        if (!byTerm[label]) byTerm[label] = [];
                        byTerm[label].push(cls);
                    });
                    const order = { Fall: 0, Summer: 1, Spring: 2 };
                    const previousGroups = Object.keys(byTerm).sort((a, b) => {
                        const [semA, yearA] = a.split(' ');
                        const [semB, yearB] = b.split(' ');
                        if (yearB !== yearA) return parseInt(yearB, 10) - parseInt(yearA, 10);
                        return (order[semB] || 0) - (order[semA] || 0);
                    }).map(label => ({ label, courses: byTerm[label] }));
                    
                    // Return structure: current courses first, then previous grouped by term
                    courses = [{ label: 'Current', courses: currentTermCourses }, ...previousGroups];
                } else if (currentTermCourses.length > 0) {
                    // Only current courses
                    courses = currentTermCourses;
                } else if (previousTermCourses.length > 0) {
                    // Only previous courses - group by term
                    const byTerm = {};
                    previousTermCourses.forEach(cls => {
                        const label = (cls.semester || '') + ' ' + (cls.year || '').toString();
                        if (!byTerm[label]) byTerm[label] = [];
                        byTerm[label].push(cls);
                    });
                    const order = { Fall: 0, Summer: 1, Spring: 2 };
                    courses = Object.keys(byTerm).sort((a, b) => {
                        const [semA, yearA] = a.split(' ');
                        const [semB, yearB] = b.split(' ');
                        if (yearB !== yearA) return parseInt(yearB, 10) - parseInt(yearA, 10);
                        return (order[semB] || 0) - (order[semA] || 0);
                    }).map(label => ({ label, courses: byTerm[label] }));
                }
            }
            
            const cacheKey = _coursesViewTab;
            const dataHash = hashCoursesData(courses);
            
            // Initialize cache for custom tabs if needed
            if (!_coursesGridCache[cacheKey]) {
                _coursesGridCache[cacheKey] = { html: null, dataHash: null };
            }
            
            // Check if we have cached HTML for this tab and data hasn't changed
            // Skip cache if search is active (search results should be fresh)
            if (!unifiedSearchInput || !unifiedSearchInput.value.trim() || !isCoursesTab) {
                if (_coursesGridCache[cacheKey] && _coursesGridCache[cacheKey].dataHash === dataHash && _coursesGridCache[cacheKey].html) {
                    const grid = document.getElementById('classesGrid');
                    if (grid) {
                        grid.innerHTML = _coursesGridCache[cacheKey].html;
                        // Re-attach listeners (they're lost when innerHTML is set)
                        attachCourseCardListeners(grid);
                        return; // Use cached version, skip re-rendering
                    }
                }
            }
            
            // No cache hit, render fresh
            if (typeof renderInstructorCoursesGrid === 'function') renderInstructorCoursesGrid(courses);
        }
        
        // Unified search handler (context-aware)
        function handleUnifiedSearch(query) {
            const unifiedSearchInput = document.getElementById('unifiedSearchInput');
            if (!unifiedSearchInput) return;
            
            const searchValue = query !== undefined ? query : unifiedSearchInput.value;
            
            // Determine which tab is active
            const isCoursesTab = document.getElementById('instructorTabBtnCourses')?.classList.contains('instructor-dashboard-tab-active');
            const isRubricsTab = document.getElementById('instructorTabBtnRubrics')?.classList.contains('instructor-dashboard-tab-active');
            const isInsightsTab = document.getElementById('instructorTabBtnInsights')?.classList.contains('instructor-dashboard-tab-active');
            
            if (isCoursesTab) {
                // Search courses
            applyInstructorFilters();
            } else if (isRubricsTab) {
                // Search rubrics (if rubrics search is implemented)
                // For now, just trigger a re-render if needed
                if (typeof filterRubricsBySearch === 'function') {
                    filterRubricsBySearch(searchValue);
                }
            } else if (isInsightsTab) {
                // Search insights/analytics
                // Ensure currentAnalyticsTabId is initialized (defaults to 'overview' if not set)
                const activeTabId = typeof currentAnalyticsTabId !== 'undefined' && currentAnalyticsTabId ? currentAnalyticsTabId : 'overview';
                const isEvaluationsTab = activeTabId === 'evaluations';
                
                // If there's a search term and we're not on Evaluations tab, switch to it
                if (searchValue && searchValue.trim() && !isEvaluationsTab) {
                    // Switch to Evaluations tab to show search results
                    if (typeof switchAnalyticsTab === 'function') {
                        switchAnalyticsTab('evaluations');
                        // Wait a moment for tab switch and currentAnalyticsTabId to be set, then apply search
                        setTimeout(() => {
                            const hasData = typeof analyticsData !== 'undefined' && analyticsData.evaluations && analyticsData.evaluations.length > 0;
                            if (!hasData && typeof loadEnhancedAnalytics === 'function') {
                                loadEnhancedAnalytics(false).then(() => {
                                    if (typeof renderEvaluationsTab === 'function') {
                                        renderEvaluationsTab();
                                    }
                                });
                            } else if (typeof renderEvaluationsTab === 'function') {
                                renderEvaluationsTab();
                            }
                        }, 200);
                        return; // Exit early, search will be applied after tab switch
                    }
                }
                
                if (isEvaluationsTab) {
                    // Ensure analytics data is loaded before searching
                    const hasData = typeof analyticsData !== 'undefined' && analyticsData.evaluations && analyticsData.evaluations.length > 0;
                    if (!hasData && typeof loadEnhancedAnalytics === 'function') {
                        // Load analytics first, then apply search
                        loadEnhancedAnalytics(false).then(() => {
                            if (typeof renderEvaluationsTab === 'function') {
                                renderEvaluationsTab();
                            }
                        });
                    } else {
                        // Trigger re-render of evaluations tab with search filter
                        // This will apply the search filter inside renderEvaluationsTab()
                        if (typeof renderEvaluationsTab === 'function') {
                            renderEvaluationsTab();
                        }
                    }
                } else if (!searchValue || !searchValue.trim()) {
                    // Only auto-load analytics if there's no search term
                    // For other tabs (overview, etc.), ensure analytics are loaded
                    const hasData = typeof analyticsData !== 'undefined' && analyticsData.evaluations && analyticsData.evaluations.length > 0;
                    if (!hasData && typeof loadEnhancedAnalytics === 'function') {
                        loadEnhancedAnalytics(false);
                    }
                }
            }
            
            // Update search icon
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons({ root: unifiedSearchInput.parentElement });
            }
        }
        
        // Toggle instructor filters function removed - filters are now always visible in compact toolbar
        
        // Filter rubrics by search query
        async function filterRubricsBySearch(query) {
            const searchTerm = (query || '').trim().toLowerCase();
            const list = document.getElementById('rubricsList');
            if (!list) return;
            
            // Get all rubrics
            let allRubrics = await getAllRubrics();
            if (!Array.isArray(allRubrics)) allRubrics = [];
            
            // Filter rubrics if search term exists
            let filteredRubrics = allRubrics;
            if (searchTerm) {
                const classes = JSON.parse(getUserItem('classes') || '[]');
                filteredRubrics = allRubrics.filter(rubric => {
                    const name = (rubric.name || '').toLowerCase();
                    const description = (rubric.description || '').toLowerCase();
                    const speechType = (rubric.speechType || '').toLowerCase();
                    
                    // Check if search term matches rubric properties
                    if (name.includes(searchTerm) || description.includes(searchTerm) || speechType.includes(searchTerm)) {
                        return true;
                    }
                    
                    // Check course names
                    let courseIdsToCheck = [];
                    if (rubric.courseIds && Array.isArray(rubric.courseIds)) {
                        courseIdsToCheck = rubric.courseIds;
                    } else if (rubric.courseId) {
                        courseIdsToCheck = [rubric.courseId];
                    }
                    
                    const matchingCourses = courseIdsToCheck
                        .map(id => classes.find(c => c.id === id))
                        .filter(c => c);
                    
                    return matchingCourses.some(course => {
                        const courseName = (course.name || '').toLowerCase();
                        const courseCode = (course.section || '').toLowerCase();
                        return courseName.includes(searchTerm) || courseCode.includes(searchTerm);
                    });
                });
            }
            
            // Re-render filtered rubrics (reuse loadRubrics logic)
            const classes = JSON.parse(getUserItem('classes') || '[]');
            list.innerHTML = filteredRubrics.map(rubric => {
                // Get course info - handle both new courseIds array and old single courseId
                let courseInfo = '';
                let courseIdsToDisplay = [];
                
                if (rubric.courseIds && Array.isArray(rubric.courseIds) && rubric.courseIds.length > 0) {
                    courseIdsToDisplay = rubric.courseIds;
                } else if (rubric.courseId) {
                    courseIdsToDisplay = [rubric.courseId];
                }
                
                if (courseIdsToDisplay.length > 0) {
                    const courses = courseIdsToDisplay
                        .map(id => classes.find(c => c.id === id))
                        .filter(c => c);
                    
                    if (courses.length > 0) {
                        const courseGroups = {};
                        courses.forEach(course => {
                            if (!courseGroups[course.name]) {
                                courseGroups[course.name] = [];
                            }
                            courseGroups[course.name].push(course);
                        });
                        
                        const courseDisplays = Object.keys(courseGroups).map(courseName => {
                            const sections = courseGroups[courseName];
                            const firstCourse = sections[0];
                            const sectionNums = sections.map(s => s.section).join(', ');
                            const sectionText = sections.length > 1 ? `Sections ${sectionNums}` : `Section ${sectionNums}`;
                            return `${courseName} (${firstCourse.semester} ${firstCourse.year}) - ${sectionText}`;
                        });
                        
                        courseInfo = ` • <span style="color: var(--primary); font-weight: 500;">${courseDisplays.join(' • ')}</span>`;
                    } else if (courseIdsToDisplay.length > 0) {
                        courseInfo = ' • <span style="color: #999;">Course(s) not found</span>';
                    }
                }
                
                return `
                <div class="rubric-item">
                    <div class="rubric-info">
                        <h4>${rubric.name}</h4>
                        <p>${rubric.description || 'No description'} • ${rubric.totalPoints} points${rubric.speechType ? ' • ' + rubric.speechType : ''}${courseInfo}</p>
                    </div>
                    <div class="rubric-actions">
                        <button class="btn-small btn-view" data-rubric-id="${rubric.id}">View</button>
                        <button class="btn-small btn-edit" data-rubric-id="${rubric.id}">Edit</button>
                        <button class="btn-small btn-duplicate" data-rubric-id="${rubric.id}">Duplicate</button>
                        ${rubric.id !== 'default' ? `
                            <button type="button" class="btn-small btn-danger btn-delete" data-rubric-id="${rubric.id}" aria-label="Delete rubric" title="Delete rubric"><i data-lucide="trash-2" style="width:1.1em;height:1.1em;"></i></button>
                        ` : ''}
                    </div>
                </div>
            `;
            }).join('');
            
            // Re-attach event listeners
            document.querySelectorAll('.btn-view').forEach(btn => {
                btn.addEventListener('click', () => viewRubric(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-edit').forEach(btn => {
                btn.addEventListener('click', () => editRubric(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-duplicate').forEach(btn => {
                btn.addEventListener('click', () => duplicateRubricUI(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-delete').forEach(btn => {
                btn.addEventListener('click', () => {
                    deleteRubricUI(btn.dataset.rubricId);
                });
            });
            
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: list });
        }
        function onInstructorCourseFilterChange() {
            log.debug('🔍 Instructor course filter changed');
            applyInstructorFilters();
        }
        function onInstructorSemesterFilterChange() {
            log.debug('🔍 Instructor semester filter changed');
            applyInstructorFilters();
        }
        function onInstructorYearFilterChange() {
            log.debug('🔍 Instructor year filter changed');
            applyInstructorFilters();
        }
        function clearInstructorFilters() {
            log.debug('🧹 Clearing instructor filters');
            const ic = document.getElementById('instructorFilterCourse');
            if (ic) ic.value = '';
            const isem = document.getElementById('instructorFilterSemester');
            if (isem) isem.value = '';
            const iy = document.getElementById('instructorFilterYear');
            if (iy) iy.value = '';
            // Clear unified search if on courses tab
            const unifiedSearchInput = document.getElementById('unifiedSearchInput');
            if (unifiedSearchInput && document.getElementById('instructorTabBtnCourses')?.classList.contains('instructor-dashboard-tab-active')) {
                unifiedSearchInput.value = '';
            }
            // Update Lucide icons in the clear button
            const clearBtn = document.querySelector('button[onclick="clearInstructorFilters()"]');
            if (clearBtn && typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons({ root: clearBtn });
            }
            applyInstructorFilters();
        }
        
        // Table Sorting (Phase 4)
        function _sortCourses(courses, column, asc) {
            const key = column === 'semester' ? ['semester', 'year'] : (column === 'students' ? 'student_count' : column === 'evaluations' ? 'evaluation_count' : column === 'instructor' ? 'instructor_name' : column === 'institution' ? 'institution_name' : column === 'name' ? 'name' : column === 'code' ? 'code' : column === 'modality' ? 'modality' : column);
            return (courses || []).slice().sort((a, b) => {
                let va, vb;
                if (Array.isArray(key)) {
                    va = (a[key[0]] || '') + ' ' + (a[key[1]] || '');
                    vb = (b[key[0]] || '') + ' ' + (b[key[1]] || '');
                } else {
                    va = a[key];
                    vb = b[key];
                }
                if (va == null) va = '';
                if (vb == null) vb = '';
                const str = String(va).localeCompare(String(vb), undefined, { numeric: true });
                return asc ? str : -str;
            });
        }
        function sortTableBy(column) {
            _superAdminSortAsc = _superAdminSortColumn === column ? !_superAdminSortAsc : true;
            _superAdminSortColumn = column;
            const sorted = _sortCourses(_superAdminCoursesCache, column, _superAdminSortAsc);
            renderSuperAdminCoursesTable(sorted);
        }
        function sortAdminTableBy(column) {
            _adminSortAsc = _adminSortColumn === column ? !_adminSortAsc : true;
            _adminSortColumn = column;
            const sorted = _sortCourses(_adminCoursesCache, column, _adminSortAsc);
            renderAdminCoursesTable(sorted);
        }
        
        // ===== TABLE RENDERING FUNCTIONS (PHASE 4) =====
        
        /**
         * Render courses in super admin table
         * @param {Array} courses - Array of course objects
         */
        function renderSuperAdminCoursesTable(courses) {
            _superAdminCoursesCache = courses || [];
            log.debug('📊 Rendering super admin table with', _superAdminCoursesCache.length, 'courses');
            
            const table = document.getElementById('coursesTable');
            const tbody = document.getElementById('coursesTableBody');
            const resultsInfo = document.getElementById('filterResultsInfo');
            
            if (!tbody || !table || !resultsInfo) {
                log.error('Table elements not found');
                return;
            }
            
            // Update results info
            if (_superAdminCoursesCache.length === 0) {
                resultsInfo.textContent = 'No courses found matching filters';
                table.style.display = 'none';
                return;
            }
            
            resultsInfo.textContent = `Showing ${_superAdminCoursesCache.length} course${_superAdminCoursesCache.length === 1 ? '' : 's'}`;
            table.style.display = 'table';
            
            // Build table rows
            tbody.innerHTML = _superAdminCoursesCache.map(course => {
                const courseName = escapeHtml(course.name || 'Untitled Course');
                const courseCode = escapeHtml(course.code || course.section || 'N/A');
                const instructorName = escapeHtml(course.instructor_name || 'Unknown');
                const institutionName = escapeHtml(course.institution_name || 'Unknown');
                const semester = escapeHtml(course.semester || 'N/A');
                const year = escapeHtml(course.year || '');
                const semesterYear = `${semester} ${year}`.trim();
                const modality = escapeHtml(course.modality || 'N/A');
                const studentCount = course.student_count || (course.roster ? course.roster.length : 0);
                const evalCount = course.evaluation_count || 0;
                const courseId = escapeHtml(String(course.id || course.supabaseId || ''));
                const deletedTag = formatDeletedLocallyTag(course.deleted_locally_at);
                
                return `
                    <tr>
                        <td><strong>${courseName}</strong>${deletedTag}</td>
                        <td>${courseCode}</td>
                        <td>${instructorName}</td>
                        <td>${institutionName}</td>
                        <td>${semesterYear}</td>
                        <td>${modality}</td>
                        <td>${studentCount}</td>
                        <td>${evalCount}</td>
                        <td>
                            <button onclick="viewCourse('${courseId}')" style="padding: 0.5rem 1rem; background: var(--primary); color: white; border: none; border-radius: 0.25rem; cursor: pointer; font-size: 0.9rem;">
                                View
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');
            
            log.debug('✅ Super admin table rendered');
        }
        
        /**
         * Render courses in admin table
         * @param {Array} courses - Array of course objects
         */
        function renderAdminCoursesTable(courses) {
            _adminCoursesCache = courses || [];
            log.debug('📊 Rendering admin table with', _adminCoursesCache.length, 'courses');
            
            const table = document.getElementById('adminCoursesTable');
            const tbody = document.getElementById('adminCoursesTableBody');
            const resultsInfo = document.getElementById('adminFilterResultsInfo');
            
            if (!tbody || !table || !resultsInfo) {
                log.error('Admin table elements not found');
                return;
            }
            
            if (_adminCoursesCache.length === 0) {
                resultsInfo.textContent = 'No courses found in your department';
                tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; padding: 2rem; color: var(--text-light);">No courses found</td></tr>';
                return;
            }
            
            resultsInfo.textContent = `Showing ${_adminCoursesCache.length} course${_adminCoursesCache.length === 1 ? '' : 's'}`;
            
            tbody.innerHTML = _adminCoursesCache.map(course => {
                const courseName = escapeHtml(course.name || 'Untitled Course');
                const courseCode = escapeHtml(course.code || course.section || 'N/A');
                const instructorName = escapeHtml(course.instructor_name || 'Unknown');
                const semester = escapeHtml(course.semester || 'N/A');
                const year = escapeHtml(course.year || '');
                const semesterYear = `${semester} ${year}`.trim();
                const modality = escapeHtml(course.modality || 'N/A');
                const studentCount = course.student_count || (course.roster ? course.roster.length : 0);
                const evalCount = course.evaluation_count || 0;
                const courseId = escapeHtml(String(course.id || course.supabaseId || ''));
                const deletedTag = formatDeletedLocallyTag(course.deleted_locally_at);
                
                return `
                    <tr>
                        <td><strong>${courseName}</strong>${deletedTag}</td>
                        <td>${courseCode}</td>
                        <td>${instructorName}</td>
                        <td>${semesterYear}</td>
                        <td>${modality}</td>
                        <td>${studentCount}</td>
                        <td>${evalCount}</td>
                        <td>
                            <button onclick="viewCourse('${courseId}')" style="padding: 0.5rem 1rem; background: var(--primary); color: white; border: none; border-radius: 0.25rem; cursor: pointer; font-size: 0.9rem;">
                                View
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');
            
            log.debug('✅ Admin table rendered');
        }
        
        /**
         * Test table rendering with mock data (for Phase 4 testing only)
         */
        function testTableRenderingWithMockData() {
            log.debug('🧪 Testing table rendering with mock data');
            
            const mockCourses = [
                {
                    id: '1',
                    name: 'Public Speaking 101',
                    code: 'CMST 210',
                    instructor_name: 'John Doe',
                    institution_name: 'University of Tennessee',
                    semester: 'Fall',
                    year: '2024',
                    modality: 'in-person',
                    student_count: 25,
                    evaluation_count: 12
                },
                {
                    id: '2',
                    name: 'Advanced Rhetoric',
                    code: 'CMST 340',
                    instructor_name: 'Jane Smith',
                    institution_name: 'University of Tennessee',
                    semester: 'Spring',
                    year: '2025',
                    modality: 'online',
                    student_count: 18,
                    evaluation_count: 8
                }
            ];
            
            // Test super admin table
            if (userTier === 'super_admin') {
                renderSuperAdminCoursesTable(mockCourses);
            }
            
            // Test admin table
            if (userTier === 'admin') {
                renderAdminCoursesTable(mockCourses);
            }
        }
        
        // ===== END TABLE RENDERING FUNCTIONS =====
        
        // ===== DATA LOADING FUNCTIONS (PHASE 5) =====
        
        /**
         * Load all institutions for super admin filter dropdown
         */
        async function loadInstitutionsForFilter() {
            if (!supabaseClient) return;
            
            log.debug('📊 Loading institutions for filter...');
            
            try {
                const { data: institutions, error } = await supabaseClient
                    .from('institutions')
                    .select('id, name')
                    .order('name');
                
                if (error) {
                    console.error('Error loading institutions:', error);
                    return;
                }
                
                log.debug('✅ Loaded', institutions.length, 'institutions');
                
                // Populate institution dropdown
                const institutionSelect = document.getElementById('filterInstitution');
                if (institutionSelect) {
                    const options = institutions.map(inst => 
                        `<option value="${escapeHtml(inst.id)}">${escapeHtml(inst.name)}</option>`
                    ).join('');
                    institutionSelect.innerHTML = '<option value="">All Institutions</option>' + options;
                }
            } catch (error) {
                console.error('Error in loadInstitutionsForFilter:', error);
            }
        }
        
        /**
         * Load instructors for a specific institution
         */
        async function loadInstructorsForFilter(institutionId) {
            if (!supabaseClient) return;
            
            log.debug('📊 Loading instructors for institution:', institutionId || 'All');
            
            try {
                let query = supabaseClient
                    .from('user_profiles')
                    .select('id, full_name, institution_id');
                
                // Filter by institution if specified
                if (institutionId) {
                    query = query.eq('institution_id', institutionId);
                }
                
                query = query.order('full_name');
                
                const { data: instructors, error } = await query;
                
                if (error) {
                    console.error('Error loading instructors:', error);
                    return;
                }
                
                log.debug('✅ Loaded', (instructors || []).length, 'instructors');
                
                // Populate instructor dropdown (user_profiles uses full_name)
                const instructorSelect = document.getElementById('filterInstructor');
                if (instructorSelect) {
                    const options = (instructors || []).map(inst => {
                        const name = (inst.full_name || '').trim() || 'Unknown';
                        return `<option value="${inst.id}">${name}</option>`;
                    }).join('');
                    instructorSelect.innerHTML = '<option value="">All Instructors</option>' + options;
                }
            } catch (error) {
                console.error('Error in loadInstructorsForFilter:', error);
            }
        }
        
        /**
         * Load instructors for admin (department only)
         */
        async function loadDepartmentInstructorsForFilter() {
            if (!supabaseClient || !currentUser) return;
            
            log.debug('📊 Loading department instructors...');
            
            try {
                const { data: instructors, error } = await supabaseClient
                    .from('user_profiles')
                    .select('id, full_name')
                    .eq('institution_id', currentUser.institution_id)
                    .order('full_name');
                
                if (error) {
                    console.error('Error loading department instructors:', error);
                    return;
                }
                
                log.debug('✅ Loaded', instructors.length, 'department instructors');
                
                // Populate admin instructor dropdown (user_profiles may have full_name, not first_name/last_name)
                const instructorSelect = document.getElementById('adminFilterInstructor');
                if (instructorSelect) {
                    const options = (instructors || []).map(inst => {
                        const name = (inst.full_name || '').trim() || 'Unknown';
                        return `<option value="${inst.id}">${name}</option>`;
                    }).join('');
                    instructorSelect.innerHTML = '<option value="">All Instructors</option>' + options;
                }
            } catch (error) {
                console.error('Error in loadDepartmentInstructorsForFilter:', error);
            }
        }
        
        /**
         * Course scope filter (main Courses card): populate institution dropdown for super admin
         */
        async function loadCourseScopeInstitutions() {
            if (!supabaseClient) return;
            try {
                const { data: institutions, error } = await supabaseClient
                    .from('institutions')
                    .select('id, name')
                    .order('name');
                if (error) return;
                const sel = document.getElementById('courseScopeInstitution');
                if (!sel) return;
                sel.innerHTML = '<option value="">Select institution</option>' +
                    (institutions || []).map(inst => `<option value="${inst.id}">${escapeHtml(inst.name)}</option>`).join('');
            } catch (e) {
                console.warn('loadCourseScopeInstitutions:', e);
            }
        }
        
        /**
         * Course scope filter: populate instructor dropdown (for selected institution or department)
         */
        async function loadCourseScopeInstructors(institutionId) {
            if (!supabaseClient) return;
            try {
                let query = supabaseClient.from('user_profiles').select('id, full_name');
                if (institutionId) query = query.eq('institution_id', institutionId);
                const { data: instructors, error } = await query.order('full_name');
                if (error) return;
                const sel = document.getElementById('courseScopeInstructor');
                if (!sel) return;
                sel.innerHTML = '<option value="">All instructors</option>' +
                    (instructors || []).map(inst => {
                        const name = (inst.full_name || '').trim() || 'Unknown';
                        return `<option value="${inst.id}">${escapeHtml(name)}</option>`;
                    }).join('');
            } catch (e) {
                console.warn('loadCourseScopeInstructors:', e);
            }
        }
        
        function onCourseScopeChange() {
            const scope = document.getElementById('courseScopeSelect')?.value || 'own';
            const institutionWrap = document.getElementById('courseScopeInstitutionWrap');
            const instructorWrap = document.getElementById('courseScopeInstructorWrap');
            const institutionSel = document.getElementById('courseScopeInstitution');
            const instructorSel = document.getElementById('courseScopeInstructor');
            
            currentFilterInstitutionId = null;
            currentFilterInstructorId = null;
            if (institutionSel) institutionSel.value = '';
            if (instructorSel) instructorSel.value = '';
            
            if (scope === 'own') {
                currentViewMode = 'own';
                if (institutionWrap) institutionWrap.style.display = 'none';
                if (instructorWrap) instructorWrap.style.display = 'none';
                loadClasses();
            } else {
                currentViewMode = 'institution';
                if (isSuperAdmin()) {
                    if (institutionWrap) institutionWrap.style.display = 'block';
                    if (instructorWrap) instructorWrap.style.display = 'none';
                    loadCourseScopeInstitutions();
                    loadClasses(); // clears grid until institution selected
                } else {
                    if (institutionWrap) institutionWrap.style.display = 'none';
                    if (instructorWrap) instructorWrap.style.display = 'block';
                    loadCourseScopeInstructors(currentUser?.institution_id || null);
                    loadClasses();
                }
            }
        }
        
        function onCourseScopeInstitutionChange() {
            const sel = document.getElementById('courseScopeInstitution');
            currentFilterInstitutionId = sel?.value || null;
            currentFilterInstructorId = null;
            const instructorSel = document.getElementById('courseScopeInstructor');
            if (instructorSel) instructorSel.value = '';
            const instructorWrap = document.getElementById('courseScopeInstructorWrap');
            if (instructorWrap) instructorWrap.style.display = currentFilterInstitutionId ? 'block' : 'none';
            loadCourseScopeInstructors(currentFilterInstitutionId || null);
            loadClasses();
        }
        
        function onCourseScopeInstructorChange() {
            const sel = document.getElementById('courseScopeInstructor');
            currentFilterInstructorId = sel?.value || null;
            loadClasses();
        }
        
        /**
         * Load courses with current filter settings (Super Admin)
         */
        async function loadFilteredCoursesForSuperAdmin() {
            if (!supabaseClient) return;
            
            console.log('=== LOADING FILTERED COURSES (SUPER ADMIN) ===');
            
            // Get filter values
            const institutionId = document.getElementById('filterInstitution')?.value;
            const instructorId = document.getElementById('filterInstructor')?.value;
            const year = document.getElementById('filterYear')?.value;
            const semester = document.getElementById('filterSemester')?.value;
            const modality = document.getElementById('filterModality')?.value;
            const searchTerm = document.getElementById('filterSearch')?.value;
            
            log.debug('Filters:', { institutionId, instructorId, year, semester, modality, searchTerm });
            
            try {
                // Build base query; exclude courses deleted locally by instructor so super admin does not see them
                let query = supabaseClient
                    .from('courses')
                    .select('*')
                    .is('deleted_locally_at', null);
                
                // Apply instructor filter directly
                if (instructorId) {
                    query = query.eq('instructor_id', instructorId);
                } else if (institutionId) {
                    // If filtering by institution but no specific instructor,
                    // we need to get all instructors in that institution first
                    const { data: instInstructors } = await supabaseClient
                        .from('user_profiles')
                        .select('id')
                        .eq('institution_id', institutionId);
                    
                    if (instInstructors && instInstructors.length > 0) {
                        const instructorIds = instInstructors.map(i => i.id);
                        query = query.in('instructor_id', instructorIds);
                    } else {
                        // No instructors in this institution, return empty
                        renderSuperAdminCoursesTable([]);
                        return;
                    }
                }
                
                // Apply other filters
                if (year) {
                    query = query.eq('year', parseInt(year));
                }
                
                if (semester) {
                    query = query.eq('semester', semester);
                }
                
                if (modality) {
                    query = query.eq('modality', modality);
                }
                
                if (searchTerm) {
                    query = query.or(`name.ilike.%${searchTerm}%,code.ilike.%${searchTerm}%`);
                }
                
                query = query.order('created_at', { ascending: false });
                
                const { data: courses, error } = await query;
                
                if (error) {
                    console.error('❌ Error loading courses:', error);
                    renderSuperAdminCoursesTable([]);
                    return;
                }
                
                log.debug('✅ Loaded', courses.length, 'courses');
                
                // Super admin: hide courses deleted locally by an instructor (same as admin)
                const visibleCourses = (courses || []).filter(c => !c.deleted_locally_at);
                
                // Fetch course_students for student/eval counts (like admin)
                let rosterByCourse = {};
                if (visibleCourses.length > 0) {
                    const { data: coursesWithRoster } = await supabaseClient
                        .from('courses')
                        .select('id, course_students!course_students_course_id_fkey(id, deleted_locally_at)')
                        .in('id', visibleCourses.map(c => c.id));
                    if (coursesWithRoster) coursesWithRoster.forEach(c => { rosterByCourse[c.id] = (c.course_students || []).filter(s => !s.deleted_locally_at).length; });
                }
                const courseIds = visibleCourses.map(c => c.id);
                let evalCountByCourse = {};
                if (courseIds.length > 0) {
                    try {
                        const { data: evals } = await supabaseClient.from('evaluations').select('course_id, id').in('course_id', courseIds).is('deleted_locally_at', null);
                        if (evals) evals.forEach(e => { evalCountByCourse[e.course_id] = (evalCountByCourse[e.course_id] || 0) + 1; });
                    } catch (e) { log.debug('Super admin eval count:', e); }
                }
                
                if (visibleCourses.length > 0) {
                    const instructorIds = [...new Set(visibleCourses.map(c => c.instructor_id).filter(Boolean))];
                    let profiles = [];
                    let institutions = [];
                    
                    if (instructorIds.length > 0) {
                        const { data: profilesData, error: profilesError } = await supabaseClient
                            .from('user_profiles')
                            .select('id, full_name, institution_id, is_admin')
                            .in('id', instructorIds);
                        if (profilesError) {
                            console.warn('Could not load instructor profiles for All Institutions (check RLS):', profilesError.message);
                        } else {
                            profiles = profilesData || [];
                        }
                        
                        const institutionIds = [...new Set(profiles.map(p => p.institution_id).filter(Boolean))];
                        if (institutionIds.length > 0) {
                            const { data: institutionsData, error: instError } = await supabaseClient
                                .from('institutions')
                                .select('id, name')
                                .in('id', institutionIds);
                            if (instError) {
                                console.warn('Could not load institutions (check RLS):', instError.message);
                            } else {
                                institutions = institutionsData || [];
                            }
                        }
                    }
                    
                    const institutionMap = {};
                    institutions.forEach(inst => { institutionMap[inst.id] = inst.name; });
                    
                    const profileMap = {};
                    profiles.forEach(prof => {
                        const name = (prof.full_name || '').trim() || 'Unknown';
                        profileMap[prof.id] = {
                            name: prof.is_admin ? name + ' - Admin' : name,
                            institution_id: prof.institution_id,
                            institution_name: institutionMap[prof.institution_id] || '—'
                        };
                    });
                    
                    const transformedCourses = visibleCourses.map(course => {
                        const prof = course.instructor_id ? profileMap[course.instructor_id] : null;
                        return {
                            ...course,
                            instructor_name: prof?.name || (course.instructor_id ? 'Unknown' : '—'),
                            institution_name: prof?.institution_name || '—',
                            student_count: rosterByCourse[course.id] ?? 0,
                            evaluation_count: evalCountByCourse[course.id] || 0
                        };
                    });
                    
                    renderSuperAdminCoursesTable(transformedCourses);
                } else {
                    renderSuperAdminCoursesTable([]);
                }
            } catch (error) {
                console.error('❌ Error in loadFilteredCoursesForSuperAdmin:', error);
                renderSuperAdminCoursesTable([]);
            }
        }
        
        /**
         * Load courses for admin (department only)
         * @param {boolean} forSearch - If true, load ALL institution courses (ignore dashboard filters) for account search
         */
        async function loadFilteredCoursesForAdmin(forSearch) {
            if (!supabaseClient || !currentUser) return;
            
            console.log('=== LOADING FILTERED COURSES (ADMIN)', forSearch ? '(for search)' : '===');
            
            // Get filter values (skip when loading for search - we need all courses)
            const instructorId = forSearch ? '' : (document.getElementById('adminFilterInstructor')?.value || '');
            const year = forSearch ? '' : (document.getElementById('adminFilterYear')?.value || '');
            const semester = forSearch ? '' : (document.getElementById('adminFilterSemester')?.value || '');
            const modality = forSearch ? '' : (document.getElementById('adminFilterModality')?.value || '');
            
            log.debug('Filters:', { instructorId, year, semester, modality });
            
            try {
                // Get all users in this institution (user_profiles uses full_name)
                const { data: institutionUsers } = await supabaseClient
                    .from('user_profiles')
                    .select('id, full_name')
                    .eq('institution_id', currentUser.institution_id);
                
                const userIds = institutionUsers?.map(u => u.id) || [];
                
                // Create instructor name lookup
                const instructorMap = {};
                institutionUsers?.forEach(user => {
                    instructorMap[user.id] = (user.full_name || '').trim() || 'Unknown';
                });
                
                // Build query: include course_students (full roster for search); exclude courses deleted locally by instructor so admin does not see them
                let query = supabaseClient
                    .from('courses')
                    .select(`
                        *,
                        course_students!course_students_course_id_fkey(id, first_name, last_name, email, student_id, deleted_locally_at)
                    `)
                    .in('instructor_id', userIds)
                    .is('deleted_locally_at', null);
                
                // Apply filters
                if (instructorId) {
                    query = query.eq('instructor_id', instructorId);
                }
                
                if (year) {
                    query = query.eq('year', parseInt(year));
                }
                
                if (semester) {
                    query = query.eq('semester', semester);
                }
                
                if (modality) {
                    query = query.eq('modality', modality);
                }
                
                query = query.order('created_at', { ascending: false });
                
                const { data: courses, error } = await query;
                
                if (error) {
                    console.error('❌ Error loading courses:', error);
                    renderAdminCoursesTable([]);
                    return;
                }
                
                log.debug('✅ Loaded', courses.length, 'courses (excluding locally deleted)');
                
                const visibleCourses = courses || [];
                const courseIds = visibleCourses.map(c => c.id);
                let evalCountByCourse = {};
                if (courseIds.length > 0 && supabaseClient) {
                    try {
                        const { data: evals } = await supabaseClient
                            .from('evaluations')
                            .select('course_id, id')
                            .in('course_id', courseIds)
                            .is('deleted_locally_at', null);
                        if (evals) {
                            evals.forEach(e => {
                                if (!evalCountByCourse[e.course_id]) evalCountByCourse[e.course_id] = 0;
                                evalCountByCourse[e.course_id]++;
                            });
                        }
                    } catch (e) {
                        log.debug('Eval count by course skipped:', e);
                    }
                }
                
                // Transform data for table rendering (exclude locally-deleted students from count)
                const transformedCourses = visibleCourses.map(course => {
                    const roster = course.course_students || [];
                    const activeRoster = roster.filter(s => !s.deleted_locally_at);
                    const student_count = activeRoster.length;
                    const evaluation_count = evalCountByCourse[course.id] || 0;
                    const { course_students, ...rest } = course;
                    return {
                        ...rest,
                        instructor_name: instructorMap[course.instructor_id] || 'Unknown',
                        institution_name: (typeof currentInstitution !== 'undefined' && currentInstitution?.name) || '',
                        student_count,
                        evaluation_count,
                        roster: activeRoster
                    };
                });
                
                if (forSearch) {
                    // For search: populate cache only, don't overwrite Dashboard table
                    _adminCoursesCache = transformedCourses;
                } else {
                    renderAdminCoursesTable(transformedCourses);
                }
            } catch (error) {
                console.error('❌ Error in loadFilteredCoursesForAdmin:', error);
                if (!forSearch) renderAdminCoursesTable([]);
                else _adminCoursesCache = [];
            }
        }
        
        // ===== END DATA LOADING FUNCTIONS =====
        
        // Load user's account tier from user_profiles table
        async function loadUserTier() {
            if (!currentUser || !supabaseClient) {
                userTier = 'demo';
                resetThemeToDefault();
                routeToInterface();
                return;
            }
            
            // Start from SpeechGradebook default (dark blue); loadInstitutionalTheme will apply custom theme if institution has one
            resetThemeToDefault();
            
            try {
                // Fetch only flat columns so RLS on institutions/departments can't break the query
                const { data, error } = await supabaseClient
                    .from('user_profiles')
                    .select('account_tier, is_admin, is_super_admin, institution_id, department_id, llm_training_consent_given, full_name, approval_status')
                    .eq('id', currentUser.id)
                    .single();
                
                console.log('[loadUserTier] Profile fetch:', error ? 'error ' + error.message : 'ok', 'account_tier=', data?.account_tier, 'approval_status=', data?.approval_status);
                
                if (error) {
                    console.warn('Could not load user profile:', error.message, '- Ensure user_profiles has a row for this user and RLS allows read. Falling back to demo.');
                    userTier = (currentUser.user_metadata?.account_tier || currentUser.app_metadata?.account_tier) || 'demo';
                    if (userTier === 'demo') {
                        currentUser.is_admin = false;
                        currentUser.is_super_admin = false;
                        currentInstitution = null;
                    }
                } else if (data && (data.approval_status || '').toLowerCase() === 'pending_approval') {
                    showPendingApprovalScreen();
                    return;
                } else if (data) {
                    userTier = (data.account_tier || currentUser.user_metadata?.account_tier || currentUser.app_metadata?.account_tier) || 'demo';
                    currentUser.is_admin = data.is_admin;
                    currentUser.is_super_admin = data.is_super_admin;
                    currentUser.institution_id = data.institution_id;
                    currentUser.department_id = data.department_id;
                    currentUser.llm_training_consent_given = data.llm_training_consent_given === true;
                    currentUser.full_name = (data.full_name || '').trim() || null;
                    currentInstitution = null; // Load below if needed
                    
                    log.debug('✓ Account tier:', userTier, 
                        data.is_super_admin ? '(Super Admin)' : 
                        data.is_admin ? '(Admin)' : '(Instructor)');
                    
                    // Optionally load institution name for display (separate query so RLS on institutions is independent)
                    if (data.institution_id) {
                        const { data: inst } = await supabaseClient
                            .from('institutions')
                            .select('id, name, domain')
                            .eq('id', data.institution_id)
                            .single();
                        if (inst) currentInstitution = inst;
                    }
                    
                    // Load institutional theme if user has an institution (skip when user chose Generic/Default so that choice sticks)
                    const savedTenantBeforeLoad = (typeof localStorage !== 'undefined' && localStorage.getItem('current_tenant')) || null;
                    if (currentUser.institution_id && savedTenantBeforeLoad !== 'default') {
                        await loadInstitutionalTheme(currentUser.institution_id);
                    }
                } else {
                    console.warn('No user_profiles row for', currentUser.id, '- Set account_tier in user_profiles for this user.');
                    userTier = (currentUser.user_metadata?.account_tier || currentUser.app_metadata?.account_tier) || 'demo';
                }
            } catch (err) {
                console.error('Error loading tier:', err);
                userTier = 'demo';
            }
            
            // Route to appropriate interface (each interface handles its own UI setup)
            await routeToInterface();
            
            // Update user display with name from profile (now that loadUserTier has completed)
            updateUserDisplay();
            
            // Apply Demo Theme Customizer from sessionStorage if in demo mode
            if (userTier === 'demo' && typeof applyDemoTheme === 'function') applyDemoTheme();
            
            // Remove demo banner after UI is built (in case interface added it)
            if (userTier !== 'demo') {
                removeDemoBannerIfPresent();
                setTimeout(removeDemoBannerIfPresent, 0);
                setTimeout(removeDemoBannerIfPresent, 200);
                setTimeout(removeDemoBannerIfPresent, 600);
            } else if (currentUser && supabaseClient) {
                // Retry profile fetch once in case first load failed (e.g. RLS timing)
                setTimeout(async function retryProfile() {
                    const { data, error } = await supabaseClient
                        .from('user_profiles')
                        .select('account_tier, is_admin, is_super_admin, institution_id, llm_training_consent_given, full_name, approval_status')
                        .eq('id', currentUser.id)
                        .single();
                    if (!error && data && (data.approval_status || '').toLowerCase() === 'pending_approval') {
                        showPendingApprovalScreen();
                        return;
                    }
                    if (!error && data && data.account_tier && data.account_tier !== 'demo') {
                        console.log('[loadUserTier] Retry got tier:', data.account_tier);
                        userTier = data.account_tier;
                        currentUser.is_admin = data.is_admin;
                        currentUser.is_super_admin = data.is_super_admin;
                        currentUser.institution_id = data.institution_id;
                        currentUser.llm_training_consent_given = data.llm_training_consent_given === true;
                        currentUser.full_name = (data.full_name || '').trim() || null;
                        if (data.institution_id) {
                            const { data: inst } = await supabaseClient.from('institutions').select('id, name').eq('id', data.institution_id).single();
                            if (inst) currentInstitution = inst;
                            await loadInstitutionalTheme(data.institution_id);
                        }
                        routeToInterface();
                        removeDemoBannerIfPresent();
                        setTimeout(removeDemoBannerIfPresent, 0);
                        setTimeout(removeDemoBannerIfPresent, 200);
                    }
                }, 800);
            }
        }
        
        function removeDemoBannerIfPresent() {
            const b = document.getElementById('demoBanner');
            if (b) { b.remove(); console.log('[loadUserTier] Removed demo banner'); }
        }
        
        // Load custom institutional theme from database (e.g. University of Tennessee).
        // If the institution has no theme row, we reset to SpeechGradebook default (dark blue).
        async function loadInstitutionalTheme(institutionId) {
            // All accounts use the default SpeechGradebook theme
            console.log('[loadInstitutionalTheme] Using default SpeechGradebook theme for all accounts.');
            currentUser.theme = null;
            currentInstitutionTheme = null;
            resetThemeToDefault();
        }
        
        // Load custom fonts on startup (for all users)
        function loadCustomFontsOnStartup(customFontsData) {
            if (!customFontsData) return;
            
            let fonts = [];
            try {
                fonts = typeof customFontsData === 'string' ? JSON.parse(customFontsData) : customFontsData;
            } catch (e) {
                console.error('Error parsing custom fonts:', e);
                return;
            }
            
            if (!Array.isArray(fonts) || fonts.length === 0) return;
            
            // Inject font-face CSS for each font
            fonts.forEach(font => {
                injectFontFace(font);
            });
            
            log.debug('✓ Loaded', fonts.length, 'custom font(s)');
        }
        
        // SpeechGradebook theme (default) - dark blue, matches :root. Used when user has no institution
        // or institution has no theme row. Header uses same color as footer (solid #1e3a5f).
        function resetThemeToDefault() {
            const root = document.documentElement;
            // Always use light theme for login screen
            root.removeAttribute('data-theme');
            root.classList.remove('theme-torch', 'theme-utk-torch', 'theme-option7-dark');
            root.style.removeProperty('--smokey');
            root.style.removeProperty('--link-blue');
            // Apply SpeechGradebook Light Theme (Option 7)
            root.style.setProperty('--primary', '#1e3a5f');
            root.style.setProperty('--primary-dark', '#142940');
            root.style.setProperty('--secondary', '#5a6c7d');
            root.style.setProperty('--accent', '#4a6fa5');
            root.style.setProperty('--text', '#1a1a1a');
            root.style.setProperty('--text-light', '#6b6b6b');
            root.style.setProperty('--bg', '#fafbfc');
            root.style.setProperty('--bg-alt', '#f1f4f7');
            root.style.setProperty('--card', '#ffffff');
            root.style.setProperty('--border', '#d1d5db');
            root.style.setProperty('--success', '#059669');
            root.style.setProperty('--warning', '#d97706');
            root.style.setProperty('--error', '#b91c1c');
            root.style.setProperty('--heading-font', "'Roboto', sans-serif");
            root.style.setProperty('--body-font', "'Roboto', sans-serif");
            const faviconEl = document.getElementById('faviconLink');
            if (faviconEl) { faviconEl.href = 'assets/3d-logo-transparent.png'; faviconEl.type = 'image/png'; }
            const header = document.querySelector('header');
            if (header) {
                header.style.background = '#142940';
                header.style.backgroundImage = 'none';
                header.style.color = 'white';
                header.querySelectorAll('h1, .subtitle, #logoutLink, .nav-link').forEach(el => { if (el) el.style.color = ''; });
            }
            const footer = document.querySelector('footer');
            if (footer) { footer.style.background = ''; footer.style.backgroundImage = ''; }
            const logo = document.getElementById('appLogo');
            if (logo) { logo.innerHTML = '<img src="assets/3d-logo-transparent.png" alt="SpeechGradebook" style="width: 100%; height: 100%; object-fit: contain; object-position: center; border-radius: 50%; padding: 12%;">'; logo.style.backgroundColor = '#ffffff'; }
            const appTaglineEl = document.getElementById('appTagline');
            if (appTaglineEl) appTaglineEl.textContent = 'Instructor-Informed Speech Assessment';
            currentInstitutionTheme = null;
            if (typeof currentUser !== 'undefined' && currentUser) currentUser.theme = null;
            removeDemoInjectedStyles();
            log.debug('Theme reset to SpeechGradebook default');
        }
        
        const DEMO_THEME_KEY = 'speech_demo_theme';

        // Demo branding package presets – full demo form field mapping
        var DEMO_BRANDING_PACKAGES = {
            default: {
                primary: '#1e3a5f', primaryDark: '#142940', secondary: '#c8a882', accent: '#d4af37',
                text: '#2c3e50', textLight: '#6c757d', bg: '#fafbfc', bgAlt: '#f1f4f7',
                card: '#ffffff', border: '#e1e8ed', success: '#059669', warning: '#d97706', error: '#b91c1c'
            },
            'utk-wds': {
                primary: '#FF8200', primaryDark: '#4B4B4B', secondary: '#1a73c5', accent: '#FF8200',
                text: '#4B4B4B', textLight: '#6B6B6B', bg: '#FAFAFA', bgAlt: '#F0F0F0',
                card: '#ffffff', border: '#E0E0E0', success: '#059669', warning: '#d97706', error: '#b91c1c'
            },
            'option4': {
                primary: '#1a2332', primaryDark: '#0f1419', secondary: '#4a5568', accent: '#5b7fa6',
                text: '#1a1a1a', textLight: '#6b6b6b', bg: '#f8f9fa', bgAlt: '#e9ecef',
                card: '#ffffff', border: '#dee2e6', success: '#28a745', warning: '#ffc107', error: '#dc3545'
            },
            'option7': {
                primary: '#1e3a5f', primaryDark: '#142940', secondary: '#5a6c7d', accent: '#4a6fa5',
                text: '#1a1a1a', textLight: '#6b6b6b', bg: '#fafbfc', bgAlt: '#f1f4f7',
                card: '#ffffff', border: '#d1d5db', success: '#059669', warning: '#d97706', error: '#b91c1c'
            },
            'speechgradebook-light': {
                primary: '#1e3a5f', primaryDark: '#142940', secondary: '#5a6c7d', accent: '#4a6fa5',
                text: '#1a1a1a', textLight: '#6b6b6b', bg: '#fafbfc', bgAlt: '#f1f4f7',
                card: '#ffffff', border: '#d1d5db', success: '#059669', warning: '#d97706', error: '#b91c1c'
            },
            'option7-apple': {
                primary: '#1e3a5f', primaryDark: '#142940', secondary: '#5a6c7d', accent: '#4a6fa5',
                text: '#1a1a1a', textLight: '#6b6b6b', bg: '#fafbfc', bgAlt: '#f1f4f7',
                card: '#ffffff', border: '#d1d5db', success: '#30D158', warning: '#FF9F0A', error: '#FF453A'
            },
            'option7-dark': {
                primary: '#6ba5d7', primaryDark: '#1e3a5f', secondary: '#8bb5d7', accent: '#7bb5e7',
                text: '#e8f0f8', textLight: '#b8c8d8', bg: '#121a24', bgAlt: '#1a2432',
                card: '#1e2838', border: '#2d3a4d', success: '#34c759', warning: '#ff9500', error: '#ff3b30'
            },
            'speechgradebook-dark': {
                primary: '#6ba5d7', primaryDark: '#1e3a5f', secondary: '#8bb5d7', accent: '#7bb5e7',
                text: '#e8f0f8', textLight: '#b8c8d8', bg: '#121a24', bgAlt: '#1a2432',
                card: '#1e2838', border: '#2d3a4d', success: '#34c759', warning: '#ff9500', error: '#ff3b30'
            },
            'option8': {
                primary: '#007AFF', primaryDark: '#0051D5', secondary: '#5856D6', accent: '#5AC8FA',
                text: '#000000', textLight: '#3C3C43', bg: '#F2F2F7', bgAlt: '#E5E5EA',
                card: '#FFFFFF', border: '#C6C6C8', success: '#30D158', warning: '#FF9F0A', error: '#FF453A'
            }
        };

        function setDemoFormToBrandingPackage(pkgId) {
            var pkg = DEMO_BRANDING_PACKAGES[pkgId] || DEMO_BRANDING_PACKAGES.default;
            DEMO_THEME_COLOR_IDS.forEach(function(row) {
                var colorKey = row[2];
                var val = pkg[colorKey];
                if (val) {
                    var colorEl = document.getElementById(row[0]);
                    var textEl = document.getElementById(row[1]);
                    if (colorEl) colorEl.value = val;
                    if (textEl) textEl.value = val;
                }
            });
            var sel = document.getElementById('demoBrandingPackageSelect');
            if (sel) sel.value = pkgId;
        }

        function onDemoBrandingPackageChange(value) {
            setDemoFormToBrandingPackage(value);
            applyDemoThemeFromForm();
            var status = document.getElementById('demoThemeStatus');
            if (status) {
                if (value === 'utk-wds') {
                    status.textContent = 'UTK WDS theme applied. You can tweak colors below.';
                } else if (value === 'option4') {
                    status.textContent = 'Option 4: Sophisticated Navy theme applied. You can tweak colors below.';
                } else if (value === 'option7') {
                    status.textContent = 'Option 7: Current Primary Refined theme applied. You can tweak colors below.';
                } else if (value === 'option7-apple') {
                    status.textContent = 'Option 7: Current Primary Refined (Apple-aligned) theme applied. Uses Apple system colors for semantic states.';
                } else if (value === 'option7-dark') {
                    status.textContent = 'Option 7: Dark Theme applied. Dark backgrounds with light headers and text for optimal contrast.';
                } else if (value === 'speechgradebook-light') {
                    status.textContent = 'SpeechGradebook Light Theme applied.';
                } else if (value === 'speechgradebook-dark') {
                    status.textContent = 'SpeechGradebook Dark Theme applied.';
                } else if (value === 'option8') {
                    status.textContent = 'Option 8: Ideal Apple HIG theme applied. Fully aligned with Apple Human Interface Guidelines.';
                } else {
                    status.textContent = 'Default theme applied.';
                }
            }
        }
        
        function getDemoTheme() {
            try {
                const raw = sessionStorage.getItem(DEMO_THEME_KEY);
                return raw ? JSON.parse(raw) : null;
            } catch (e) { return null; }
        }
        
        function setDemoTheme(obj) {
            try {
                if (obj) sessionStorage.setItem(DEMO_THEME_KEY, JSON.stringify(obj));
                else sessionStorage.removeItem(DEMO_THEME_KEY);
            } catch (e) { console.warn('Demo theme storage failed', e); }
        }
        
        function clearDemoTheme() {
            setDemoTheme(null);
            removeDemoInjectedStyles();
        }
        
        function removeDemoInjectedStyles() {
            document.getElementById('demo-theme-style')?.remove();
            document.getElementById('demo-font-style')?.remove();
            document.documentElement.classList.remove('theme-torch', 'theme-utk-torch');
            document.documentElement.style.removeProperty('--smokey');
            document.documentElement.style.removeProperty('--link-blue');
            var fav = document.getElementById('faviconLink');
            if (fav) { fav.href = 'assets/3d-logo-transparent.png'; fav.type = 'image/png'; }
        }
        
        function applyDemoTheme() {
            if (typeof userTier === 'undefined' || userTier !== 'demo') return;
            var theme = getDemoTheme();
            if (!theme) return;
            var root = document.documentElement;
            const isDarkMode = root.getAttribute('data-theme') === 'dark';
            const isDarkTheme = theme.brandingPackage === 'option7-dark';
            
            // Add/remove theme class for CSS targeting
            if (isDarkTheme) {
                root.classList.add('theme-option7-dark');
            } else {
                root.classList.remove('theme-option7-dark');
            }
            
            // Always apply primary colors (they work in both modes)
            if (theme.primary) root.style.setProperty('--primary', theme.primary);
            if (theme.primaryDark != null) root.style.setProperty('--primary-dark', theme.primaryDark);
            if (theme.secondary) root.style.setProperty('--secondary', theme.secondary);
            if (theme.accent) root.style.setProperty('--accent', theme.accent);
            
            // For dark themes (like option7-dark), always apply the theme colors directly
            // For other themes, only apply in light mode (let dark mode CSS handle dark mode toggle)
            if (isDarkTheme || !isDarkMode) {
                if (theme.text) root.style.setProperty('--text', theme.text);
                if (theme.textLight) root.style.setProperty('--text-light', theme.textLight);
                if (theme.bg) root.style.setProperty('--bg', theme.bg);
                if (theme.bgAlt) root.style.setProperty('--bg-alt', theme.bgAlt);
                if (theme.card) root.style.setProperty('--card', theme.card);
                if (theme.border) root.style.setProperty('--border', theme.border);
            } else {
                // Remove light mode overrides so dark mode CSS can take effect
                root.style.removeProperty('--text');
                root.style.removeProperty('--text-light');
                root.style.removeProperty('--bg');
                root.style.removeProperty('--bg-alt');
                root.style.removeProperty('--card');
                root.style.removeProperty('--border');
            }
            
            // Semantic colors can be set in both modes (they're adjusted in dark mode CSS)
            if (theme.success) root.style.setProperty('--success', theme.success);
            if (theme.warning) root.style.setProperty('--warning', theme.warning);
            if (theme.error) root.style.setProperty('--error', theme.error);
            if (theme.brandingPackage === 'utk-wds') {
                root.classList.add('theme-torch', 'theme-utk-torch');
                root.style.setProperty('--smokey', '#4B4B4B');
                root.style.setProperty('--link-blue', theme.secondary || '#1a73c5');
            } else {
                root.classList.remove('theme-torch', 'theme-utk-torch');
                root.style.removeProperty('--smokey');
                root.style.removeProperty('--link-blue');
            }
            // Tab favicon always SpeechGradebook
            var fav = document.getElementById('faviconLink');
            if (fav) { fav.href = 'assets/3d-logo-transparent.png'; fav.type = 'image/png'; }
            var header = document.querySelector('header');
            if (header && (theme.primaryDark != null || theme.primary)) {
                var headerBg = theme.primaryDark != null ? theme.primaryDark : theme.primary;
                header.style.background = headerBg;
                header.style.backgroundImage = 'none';
                // For dark themes, use light text; otherwise check if background is dark
                var isDark = isDarkTheme || parseInt(String(headerBg).replace('#', ''), 16) < 0x808080;
                header.style.color = isDark ? 'white' : '#2c3e50';
                if (isDark) {
                    // Ensure all header text is white for dark themes
                    header.querySelectorAll('h1, .subtitle, #logoutLink, .nav-link').forEach(function(el) { 
                        if (el) el.style.color = 'white'; 
                    });
                } else {
                    header.querySelectorAll('h1, .subtitle, #logoutLink, .nav-link').forEach(function(el) { 
                        if (el) el.style.color = ''; 
                    });
                }
            }
            var logo = document.getElementById('appLogo');
            if (logo) {
                if (theme.logoDataUrl) {
                    logo.innerHTML = '<img src="' + theme.logoDataUrl.replace(/"/g, '&quot;') + '" alt="Logo" style="width:100%;height:100%;object-fit:cover;object-position:center;border-radius:50%;">';
                    logo.style.backgroundColor = '#ffffff';
                } else {
                    logo.innerHTML = '<img src="assets/3d-logo-transparent.png" alt="SpeechGradebook" style="width:100%;height:100%;object-fit:contain;object-position:center;border-radius:50%;padding:12%;">';
                    logo.style.backgroundColor = '#ffffff';
                }
            }
            var taglineEl = document.getElementById('appTagline');
            if (taglineEl && theme.tagline) taglineEl.textContent = theme.tagline;
            if (theme.fontFamily) {
                root.style.setProperty('--heading-font', theme.fontFamily);
                root.style.setProperty('--body-font', theme.fontFamily);
            }
            if (theme.customFontDataUrl && theme.customFontName) {
                var style = document.getElementById('demo-font-style');
                if (!style) { style = document.createElement('style'); style.id = 'demo-font-style'; document.head.appendChild(style); }
                var format = (theme.customFontDataUrl.indexOf('woff2') !== -1) ? 'woff2' : (theme.customFontDataUrl.indexOf('woff') !== -1) ? 'woff' : (theme.customFontDataUrl.indexOf('ttf') !== -1 || theme.customFontDataUrl.indexOf('truetype') !== -1) ? 'truetype' : 'opentype';
                style.textContent = '@font-face { font-family: "' + theme.customFontName.replace(/"/g, '\\"') + '"; src: url(' + theme.customFontDataUrl + ') format("' + format + '"); font-weight: 400 700; }\n' +
                    ':root { --heading-font: "' + theme.customFontName.replace(/"/g, '\\"') + '", sans-serif; --body-font: "' + theme.customFontName.replace(/"/g, '\\"') + '", sans-serif; }';
            }
        }
        
        var DEMO_THEME_COLOR_IDS = [
            ['demoThemePrimary', 'demoThemePrimaryText', 'primary', '#1e3a5f'],
            ['demoThemePrimaryDark', 'demoThemePrimaryDarkText', 'primaryDark', '#142940'],
            ['demoThemeSecondary', 'demoThemeSecondaryText', 'secondary', '#c8a882'],
            ['demoThemeAccent', 'demoThemeAccentText', 'accent', '#d4af37'],
            ['demoThemeText', 'demoThemeTextText', 'text', '#2c3e50'],
            ['demoThemeTextLight', 'demoThemeTextLightText', 'textLight', '#6c757d'],
            ['demoThemeBg', 'demoThemeBgText', 'bg', '#fafbfc'],
            ['demoThemeBgAlt', 'demoThemeBgAltText', 'bgAlt', '#f1f4f7'],
            ['demoThemeCard', 'demoThemeCardText', 'card', '#ffffff'],
            ['demoThemeBorder', 'demoThemeBorderText', 'border', '#e1e8ed'],
            ['demoThemeSuccess', 'demoThemeSuccessText', 'success', '#059669'],
            ['demoThemeWarning', 'demoThemeWarningText', 'warning', '#d97706'],
            ['demoThemeError', 'demoThemeErrorText', 'error', '#b91c1c']
        ];
        
        function loadDemoThemeForm() {
            var theme = getDemoTheme();
            DEMO_THEME_COLOR_IDS.forEach(function(row) {
                var pickerId = row[0], textId = row[1], key = row[2], def = row[3];
                var val = (theme && theme[key]) ? theme[key] : def;
                var picker = document.getElementById(pickerId);
                var text = document.getElementById(textId);
                if (picker) picker.value = val;
                if (text) text.value = val;
            });
            var logoPreview = document.getElementById('demoLogoPreview');
            var logoPreviewImg = document.getElementById('demoLogoPreviewImg');
            var logoPlaceholder = document.getElementById('demoLogoPlaceholder');
            var logoClear = document.getElementById('demoLogoClear');
            if (theme && theme.logoDataUrl) {
                if (logoPreviewImg) { logoPreviewImg.src = theme.logoDataUrl; logoPreviewImg.style.display = 'block'; }
                if (logoPlaceholder) logoPlaceholder.style.display = 'none';
                if (logoClear) logoClear.style.display = '';
            } else {
                if (logoPreviewImg) { logoPreviewImg.src = 'assets/3d-logo-transparent.png'; logoPreviewImg.style.display = 'none'; }
                if (logoPlaceholder) logoPlaceholder.style.display = '';
                if (logoClear) logoClear.style.display = 'none';
            }
            var fontSelect = document.getElementById('demoFontSelect');
            if (fontSelect) {
                if (theme && theme.customFontDataUrl && theme.customFontName) fontSelect.value = '__custom__';
                else if (theme && theme.fontFamily) fontSelect.value = theme.fontFamily;
                else fontSelect.value = '';
            }
            var customWrap = document.getElementById('demoCustomFontWrap');
            if (customWrap) customWrap.style.display = (fontSelect && fontSelect.value === '__custom__') ? 'block' : 'none';
            var customName = document.getElementById('demoCustomFontName');
            if (customName && theme && theme.customFontName) customName.value = theme.customFontName;
            var taglineInput = document.getElementById('demoTagline');
            if (taglineInput) taglineInput.value = (theme && theme.tagline) ? theme.tagline : 'Instructor-Informed Speech Assessment';
            var pkgSel = document.getElementById('demoBrandingPackageSelect');
            if (pkgSel && theme && theme.brandingPackage) pkgSel.value = theme.brandingPackage;
            else if (pkgSel) pkgSel.value = 'default';
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: document.getElementById('settingsTabDemo') });
        }
        
        function applyDemoThemeFromForm() {
            var theme = {};
            DEMO_THEME_COLOR_IDS.forEach(function(row) {
                var textId = row[1], key = row[2], def = row[3];
                var text = document.getElementById(textId);
                var val = (text && text.value && text.value.trim()) ? text.value.trim() : def;
                if (/^#[0-9a-fA-F]{6}$/.test(val)) theme[key] = val;
                else theme[key] = def;
            });
            var logoUpload = document.getElementById('demoLogoUpload');
            if (logoUpload && logoUpload.files && logoUpload.files[0]) {
                var reader = new FileReader();
                reader.onload = function() {
                    theme.logoDataUrl = reader.result;
                    finishDemoThemeApply(theme);
                };
                reader.readAsDataURL(logoUpload.files[0]);
                return;
            }
            var existing = getDemoTheme();
            if (existing && existing.logoDataUrl) theme.logoDataUrl = existing.logoDataUrl;
            finishDemoThemeApply(theme);
        }
        
        function finishDemoThemeApply(theme) {
            var taglineEl = document.getElementById('demoTagline');
            if (taglineEl && taglineEl.value.trim()) theme.tagline = taglineEl.value.trim();
            var pkgSel = document.getElementById('demoBrandingPackageSelect');
            theme.brandingPackage = (pkgSel && pkgSel.value) ? pkgSel.value : 'default';
            var fontSelect = document.getElementById('demoFontSelect');
            if (fontSelect && fontSelect.value === '__custom__') {
                var customName = document.getElementById('demoCustomFontName');
                var customData = window.demoCustomFontDataUrl;
                if (!customData) {
                    var existing = getDemoTheme();
                    if (existing && existing.customFontDataUrl) customData = existing.customFontDataUrl;
                }
                if (customName && customName.value.trim() && customData) {
                    theme.customFontName = customName.value.trim();
                    theme.customFontDataUrl = customData;
                }
            } else if (fontSelect && fontSelect.value) {
                theme.fontFamily = fontSelect.value;
            }
            setDemoTheme(theme);
            applyDemoTheme();
            var status = document.getElementById('demoThemeStatus');
            if (status) status.textContent = 'Applied. Changes reset when you log out.';
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: document.getElementById('settingsSection') });
        }
        
        function resetDemoThemeAndForm() {
            clearDemoTheme();
            resetThemeToDefault();
            var logoUpload = document.getElementById('demoLogoUpload');
            if (logoUpload) logoUpload.value = '';
            window.demoCustomFontDataUrl = null;
            var customName = document.getElementById('demoCustomFontName');
            if (customName) customName.value = '';
            var customFile = document.getElementById('demoCustomFontFile');
            if (customFile) customFile.value = '';
            var fontSelect = document.getElementById('demoFontSelect');
            if (fontSelect) fontSelect.value = '';
            var customWrap = document.getElementById('demoCustomFontWrap');
            if (customWrap) customWrap.style.display = 'none';
            DEMO_THEME_COLOR_IDS.forEach(function(row) {
                var pickerId = row[0], textId = row[1], def = row[3];
                var picker = document.getElementById(pickerId);
                var text = document.getElementById(textId);
                if (picker) picker.value = def;
                if (text) text.value = def;
            });
            var tagline = document.getElementById('demoTagline');
            if (tagline) tagline.value = 'Instructor-Informed Speech Assessment';
            var logoPreviewImg = document.getElementById('demoLogoPreviewImg');
            var logoPlaceholder = document.getElementById('demoLogoPlaceholder');
            if (logoPreviewImg) { logoPreviewImg.style.display = 'none'; logoPreviewImg.removeAttribute('src'); }
            if (logoPlaceholder) logoPlaceholder.style.display = '';
            var logoClear = document.getElementById('demoLogoClear');
            if (logoClear) logoClear.style.display = 'none';
            var demoPkgSel = document.getElementById('demoBrandingPackageSelect');
            if (demoPkgSel) demoPkgSel.value = 'default';
            var status = document.getElementById('demoThemeStatus');
            if (status) status.textContent = 'Reset to default.';
        }
        
        function clearDemoLogo() {
            var theme = getDemoTheme();
            if (theme) {
                delete theme.logoDataUrl;
                setDemoTheme(Object.keys(theme).length ? theme : null);
            }
            var logoUpload = document.getElementById('demoLogoUpload');
            if (logoUpload) logoUpload.value = '';
            var logoPreviewImg = document.getElementById('demoLogoPreviewImg');
            var logoPlaceholder = document.getElementById('demoLogoPlaceholder');
            if (logoPreviewImg) { logoPreviewImg.style.display = 'none'; logoPreviewImg.removeAttribute('src'); }
            if (logoPlaceholder) logoPlaceholder.style.display = '';
            var logoClear = document.getElementById('demoLogoClear');
            if (logoClear) logoClear.style.display = 'none';
            if (getDemoTheme()) applyDemoTheme();
            else resetThemeToDefault();
        }
        
        // Apply custom institutional theme to CSS (e.g. University of Tennessee).
        // Only called when institution_themes has a row for this institution.
        function applyThemeToCSS(theme, institutionName) {
            if (!theme) return;
            
            const root = document.documentElement;
            
            log.debug('🎨 Applying custom institutional theme...');
            
            // Verify this is University of Tennessee before applying Torch theme
            const isUniversityOfTennessee = institutionName && 
                (institutionName.toLowerCase().includes('university of tennessee') || 
                 institutionName.toLowerCase().includes('utk'));
            
            // Apply colors to CSS variables
            if (theme.primary_color) {
                root.style.setProperty('--primary', theme.primary_color);
                root.style.setProperty('--primary-dark', theme.primary_color); // Use same color, no gradient
            }
            if (theme.secondary_color) root.style.setProperty('--secondary', theme.secondary_color);
            
            // Apply extended theme colors if available
            if (theme.bg_primary) root.style.setProperty('--bg', theme.bg_primary);
            if (theme.bg_secondary) root.style.setProperty('--bg-alt', theme.bg_secondary);
            if (theme.bg_tertiary) {
                root.style.setProperty('--bg-elevated', theme.bg_tertiary);
                root.style.setProperty('--card', theme.bg_tertiary); // Also update card background
            }
            
            if (theme.text_primary) {
                root.style.setProperty('--text', theme.text_primary);
            }
            if (theme.text_secondary) {
                root.style.setProperty('--text-light', theme.text_secondary);
            }
            if (theme.border_color) root.style.setProperty('--border', theme.border_color);
            
            if (theme.accent_color) root.style.setProperty('--success', theme.accent_color);
            if (theme.warning_color) root.style.setProperty('--warning', theme.warning_color);
            if (theme.error_color) root.style.setProperty('--error', theme.error_color);
            
            // Apply font family if specified (use for both heading and body for consistency)
            if (theme.font_family) {
                root.style.setProperty('--font-family', theme.font_family);
                root.style.setProperty('--body-font', theme.font_family);
                root.style.setProperty('--heading-font', theme.font_family);
            }
            
            // Apply header background - use solid color instead of gradient
            const header = document.querySelector('header');
            if (header && theme.header_bg_color) {
                header.style.background = theme.header_bg_color; // Solid color
                header.style.backgroundImage = 'none'; // Remove gradient
                
                // Set header text color (white for dark backgrounds, dark for light)
                const headerColor = theme.header_bg_color;
                // Simple brightness check: if background is dark, use white text
                if (headerColor) {
                    const isDark = headerColor.toLowerCase() === '#4b4b4b' || 
                                   headerColor.toLowerCase() === '#061e29' ||
                                   headerColor.toLowerCase() === '#0f172a' ||
                                   parseInt(headerColor.replace('#', ''), 16) < 0x808080;
                    
                    const textColor = isDark ? 'white' : '#4B4B4B';
                    header.style.color = textColor;
                    
                    // Also update heading text colors
                    const h1 = header.querySelector('h1');
                    const subtitle = header.querySelector('.subtitle');
                    const logoutLink = document.getElementById('logoutLink');
                    const navLinks = header.querySelectorAll('.nav-link');
                    
                    if (h1) h1.style.color = textColor;
                    if (subtitle) subtitle.style.color = textColor;
                    if (logoutLink) logoutLink.style.color = textColor;
                    
                    // Update all nav links
                    navLinks.forEach(link => {
                        link.style.color = textColor;
                    });
                }
            }
            
            // Update logo based on institution
            updateInstitutionLogo();
            
            // Only apply UTK Torch styling if this is actually University of Tennessee
            // Check both institution name and color values for safety
            const isUTKTorch = isUniversityOfTennessee &&
                theme.primary_color && theme.primary_color.toLowerCase() === '#ff8200' &&
                theme.header_bg_color && theme.header_bg_color.toLowerCase() === '#4b4b4b';
            
            if (isUTKTorch) {
                root.classList.add('theme-torch', 'theme-utk-torch');
                root.style.setProperty('--smokey', '#4B4B4B');
                root.style.setProperty('--text', theme.text_primary || '#4B4B4B');
                root.style.setProperty('--text-light', theme.text_secondary || '#6B6B6B');
                root.style.setProperty('--bg', '#FAFAFA');
                root.style.setProperty('--bg-alt', '#F0F0F0');
                root.style.setProperty('--border', '#E0E0E0');
                root.style.setProperty('--link-blue', theme.secondary_color || '#1a73c5');
                const footer = document.querySelector('footer');
                if (footer) {
                    footer.style.background = '#4B4B4B';
                    footer.style.backgroundImage = 'none';
                }
                // Tab favicon always SpeechGradebook (never institution logo)
                const faviconEl = document.getElementById('faviconLink');
                if (faviconEl) { faviconEl.href = 'assets/3d-logo-transparent.png'; faviconEl.type = 'image/png'; }
            } else {
                // Remove Torch theme classes for non-UTK institutions
                root.classList.remove('theme-torch', 'theme-utk-torch');
                root.style.removeProperty('--smokey');
                root.style.removeProperty('--link-blue');
            }
            
            // Log what was applied
            log.debug('✓ Theme applied successfully');
            log.debug('  - Institution:', institutionName || 'Unknown');
            log.debug('  - Primary:', theme.primary_color);
            log.debug('  - Background:', theme.bg_primary);
            console.log('  - Text:', theme.text_primary);
            console.log('  - Mode:', theme.is_dark_mode ? 'Dark' : 'Light');
            console.log('  - UTK Torch applied:', isUTKTorch);
        }
        
        // Update logo based on institution
        async function updateInstitutionLogo() {
            const logo = document.getElementById('appLogo');
            if (!logo) {
                console.error('❌ Logo element not found');
                return;
            }
            
            console.log('🔄 Updating institution logo...');
            console.log('Current user institution:', currentUser?.institution_id);
            console.log('Current theme institution:', currentInstitutionTheme?.institution_id);
            
            // CRITICAL: Only use theme if it matches current user's institution
            // This prevents theme bleeding across institutions
            if (currentInstitutionTheme && 
                currentUser && 
                currentUser.institution_id &&
                currentInstitutionTheme.institution_id === currentUser.institution_id) {
                
                console.log('✓ Institution match verified - theme belongs to this user');
                
                // Check if institution has a custom logo in theme
                if (currentInstitutionTheme.logo_url) {
                    console.log('✓ Custom logo URL found:', currentInstitutionTheme.logo_url.substring(0, 50) + '...');
                    
                    // Use custom logo image
                    try {
                        logo.style.backgroundColor = '#ffffff';
                        logo.innerHTML = `<img src="${currentInstitutionTheme.logo_url}" 
                                              style="width: 100%; height: 100%; object-fit: contain; border-radius: 50%; padding: 12%;" 
                                              onerror="console.error('Logo image failed to load'); this.style.display='none';"
                                              onload="console.log('✓ Logo image loaded successfully');">`;
                        console.log('✓ Logo HTML updated with custom image');
                        return;
                    } catch (error) {
                        console.error('Error setting logo image:', error);
                    }
                }
            } else if (currentInstitutionTheme && currentUser && currentInstitutionTheme.institution_id !== currentUser.institution_id) {
                console.warn('⚠️ Institution mismatch detected! Theme will not be applied.');
                console.warn('  User institution:', currentUser.institution_id);
                console.warn('  Theme institution:', currentInstitutionTheme.institution_id);
            } else {
                console.log('No custom logo URL in theme or no theme loaded');
            }
            
            // Fallback: SpeechGradebook logo image (no custom institution logo)
            logo.innerHTML = '<img src="assets/3d-logo-transparent.png" alt="SpeechGradebook" style="width: 100%; height: 100%; object-fit: contain; object-position: center; border-radius: 50%; padding: 12%;">';
            logo.style.backgroundColor = '#ffffff';
            console.log('✓ Logo updated with default SpeechGradebook image');
        }
        
        // Route user to appropriate interface based on their tier
        async function routeToInterface() {
            console.log('🎯 Routing to interface for tier:', userTier);
            
            // Check for student evaluation view link
            const urlParams = new URLSearchParams(window.location.search);
            const viewMode = urlParams.get('view');
            const evalId = urlParams.get('evalId');
            const studentId = urlParams.get('studentId');
            
            if (viewMode === 'evaluation' && evalId && studentId) {
                // Show student view of evaluation
                await showStudentEvaluationView(evalId, studentId);
                return; // Don't continue with normal routing
            }
            
            // Determine interface type based on account tier
            let interfaceType = 'demo'; // default
            
            if (userTier === 'super_admin') {
                interfaceType = 'super_admin';
            } else if (userTier === 'admin') {
                interfaceType = 'admin';
            } else if (userTier === 'instructor') {
                interfaceType = 'instructor';
            } else if (userTier === 'demo') {
                interfaceType = 'demo';
            }
            
            console.log('✓ Interface type:', interfaceType);
            
            // Initialize the appropriate interface (await so admin dashboard has data before main app is shown)
            await initializeInterface(interfaceType);
            
            if (typeof setActiveSection === 'function') setActiveSection('dashboardSection', 'navDashboard');
            var mainOverlay = document.getElementById('mainAppLoadingOverlay');
            var dashboardEl = document.getElementById('dashboardSection');
            function hideOverlay() {
                if (mainOverlay) mainOverlay.style.display = 'none';
            }
            // Admin/super_admin: keep overlay until dashboard has painted (fixes white page on login)
            if (interfaceType === 'admin' || interfaceType === 'super_admin') {
                requestAnimationFrame(function() {
                    requestAnimationFrame(function() {
                        if (dashboardEl) void dashboardEl.offsetHeight; // force reflow
                        setTimeout(hideOverlay, 350);
                    });
                });
            } else {
                requestAnimationFrame(function() { requestAnimationFrame(hideOverlay); });
            }
        }
        
        // Move admin section content into dashboard (admin/super admin only); run once
        function moveAdminPanelIntoDashboard() {
            const container = document.getElementById('dashboardAdminContainer');
            const adminSection = document.getElementById('adminSection');
            if (!container || !adminSection || container.children.length > 0) return;
            while (adminSection.firstChild) container.appendChild(adminSection.firstChild);
            adminSection.style.display = 'none';
        }
        
        // Move Department Courses and All Institutions into Analytics Overview tab (admin/super admin)
        function moveCoursesSectionsIntoOverview() {
            const deptWrap = document.getElementById('overviewDepartmentCoursesWrap');
            const allWrap = document.getElementById('overviewAllInstitutionsWrap');
            const deptSection = document.getElementById('departmentCoursesSection');
            const allSection = document.getElementById('allInstitutionsSection');
            if (deptWrap && deptSection && deptSection.parentNode !== deptWrap) deptWrap.appendChild(deptSection);
            if (allWrap && allSection && allSection.parentNode !== allWrap) allWrap.appendChild(allSection);
        }
        
        // Initialize interface based on user type
        async function initializeInterface(interfaceType) {
            console.log('🚀 Initializing interface:', interfaceType);
            
            const isAdminOrSuperAdmin = (interfaceType === 'admin' || interfaceType === 'super_admin');
            // Hide all sections except dashboard for admin/super_admin (keep dashboard visible to avoid white page)
            document.querySelectorAll('.section').forEach(section => {
                if (section.id === 'dashboardSection' && isAdminOrSuperAdmin) {
                    section.style.display = 'block';
                } else {
                    section.style.display = 'none';
                }
            });
            
            // Courses card: show for instructor/demo, hide for admin/super admin
            const mainCoursesCard = document.getElementById('mainCoursesCard');
            if (mainCoursesCard) {
                mainCoursesCard.style.display = (interfaceType === 'admin' || interfaceType === 'super_admin') ? 'none' : '';
            }
            
            console.log('✓ Previous interface cleared');
            
            switch(interfaceType) {
                case 'super_admin':
                    initializeSuperAdminInterface();
                    break;
                case 'admin':
                    await initializeAdminInterface();
                    break;
                case 'instructor':
                    initializeInstructorInterface();
                    break;
                case 'demo':
                    initializeDemoInterface();
                    break;
                default:
                    console.warn('Unknown interface type:', interfaceType);
                    initializeDemoInterface();
            }
            if (typeof updateEvalProviderOptions === 'function') updateEvalProviderOptions();
            if (typeof updateApiKeysSectionVisibility === 'function') updateApiKeysSectionVisibility();
        }
        
        // Initialize Super Admin interface
        function initializeSuperAdminInterface() {
            console.log('🌐 Setting up Super Admin interface');
            
            // Super admin: default to My Courses; scope filter in main Courses card
            currentViewMode = 'own';
            currentFilterInstitutionId = null;
            currentFilterInstructorId = null;
            const scopeFilterRow = document.getElementById('courseScopeFilterRow');
            if (scopeFilterRow) {
                scopeFilterRow.style.display = 'flex';
                const opt = document.getElementById('courseScopeInstitutionOption');
                if (opt) opt.textContent = 'Institution';
            }
            loadCourseScopeInstitutions();
            updateViewMode();
            moveCoursesSectionsIntoOverview();
            const dashboardAdmin = document.getElementById('dashboardAdminContainer');
            if (dashboardAdmin) dashboardAdmin.style.display = 'none';

            const createInstitutionWrap = document.getElementById('createInstitutionWrap');
            if (createInstitutionWrap) createInstitutionWrap.style.display = 'block';
            const themeCustomizerWrap = document.getElementById('themeCustomizerWrap');
            if (themeCustomizerWrap) themeCustomizerWrap.style.display = '';
            const themeInstitutionRow = document.getElementById('themeInstitutionRow');
            if (themeInstitutionRow) themeInstitutionRow.style.display = 'block';
            const assignThemeWrap = document.getElementById('assignThemeWrap');
            if (assignThemeWrap) assignThemeWrap.style.display = 'block';
            loadInstitutionsForThemeCustomizer();
            const themeInstitutionSelect = document.getElementById('themeInstitutionSelect');
            if (themeInstitutionSelect) themeInstitutionSelect.removeEventListener('change', onThemeInstitutionChange);
            if (themeInstitutionSelect) themeInstitutionSelect.addEventListener('change', onThemeInstitutionChange);
            const complianceTestingWrap = document.getElementById('complianceTestingWrap');
            if (complianceTestingWrap) complianceTestingWrap.style.display = '';
            const llmTrainingSettingsWrap = document.getElementById('llmTrainingSettingsWrap');
            if (llmTrainingSettingsWrap) llmTrainingSettingsWrap.style.display = 'block';
            
            const instructorTabBar = document.getElementById('instructorDashboardTabBar');
            if (instructorTabBar) instructorTabBar.style.display = 'none';
            const unifiedSearchBar = document.getElementById('unifiedSearchBar');
            if (unifiedSearchBar) unifiedSearchBar.style.display = 'none';
            const rubricsWrap = document.getElementById('dashboardRubricsWrap');
            if (rubricsWrap) rubricsWrap.style.display = 'none';
            const analyticsSection = document.getElementById('analyticsSection');
            if (analyticsSection) analyticsSection.style.display = 'block';
            
            const overviewAllWrap = document.getElementById('overviewAllInstitutionsWrap');
            const overviewDeptWrap = document.getElementById('overviewDepartmentCoursesWrap');
            if (overviewAllWrap) overviewAllWrap.style.display = 'block';
            if (overviewDeptWrap) overviewDeptWrap.style.display = 'none';
            
            // Old filter section removed - filters now in compact toolbar
            
            // Hide department section, show user management (super admins manage all users)
            const deptSection = document.getElementById('departmentInstructorsSection');
            const userMgmtSection = document.getElementById('userManagementSection');
            if (deptSection) deptSection.style.display = 'none';
            if (userMgmtSection) userMgmtSection.style.display = 'block';
            
            // Remove any demo banners (unless in demo mode)
            if (currentViewMode !== 'demo') {
                const demoBanner = document.getElementById('demoBanner');
                if (demoBanner) demoBanner.remove();
            }
            
            console.log('✓ Super Admin interface ready');
            console.log('  - View:', currentViewMode);
            console.log('  - Can manage:', 'All institutions and users');
            
            // PHASE 5: Load filter dropdowns and All Institutions course table
            loadInstitutionsForFilter();
            loadInstructorsForFilter(''); // Load all instructors initially
            loadFilteredCoursesForSuperAdmin(); // Populate All Institutions table on first load
            
            // Show initial section (Dashboard after login; last viewed section on refresh)
            if (typeof showInitialSection === 'function') showInitialSection();
        }
        
        // Initialize Admin interface
        async function initializeAdminInterface() {
            console.log('🏛️ Setting up Admin interface');
            
            // Admin: default to My Courses; scope filter in main Courses card
            currentViewMode = 'own';
            currentFilterInstitutionId = null;
            currentFilterInstructorId = null;
            const scopeFilterRow = document.getElementById('courseScopeFilterRow');
            if (scopeFilterRow) {
                scopeFilterRow.style.display = 'flex';
                const opt = document.getElementById('courseScopeInstitutionOption');
                if (opt) opt.textContent = 'Department';
            }
            updateViewMode();
            moveCoursesSectionsIntoOverview();
            const dashboardAdmin = document.getElementById('dashboardAdminContainer');
            if (dashboardAdmin) dashboardAdmin.style.display = 'none';

            const createInstitutionWrap = document.getElementById('createInstitutionWrap');
            if (createInstitutionWrap) createInstitutionWrap.style.display = 'none';
            const themeCustomizerWrap = document.getElementById('themeCustomizerWrap');
            if (themeCustomizerWrap) themeCustomizerWrap.style.display = '';
            const assignThemeWrap = document.getElementById('assignThemeWrap');
            if (assignThemeWrap) assignThemeWrap.style.display = 'none';
            const complianceTestingWrap = document.getElementById('complianceTestingWrap');
            if (complianceTestingWrap) complianceTestingWrap.style.display = '';
            const llmTrainingSettingsWrap = document.getElementById('llmTrainingSettingsWrap');
            if (llmTrainingSettingsWrap) llmTrainingSettingsWrap.style.display = 'none';

            const instructorTabBar = document.getElementById('instructorDashboardTabBar');
            if (instructorTabBar) instructorTabBar.style.display = 'none';
            const unifiedSearchBar = document.getElementById('unifiedSearchBar');
            if (unifiedSearchBar) unifiedSearchBar.style.display = 'none';
            const rubricsWrap = document.getElementById('dashboardRubricsWrap');
            if (rubricsWrap) rubricsWrap.style.display = 'none';

            const overviewDeptWrap = document.getElementById('overviewDepartmentCoursesWrap');
            const overviewAllWrap = document.getElementById('overviewAllInstitutionsWrap');
            if (overviewDeptWrap) overviewDeptWrap.style.display = 'block';
            if (overviewAllWrap) overviewAllWrap.style.display = 'none';

            // Show the Department Courses card (table lives inside it; was display:none by default)
            const departmentCoursesSection = document.getElementById('departmentCoursesSection');
            if (departmentCoursesSection) departmentCoursesSection.style.display = 'block';

            // Old filter section removed - filters now in compact toolbar

            // Show department section, hide user management (admins manage department, not all users)
            const deptSection = document.getElementById('departmentInstructorsSection');
            const userMgmtSection = document.getElementById('userManagementSection');
            if (deptSection) deptSection.style.display = 'block';
            if (userMgmtSection) userMgmtSection.style.display = 'none';
            
            // Remove any demo banners (unless in demo mode)
            if (currentViewMode !== 'demo') {
                const demoBanner = document.getElementById('demoBanner');
                if (demoBanner) demoBanner.remove();
            }
            
            console.log('✓ Admin interface ready');
            console.log('  - Theme:', currentInstitution?.name || 'Default');
            console.log('  - View:', currentViewMode);
            console.log('  - Can manage:', 'Department instructors');
            
            // PHASE 5: Load filter dropdowns and courses, then show dashboard (fixes blank on first load)
            try {
                await loadDepartmentInstructorsForFilter();
                await loadFilteredCoursesForAdmin();
            } catch (e) {
                console.error('Admin load error (dashboard will still show):', e);
                const tbody = document.getElementById('adminCoursesTableBody');
                const resultsInfo = document.getElementById('adminFilterResultsInfo');
                if (tbody) tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; padding: 2rem; color: var(--text-light);">Could not load courses. Check console.</td></tr>';
                if (resultsInfo) resultsInfo.textContent = 'Load error';
            }
            if (typeof setActiveSection === 'function') setActiveSection('dashboardSection', 'navDashboard');
            if (typeof showInitialSection === 'function') showInitialSection();
        }
        
        // Initialize Instructor interface
        function initializeInstructorInterface() {
            console.log('👤 Setting up Instructor interface');
            
            // CRITICAL: Hide admin panel container so instructor never sees admin content
            const dashboardAdmin = document.getElementById('dashboardAdminContainer');
            if (dashboardAdmin) {
                dashboardAdmin.style.display = 'none';
                dashboardAdmin.innerHTML = '';
                console.log('  ✓ Dashboard admin container hidden');
            }
            const createInstitutionWrap = document.getElementById('createInstitutionWrap');
            if (createInstitutionWrap) createInstitutionWrap.style.display = 'none';
            const themeCustomizerWrap = document.getElementById('themeCustomizerWrap');
            if (themeCustomizerWrap) themeCustomizerWrap.style.display = 'none';
            const complianceTestingWrap = document.getElementById('complianceTestingWrap');
            if (complianceTestingWrap) complianceTestingWrap.style.display = 'none';
            const llmTrainingSettingsWrap = document.getElementById('llmTrainingSettingsWrap');
            if (llmTrainingSettingsWrap) llmTrainingSettingsWrap.style.display = 'none';
            
            // Instructors always see their own courses
            currentViewMode = 'own';
            
            // Filter courses section removed from instructor dashboard (replaced by Courses | Rubrics | Course Insights tabs)
            const overviewDeptWrap = document.getElementById('overviewDepartmentCoursesWrap');
            const overviewAllWrap = document.getElementById('overviewAllInstitutionsWrap');
            if (overviewDeptWrap) overviewDeptWrap.style.display = 'none';
            if (overviewAllWrap) overviewAllWrap.style.display = 'none';
            
            // CRITICAL: Remove view mode banner (from previous admin session)
            const viewBanner = document.getElementById('viewModeBanner');
            if (viewBanner) {
                viewBanner.remove();
                console.log('  ✓ View mode banner removed');
            }
            
            // Remove any demo banners
            const demoBanner = document.getElementById('demoBanner');
            if (demoBanner) {
                demoBanner.remove();
                console.log('  ✓ Demo banner removed');
            }
            
            // CRITICAL: Set view mode to 'own' (instructor sees only their courses)
            // This prevents institution banner from showing
            currentViewMode = 'own';
            
            // Instructor sees only their own courses: hide Show department/instructor filter
            const scopeFilterRow = document.getElementById('courseScopeFilterRow');
            if (scopeFilterRow) scopeFilterRow.style.display = 'none';
            
            // Instructor dashboard: show tab bar (Courses | Rubrics | Course Insights) and default to Courses tab
            const instructorTabBar = document.getElementById('instructorDashboardTabBar');
            if (instructorTabBar) instructorTabBar.style.display = 'block';
            const unifiedSearchBar = document.getElementById('unifiedSearchBar');
            if (unifiedSearchBar) unifiedSearchBar.style.display = 'block';
            if (typeof switchInstructorDashboardTab === 'function') switchInstructorDashboardTab('courses');
            // Current vs Previous courses tabs (instructor only)
            const coursesCurrentPreviousTabs = document.getElementById('coursesCurrentPreviousTabs');
            if (coursesCurrentPreviousTabs) coursesCurrentPreviousTabs.style.display = 'block';
            _coursesViewTab = 'current';
            const tabCurrent = document.getElementById('coursesTabCurrent');
            const tabPrevious = document.getElementById('coursesTabPrevious');
            if (tabCurrent) { tabCurrent.classList.add('instructor-dashboard-tab-active'); tabCurrent.onclick = function() { 
                switchToTab('current');
            }; }
            if (tabPrevious) { tabPrevious.classList.remove('instructor-dashboard-tab-active'); tabPrevious.onclick = function() { 
                switchToTab('previous');
            }; }
            // Render custom tabs
            renderCustomTabs();
            
            // Show Filter courses section for instructors (Phase 8)
            // Old filter section removed - filters now in compact toolbar
            
            console.log('✓ Instructor interface ready');
            console.log('  - Theme:', currentInstitution?.name || 'Default');
            console.log('  - View: Own courses only');
            
            // Handle route on page load (for deep linking)
            if (typeof Router !== 'undefined' && Router.handleRoute) {
                Router.handleRoute().catch(err => {
                    console.error('Error handling initial route:', err);
                    // Fallback: show initial section if route handling fails
                    if (typeof showInitialSection === 'function') showInitialSection();
                });
            } else {
                // Fallback: show initial section if Router not available
            if (typeof showInitialSection === 'function') showInitialSection();
            }
        }
        
        // Initialize Demo interface
        function initializeDemoInterface() {
            console.log('🎭 Setting up Demo interface');
            
            const createInstitutionWrap = document.getElementById('createInstitutionWrap');
            if (createInstitutionWrap) createInstitutionWrap.style.display = 'none';
            const themeCustomizerWrap = document.getElementById('themeCustomizerWrap');
            if (themeCustomizerWrap) themeCustomizerWrap.style.display = 'none';
            const llmTrainingSettingsWrap = document.getElementById('llmTrainingSettingsWrap');
            if (llmTrainingSettingsWrap) llmTrainingSettingsWrap.style.display = 'none';
            
            // Set view mode to demo
            currentViewMode = 'demo';
            
            // Show demo banner with View as: Instructor | Admin switcher
            if (typeof updateTierUI === 'function') updateTierUI();
            console.log('  ✓ Demo banner with view switcher shown');
            
            var instructorTabBar = document.getElementById('instructorDashboardTabBar');
            if (instructorTabBar) instructorTabBar.style.display = (typeof demoViewAs !== 'undefined' && demoViewAs === 'admin') ? 'none' : 'block';
            var unifiedSearchBar = document.getElementById('unifiedSearchBar');
            if (unifiedSearchBar) unifiedSearchBar.style.display = (typeof demoViewAs !== 'undefined' && demoViewAs === 'admin') ? 'none' : 'block';
            if (typeof demoViewAs !== 'undefined' && demoViewAs === 'instructor' && typeof switchInstructorDashboardTab === 'function') switchInstructorDashboardTab('courses');
            if (typeof demoViewAs !== 'undefined' && demoViewAs === 'admin') {
                var mainCard = document.getElementById('mainCoursesCard');
                var rubricsWrap = document.getElementById('dashboardRubricsWrap');
                var analyticsSec = document.getElementById('analyticsSection');
                if (mainCard) mainCard.style.display = 'none';
                if (rubricsWrap) rubricsWrap.style.display = 'none';
                if (analyticsSec) analyticsSec.style.display = 'block';
                var adminTestWrap = document.getElementById('adminTestTableBtnWrap');
                var superTestWrap = document.getElementById('superAdminTestTableBtnWrap');
                if (adminTestWrap) adminTestWrap.style.display = '';
                if (superTestWrap) superTestWrap.style.display = '';
            } else {
                var adminTestWrap = document.getElementById('adminTestTableBtnWrap');
                var superTestWrap = document.getElementById('superAdminTestTableBtnWrap');
                if (adminTestWrap) adminTestWrap.style.display = 'none';
                if (superTestWrap) superTestWrap.style.display = 'none';
            }
            
            console.log('✓ Demo interface ready');
            console.log('  - Storage: localStorage only');
            console.log('  - Features: Full evaluation features for testing');
            
            // Ensure Demo Theme Customizer tab is visible in Settings (so it shows when user opens Settings)
            var demoTabBtn = document.getElementById('settingsTabBtnDemo');
            if (demoTabBtn) {
                demoTabBtn.style.display = '';
                demoTabBtn.setAttribute('aria-hidden', 'false');
            }
            
            // Show initial section (Dashboard after login; last viewed section on refresh)
            if (typeof showInitialSection === 'function') showInitialSection();
        }
        
        // Update UI elements based on account tier
        function updateTierUI() {
            const isDemoMode = userTier === 'demo' || currentViewMode === 'demo';
            
            // Remove old banners
            const oldDemoBanner = document.getElementById('demoBanner');
            if (oldDemoBanner) oldDemoBanner.remove();
            
            if (isDemoMode && currentViewMode === 'demo') {
                const header = document.querySelector('header .container');
                let banner = document.getElementById('demoBanner');
                if (header && !banner) {
                    banner = document.createElement('div');
                    banner.id = 'demoBanner';
                    header.appendChild(banner);
                }
                if (banner) {
                    banner.style.cssText = 'background: #d4af37; color: var(--primary-dark); padding: 0.5rem 1rem; border-radius: 0.25rem; margin-top: 0.5rem; display: flex; align-items: center; justify-content: center; gap: 1rem; flex-wrap: wrap; border: 1px solid rgba(0,0,0,0.15);';
                    banner.innerHTML = '<span style="font-weight: 600; display: inline-flex; align-items: center; gap: 0.35rem;"><i data-lucide="theater" style="width:1.1em;height:1.1em;"></i> Demo Mode</span><span style="font-size: 0.9rem;">Data stored in localStorage only (not saved to database)</span><span style="display: inline-flex; align-items: center; gap: 0.5rem;"><label style="font-size: 0.875rem; font-weight: 600;">View as:</label><button type="button" id="demoViewInstructor" class="btn-secondary" style="padding: 0.25rem 0.75rem; font-size: 0.8rem; background: rgba(0,0,0,0.12); color: var(--primary-dark); border-color: rgba(0,0,0,0.2);"><span class="icon-with-text"><i data-lucide="user" style="width:1em;height:1em;"></i> Instructor</span></button><button type="button" id="demoViewAdmin" class="btn-secondary" style="padding: 0.25rem 0.75rem; font-size: 0.8rem; background: rgba(0,0,0,0.12); color: var(--primary-dark); border-color: rgba(0,0,0,0.2);"><span class="icon-with-text"><i data-lucide="shield" style="width:1em;height:1em;"></i> Admin</span></button></span>';
                    if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: banner });
                    var instrBtn = document.getElementById('demoViewInstructor');
                    var adminBtn = document.getElementById('demoViewAdmin');
                    if (instrBtn) instrBtn.onclick = function() { setDemoViewAs('instructor'); };
                    if (adminBtn) adminBtn.onclick = function() { setDemoViewAs('admin'); };
                    updateDemoViewButtons();
                }
            }
        }
        function setDemoViewAs(view) {
            if (typeof demoViewAs !== 'undefined') demoViewAs = view;
            if (typeof updateDemoViewButtons === 'function') updateDemoViewButtons();
            if (typeof updateAnalyticsUIForRole === 'function') updateAnalyticsUIForRole();
            var instructorTabBar = document.getElementById('instructorDashboardTabBar');
            if (instructorTabBar) instructorTabBar.style.display = view === 'instructor' ? 'block' : 'none';
            var unifiedSearchBar = document.getElementById('unifiedSearchBar');
            if (unifiedSearchBar) unifiedSearchBar.style.display = view === 'instructor' ? 'block' : 'none';
            var adminTestWrap = document.getElementById('adminTestTableBtnWrap');
            var superTestWrap = document.getElementById('superAdminTestTableBtnWrap');
            if (adminTestWrap) adminTestWrap.style.display = view === 'admin' ? '' : 'none';
            if (superTestWrap) superTestWrap.style.display = view === 'admin' ? '' : 'none';
            if (view === 'instructor') {
                if (typeof switchInstructorDashboardTab === 'function') switchInstructorDashboardTab('courses');
            } else {
                var mainCard = document.getElementById('mainCoursesCard');
                var rubricsWrap = document.getElementById('dashboardRubricsWrap');
                var analyticsSec = document.getElementById('analyticsSection');
                if (mainCard) mainCard.style.display = 'none';
                if (rubricsWrap) rubricsWrap.style.display = 'none';
                if (analyticsSec) analyticsSec.style.display = 'block';
            }
            if (typeof loadDemoAnalytics === 'function') loadDemoAnalytics(view);
        }
        function updateDemoViewButtons() {
            var instrBtn = document.getElementById('demoViewInstructor');
            var adminBtn = document.getElementById('demoViewAdmin');
            var active = typeof demoViewAs !== 'undefined' ? demoViewAs : 'instructor';
            if (instrBtn) { instrBtn.style.background = active === 'instructor' ? 'var(--primary-dark)' : 'rgba(0,0,0,0.12)'; instrBtn.style.color = active === 'instructor' ? 'white' : 'var(--primary-dark)'; instrBtn.style.borderColor = active === 'instructor' ? 'var(--primary-dark)' : 'rgba(0,0,0,0.2)'; }
            if (adminBtn) { adminBtn.style.background = active === 'admin' ? 'var(--primary-dark)' : 'rgba(0,0,0,0.12)'; adminBtn.style.color = active === 'admin' ? 'white' : 'var(--primary-dark)'; adminBtn.style.borderColor = active === 'admin' ? 'var(--primary-dark)' : 'rgba(0,0,0,0.2)'; }
        }
        
        // Show information about upgrading to research partner
        function showUpgradeInfo() {
            alert('To become a Research Partner with full features:\n\n' +
                  '• Full evaluation storage\n' +
                  '• Correction tracking for AI improvement\n' +
                  '• Contribute to research\n\n' +
                  'Contact: speechgradebook@proton.me');
        }
        
        // Check if user has research partner access (can save to database)
        function hasResearchAccess() {
            // Demo users can't save to database
            if (userTier === 'demo') {
                return false;
            }
            // All other tiers can save
            return ['instructor', 'admin', 'super_admin'].includes(userTier);
        }
        
        // Check if user is admin (institution admin)
        // Check if user is admin (institution admin, not super admin)
        function isAdmin() {
            return currentUser?.is_admin === true && userTier === 'admin';
        }
        
        // Check if user is super admin
        function isSuperAdmin() {
            return currentUser?.is_super_admin === true && userTier === 'super_admin';
        }
        
        // Check if user can manage other users (admin OR super admin)
        function canManageUsers() {
            return isAdmin() || isSuperAdmin();
        }
        
        // Check if user can view institution-wide data (admin OR super admin)
        function canViewInstitutionData() {
            return isAdmin() || isSuperAdmin();
        }
        
        // Check if user has any admin privileges (used for UI elements)
        function hasAdminAccess() {
            return currentUser?.is_admin === true || currentUser?.is_super_admin === true;
        }
        
        // Check if user is logged in
        async function checkAuth() {
            if (!supabaseClient) {
                console.log('Supabase not available - skipping auth');
                showMainApp();
                return;
            }
            
            const { data: { session } } = await supabaseClient.auth.getSession();
            
            if (session) {
                currentUser = session.user;
                console.log('✓ Logged in as:', currentUser.email);
                
                // Show main app first so theme and interface apply to it, not the login page (fixes login page color flash and blank admin)
                showMainApp();
                await loadUserTier();
                maybeShowInstructorLLMConsent();
            } else {
                console.log('Not logged in - showing auth screen');
                showAuthScreen();
                // Handle hash-based routing (backward compatibility)
                if (window.location.hash === '#register') {
                    showRegisterForm();
                } else if (window.location.hash && window.location.hash !== '#') {
                    // Convert hash to path-based route if possible
                    const hash = window.location.hash.substring(1);
                    if (typeof Router !== 'undefined' && Router.handleRoute) {
                        // Clear hash and let Router handle it
                        window.history.replaceState({}, '', window.location.pathname + window.location.search);
                        Router.handleRoute();
                    }
                }
            }
        }
        
        function showPendingApprovalScreen() {
            var loadingEl = document.getElementById('authLoadingOverlay');
            if (loadingEl) loadingEl.classList.add('hidden');
            const authScreen = document.getElementById('authScreen');
            if (authScreen) authScreen.classList.add('hidden');
            const mainApp = document.getElementById('mainApp');
            if (mainApp) mainApp.style.display = 'none';
            const pendingEl = document.getElementById('pendingApprovalScreen');
            if (pendingEl) pendingEl.style.display = 'flex';
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: pendingEl });
        }
        
        function showAuthScreen() {
            var loadingEl = document.getElementById('authLoadingOverlay');
            if (loadingEl) loadingEl.classList.add('hidden');
            const pendingEl = document.getElementById('pendingApprovalScreen');
            if (pendingEl) pendingEl.style.display = 'none';
            // Always reset theme so login page looks consistent (no leftover institution theme)
            resetThemeToDefault();
            const authScreen = document.getElementById('authScreen');
            if (authScreen) authScreen.classList.remove('hidden');
            const mainApp = document.getElementById('mainApp');
            if (mainApp) mainApp.style.display = 'none';
            // Show banner if Supabase credentials are missing (e.g. Render env vars not set)
            const configBanner = document.getElementById('configMissingBanner');
            if (configBanner) {
                if (typeof CONFIG !== 'undefined' && (!CONFIG.SUPABASE_URL || !CONFIG.SUPABASE_ANON_KEY)) {
                    configBanner.classList.remove('hidden');
                } else {
                    configBanner.classList.add('hidden');
                }
            }
        }
        
        function enterDemoMode() {
            currentUser = null;
            userTier = 'demo';
            currentViewMode = 'demo';
            currentInstitution = null;
            currentInstitutionTheme = null;
            window.institutionLogoData = null;
            // Clear all demo (guest) localStorage so each "Try demo" starts with a clean slate
            try {
                const keysToRemove = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('guest_')) keysToRemove.push(key);
                }
                keysToRemove.forEach(k => localStorage.removeItem(k));
            } catch (e) { console.warn('Could not clear demo storage', e); }
            resetThemeToDefault();
            if (typeof sessionStorage !== 'undefined') sessionStorage.setItem('justLoggedIn', '1');
            showMainApp();
            routeToInterface();
        }
        
        // Show student view of evaluation (read-only, no login required)
        async function showStudentEvaluationView(evalId, studentId) {
            console.log('📧 Showing student evaluation view:', evalId, studentId);
            
            // Show main app
            showMainApp();
            
            // Load evaluation from Supabase (public read should work if RLS allows)
            let evaluation = null;
            let videoUrl = null;
            let audioUrl = null;
            
            if (supabaseClient) {
                try {
                    const { data, error } = await supabaseClient
                        .from('evaluations')
                        .select('*')
                        .eq('id', evalId)
                        .eq('student_id', studentId)
                        .single();
                    
                    if (data && !error) {
                        evaluation = data.evaluation_data;
                        if (typeof evaluation === 'string') {
                            try { evaluation = JSON.parse(evaluation); } catch (_) { evaluation = null; }
                        }
                        if (evaluation && data.transcript != null) evaluation.transcript = data.transcript;
                        videoUrl = data.video_url || null;
                        audioUrl = data.audio_url || null;
                        if (videoUrl) evaluation.video_url = videoUrl;
                        if (audioUrl) evaluation.audio_url = audioUrl;
                    } else {
                        console.error('Error loading evaluation:', error);
                    }
                } catch (e) {
                    console.error('Error accessing evaluation:', e);
                }
            }
            
            if (!evaluation) {
                document.getElementById('mainApp').innerHTML = `
                    <div style="padding: 3rem; text-align: center;">
                        <h2 style="color: var(--error);">Evaluation Not Found</h2>
                        <p style="color: var(--text-light); margin-top: 1rem;">The evaluation you're looking for could not be found or is no longer available.</p>
                        <p style="color: var(--text-light); margin-top: 0.5rem;">Please contact your instructor if you believe this is an error.</p>
                    </div>
                `;
                return;
            }
            
            // Set evaluation results for display
            evaluationResults = evaluation;
            
            // Show evaluation section and display results (read-only)
            const evalSection = document.getElementById('evaluateSection');
            if (evalSection) {
                evalSection.classList.add('active');
                // Hide other sections
                ['dashboardSection', 'settingsSection', 'helpSection'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.classList.remove('active');
                });
            }
            
            // Hide all steps and show results
            ['uploadStep', 'detailsStep', 'processingStep'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.classList.add('hidden');
            });
            
            const resultsStep = document.getElementById('resultsStep');
            if (resultsStep) {
                resultsStep.classList.remove('hidden');
            }
            
            // Display results (read-only - hide edit buttons)
            displayResults(evaluation);
            
            // Hide save/edit buttons for student view
            const saveBtn = document.querySelector('button[onclick="openSaveModal()"]');
            const moveBtn = document.getElementById('moveEvalBtn');
            const editBtns = document.querySelectorAll('button[onclick*="edit"]');
            if (saveBtn) saveBtn.style.display = 'none';
            if (moveBtn) moveBtn.style.display = 'none';
            editBtns.forEach(btn => {
                if (btn && btn.onclick && btn.onclick.toString().includes('edit')) {
                    btn.style.display = 'none';
                }
            });
            
            // Add student view banner
            const resultsContent = document.getElementById('resultsContent');
            if (resultsContent) {
                const banner = document.createElement('div');
                banner.style.cssText = 'background: #e3f2fd; border-left: 4px solid #2196f3; padding: 1rem 1.5rem; border-radius: 0.5rem; margin-bottom: 1.5rem;';
                banner.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <i data-lucide="info" style="width:1.25em;height:1.25em;"></i>
                        <strong style="color: #1976d2;">Student View</strong>
                    </div>
                    <p style="margin: 0.5rem 0 0 0; color: #1565c0; font-size: 0.9rem;">This is a read-only view of your evaluation. Contact your instructor with any questions.</p>
                `;
                resultsContent.insertBefore(banner, resultsContent.firstChild);
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: banner });
            }
        }
        
        // Update user display to show name instead of email
        function updateUserDisplay() {
            const userDisplayEl = document.getElementById('userDisplay');
            const userDisplayDropdown = document.getElementById('userDisplayDropdown');
            let displayName = 'Demo';
            if (currentUser) {
                // Prioritize full_name from user_profiles (loaded by loadUserTier)
                // Fall back to user_metadata.full_name, then email
                displayName = currentUser.full_name || 
                              currentUser.user_metadata?.full_name || 
                              currentUser.email || 
                              'User';
            }
            if (userDisplayEl) {
                userDisplayEl.textContent = displayName;
            }
            if (userDisplayDropdown) {
                userDisplayDropdown.textContent = displayName;
            }
        }
        
        // Account Dropdown Functions
        function toggleAccountDropdown() {
            const trigger = document.getElementById('accountDropdownTrigger');
            const menu = document.getElementById('accountDropdownMenu');
            if (!trigger || !menu) return;
            
            const isExpanded = trigger.getAttribute('aria-expanded') === 'true';
            trigger.setAttribute('aria-expanded', !isExpanded);
            menu.classList.toggle('hidden', isExpanded);
            
            // Close dropdown when clicking outside
            if (!isExpanded) {
                setTimeout(() => {
                    document.addEventListener('click', closeAccountDropdownOnOutsideClick, true);
                }, 0);
            } else {
                document.removeEventListener('click', closeAccountDropdownOnOutsideClick, true);
            }
        }
        
        function closeAccountDropdown() {
            const trigger = document.getElementById('accountDropdownTrigger');
            const menu = document.getElementById('accountDropdownMenu');
            if (trigger) trigger.setAttribute('aria-expanded', 'false');
            if (menu) menu.classList.add('hidden');
            document.removeEventListener('click', closeAccountDropdownOnOutsideClick, true);
        }
        
        function closeAccountDropdownOnOutsideClick(event) {
            const wrapper = document.querySelector('.account-dropdown-wrapper');
            if (wrapper && !wrapper.contains(event.target)) {
                closeAccountDropdown();
            }
        }
        
        // Evaluation actions dropdown functions
        function toggleEvalActionsDropdown(evalId) {
            const btn = document.getElementById('evalActionsBtn_' + evalId);
            const menu = document.getElementById('evalActionsMenu_' + evalId);
            if (!btn || !menu) {
                console.warn('Menu or button not found for evalId:', evalId);
                return;
            }
            
            // Close all other dropdowns first
            document.querySelectorAll('.eval-actions-menu:not(.hidden)').forEach(m => {
                if (m.id !== 'evalActionsMenu_' + evalId) {
                    m.classList.add('hidden');
                }
            });
            
            const isExpanded = !menu.classList.contains('hidden');
            
            if (!isExpanded) {
                // Opening menu - ensure parent has relative positioning
                const parent = menu.parentElement;
                if (parent && window.getComputedStyle(parent).position === 'static') {
                    parent.style.position = 'relative';
                }
                
                // Show menu
                menu.classList.remove('hidden');
                
                // Close dropdown when clicking outside
                setTimeout(() => {
                    document.addEventListener('click', (e) => closeEvalActionsDropdownOnOutsideClick(e, evalId), true);
                }, 0);
            } else {
                // Closing menu
                menu.classList.add('hidden');
                document.removeEventListener('click', (e) => closeEvalActionsDropdownOnOutsideClick(e, evalId), true);
            }
        }
        
        // Student actions dropdown function (Apple HIG style)
        window.toggleStudentActions = function(studentId, evt) {
            try {
                const event = evt || window.event;
                if (event) {
                    event.stopPropagation();
                    event.preventDefault();
                }
            const menu = document.getElementById('studentActionsMenu_' + studentId);
            if (!menu) {
                console.warn('Menu not found for student:', studentId);
                return false;
            }
            
            // Find the button - try multiple methods for reliability
            let btn = null;
            if (event && event.target) {
                // First try: use the event target if it's a button
                btn = event.target.closest('button');
            }
            if (!btn) {
                // Second try: find by aria-haspopup in the same parent container
                btn = menu.parentElement?.querySelector('button[aria-haspopup="true"]');
            }
            if (!btn) {
                // Third try: find by onclick attribute containing the function name
                btn = menu.parentElement?.querySelector(`button[onclick*="toggleStudentActions"]`);
            }
            if (!btn) {
                // Fourth try: find any button in the parent container
                btn = menu.parentElement?.querySelector('button');
            }
            
            if (!btn) {
                console.warn('Button not found for student:', studentId, 'Menu parent:', menu.parentElement);
                return false;
            }
            
            // Close all other student action menus first
            document.querySelectorAll('.student-actions-menu:not(.hidden)').forEach(m => {
                if (m.id !== menu.id) {
                    m.classList.add('hidden');
                    const b = m.parentElement?.querySelector('button[aria-haspopup="true"]');
                    if (b) b.setAttribute('aria-expanded', 'false');
                }
            });
            
            const isExpanded = !menu.classList.contains('hidden');
            if (isExpanded) {
                menu.classList.add('hidden');
                btn.setAttribute('aria-expanded', 'false');
            } else {
                // Remove hidden class first so we can measure the menu
                menu.classList.remove('hidden');
                btn.setAttribute('aria-expanded', 'true');
                
                // Position menu using fixed positioning to avoid clipping by table cells
                const btnRect = btn.getBoundingClientRect();
                menu.style.position = 'fixed';
                menu.style.right = Math.max(10, window.innerWidth - btnRect.right) + 'px';
                // Position below button, or above if not enough space
                const spaceBelow = window.innerHeight - btnRect.bottom;
                const spaceAbove = btnRect.top;
                const estimatedMenuHeight = 200; // Approximate menu height
                
                if (spaceBelow >= estimatedMenuHeight || spaceBelow > spaceAbove) {
                    // Position below button
                    menu.style.top = (btnRect.bottom + 5) + 'px';
                    menu.style.bottom = 'auto';
                } else {
                    // Position above button
                    menu.style.top = 'auto';
                    menu.style.bottom = Math.max(10, window.innerHeight - btnRect.top + 5) + 'px';
                }
                
                menu.style.left = 'auto';
                menu.style.zIndex = '99999';
                menu.style.maxHeight = (window.innerHeight - 20) + 'px';
                menu.style.overflowY = 'auto';
                menu.style.display = 'block';
                menu.style.visibility = 'visible';
                
                // Initialize icons in the menu
                if (typeof lucide !== 'undefined' && lucide.createIcons) {
                    lucide.createIcons({ root: menu });
                }
            }
                return false;
            } catch (error) {
                console.error('Error in toggleStudentActions:', error);
                return false;
            }
        }
        
        // Close student actions menus when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.student-actions-menu') && !e.target.closest('button[onclick*="toggleStudentActions"]')) {
                document.querySelectorAll('.student-actions-menu:not(.hidden)').forEach(m => {
                    m.classList.add('hidden');
                    const btn = m.parentElement?.querySelector('button[aria-haspopup="true"]');
                    if (btn) btn.setAttribute('aria-expanded', 'false');
                });
            }
        });
        
        function closeEvalActionsDropdown(evalId) {
            const menu = document.getElementById('evalActionsMenu_' + evalId);
            if (menu) {
                menu.classList.add('hidden');
            }
        }
        
        function closeEvalActionsDropdownOnOutsideClick(event, evalId) {
            const dropdown = document.querySelector('#evalActionsMenu_' + evalId)?.closest('.eval-actions-dropdown');
            if (dropdown && !dropdown.contains(event.target)) {
                closeEvalActionsDropdown(evalId);
                document.removeEventListener('click', (e) => closeEvalActionsDropdownOnOutsideClick(e, evalId), true);
            }
        }
        
        // Expandable Search Functions
        function toggleSearch() {
            const button = document.getElementById('searchIconButton');
            const searchWrap = document.getElementById('accountSearchWrap');
            const searchInput = document.getElementById('accountSearchInput');
            
            if (!button || !searchWrap) return;
            
            const isExpanded = button.getAttribute('aria-expanded') === 'true';
            button.setAttribute('aria-expanded', !isExpanded);
            searchWrap.classList.toggle('hidden', isExpanded);
            
            // Focus input when expanded
            if (!isExpanded && searchInput) {
                setTimeout(() => {
                    searchInput.focus();
                }, 100);
            }
            
            // Close search when clicking outside
            if (!isExpanded) {
                setTimeout(() => {
                    document.addEventListener('click', closeSearchOnOutsideClick, true);
                }, 0);
            } else {
                document.removeEventListener('click', closeSearchOnOutsideClick, true);
            }
        }
        
        function closeSearchOnOutsideClick(event) {
            const wrapper = document.querySelector('.search-wrapper');
            if (wrapper && !wrapper.contains(event.target)) {
                const button = document.getElementById('searchIconButton');
                const searchWrap = document.getElementById('accountSearchWrap');
                if (button) button.setAttribute('aria-expanded', 'false');
                if (searchWrap) searchWrap.classList.add('hidden');
                document.removeEventListener('click', closeSearchOnOutsideClick, true);
            }
        }
        
        // Close search when pressing Escape
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const searchWrap = document.getElementById('accountSearchWrap');
                const button = document.getElementById('searchIconButton');
                if (searchWrap && !searchWrap.classList.contains('hidden')) {
                    if (button) button.setAttribute('aria-expanded', 'false');
                    searchWrap.classList.add('hidden');
                    document.removeEventListener('click', closeSearchOnOutsideClick, true);
                }
            }
        });
        
        function showMainApp() {
            var loadingEl = document.getElementById('authLoadingOverlay');
            if (loadingEl) loadingEl.classList.add('hidden');
            const authEl = document.getElementById('authScreen');
            if (authEl) authEl.classList.add('hidden');
            const mainApp = document.getElementById('mainApp');
            if (mainApp) mainApp.style.display = 'block';
            var mainOverlay = document.getElementById('mainAppLoadingOverlay');
            if (mainOverlay) {
                mainOverlay.style.display = 'flex';
            }
            
            // Update user display with name (will be updated again after loadUserTier completes)
            updateUserDisplay();
            
            // Remove demo banner when user is not in demo mode; repeat a few times in case UI adds it later
            if (userTier !== 'demo') {
                if (typeof removeDemoBannerIfPresent === 'function') removeDemoBannerIfPresent();
                setTimeout(function() { if (typeof removeDemoBannerIfPresent === 'function') removeDemoBannerIfPresent(); }, 100);
                setTimeout(function() { if (typeof removeDemoBannerIfPresent === 'function') removeDemoBannerIfPresent(); }, 400);
            }
            if (typeof initAccountSearch === 'function') initAccountSearch();
        }

        // One-time instructor LLM consent (user-agreement style)
        function maybeShowInstructorLLMConsent() {
            if (!currentUser || !supabaseClient || userTier === 'demo') return;
            if (currentUser.llm_training_consent_given === true) return;
            // Anyone who can create evaluations (instructor, admin, super_admin) sees the agreement
            var overlay = document.getElementById('instructorConsentOverlay');
            var checkbox = document.getElementById('instructorConsentCheckbox');
            var submitBtn = document.getElementById('instructorConsentSubmit');
            if (!overlay || !checkbox || !submitBtn) return;
            overlay._focusReturn = document.activeElement && document.activeElement.nodeName ? document.activeElement : null;
            overlay.hidden = false;
            checkbox.checked = false;
            submitBtn.disabled = true;
            checkbox.onchange = function() { submitBtn.disabled = !checkbox.checked; };
            checkbox.focus();
            submitBtn.onclick = function() {
                if (!checkbox.checked) return;
                submitBtn.disabled = true;
                supabaseClient.from('user_profiles')
                    .update({
                        llm_training_consent_given: true,
                        llm_training_consent_given_at: new Date().toISOString()
                    })
                    .eq('id', currentUser.id)
                    .then(function(res) {
                        if (res.error) {
                            console.warn('Could not save instructor consent:', res.error);
                            submitBtn.disabled = false;
                            return;
                        }
                        currentUser.llm_training_consent_given = true;
                        overlay.hidden = true;
                        var returnEl = overlay._focusReturn;
                        if (returnEl && typeof returnEl.focus === 'function') returnEl.focus();
                        if (typeof removeDemoBannerIfPresent === 'function') removeDemoBannerIfPresent();
                    })
                    .catch(function(err) {
                        console.warn('Instructor consent update failed:', err);
                        submitBtn.disabled = false;
                    });
            };
        }
        
        function showLoginForm() {
            const loginDiv = document.getElementById('loginFormDiv');
            if (loginDiv) loginDiv.classList.remove('hidden');
            const regDiv = document.getElementById('registerFormDiv');
            if (regDiv) regDiv.classList.add('hidden');
        }
        
        function showRegisterForm() {
            const loginDiv = document.getElementById('loginFormDiv');
            if (loginDiv) loginDiv.classList.add('hidden');
            const regDiv = document.getElementById('registerFormDiv');
            if (regDiv) regDiv.classList.remove('hidden');
        }
        
        // Login
        async function login(email, password) {
            try {
                console.log('=== LOGGING IN ===');
                
                // CRITICAL: Clear previous user state FIRST
                currentUser = null;
                userTier = 'demo';
                currentViewMode = 'own';
                currentInstitution = null;
                currentInstitutionTheme = null;
                window.institutionLogoData = null;
                window.pendingCustomFonts = null;
                cachedDepartmentInstructors = [];
                resetThemeToDefault(); // So previous user's theme doesn't stick
                
                console.log('✓ Previous state cleared');
                
                const { data, error } = await supabaseClient.auth.signInWithPassword({
                    email: email,
                    password: password
                });
                
                if (error) {
                    alert('Login failed: ' + error.message);
                    return false;
                }
                
                currentUser = data.user;
                console.log('✓ Login successful:', email);
                
                // Flag so we show Dashboard (not last section) on this load
                if (typeof sessionStorage !== 'undefined') sessionStorage.setItem('justLoggedIn', '1');
                
                // Load new user's profile and theme
                await checkAuth();
                
                // Reload data for this user
                await loadClasses();
                await loadRubrics();
                
                return true;
            } catch (error) {
                console.error('Login error:', error);
                alert('Login failed: ' + error.message);
                return false;
            }
        }
        
        // Register
        async function register(name, email, password, requestedRole) {
            try {
                // Check if user was invited
                let invitedTier = 'demo';
                let invitation = null;
                
                if (supabaseClient) {
                    try {
                        const { data: invites, error: inviteError } = await supabaseClient
                            .from('invitations')
                            .select('*')
                            .eq('email', email)
                            .eq('status', 'pending')
                            .gt('expires_at', new Date().toISOString())
                            .order('created_at', { ascending: false })
                            .limit(1);
                        
                        if (!inviteError && invites && invites.length > 0) {
                            invitation = invites[0];
                            invitedTier = invitation.account_tier || 'research_partner';
                            console.log('✓ Found valid invitation for', email, '- will upgrade to', invitedTier);
                        }
                    } catch (err) {
                        console.log('Could not check invitations:', err);
                    }
                }
                
                // Non-invited signups: require .edu email
                if (!invitation) {
                    const emailLower = (email || '').trim().toLowerCase();
                    if (!emailLower.endsWith('.edu')) {
                        alert('Accounts without an invitation must use a .edu email address.');
                        return false;
                    }
                    if (!requestedRole || !['instructor', 'admin'].includes(requestedRole)) {
                        requestedRole = 'instructor';
                    }
                }
                
                // First create the auth user
                const { data: authData, error: authError } = await supabaseClient.auth.signUp({
                    email: email,
                    password: password
                });
                
                if (authError) {
                    alert('Registration failed: ' + authError.message);
                    return false;
                }
                
                if (!authData.user) {
                    alert('Registration failed: No user data returned');
                    return false;
                }
                
                // Split name into first and last
                const nameParts = name.trim().split(' ');
                const firstName = nameParts[0] || '';
                const lastName = nameParts.slice(1).join(' ') || '';
                
                const isPendingApproval = !invitation;
                const userStatus = isPendingApproval ? 'pending_approval' : 'active';
                const userRole = isPendingApproval ? (requestedRole === 'admin' ? 'admin' : 'instructor') : 'instructor';
                
                // Create user record in users table (legacy)
                const { data: userData, error: userError } = await supabaseClient
                    .from('users')
                    .insert([{
                        id: authData.user.id,
                        email: email,
                        password_hash: 'managed_by_supabase_auth',
                        role: userRole,
                        account_type: 'individual',
                        status: userStatus,
                        first_name: firstName,
                        last_name: lastName
                    }])
                    .select();
                
                if (userError) {
                    console.error('Failed to create user record:', userError);
                }
                
                if (invitation) {
                    // Update user_profile with invited tier
                    try {
                        const { error: profileError } = await supabaseClient
                            .from('user_profiles')
                            .update({
                                account_tier: invitedTier,
                                full_name: name,
                                institution: invitation.institution
                            })
                            .eq('id', authData.user.id);
                        
                        if (profileError) {
                            console.error('Could not upgrade account:', profileError);
                        } else {
                            console.log('✓ Account upgraded to', invitedTier);
                            await supabaseClient
                                .from('invitations')
                                .update({
                                    status: 'accepted',
                                    accepted_at: new Date().toISOString()
                                })
                                .eq('id', invitation.id);
                        }
                    } catch (err) {
                        console.error('Error upgrading account:', err);
                    }
                } else {
                    // Pending approval: set approval_status and requested_role on user_profiles
                    try {
                        const { error: profileError } = await supabaseClient
                            .from('user_profiles')
                            .update({
                                approval_status: 'pending_approval',
                                requested_role: requestedRole,
                                full_name: name
                            })
                            .eq('id', authData.user.id);
                        
                        if (profileError) {
                            console.error('Could not set pending approval:', profileError);
                        }
                        // Notify Super Admin via Slack (app endpoint forwards to webhook)
                        try {
                            const base = window.location.origin;
                            await fetch(base + '/notify-signup-request', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    email: email,
                                    full_name: name,
                                    requested_role: requestedRole
                                })
                            });
                        } catch (notifyErr) {
                            console.warn('Could not send signup notification:', notifyErr);
                        }
                    } catch (err) {
                        console.error('Error setting pending approval:', err);
                    }
                }
                
                console.log('✓ User record created:', userData);
                
                if (invitation) {
                    alert('Success. Account created successfully!\n\nYou have been upgraded to Research Partner with full access.\n\nYou can now login.');
                } else {
                    alert('Success. Your account request has been submitted.\n\nPlease confirm your email (check your inbox), then wait for an administrator to approve your account. You will not be able to sign in until then.');
                }
                
                showLoginForm();
                return true;
            } catch (error) {
                console.error('Registration error:', error);
                alert('Registration failed: ' + error.message);
                return false;
            }
        }
        
        // Logout
        async function logout() {
            console.log('=== LOGGING OUT ===');
            
            // Sign out from Supabase
            if (supabaseClient) {
                await supabaseClient.auth.signOut();
            }
            
            // Clear ALL global state
            currentUser = null;
            userTier = 'demo';
            currentViewMode = 'own';
            currentInstitution = null;
            currentInstitutionTheme = null;
            
            // Clear window variables
            window.institutionLogoData = null;
            window.pendingCustomFonts = null;
            
            // Clear any cached data
            cachedDepartmentInstructors = [];
            cachedInstitutionApiKeys = null;
            cachedDepartmentApiKeys = null;
            
            // CRITICAL: Clear login form
            const loginEmail = document.getElementById('loginEmail');
            const loginPassword = document.getElementById('loginPassword');
            if (loginEmail) loginEmail.value = '';
            if (loginPassword) loginPassword.value = '';
            
            // Remove all banners
            const viewBanner = document.getElementById('viewModeBanner');
            if (viewBanner) viewBanner.remove();
            const demoBanner = document.getElementById('demoBanner');
            if (demoBanner) demoBanner.remove();
            
            // Clear Demo Theme Customizer (sessionStorage + injected styles) so it resets on next demo session
            if (typeof clearDemoTheme === 'function') clearDemoTheme();
            // Reset theme to stylesheet default (same as login page) so next login is consistent
            resetThemeToDefault();
            
            // Hide all sections
            document.querySelectorAll('.section').forEach(section => {
                section.style.display = 'none';
            });
            
            console.log('✓ State cleared');
            console.log('✓ Login form cleared');
            console.log('✓ Banners removed');
            console.log('✓ Theme reset to defaults');
            console.log('✓ Logged out');
            
            // Show login screen
            showAuthScreen();
        }
        
        // Handle login form
        document.getElementById('loginForm')?.addEventListener('submit', async (e) => {
            e.preventDefault();
            const email = document.getElementById('loginEmail')?.value ?? '';
            const password = document.getElementById('loginPassword')?.value ?? '';
            await login(email, password);
        });
        
        // Handle register form
        document.getElementById('registerForm')?.addEventListener('submit', async (e) => {
            e.preventDefault();
            const name = document.getElementById('registerName')?.value ?? '';
            const email = document.getElementById('registerEmail')?.value ?? '';
            const password = document.getElementById('registerPassword')?.value ?? '';
            const requestedRole = (document.getElementById('registerRole')?.value ?? 'instructor').trim();
            await register(name, email, password, requestedRole);
        });
        
        // ===== TENANT CONFIGURATION =====
        const TENANT_CONFIGS = {
            'utk': {
                name: 'University of Tennessee, Knoxville',
                shortName: 'UTK',
                domain: 'utk.edu',
                headerBg: '#4B4B4B',  /* Smokey Gray */
                footerBg: '#4B4B4B',  /* Smokey Gray */
                favicon: 'assets/3d-logo-transparent.png',  /* Tab favicon always SpeechGradebook */
                logoUrl: 'assets/utk-logo.png',
                branding: {
                    appName: 'SpeechGradebook',
                    tagline: 'Instructor-Informed Speech Assessment'
                },
                colors: {
                    primary: '#FF8200',
                    primaryDark: '#D66D00',
                    secondary: '#58595B',
                    accent: '#FF8200'
                },
                typography: {
                    headingFont: "'Montserrat', sans-serif",
                    bodyFont: "'Georgia', serif",
                    headingWeight: '600',
                    bodyWeight: '400'
                },
                contact: {
                    supportEmail: 'speecheval-support@utk.edu'
                },
                footer: {
                    links: [
                        { text: 'Privacy Policy', url: 'https://www.utk.edu/aboutut/privacy/' },
                        { text: 'Accessibility', url: 'https://dae.utk.edu/eoa/ada/' },
                        { text: 'Title IX', url: 'https://titleix.utk.edu/' },
                        { text: 'IT Help', url: 'https://oit.utk.edu/help' }
                    ],
                    copyright: '© 2026 SpeechGradebook',
                    additionalText: null
                }
            },
            'utk-torch': {
                name: 'UTK Torch Theme',
                shortName: 'UTK Torch',
                domain: 'utk.edu',
                headerBg: '#4B4B4B',
                footerBg: '#4B4B4B',
                favicon: 'assets/3d-logo-transparent.png',  /* Tab favicon always SpeechGradebook */
                logoUrl: 'assets/utk-logo.png',
                branding: {
                    appName: 'SpeechGradebook',
                    tagline: 'Instructor-Informed Speech Assessment'
                },
                colors: {
                    primary: '#FF8200',
                    primaryDark: '#E56B00',
                    secondary: '#58595B',
                    accent: '#FF8200'
                },
                typography: {
                    headingFont: "'Montserrat', sans-serif",
                    bodyFont: "'Source Sans 3', -apple-system, sans-serif",
                    headingWeight: '600',
                    bodyWeight: '400'
                },
                contact: {
                    supportEmail: 'speecheval-support@utk.edu'
                },
                footer: {
                    links: [
                        { text: 'Privacy Policy', url: 'https://www.utk.edu/aboutut/privacy/' },
                        { text: 'Accessibility', url: 'https://dae.utk.edu/eoa/ada/' },
                        { text: 'Title IX', url: 'https://titleix.utk.edu/' },
                        { text: 'IT Help', url: 'https://oit.utk.edu/help' }
                    ],
                    copyright: '© 2026 SpeechGradebook',
                    additionalText: null
                }
            },
            'default': {
                name: 'SpeechGradebook',
                shortName: 'SG',
                domain: null,
                branding: {
                    appName: 'SpeechGradebook',
                    tagline: 'Instructor-Informed Speech Assessment'
                },
                colors: {
                    primary: '#1e3a5f',
                    primaryDark: '#142940',
                    secondary: '#c8a882',
                    accent: '#d4af37'
                },
                typography: {
                    headingFont: "'Roboto', sans-serif",
                    bodyFont: "'Roboto', sans-serif",
                    headingWeight: '700',
                    bodyWeight: '400'
                },
                contact: {
                    supportEmail: 'speechgradebook@proton.me'
                },
                footer: {
                    links: [
                        { text: 'Privacy Policy', url: 'privacy.html' },
                        { text: 'Terms of Service', url: 'terms.html' }
                    ],
                    copyright: '© 2026 SpeechGradebook',
                    additionalText: null
                }
            }
        };

        // Branding packages – templates for theme customizer. Based on https://github.com/utkwdn/utkwds
        // Select a package to load its colors; then customize as needed before saving.
        const BRANDING_PACKAGES = {
            'default': {
                name: 'SpeechGradebook Default',
                primary: '#1e3a5f',
                header: '#142940',
                secondary: '#8b9dc3',
                text: '#2c3e50',
                fontHeading: "'Roboto', sans-serif",
                fontBody: "'Roboto', sans-serif"
            },
            'utk-wds': {
                name: 'UTK WDS (University of Tennessee, Knoxville)',
                primary: '#FF8200',
                header: '#4B4B4B',
                secondary: '#1a73c5',
                text: '#4B4B4B',
                fontHeading: "'Montserrat', sans-serif",
                fontBody: "'Source Sans 3', -apple-system, sans-serif"
            },
            'option4': {
                name: 'Option 4: Sophisticated Navy',
                primary: '#1a2332',
                header: '#0f1419',
                secondary: '#4a5568',
                text: '#1a1a1a',
                fontHeading: "'Roboto', sans-serif",
                fontBody: "'Roboto', sans-serif"
            },
            'option7': {
                name: 'Option 7: Current Primary Refined',
                primary: '#1e3a5f',
                header: '#142940',
                secondary: '#5a6c7d',
                text: '#1a1a1a',
                fontHeading: "'Roboto', sans-serif",
                fontBody: "'Roboto', sans-serif"
            },
            'speechgradebook-light': {
                name: 'SpeechGradebook Light Theme',
                primary: '#1e3a5f',
                header: '#142940',
                secondary: '#5a6c7d',
                text: '#1a1a1a',
                fontHeading: "'Roboto', sans-serif",
                fontBody: "'Roboto', sans-serif"
            },
            'option7-apple': {
                name: 'Option 7: Current Primary Refined (Apple-aligned)',
                primary: '#1e3a5f',
                header: '#142940',
                secondary: '#5a6c7d',
                text: '#1a1a1a',
                fontHeading: "'Roboto', sans-serif",
                fontBody: "'Roboto', sans-serif"
            },
            'option7-dark': {
                name: 'Option 7: Dark Theme',
                primary: '#5a8fc7',
                header: '#1e3a5f',
                secondary: '#7a9fc7',
                text: '#f5f7fa',
                fontHeading: "'Roboto', sans-serif",
                fontBody: "'Roboto', sans-serif"
            },
            'speechgradebook-dark': {
                name: 'SpeechGradebook Dark Theme',
                primary: '#6ba5d7',
                header: '#1e3a5f',
                secondary: '#8bb5d7',
                text: '#e8f0f8',
                fontHeading: "'Roboto', sans-serif",
                fontBody: "'Roboto', sans-serif"
            },
            'option8': {
                name: 'Option 8: Ideal Apple HIG',
                primary: '#007AFF',
                header: '#0051D5',
                secondary: '#5856D6',
                text: '#000000',
                fontHeading: "'Roboto', sans-serif",
                fontBody: "'Roboto', sans-serif"
            }
        };

        // ===== GLOBAL STATE =====
        console.log('🚀 SpeechGradebook JavaScript Loading...');
        let currentTenant = 'default';
        let uploadedFile = null;
        let evaluationAbortController = null; // Global abort controller for canceling evaluations
        let evaluationResults = null;
        /** Original AI output (sections + timeline_markers) before any instructor edits. Set when we receive the API response; stored in evaluation_data.model_output_original on first save for "AI vs instructor" training. */
        let modelOutputOriginal = null;
        let currentStep = 1;
        let _instructorCoursesAll = []; // Full list for instructor filter (Phase 8)
        let _superAdminCoursesCache = [];
        let _adminCoursesCache = [];
        let _superAdminSortColumn = '';
        let _superAdminSortAsc = true;
        let _adminSortColumn = '';
        let _adminSortAsc = true;
        console.log('✓ Global variables initialized');
        
        // (API key placeholder – app uses SpeechGradebook Text Model (Mistral); URL from Settings or default)
        function updateApiKeyPlaceholder() {
            const el = document.getElementById('apiProvider');
            if (!el) return;
        }

        // ===== RUBRIC SYSTEM =====
        // Define the Self-Introduction Speech Rubric
        const SELF_INTRO_RUBRIC = {
            name: "Self Introduction Speech",
            totalPoints: 50,
            gradeScale: {
                A: { label: "Professional", percentage: 1.00, range: "100-91" },
                B: { label: "Proficient", percentage: 0.90, range: "90-80" },
                C: { label: "Developing", percentage: 0.80, range: "80-71" },
                D: { label: "Unprofessional", percentage: 0.70, range: "70-61" },
                F: { label: "Unacceptable", percentage: 0.60, range: "60-0" }
            },
            categories: [
                {
                    name: "Content - Introduction",
                    subcategories: [
                        "Capture Attention",
                        "Relevance to Audience",
                        "Introduction of Topic/Purpose"
                    ]
                },
                {
                    name: "Content - Organization",
                    subcategories: [
                        "Pattern",
                        "Connectives",
                        "Within Time Limits"
                    ]
                },
                {
                    name: "Content - Conclusion",
                    subcategories: [
                        "Recap/Summary",
                        "Memorable Final Thought"
                    ]
                },
                {
                    name: "Content - Assignment",
                    subcategories: [
                        "Your passion(s)",
                        "Career Goals",
                        "Philosophy",
                        "Clear Development of Ideas"
                    ]
                },
                {
                    name: "Delivery - Nonverbal",
                    subcategories: [
                        "Eye Contact",
                        "Gestures/Bodily Movements",
                        "Desire to Communicate/Enthusiasm",
                        "Professionalism"
                    ]
                },
                {
                    name: "Delivery - Verbal",
                    subcategories: [
                        "Vocal volume/variety/tone",
                        "Speaking Rate/Effective Use of Pauses",
                        "Extemporaneous style - use of notes",
                        "Use of vocalized pauses/fillers (ums, uhs, like...)"
                    ]
                }
            ]
        };

        // Calculate rubric metrics
        function calculateRubricMetrics(rubric) {
            const categories = rubric?.categories;
            if (!categories || !Array.isArray(categories)) {
                return { totalSubcategories: 0, pointsPerSubcategory: 0, categoryPoints: [] };
            }
            const totalSubcategories = categories.reduce(
                (sum, cat) => sum + (Array.isArray(cat.subcategories) ? cat.subcategories.length : 0), 
                0
            );
            const pointsPerSubcategory = totalSubcategories > 0 && rubric.totalPoints
                ? rubric.totalPoints / totalSubcategories
                : 0;
            
            return {
                totalSubcategories,
                pointsPerSubcategory,
                categoryPoints: categories.map(cat => {
                    const subCount = Array.isArray(cat.subcategories) ? cat.subcategories.length : 0;
                    return {
                        name: cat.name,
                        maxPoints: subCount * pointsPerSubcategory,
                        subcategoryCount: subCount
                    };
                })
            };
        }

        // Calculate score for a category based on grade selections
        function calculateCategoryScore(rubric, categoryIndex, gradeSelections) {
            const metrics = calculateRubricMetrics(rubric);
            const category = rubric.categories[categoryIndex];
            const pointsPerSub = metrics.pointsPerSubcategory;
            
            let totalScore = 0;
            gradeSelections.forEach(grade => {
                const gradePercentage = rubric.gradeScale[grade].percentage;
                totalScore += pointsPerSub * gradePercentage;
            });
            
            return {
                score: parseFloat(totalScore.toFixed(2)),
                maxScore: parseFloat((category.subcategories.length * pointsPerSub).toFixed(2))
            };
        }
        let currentClassId = null;

        // ===== INITIALIZATION =====
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('📄 DOM Content Loaded');
            
            // Initialize dark mode (before other theme applications)
            initDarkMode();
            console.log('✓ Dark mode initialized');
            
            // Test Supabase connection
            testSupabaseConnection();
            
            // Check authentication status (loading overlay hides when this completes)
            await checkAuth();
            
            // Handle URL routing after auth is complete
            if (currentUser && typeof Router !== 'undefined' && Router.handleRoute) {
                // Small delay to ensure all initialization is complete
                setTimeout(() => {
                    Router.handleRoute();
                }, 500);
            }
            
            // Apply tenant only when user is logged in (main app). Login screen always keeps SpeechGradebook default theme.
            if (currentUser) {
                // Apply dark mode preference first (if enabled)
                const isDark = getDarkModePreference();
                if (isDark) {
                    toggleDarkMode(true);
                }
                
                const savedTenant = (typeof localStorage !== 'undefined' && localStorage.getItem('current_tenant')) || null;
                const tenantSel = document.getElementById('tenantSelect');
                if (savedTenant) {
                    currentTenant = savedTenant;
                    applyTenant(currentTenant);
                    if (tenantSel) tenantSel.value = currentTenant;
                } else if (currentInstitutionTheme && currentInstitutionTheme.primary_color && currentInstitutionTheme.primary_color.toLowerCase() === '#ff8200') {
                    currentTenant = 'utk';
                    applyTenant('utk');
                    if (typeof localStorage !== 'undefined') localStorage.setItem('current_tenant', 'utk');
                    if (tenantSel) tenantSel.value = 'utk';
                } else {
                    currentTenant = 'default';
                    applyTenant(currentTenant);
                    if (tenantSel) tenantSel.value = 'default';
                }
                
                // Re-apply dark mode after tenant (to override tenant colors if dark mode is enabled)
                if (isDark) {
                    toggleDarkMode(true);
                }
                
                console.log('✓ Tenant applied:', currentTenant, savedTenant ? '(from localStorage)' : '(default or institution)');
            }
            // When not logged in, theme stays at default (set by showAuthScreen → resetThemeToDefault) so login page is always SpeechGradebook theme
            
            // Initialize file upload
            initializeFileUpload();
            // Initialize bulk upload mode toggle (defaults to single)
            if (document.getElementById('singleUploadModeBtn')) {
                switchUploadMode('single');
            }
            
            // Setup logo fallback (use existing logos if transparent logo doesn't exist)
            setupLogoFallback();
            console.log('✓ File upload initialized');
            
            // Initialize form handlers
            initializeForms();
            console.log('✓ Forms initialized');
            
            // Demo Theme Customizer form: color sync (all theme colors), font custom toggle, logo preview, custom font file
            (function initDemoThemeForm() {
                if (typeof DEMO_THEME_COLOR_IDS !== 'undefined') {
                    DEMO_THEME_COLOR_IDS.forEach(function(row) {
                        var pickerId = row[0], textId = row[1];
                        var picker = document.getElementById(pickerId);
                        var text = document.getElementById(textId);
                        if (picker && text) {
                            picker.addEventListener('input', function() { text.value = picker.value; });
                            text.addEventListener('input', function() {
                                var v = text.value.trim();
                                if (/^#[0-9a-fA-F]{6}$/.test(v)) picker.value = v;
                            });
                        }
                    });
                }
                var fontSelect = document.getElementById('demoFontSelect');
                var customWrap = document.getElementById('demoCustomFontWrap');
                if (fontSelect && customWrap) {
                    fontSelect.addEventListener('change', function() {
                        customWrap.style.display = fontSelect.value === '__custom__' ? 'block' : 'none';
                    });
                }
                var logoUpload = document.getElementById('demoLogoUpload');
                var logoPreviewImg = document.getElementById('demoLogoPreviewImg');
                var logoPlaceholder = document.getElementById('demoLogoPlaceholder');
                var logoClear = document.getElementById('demoLogoClear');
                if (logoUpload && logoPreviewImg && logoPlaceholder) {
                    logoUpload.addEventListener('change', function() {
                        var file = logoUpload.files && logoUpload.files[0];
                        if (!file || !file.type.startsWith('image/')) return;
                        var reader = new FileReader();
                        reader.onload = function() {
                            logoPreviewImg.src = reader.result;
                            logoPreviewImg.style.display = 'block';
                            logoPlaceholder.style.display = 'none';
                            if (logoClear) logoClear.style.display = '';
                        };
                        reader.readAsDataURL(file);
                    });
                }
                var customFontFile = document.getElementById('demoCustomFontFile');
                var customFontStatus = document.getElementById('demoCustomFontStatus');
                if (customFontFile) {
                    customFontFile.addEventListener('change', function() {
                        var file = customFontFile.files && customFontFile.files[0];
                        window.demoCustomFontDataUrl = null;
                        if (customFontStatus) customFontStatus.textContent = '';
                        if (!file) return;
                        var ext = (file.name || '').toLowerCase();
                        if (!/\.(woff2?|ttf|otf)$/.test(ext)) {
                            if (customFontStatus) customFontStatus.textContent = 'Use .woff2, .woff, .ttf, or .otf';
                            return;
                        }
                        var reader = new FileReader();
                        reader.onload = function() {
                            window.demoCustomFontDataUrl = reader.result;
                            if (customFontStatus) customFontStatus.textContent = 'Font loaded. Enter a name above and click Apply.';
                        };
                        reader.readAsDataURL(file);
                    });
                }
            })();
            
            // Load saved data
            await loadClasses();
            await loadRubrics();
            loadSavedSettings();
            console.log('✓ Data loaded');
            
            // Set current date
            const speechDateEl = document.getElementById('speechDate');
            if (speechDateEl) speechDateEl.valueAsDate = new Date();
            
            // Analytics tablist: arrow-key navigation (uses current dashboard config)
            const analyticsTablist = document.getElementById('analyticsTablist');
            if (analyticsTablist) {
                analyticsTablist.addEventListener('keydown', function(e) {
                    const config = typeof getDashboardConfig === 'function' ? getDashboardConfig() : [];
                    const tabIds = config.map(d => 'tab_' + d.id);
                    const target = e.target;
                    if (!target || !tabIds.includes(target.id)) return;
                    let idx = tabIds.indexOf(target.id);
                    if (e.key === 'ArrowLeft' && idx > 0) {
                        e.preventDefault();
                        switchAnalyticsTab(config[idx - 1].id);
                    } else if (e.key === 'ArrowRight' && idx < tabIds.length - 1) {
                        e.preventDefault();
                        switchAnalyticsTab(config[idx + 1].id);
                    }
                });
            }
            var analyticsGlobalApply = document.getElementById('analyticsGlobalApply');
            if (analyticsGlobalApply) analyticsGlobalApply.addEventListener('click', async function() {
                if (typeof loadEnhancedAnalytics !== 'function') return;
                var btn = analyticsGlobalApply;
                var origText = btn.textContent || 'Apply';
                btn.disabled = true;
                btn.textContent = 'Applying…';
                try {
                    await loadEnhancedAnalytics(true); // Show toast on Apply button click
                } finally {
                    btn.disabled = false;
                    btn.textContent = origText;
                }
            });
            var analyticsGlobalReset = document.getElementById('analyticsGlobalReset');
            if (analyticsGlobalReset) analyticsGlobalReset.addEventListener('click', function() {
                // Reset date range
                var startEl = document.getElementById('analyticsStartDate');
                var endEl = document.getElementById('analyticsEndDate');
                if (startEl) startEl.value = '';
                if (endEl) endEl.value = '';
                
                // Reset all multi-select filters
                var globalCourse = document.getElementById('analyticsGlobalCourse');
                var globalInstructor = document.getElementById('analyticsGlobalInstructor');
                var globalInstitution = document.getElementById('analyticsGlobalInstitution');
                
                if (globalCourse) {
                    Array.from(globalCourse.options).forEach(opt => opt.selected = false);
                }
                if (globalInstructor) {
                    Array.from(globalInstructor.options).forEach(opt => opt.selected = false);
                }
                if (globalInstitution) {
                    Array.from(globalInstitution.options).forEach(opt => opt.selected = false);
                }
                
                // Reset single-select filters
                var courseFilter = document.getElementById('analyticsCourseFilter');
                var instFilter = document.getElementById('analyticsInstructorFilter');
                var searchEl = document.getElementById('analyticsSearch');
                var scoreBandEl = document.getElementById('analyticsScoreBand');
                
                if (courseFilter) courseFilter.value = 'all';
                if (instFilter) instFilter.value = 'all';
                if (searchEl) searchEl.value = '';
                if (scoreBandEl) scoreBandEl.value = 'all';
                
                // Update active filters display and dropdown trigger labels
                if (typeof updateActiveFiltersDisplay === 'function') updateActiveFiltersDisplay();
                if (typeof FILTER_DROPDOWN_KEYS !== 'undefined' && typeof updateFilterDropdownTrigger === 'function') {
                    FILTER_DROPDOWN_KEYS.forEach(function(m) { updateFilterDropdownTrigger(m.key); });
                }
                
                // Reload data (show loading via Apply button if present)
                var applyBtn = document.getElementById('analyticsGlobalApply');
                if (applyBtn && typeof loadEnhancedAnalytics === 'function') {
                    applyBtn.disabled = true;
                    applyBtn.textContent = 'Applying…';
                    loadEnhancedAnalytics(true).finally(function() { // Show toast on Apply button click
                        applyBtn.disabled = false;
                        applyBtn.textContent = 'Apply';
                    });
                } else if (typeof loadEnhancedAnalytics === 'function') {
                    loadEnhancedAnalytics(true); // Show toast on filter change
                }
            });
            if (typeof renderDashboardTabs === 'function') renderDashboardTabs();
            if (typeof initFilterDropdownBehavior === 'function') initFilterDropdownBehavior();
            var editCardsBtn = document.getElementById('analyticsEditCardsBtn');
            if (editCardsBtn) editCardsBtn.addEventListener('click', function() { if (typeof openEditCardsModal === 'function' && typeof currentAnalyticsTabId !== 'undefined') openEditCardsModal(currentAnalyticsTabId); });
            var customizeBtn = document.getElementById('analyticsCustomizeDashboardsBtn');
            if (customizeBtn) customizeBtn.addEventListener('click', function() { if (typeof openCustomizeDashboardsModal === 'function') openCustomizeDashboardsModal(); });
            var customizeClose = document.getElementById('customizeDashboardsClose');
            if (customizeClose) customizeClose.addEventListener('click', function() { if (typeof closeCustomizeDashboardsModal === 'function') closeCustomizeDashboardsModal(); });
            var customizeAdd = document.getElementById('customizeDashboardsAdd');
            if (customizeAdd) customizeAdd.addEventListener('click', function() { if (typeof addDashboard === 'function') addDashboard(); });
            var editCardsClose = document.getElementById('editCardsClose');
            if (editCardsClose) editCardsClose.addEventListener('click', function() { if (typeof closeEditCardsModal === 'function') closeEditCardsModal(); });
            var instructorTabCourses = document.getElementById('instructorTabBtnCourses');
            var instructorTabRubrics = document.getElementById('instructorTabBtnRubrics');
            var instructorTabInsights = document.getElementById('instructorTabBtnInsights');
            if (instructorTabCourses) instructorTabCourses.addEventListener('click', function() { if (typeof switchInstructorDashboardTab === 'function') switchInstructorDashboardTab('courses'); });
            if (instructorTabRubrics) instructorTabRubrics.addEventListener('click', function() { if (typeof switchInstructorDashboardTab === 'function') switchInstructorDashboardTab('rubrics'); });
            if (instructorTabInsights) instructorTabInsights.addEventListener('click', function() { if (typeof switchInstructorDashboardTab === 'function') switchInstructorDashboardTab('insights'); });
            
            // Demo Theme Customizer form: color sync (picker ↔ hex), font custom toggle, logo preview, custom font upload
            if (typeof DEMO_THEME_COLOR_IDS !== 'undefined') {
                DEMO_THEME_COLOR_IDS.forEach(function(row) {
                    var pickerId = row[0], textId = row[1];
                    var picker = document.getElementById(pickerId);
                    var text = document.getElementById(textId);
                    if (picker && text) {
                        picker.addEventListener('input', function() { text.value = picker.value; });
                        text.addEventListener('input', function() {
                            var v = text.value.trim();
                            if (/^#[0-9a-fA-F]{6}$/.test(v)) picker.value = v;
                        });
                    }
                });
            }
            var demoFontSelect = document.getElementById('demoFontSelect');
            var demoCustomFontWrap = document.getElementById('demoCustomFontWrap');
            if (demoFontSelect && demoCustomFontWrap) {
                demoFontSelect.addEventListener('change', function() {
                    demoCustomFontWrap.style.display = demoFontSelect.value === '__custom__' ? 'block' : 'none';
                    if (demoFontSelect.value !== '__custom__') window.demoCustomFontDataUrl = null;
                });
            }
            var demoLogoUpload = document.getElementById('demoLogoUpload');
            if (demoLogoUpload) {
                demoLogoUpload.addEventListener('change', function() {
                    var file = demoLogoUpload.files && demoLogoUpload.files[0];
                    var img = document.getElementById('demoLogoPreviewImg');
                    var placeholder = document.getElementById('demoLogoPlaceholder');
                    var clearBtn = document.getElementById('demoLogoClear');
                    if (file && file.type.startsWith('image/')) {
                        var r = new FileReader();
                        r.onload = function() {
                            if (img) { img.src = r.result; img.style.display = 'block'; }
                            if (placeholder) placeholder.style.display = 'none';
                            if (clearBtn) clearBtn.style.display = '';
                        };
                        r.readAsDataURL(file);
                    } else if (!file) {
                        if (img) { img.style.display = 'none'; img.removeAttribute('src'); }
                        if (placeholder) placeholder.style.display = '';
                        if (clearBtn) clearBtn.style.display = 'none';
                    }
                });
            }
            var demoCustomFontFile = document.getElementById('demoCustomFontFile');
            if (demoCustomFontFile) {
                demoCustomFontFile.addEventListener('change', function() {
                    var file = demoCustomFontFile.files && demoCustomFontFile.files[0];
                    var status = document.getElementById('demoCustomFontStatus');
                    if (!file) {
                        window.demoCustomFontDataUrl = null;
                        if (status) status.textContent = '';
                        return;
                    }
                    var ext = (file.name || '').toLowerCase();
                    if (!/\.(woff2?|ttf|otf)$/.test(ext)) {
                        if (status) status.textContent = 'Please choose a .woff2, .woff, .ttf, or .otf file.';
                        window.demoCustomFontDataUrl = null;
                        return;
                    }
                    var r = new FileReader();
                    r.onload = function() {
                        window.demoCustomFontDataUrl = r.result;
                        if (status) status.textContent = 'Font file loaded. Click Apply to use it.';
                    };
                    r.onerror = function() {
                        window.demoCustomFontDataUrl = null;
                        if (status) status.textContent = 'Could not read file.';
                    };
                    r.readAsDataURL(file);
                });
            }
            
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons();
            console.log('✓ Application fully initialized and ready');
        });

        // ===== NAVIGATION =====
        function showEvaluate() {
            // Update URL
            if (typeof Router !== 'undefined' && Router.navigateToSection) {
                Router.navigateToSection('evaluate');
            }
            setActiveSection('evaluateSection', 'navEvaluate');
            if (typeof updateEvalProviderOptions === 'function') updateEvalProviderOptions();
            
            // Restore normal spacing for main-content
            const mainContent = document.getElementById('main-content');
            if (mainContent) {
                mainContent.style.removeProperty('padding-top');
                mainContent.style.removeProperty('margin-top');
                mainContent.style.removeProperty('min-height');
                mainContent.style.removeProperty('height');
            }
            
            // Restore normal display for all sections
            document.querySelectorAll('.section').forEach(section => {
                section.style.removeProperty('display');
                section.style.removeProperty('height');
                section.style.removeProperty('margin');
                section.style.removeProperty('padding');
            });
        }
        
        async function updateEvalProviderOptions() {
            // No-op: Only Qwen is used, provider selection removed
            const sel = document.getElementById('evalApiProvider');
            if (sel) {
                sel.value = 'qwen';
            }
        }

        function switchInstructorDashboardTab(tabId) {
            var panels = document.querySelectorAll('[data-instructor-panel]');
            panels.forEach(function(el) {
                el.style.display = el.getAttribute('data-instructor-panel') === tabId ? (el.id === 'mainCoursesCard' ? 'block' : 'block') : 'none';
            });
            var tabIds = ['courses', 'rubrics', 'insights'];
            tabIds.forEach(function(id) {
                var btn = document.getElementById('instructorTabBtn' + id.charAt(0).toUpperCase() + id.slice(1));
                if (btn) {
                    var active = id === tabId;
                    btn.classList.toggle('instructor-dashboard-tab-active', active);
                    btn.setAttribute('aria-selected', active ? 'true' : 'false');
                }
            });
            
            // Show unified search bar for instructor dashboard tabs
            const unifiedSearchBar = document.getElementById('unifiedSearchBar');
            if (unifiedSearchBar) {
                unifiedSearchBar.style.display = 'block';
            }
            
            // Show/hide filter toolbar (only for courses tab)
            const filterToolbar = document.getElementById('instructorFiltersToolbar');
            if (filterToolbar) {
                filterToolbar.style.display = tabId === 'courses' ? 'block' : 'none';
                // Initialize Lucide icons in filter toolbar
                if (tabId === 'courses' && typeof lucide !== 'undefined' && lucide.createIcons) {
                    lucide.createIcons({ root: filterToolbar });
                }
            }
            
            // Update search placeholder based on active tab
            const unifiedSearchInput = document.getElementById('unifiedSearchInput');
            if (unifiedSearchInput) {
                if (tabId === 'courses') {
                    unifiedSearchInput.placeholder = 'Search courses by name, code, semester, or instructor...';
                } else if (tabId === 'rubrics') {
                    unifiedSearchInput.placeholder = 'Search rubrics...';
                } else if (tabId === 'insights') {
                    unifiedSearchInput.placeholder = 'Search evaluations (switch to Evaluations tab)...';
                }
            }
            
            // Clear search when switching tabs (optional - remove if you want to preserve search)
            if (unifiedSearchInput) {
                unifiedSearchInput.value = '';
                handleUnifiedSearch('');
            }
            
            // Auto-load analytics when switching to Insights tab
            if (tabId === 'insights') {
                // Check if analytics panel is visible
                const analyticsSection = document.getElementById('analyticsSection');
                const analyticsPanel = document.getElementById('analyticsPanelsWrapper');
                const isVisible = analyticsSection && analyticsSection.style.display !== 'none';
                
                if (isVisible && typeof loadEnhancedAnalytics === 'function') {
                    // Only auto-load if analytics data is empty or if we're on a sub-tab that needs data
                    const hasData = typeof analyticsData !== 'undefined' && analyticsData.evaluations && analyticsData.evaluations.length > 0;
                    if (!hasData) {
                        // Small delay to ensure UI is ready
                        setTimeout(() => {
                            loadEnhancedAnalytics(false); // Don't show toast on auto-load
                        }, 200);
                    }
                }
            }
        }

        // ===== ACCOUNT-WIDE SEARCH =====
        let accountSearchDebounce = null;
        let accountSearchResultsData = [];

        function getSearchableCourses() {
            if (typeof isAdmin === 'function' && isAdmin() && typeof _adminCoursesCache !== 'undefined' && Array.isArray(_adminCoursesCache) && _adminCoursesCache.length > 0) {
                return _adminCoursesCache.map(c => ({ id: c.id, name: c.name, semester: c.semester, year: c.year, section: c.section || c.code, instructor_name: c.instructor_name, institution_name: c.institution_name, roster: c.roster || c.course_students || [] }));
            }
            if (typeof isSuperAdmin === 'function' && isSuperAdmin() && typeof _superAdminCoursesCache !== 'undefined' && Array.isArray(_superAdminCoursesCache) && _superAdminCoursesCache.length > 0) {
                return _superAdminCoursesCache.map(c => ({ id: c.id, name: c.name, semester: c.semester, year: c.year, section: c.section || c.code, instructor_name: c.instructor_name, institution_name: c.institution_name }));
            }
            const classes = JSON.parse(getUserItem('classes') || '[]');
            return classes.map(c => ({ id: c.id, name: c.name, semester: c.semester, year: c.year, section: c.section, roster: c.roster || c.course_students || [] }));
        }

        async function runAccountSearch(q) {
            const term = (q || '').trim().toLowerCase();
            if (!term || term.length < 2) return { courses: [], students: [], rubrics: [] };

            // Ensure admin/super admin course cache is loaded so instructor search works
            // Use forSearch=true to load ALL institution courses (ignore dashboard filters); always reload on search so we have full data
            if (typeof isAdmin === 'function' && isAdmin()) {
                if (typeof loadDepartmentInstructorsForFilter === 'function') await loadDepartmentInstructorsForFilter();
                if (typeof loadFilteredCoursesForAdmin === 'function') await loadFilteredCoursesForAdmin(true);
            }
            if (typeof isSuperAdmin === 'function' && isSuperAdmin() && (!_superAdminCoursesCache || _superAdminCoursesCache.length === 0) && typeof loadFilteredCoursesForSuperAdmin === 'function') {
                await loadFilteredCoursesForSuperAdmin();
            }

            const courses = getSearchableCourses();
            const rubrics = typeof getAllRubrics === 'function' ? await getAllRubrics() : [];

            const courseMatches = courses.filter(c => {
                const name = (c.name || '').toLowerCase();
                const sem = (c.semester || '').toLowerCase();
                const yr = String(c.year || '').toLowerCase();
                const sec = (c.section || c.code || '').toLowerCase();
                const inst = (c.instructor_name || '').toLowerCase();
                const instName = (c.institution_name || '').toLowerCase();
                return name.includes(term) || sem.includes(term) || yr.includes(term) || sec.includes(term) || inst.includes(term) || instName.includes(term);
            });

            const studentMatches = [];
            courses.forEach(c => {
                const roster = c.roster || c.course_students || [];
                roster.forEach(s => {
                    const fn = (s.firstName || s.first_name || '').toLowerCase();
                    const ln = (s.lastName || s.last_name || '').toLowerCase();
                    const full = (fn + ' ' + ln).trim();
                    const email = (s.email || '').toLowerCase();
                    const sid = (s.studentId || s.student_id || '').toLowerCase();
                    if (full.includes(term) || fn.includes(term) || ln.includes(term) || email.includes(term) || sid.includes(term)) {
                        studentMatches.push({
                            id: s.id || s.supabaseId,
                            name: (s.firstName || s.first_name || '') + ' ' + (s.lastName || s.last_name || ''),
                            courseId: c.id,
                            courseName: c.name
                        });
                    }
                });
            });

            const rubricMatches = rubrics.filter(r => {
                const name = (r.name || '').toLowerCase();
                const desc = (r.description || '').toLowerCase();
                const st = (r.speechType || r.speech_type || '').toLowerCase();
                return name.includes(term) || desc.includes(term) || st.includes(term);
            });

            return {
                courses: courseMatches.slice(0, 8),
                students: studentMatches.slice(0, 8),
                rubrics: rubricMatches.slice(0, 8)
            };
        }

        function renderAccountSearchResults(results) {
            const el = document.getElementById('accountSearchResults');
            if (!el) return;

            const { courses, students, rubrics } = results;
            const total = courses.length + students.length + rubrics.length;

            if (total === 0) {
                el.innerHTML = '<div class="search-no-results">No results found</div>';
                el.classList.remove('hidden');
                accountSearchResultsData = [];
                return;
            }

            let html = '';
            if (courses.length > 0) {
                html += '<div class="search-group-label">Courses</div>';
                courses.forEach(c => {
                    const sub = [c.semester, c.year].filter(Boolean).join(' ') || (c.instructor_name ? 'Instructor: ' + c.instructor_name : '');
                    html += `<button type="button" class="search-result-item" data-type="course" data-id="${escapeHtml(String(c.id))}" data-course-id="${escapeHtml(String(c.id))}">
                        <div>${escapeHtml(c.name || 'Untitled')}</div>
                        ${sub ? `<div class="search-result-sub">${escapeHtml(sub)}</div>` : ''}
                    </button>`;
                });
            }
            if (students.length > 0) {
                html += '<div class="search-group-label">Students</div>';
                students.forEach(s => {
                    html += `<button type="button" class="search-result-item" data-type="student" data-id="${escapeHtml(String(s.id))}" data-course-id="${escapeHtml(String(s.courseId))}">
                        <div>${escapeHtml(s.name || 'Unknown')}</div>
                        <div class="search-result-sub">${escapeHtml(s.courseName || '')}</div>
                    </button>`;
                });
            }
            if (rubrics.length > 0) {
                html += '<div class="search-group-label">Rubrics</div>';
                rubrics.forEach(r => {
                    const sub = r.totalPoints ? r.totalPoints + ' points' : '';
                    html += `<button type="button" class="search-result-item" data-type="rubric" data-id="${escapeHtml(String(r.id || r.supabaseId))}">
                        <div>${escapeHtml(r.name || 'Untitled')}</div>
                        ${sub ? `<div class="search-result-sub">${escapeHtml(sub)}</div>` : ''}
                    </button>`;
                });
            }

            el.innerHTML = html;
            el.classList.remove('hidden');
            accountSearchResultsData = [...courses, ...students.map(s => ({ ...s, type: 'student' })), ...rubrics];

            el.querySelectorAll('.search-result-item').forEach(btn => {
                btn.addEventListener('click', function() {
                    const type = this.dataset.type;
                    const id = this.dataset.id;
                    const courseId = this.dataset.courseId;
                    handleAccountSearchSelect(type, id, courseId);
                });
            });
        }

        function handleAccountSearchSelect(type, id, courseId) {
            const input = document.getElementById('accountSearchInput');
            const results = document.getElementById('accountSearchResults');
            if (input) input.value = '';
            if (results) { results.classList.add('hidden'); results.innerHTML = ''; }

            if (type === 'course') {
                // Use new path-based routing
                if (typeof Router !== 'undefined' && Router.navigateToCourse) {
                    Router.navigateToCourse(id);
                } else if (typeof viewCourse === 'function') {
                    viewCourse(id);
                }
            } else if (type === 'student') {
                // Navigate to student within course
                if (typeof Router !== 'undefined' && Router.navigateToStudent && courseId) {
                    Router.navigateToStudent(courseId, id);
                } else {
                    // Fallback to old method
                if (typeof viewCourse === 'function') viewCourse(courseId);
                setTimeout(() => { if (typeof viewStudentEvals === 'function') viewStudentEvals(id); }, 400);
                }
            } else if (type === 'rubric') {
                if (typeof showDashboard === 'function') showDashboard();
                const tabBtn = document.getElementById('instructorTabBtnRubrics');
                if (tabBtn) { tabBtn.click(); }
                setTimeout(() => { if (typeof viewRubric === 'function') viewRubric(id); }, 350);
            }
        }

        function initAccountSearch() {
            const input = document.getElementById('accountSearchInput');
            const results = document.getElementById('accountSearchResults');
            const wrap = document.getElementById('accountSearchWrap');
            if (!input || !results || !wrap) return;

            input.addEventListener('input', function() {
                const q = this.value;
                clearTimeout(accountSearchDebounce);
                if (!q || q.trim().length < 2) {
                    results.classList.add('hidden');
                    results.innerHTML = '';
                    return;
                }
                accountSearchDebounce = setTimeout(async () => {
                    const data = await runAccountSearch(q);
                    renderAccountSearchResults(data);
                }, 180);
            });

            input.addEventListener('focus', function() {
                if (this.value.trim().length >= 2 && results.innerHTML) results.classList.remove('hidden');
            });

            document.addEventListener('click', function(e) {
                if (wrap && !wrap.contains(e.target)) results.classList.add('hidden');
            });

            input.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') { results.classList.add('hidden'); input.blur(); }
            });
        }

        // Show initial section on load: Dashboard after login; last viewed section on refresh
        function showInitialSection() {
            if (typeof sessionStorage !== 'undefined' && sessionStorage.getItem('justLoggedIn')) {
                sessionStorage.removeItem('justLoggedIn');
                if (typeof showDashboard === 'function') showDashboard();
                return;
            }
            const lastSection = typeof sessionStorage !== 'undefined' ? sessionStorage.getItem('lastSection') : null;
            if (lastSection === 'evaluateSection' && typeof showEvaluate === 'function') {
                showEvaluate();
                if (typeof loadClasses === 'function') loadClasses();
                if (typeof loadRubrics === 'function') loadRubrics();
                return;
            }
            if (lastSection === 'settingsSection' && typeof showSettings === 'function') {
                showSettings();
                return;
            }
            if (lastSection === 'helpSection' && typeof showHelp === 'function') {
                showHelp();
                return;
            }
            if (typeof showDashboard === 'function') showDashboard();
        }

        function showDashboard() {
            // Check if editing before navigating
            if (editingEvaluationId) {
                checkEditingBeforeNavigate(showDashboardInternal);
                return;
            }
            // Update URL
            if (typeof Router !== 'undefined' && Router.navigateToSection) {
                Router.navigateToSection('dashboard');
            }
            showDashboardInternal();
        }
        
        function showDashboardInternal() {
            currentClassId = null; // clear so "Back to Dashboard" / "Back to Class" never triggers "Class not found"
            setActiveSection('dashboardSection', 'navDashboard');
            const headerActions = document.getElementById('classDetailHeaderActions');
            if (headerActions) headerActions.innerHTML = '';
            
            // Restore normal spacing for main-content when returning to dashboard
            const mainContent = document.getElementById('main-content');
            if (mainContent) {
                mainContent.style.removeProperty('padding-top');
                mainContent.style.removeProperty('margin-top');
                mainContent.style.removeProperty('min-height');
                mainContent.style.removeProperty('height');
            }
            
            // Restore normal display for all sections
            document.querySelectorAll('.section').forEach(section => {
                section.style.removeProperty('display');
                section.style.removeProperty('height');
                section.style.removeProperty('margin');
                section.style.removeProperty('padding');
            });
            
            // Show overview stats for instructors
            // Overview stats are now shown in Course Insights > Overview tab, not in Dashboard
            // The display logic is handled in renderOverviewTab() and switchAnalyticsTab()
            
            loadClasses();
            if ((typeof isAdmin === 'function' && isAdmin()) && typeof loadFilteredCoursesForAdmin === 'function') loadFilteredCoursesForAdmin();
            if ((typeof isSuperAdmin === 'function' && isSuperAdmin()) && typeof loadFilteredCoursesForSuperAdmin === 'function') loadFilteredCoursesForSuperAdmin();
            if (typeof loadRubrics === 'function') loadRubrics();
            if (typeof updateAnalyticsUIForRole === 'function') updateAnalyticsUIForRole();
            if (typeof prefillAnalyticsDateRange === 'function') prefillAnalyticsDateRange();
            if (typeof renderDashboardTabs === 'function') renderDashboardTabs();
            var config = typeof getDashboardConfig === 'function' ? getDashboardConfig() : [];
            var firstVisible = config.filter(function(d) { return d.visible !== false; })[0];
            if (typeof switchAnalyticsTab === 'function') switchAnalyticsTab(firstVisible ? firstVisible.id : 'overview');
            const canLoadAnalytics = (typeof userTier !== 'undefined' && userTier === 'instructor') || (typeof isAdmin === 'function' && isAdmin() && typeof currentUser !== 'undefined' && currentUser && currentUser.department_id) || (typeof isSuperAdmin === 'function' && isSuperAdmin());
            if (userTier === 'demo' && typeof loadDemoAnalytics === 'function') {
                loadDemoAnalytics(typeof demoViewAs !== 'undefined' ? demoViewAs : 'instructor');
            } else if (canLoadAnalytics && typeof loadEnhancedAnalytics === 'function') {
                loadEnhancedAnalytics();
            } else {
                const statsContainer = document.getElementById('overviewStatsContainer');
                if (statsContainer) {
                    statsContainer.innerHTML = '<div style="text-align: center; padding: 2rem 1.5rem; color: var(--text-light);"><p style="font-size: 1.5rem; margin-bottom: 0.5rem;"><i data-lucide="bar-chart-2" style="width:2rem;height:2rem;display:inline-block;"></i></p><p style="font-weight: 600; margin-bottom: 0.25rem; color: var(--text);">Analytics</p><p style="font-size: 0.9rem;">Analytics are available for instructors and department heads. Sign in with an eligible account to see evaluation insights here.</p></div>';
                    if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statsContainer });
                }
            }
        }
        
        // Navigate to section when clicking a stat card
        function navigateToStatSection(section) {
            // Show dashboard if not already shown
            if (typeof showDashboard === 'function') {
                showDashboard();
            }
            
            // Switch to appropriate tab
            if (section === 'courses') {
                const tabBtn = document.getElementById('instructorTabBtnCourses');
                if (tabBtn && typeof switchInstructorDashboardTab === 'function') {
                    switchInstructorDashboardTab('courses');
                } else if (tabBtn) {
                    tabBtn.click();
                }
            } else if (section === 'rubrics') {
                const tabBtn = document.getElementById('instructorTabBtnRubrics');
                if (tabBtn && typeof switchInstructorDashboardTab === 'function') {
                    switchInstructorDashboardTab('rubrics');
                } else if (tabBtn) {
                    tabBtn.click();
                }
            } else if (section === 'evaluations') {
                const tabBtn = document.getElementById('instructorTabBtnInsights');
                if (tabBtn && typeof switchInstructorDashboardTab === 'function') {
                    switchInstructorDashboardTab('insights');
                    // Then switch to evaluations tab within insights
                    setTimeout(() => {
                        if (typeof switchAnalyticsTab === 'function') {
                            switchAnalyticsTab('evaluations');
                        }
                    }, 100);
                } else if (tabBtn) {
                    tabBtn.click();
                }
            } else if (section === 'students') {
                // Students are within courses, so navigate to courses
                const tabBtn = document.getElementById('instructorTabBtnCourses');
                if (tabBtn && typeof switchInstructorDashboardTab === 'function') {
                    switchInstructorDashboardTab('courses');
                } else if (tabBtn) {
                    tabBtn.click();
                }
            }
        }
        
        // Navigate to section when clicking a stat card
        function navigateToStatSection(section) {
            // Show dashboard if not already shown
            if (typeof showDashboard === 'function') {
                showDashboard();
            }
            
            // Switch to appropriate tab
            if (section === 'courses') {
                const tabBtn = document.getElementById('instructorTabBtnCourses');
                if (tabBtn && typeof switchInstructorDashboardTab === 'function') {
                    switchInstructorDashboardTab('courses');
                } else if (tabBtn) {
                    tabBtn.click();
                }
            } else if (section === 'rubrics') {
                const tabBtn = document.getElementById('instructorTabBtnRubrics');
                if (tabBtn && typeof switchInstructorDashboardTab === 'function') {
                    switchInstructorDashboardTab('rubrics');
                } else if (tabBtn) {
                    tabBtn.click();
                }
            } else if (section === 'evaluations') {
                const tabBtn = document.getElementById('instructorTabBtnInsights');
                if (tabBtn && typeof switchInstructorDashboardTab === 'function') {
                    switchInstructorDashboardTab('insights');
                    // Then switch to evaluations tab within insights
                    setTimeout(() => {
                        if (typeof switchAnalyticsTab === 'function') {
                            switchAnalyticsTab('evaluations');
                        }
                    }, 100);
                } else if (tabBtn) {
                    tabBtn.click();
                }
            } else if (section === 'students') {
                // Students are within courses, so navigate to courses
                const tabBtn = document.getElementById('instructorTabBtnCourses');
                if (tabBtn && typeof switchInstructorDashboardTab === 'function') {
                    switchInstructorDashboardTab('courses');
                } else if (tabBtn) {
                    tabBtn.click();
                }
            }
        }
        
        // Calculate and display dashboard statistics
        async function refreshDashboardStats() {
            const coursesEl = document.getElementById('statTotalCourses');
            const studentsEl = document.getElementById('statTotalStudents');
            const evaluationsEl = document.getElementById('statTotalEvaluations');
            const rubricsEl = document.getElementById('statTotalRubrics');
            
            if (!coursesEl || !studentsEl || !evaluationsEl || !rubricsEl) {
                console.warn('Dashboard stats elements not found, skipping refresh');
                return;
            }
            
            // Show loading state
            coursesEl.textContent = '…';
            studentsEl.textContent = '…';
            evaluationsEl.textContent = '…';
            rubricsEl.textContent = '…';
            
            try {
                // Get courses
                const classes = JSON.parse(getUserItem('classes') || '[]');
                const courseCount = classes.filter(c => !isDeletedId('deleted_course_ids', c.id)).length;
                
                // Count students across all courses
                let studentCount = 0;
                classes.forEach(c => {
                    if (!isDeletedId('deleted_course_ids', c.id)) {
                        const roster = c.roster || [];
                        studentCount += roster.filter(s => !isDeletedId('deleted_student_ids', c.id + ':' + (s.id || s.supabaseId))).length;
                    }
                });
                
                // Count evaluations from Supabase if available
                let evaluationCount = 0;
                if (supabaseClient && currentUser) {
                    try {
                        const { data: evals, error } = await supabaseClient
                            .from('evaluations')
                            .select('id')
                            .eq('instructor_id', currentUser.id)
                            .is('deleted_locally_at', null);
                        
                        if (!error && evals) {
                            evaluationCount = evals.length;
                        }
                    } catch (e) {
                        console.warn('Could not load evaluation count:', e);
                    }
                }
                
                // Count rubrics
                let rubricCount = 0;
                if (typeof getAllRubrics === 'function') {
                    const rubrics = await getAllRubrics();
                    if (Array.isArray(rubrics)) {
                        rubricCount = rubrics.length;
                    }
                }
                
                // Update display
                coursesEl.textContent = courseCount.toLocaleString();
                studentsEl.textContent = studentCount.toLocaleString();
                evaluationsEl.textContent = evaluationCount.toLocaleString();
                rubricsEl.textContent = rubricCount.toLocaleString();
                
                // Update icons
                if (typeof lucide !== 'undefined' && lucide.createIcons) {
                    const statsContent = document.getElementById('dashboardStatsContent');
                    if (statsContent) lucide.createIcons({ root: statsContent });
                }
            } catch (error) {
                console.error('Error refreshing dashboard stats:', error);
                coursesEl.textContent = '—';
                studentsEl.textContent = '—';
                evaluationsEl.textContent = '—';
                rubricsEl.textContent = '—';
            }
        }

        function switchGeneralSection(sectionId) {
            // Hide all sections
            const sections = ['appearance', 'consent'];
            sections.forEach(section => {
                const sectionEl = document.getElementById('generalSection' + section.charAt(0).toUpperCase() + section.slice(1));
                if (sectionEl) sectionEl.classList.remove('active');
                
                const navItem = document.querySelector(`.general-nav-item[data-section="${section}"]`);
                if (navItem) navItem.classList.remove('active');
            });
            
            // Show selected section
            const selectedSection = document.getElementById('generalSection' + sectionId.charAt(0).toUpperCase() + sectionId.slice(1));
            if (selectedSection) {
                selectedSection.classList.add('active');
            }
            
            const selectedNavItem = document.querySelector(`.general-nav-item[data-section="${sectionId}"]`);
            if (selectedNavItem) {
                selectedNavItem.classList.add('active');
                selectedNavItem.focus();
            }
            
            // Load section-specific content
            if (sectionId === 'consent' && typeof loadCoursesForConsentDropdown === 'function') {
                loadCoursesForConsentDropdown();
            }
        }
        
        function switchAdminSection(sectionId) {
            // Hide all sections
            const sections = ['institution', 'users', 'branding', 'system', 'monitoring', 'compliance'];
            sections.forEach(section => {
                const sectionEl = document.getElementById('adminSection' + section.charAt(0).toUpperCase() + section.slice(1));
                if (sectionEl) sectionEl.classList.remove('active');
                
                const navItem = document.querySelector(`.admin-nav-item[data-section="${section}"]`);
                if (navItem) navItem.classList.remove('active');
            });
            
            // Show selected section
            const selectedSection = document.getElementById('adminSection' + sectionId.charAt(0).toUpperCase() + sectionId.slice(1));
            if (selectedSection) {
                selectedSection.classList.add('active');
            }
            
            const selectedNavItem = document.querySelector(`.admin-nav-item[data-section="${sectionId}"]`);
            if (selectedNavItem) {
                selectedNavItem.classList.add('active');
                selectedNavItem.focus();
            }
            
            // Load section-specific content
            if (sectionId === 'monitoring') {
                // Show/hide Cost Tracking based on user tier (admin/super_admin only)
                const costTrackingSection = document.getElementById('costTrackingSection');
                if (costTrackingSection) {
                    const hasAdminAccess = typeof canManageUsers === 'function' && canManageUsers();
                    costTrackingSection.style.display = hasAdminAccess ? 'block' : 'none';
                    if (hasAdminAccess && typeof loadCostTrackingDashboard === 'function') {
                        loadCostTrackingDashboard();
                    }
                }
                // Load energy dashboard for all users
                if (typeof loadEnergyDashboard === 'function') {
                    loadEnergyDashboard();
                }
            }
            
            // Ensure complianceTestingWrap is visible when compliance section is active (if user has access)
            if (sectionId === 'compliance') {
                const complianceWrap = document.getElementById('complianceTestingWrap');
                if (complianceWrap && (currentUser?.is_admin || currentUser?.is_super_admin)) {
                    // Only show if it was previously set to visible by role initialization
                    // Don't override if it was hidden (e.g., for instructors)
                    if (complianceWrap.style.display === 'none' || complianceWrap.style.display === '') {
                        complianceWrap.style.display = '';
                    }
                }
            }
            
            // Update icons
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                setTimeout(() => {
                    if (selectedSection) lucide.createIcons({ root: selectedSection });
                }, 100);
            }
        }

        function switchSettingsTab(tabId) {
            var generalBtn = document.getElementById('settingsTabBtnGeneral');
            var adminBtn = document.getElementById('settingsTabBtnAdmin');
            var demoBtn = document.getElementById('settingsTabBtnDemo');
            var generalPanel = document.getElementById('settingsTabGeneral');
            var adminPanel = document.getElementById('settingsTabAdmin');
            var demoPanel = document.getElementById('settingsTabDemo');
            if (!generalPanel || !adminPanel) return;
            generalPanel.style.display = tabId === 'general' ? 'block' : 'none';
            adminPanel.style.display = tabId === 'admin' ? 'block' : 'none';
            if (demoPanel) demoPanel.style.display = tabId === 'demo' ? 'block' : 'none';
            var adminPanelWrap = document.getElementById('settingsAdminPanelWrap');
            if (adminPanelWrap) adminPanelWrap.style.display = tabId === 'admin' ? 'block' : 'none';
            // Explicitly control Save Settings button visibility
            var saveButtonContainer = document.getElementById('saveSettingsButtonContainer');
            if (saveButtonContainer) {
                saveButtonContainer.style.display = tabId === 'general' ? 'flex' : 'none';
            }
            // Initialize General section navigation when General tab is opened
            if (tabId === 'general') {
                // Set first available section as active
                const sections = ['appearance', 'consent'];
                for (const section of sections) {
                    const sectionEl = document.getElementById('generalSection' + section.charAt(0).toUpperCase() + section.slice(1));
                    if (sectionEl) {
                        switchGeneralSection(section);
                        break;
                    }
                }
                // Update icons after navigation is shown
                if (typeof lucide !== 'undefined' && lucide.createIcons) {
                    setTimeout(() => {
                        const sidebar = document.querySelector('.general-settings-sidebar');
                        if (sidebar) lucide.createIcons({ root: sidebar });
                    }, 100);
                }
            }
            // Initialize admin section navigation when admin tab is opened
            if (tabId === 'admin') {
                // Filter sidebar items based on user tier
                const adminOnlyItems = document.querySelectorAll('[data-admin-only="true"]');
                const hasAdminAccess = typeof canManageUsers === 'function' && canManageUsers();
                adminOnlyItems.forEach(item => {
                    item.style.display = hasAdminAccess ? '' : 'none';
                });
                
                // Set first available section as active (Monitoring for instructors, Institution for admins)
                let defaultSection = 'monitoring';
                if (hasAdminAccess) {
                    const adminSections = ['institution', 'users', 'branding', 'system', 'monitoring', 'compliance'];
                    for (const section of adminSections) {
                        const sectionEl = document.getElementById('adminSection' + section.charAt(0).toUpperCase() + section.slice(1));
                        if (sectionEl) {
                            defaultSection = section;
                            break;
                        }
                    }
                } else {
                    // For instructors, default to Monitoring
                    defaultSection = 'monitoring';
                }
                switchAdminSection(defaultSection);
                
                // Update icons after navigation is shown
                if (typeof lucide !== 'undefined' && lucide.createIcons) {
                    setTimeout(() => {
                        const sidebar = document.querySelector('.admin-settings-sidebar');
                        if (sidebar) lucide.createIcons({ root: sidebar });
                    }, 100);
                }
                // Update Qwen Service URL visibility when admin tab is opened
                if (typeof updateApiKeysSectionVisibility === 'function') updateApiKeysSectionVisibility();
            }
            if (generalBtn) { generalBtn.classList.toggle('settings-tab-active', tabId === 'general'); generalBtn.setAttribute('aria-selected', tabId === 'general' ? 'true' : 'false'); }
            if (adminBtn) { adminBtn.classList.toggle('settings-tab-active', tabId === 'admin'); adminBtn.setAttribute('aria-selected', tabId === 'admin' ? 'true' : 'false'); }
            if (demoBtn) { demoBtn.classList.toggle('settings-tab-active', tabId === 'demo'); demoBtn.setAttribute('aria-selected', tabId === 'demo' ? 'true' : 'false'); }
            if (tabId === 'admin' && typeof canManageUsers === 'function' && canManageUsers()) {
                if (typeof loadCurrentThemeToForm === 'function') loadCurrentThemeToForm();
                if (typeof loadInstitutionApiKeys === 'function') loadInstitutionApiKeys();
            }
            if (tabId === 'demo') loadDemoThemeForm();
        }
        
        function updateApiKeysSectionVisibility() {
            const el = document.getElementById('apiKeysSectionSuperAdminOnly');
            // Show Qwen Service URL to all users who can run evaluations (instructor, admin, super_admin)
            // Note: Qwen Service URL is now in Admin > Data Management section
            if (el) el.style.display = (typeof hasResearchAccess === 'function' && hasResearchAccess()) ? 'block' : 'none';
        }

        function showSettings(openTab) {
            // Update URL
            if (typeof Router !== 'undefined' && Router.navigateToSection) {
                Router.navigateToSection('settings');
            }
            setActiveSection('settingsSection', 'navSettings');
            // Consent courses will be loaded when Consent section is shown in General tab
            if (typeof loadApiKeySettings === 'function') loadApiKeySettings();
            var adminTabBtn = document.getElementById('settingsTabBtnAdmin');
            // Admin tab is now visible to all users (instructors can access Monitoring for Energy & Sustainability)
            if (adminTabBtn) adminTabBtn.style.display = '';
            var demoTabBtn = document.getElementById('settingsTabBtnDemo');
            if (demoTabBtn) demoTabBtn.style.display = (typeof userTier !== 'undefined' && userTier === 'demo') ? '' : 'none';
            var tab = (openTab === 'admin' || openTab === 'demo') ? openTab : (typeof userTier !== 'undefined' && userTier === 'demo' ? 'demo' : 'general');
            if (typeof switchSettingsTab === 'function') switchSettingsTab(tab);
            if (typeof updateApiKeysSectionVisibility === 'function') updateApiKeysSectionVisibility();
            
            // Initialize dark mode toggle
            const isDark = getDarkModePreference();
            updateDarkModeToggle(isDark);
            
            // Refresh icons after settings are shown
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                setTimeout(() => lucide.createIcons(), 100);
            }
            
            // Restore normal spacing for main-content
            const mainContent = document.getElementById('main-content');
            if (mainContent) {
                mainContent.style.removeProperty('padding-top');
                mainContent.style.removeProperty('margin-top');
                mainContent.style.removeProperty('min-height');
                mainContent.style.removeProperty('height');
            }
            
            // Restore normal display for all sections
            document.querySelectorAll('.section').forEach(section => {
                section.style.removeProperty('display');
                section.style.removeProperty('height');
                section.style.removeProperty('margin');
                section.style.removeProperty('padding');
            });
        }

        function showHelp() {
            // Update URL
            if (typeof Router !== 'undefined' && Router.navigateToSection) {
                Router.navigateToSection('help');
            }
            setActiveSection('helpSection', 'navHelp');
            refreshSupportContent();
            
            // Restore normal spacing for main-content
            const mainContent = document.getElementById('main-content');
            if (mainContent) {
                mainContent.style.removeProperty('padding-top');
                mainContent.style.removeProperty('margin-top');
                mainContent.style.removeProperty('min-height');
                mainContent.style.removeProperty('height');
            }
            
            // Restore normal display for all sections
            document.querySelectorAll('.section').forEach(section => {
                section.style.removeProperty('display');
                section.style.removeProperty('height');
                section.style.removeProperty('margin');
                section.style.removeProperty('padding');
            });
        }

        function switchSupportDocTab(tabId) {
            const panels = ['supportPanelGettingStarted', 'supportPanelUserManual', 'supportPanelTechnical'];
            const buttons = ['supportTabBtnGettingStarted', 'supportTabBtnUserManual', 'supportTabBtnTechnical'];
            panels.forEach(id => {
                const el = document.getElementById(id);
                if (el) { el.classList.toggle('active', id === 'supportPanel' + tabId.split('-').map(s => s.charAt(0).toUpperCase() + s.slice(1)).join('')); }
            });
            buttons.forEach((id, i) => {
                const key = ['getting-started', 'user-manual', 'technical'][i];
                const el = document.getElementById(id);
                if (el) { el.classList.toggle('support-tab-active', key === tabId); el.setAttribute('aria-selected', key === tabId ? 'true' : 'false'); }
            });
            if (tabId === 'technical') populateSupportChangelog();
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: document.getElementById('helpSection') });
        }

        function refreshSupportContent() {
            const v = (typeof CONFIG !== 'undefined' && CONFIG.appVersion) ? CONFIG.appVersion : '3.0';
            const label = (typeof CONFIG !== 'undefined' && CONFIG.appVersionLabel) ? ' ' + CONFIG.appVersionLabel : ' (Supabase Edition)';
            const versionEl = document.getElementById('supportVersionText');
            const labelEl = document.getElementById('supportVersionLabel');
            if (versionEl) versionEl.textContent = 'v' + v;
            if (labelEl) labelEl.textContent = label;
            const tier = typeof userTier !== 'undefined' ? userTier : 'demo';
            document.querySelectorAll('.support-tier-badge').forEach(badge => {
                const t = badge.getAttribute('data-tier');
                const show = t === tier || (tier === 'super_admin' && (t === 'admin' || t === 'instructor')) || (tier === 'admin' && t === 'instructor');
                badge.style.display = show ? 'inline-block' : 'none';
            });
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: document.getElementById('helpSection') });
        }

        function populateSupportChangelog() {
            const el = document.getElementById('supportChangelogContent');
            if (!el) return;
            const log = typeof SUPPORT_CHANGELOG !== 'undefined' ? SUPPORT_CHANGELOG : 'See CHANGELOG.md in the project for the full change history.';
            el.textContent = log;
        }

        // Recent changelog text for Support → Technical Documentation (full history in CHANGELOG.md)
        const SUPPORT_CHANGELOG = `v3.0 (Supabase Edition)
• Support section restructured: version at top, Getting Started, User Manual, Technical Documentation
• Documentation tailored by user tier (instructor, admin, super_admin)
• Data management, Change Log, and Licensing/Legal in Technical Documentation

Earlier:
• Supabase backend: courses, evaluations, rubrics, consent, audit logs, RLS
• Multi-provider evaluation: Gemini, GPT-4o, Claude, SpeechGradebook Text Model (Mistral), SpeechGradebook Text + Video Model (Qwen)
• Institution themes, custom fonts, consent links, Course Insights / analytics
• FERPA-oriented audit logging and consent flows`;

        // Consent: store last generated links for copy/download
        let lastConsentLinks = [];

        function showConsent() {
            // Consent management is in Settings (Consent tab)
            showSettings('consent');
        }

        async function loadCoursesForConsentDropdown() {
            const sel = document.getElementById('consentCourseSelect');
            if (!sel || !supabaseClient || !currentUser) return;
            try {
                let query = supabaseClient.from('courses').select('id, name').order('name');
                if (userTier === 'instructor') {
                    query = query.eq('instructor_id', currentUser.id);
                } else if (userTier === 'admin' && currentUser.institution_id) {
                    const { data: instInstructors } = await supabaseClient
                        .from('user_profiles')
                        .select('id')
                        .eq('institution_id', currentUser.institution_id);
                    const ids = (instInstructors || []).map(i => i.id);
                    if (ids.length) query = query.in('instructor_id', ids);
                    else { sel.innerHTML = '<option value="">-- No courses --</option>'; return; }
                }
                query = query.is('deleted_locally_at', null);
                const { data: courses, error } = await query;
                if (error) throw error;
                sel.innerHTML = '<option value="">-- Select a course --</option>' +
                    (courses || []).map(c => `<option value="${c.id}">${escapeHtml(c.name)}</option>`).join('');
            } catch (e) {
                console.error('loadCoursesForConsentDropdown:', e);
                const msgEl = document.getElementById('consentLinksMessage');
                if (msgEl) msgEl.textContent = 'Could not load courses.';
            }
        }

        async function generateConsentLinks() {
            const courseId = document.getElementById('consentCourseSelect')?.value;
            const consentType = 'data_collection'; // Single catch-all consent (matches DB allowed values; covers grading, platform improvement, research)
            const msgEl = document.getElementById('consentLinksMessage');
            const container = document.getElementById('consentLinksContainer');
            const btn = document.getElementById('consentGenerateBtn');
            if (!courseId || !supabaseClient || !currentUser) {
                if (msgEl) msgEl.textContent = 'Please select a course and sign in.';
                return;
            }
            msgEl.textContent = 'Generating links…';
            if (container) container.classList.add('hidden');
            if (btn) btn.disabled = true;
            try {
                const { data: students, error: studErr } = await supabaseClient
                    .from('course_students')
                    .select('id, first_name, last_name, email')
                    .eq('course_id', courseId);
                if (studErr) throw studErr;
                if (!students || students.length === 0) {
                    msgEl.textContent = 'No students in this course.';
                    return;
                }
                // Include all consent_requests for this course/type (completed or not) so we reuse tokens and never INSERT duplicate (student_id, course_id, consent_type)
                const { data: existing } = await supabaseClient
                    .from('consent_requests')
                    .select('student_id, token')
                    .eq('course_id', courseId)
                    .eq('consent_type', consentType);
                const tokenByStudent = {};
                (existing || []).forEach(r => { tokenByStudent[r.student_id] = r.token; });
                var path = (window.location.pathname || '/').replace(/\/index\.html$/i, '') || '/';
                if (!path.endsWith('/')) path += '/';
                const baseUrl = window.location.origin + path + 'consent.html';
                const links = [];
                for (const s of students) {
                    let token = tokenByStudent[s.id];
                    if (!token) {
                        const { data: inserted, error: insErr } = await supabaseClient
                            .from('consent_requests')
                            .insert({
                                student_id: s.id,
                                course_id: courseId,
                                consent_type: consentType,
                                created_by: currentUser.id
                            })
                            .select('token')
                            .single();
                        if (insErr) {
                            console.error('Insert consent_request:', insErr);
                            continue;
                        }
                        token = inserted?.token;
                    }
                    if (!token) continue;
                    const name = [s.first_name, s.last_name].filter(Boolean).join(' ').trim() || 'Student';
                    const link = baseUrl + '?token=' + token;
                    links.push({ name, email: s.email || '', link });
                }
                lastConsentLinks = links;
                renderConsentLinksTable(links);
                msgEl.textContent = links.length + ' link(s) ready. Copy or download, then email each student their link.';
                if (container) container.classList.remove('hidden');
            } catch (e) {
                console.error('generateConsentLinks:', e);
                msgEl.textContent = 'Error: ' + (e.message || 'Could not generate links.');
            } finally {
                if (btn) btn.disabled = false;
            }
        }

        function renderConsentLinksTable(links) {
            const tbody = document.getElementById('consentLinksTableBody');
            if (!tbody) return;
            tbody.innerHTML = links.map((row, i) => {
                const linkEsc = escapeHtml(row.link);
                const nameEsc = escapeHtml(row.name);
                const emailEsc = escapeHtml(row.email);
                return `<tr>
                    <td>${nameEsc}</td>
                    <td>${emailEsc || '<span style="color:var(--text-light);font-style:italic;">No email</span>'}</td>
                    <td><a href="${linkEsc}" target="_blank" rel="noopener" style="word-break:break-all;">${linkEsc}</a></td>
                    <td style="white-space:nowrap;">
                        ${row.email ? `<button type="button" class="send-consent-email" data-email="${escapeHtml(row.email)}" data-name="${escapeHtml(row.name)}" data-link="${escapeHtml(row.link)}" style="padding:0.25rem 0.5rem;margin-right:0.5rem;" title="Send email to ${escapeHtml(row.name)}"><span class="icon-with-text"><i data-lucide="mail" style="width:0.875rem;height:0.875rem;"></i> Email</span></button>` : ''}
                        <button type="button" class="copy-consent-link" data-link="${escapeHtml(row.link)}" style="padding:0.25rem 0.5rem;" title="Copy link"><span class="icon-with-text"><i data-lucide="copy" style="width:0.875rem;height:0.875rem;"></i> Copy</span></button>
                    </td>
                </tr>`;
            }).join('');
            tbody.querySelectorAll('.copy-consent-link').forEach(btn => {
                btn.addEventListener('click', function() {
                    const link = this.getAttribute('data-link');
                    if (link) {
                        navigator.clipboard.writeText(link).then(() => { 
                            const icon = this.querySelector('i');
                            const originalIcon = icon ? icon.getAttribute('data-lucide') : 'copy';
                            if (icon) {
                                icon.setAttribute('data-lucide', 'check');
                                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: this });
                            }
                            setTimeout(() => { 
                                if (icon) {
                                    icon.setAttribute('data-lucide', originalIcon);
                                    if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: this });
                                }
                            }, 1500);
                        });
                    }
                });
            });
            
            // Add event listeners for send email buttons
            tbody.querySelectorAll('.send-consent-email').forEach(btn => {
                btn.addEventListener('click', function() {
                    const email = this.getAttribute('data-email');
                    const name = this.getAttribute('data-name');
                    const link = this.getAttribute('data-link');
                    if (email && link) {
                        sendConsentEmail(email, name, link);
                    }
                });
            });
            
            // Re-initialize Lucide icons
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons({ root: tbody });
            }
        }

        function copyAllConsentLinks() {
            if (!lastConsentLinks.length) return;
            const text = lastConsentLinks.map(r => r.name + ' – ' + r.link).join('\n');
            navigator.clipboard.writeText(text).then(() => {
                const msg = document.getElementById('consentLinksMessage');
                if (msg) msg.textContent = 'All links copied to clipboard.';
            }).catch(() => alert('Copy failed.'));
        }

        function downloadConsentCSV() {
            if (!lastConsentLinks.length) return;
            const header = 'Name,Email,Consent link\n';
            const rows = lastConsentLinks.map(r => {
                const name = '"' + (r.name || '').replace(/"/g, '""') + '"';
                const email = '"' + (r.email || '').replace(/"/g, '""') + '"';
                const link = '"' + (r.link || '').replace(/"/g, '""') + '"';
                return [name, email, link].join(',');
            }).join('\n');
            const blob = new Blob([header + rows], { type: 'text/csv;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'consent-links.csv';
            a.click();
            URL.revokeObjectURL(a.href);
        }
        
        // Send consent email to a single student
        function sendConsentEmail(email, studentName, consentLink) {
            if (!email || !consentLink) {
                alert('Email address or consent link is missing.');
                return;
            }
            
            // Get course name if available
            const courseSelect = document.getElementById('consentCourseSelect');
            let courseName = 'your course';
            if (courseSelect && courseSelect.value) {
                const selectedOption = courseSelect.options[courseSelect.selectedIndex];
                if (selectedOption) {
                    courseName = selectedOption.textContent;
                }
            }
            
            const subject = encodeURIComponent('Data Use Consent Request - ' + courseName);
            const body = encodeURIComponent(
                'Dear ' + studentName + ',\n\n' +
                'Your instructor is requesting your consent for data use in ' + courseName + '.\n\n' +
                'Your course and evaluation data may be used for:\n' +
                '• Grading\n' +
                '• Platform and AI improvement\n' +
                '• Research\n' +
                '• Potential sharing or licensing to third parties (e.g., researchers or partners)\n\n' +
                'You can still be evaluated if you do not consent; your data will then be stored only on your instructor\'s device and not used for research, improvement, or third-party sharing.\n\n' +
                'Please click the link below to provide your consent:\n' +
                consentLink + '\n\n' +
                'Thank you,\n' +
                'SpeechGradebook'
            );
            
            const mailtoLink = `mailto:${email}?subject=${subject}&body=${body}`;
            window.open(mailtoLink);
        }
        
        // Send consent emails to all students
        function sendAllConsentEmails() {
            if (!lastConsentLinks || lastConsentLinks.length === 0) {
                alert('No consent links available. Please generate links first.');
                return;
            }
            
            const studentsWithEmail = lastConsentLinks.filter(link => link.email && link.email.trim());
            if (studentsWithEmail.length === 0) {
                alert('No students have email addresses. Cannot send emails.');
                return;
            }
            
            // Get course name if available
            const courseSelect = document.getElementById('consentCourseSelect');
            let courseName = 'your course';
            if (courseSelect && courseSelect.value) {
                const selectedOption = courseSelect.options[courseSelect.selectedIndex];
                if (selectedOption) {
                    courseName = selectedOption.textContent;
                }
            }
            
            // Create a single email with all consent links (BCC all students)
            const bccEmails = studentsWithEmail.map(link => link.email).join(',');
            const subject = encodeURIComponent('Data Use Consent Request - ' + courseName);
            
            // Create body with individual links for each student
            let bodyText = 'Dear Students,\n\n';
            bodyText += 'Your instructor is requesting your consent for data use in ' + courseName + '.\n\n';
            bodyText += 'Your course and evaluation data may be used for:\n';
            bodyText += '• Grading\n';
            bodyText += '• Platform and AI improvement\n';
            bodyText += '• Research\n';
            bodyText += '• Potential sharing or licensing to third parties (e.g., researchers or partners)\n\n';
            bodyText += 'You can still be evaluated if you do not consent; your data will then be stored only on your instructor\'s device and not used for research, improvement, or third-party sharing.\n\n';
            bodyText += 'Please click your individual consent link below:\n\n';
            
            studentsWithEmail.forEach(link => {
                bodyText += link.name + ':\n' + link.link + '\n\n';
            });
            
            bodyText += 'Thank you,\nSpeechGradebook';
            
            const body = encodeURIComponent(bodyText);
            
            // Option 1: Send one email with BCC (if email client supports it)
            const mailtoLink = `mailto:?bcc=${bccEmails}&subject=${subject}&body=${body}`;
            
            // Show confirmation dialog
            const confirmMsg = `This will open your email client to send consent links to ${studentsWithEmail.length} student(s).\n\n` +
                             `Note: Some email clients may not support BCC in mailto: links. If that's the case, you can:\n` +
                             `1. Copy all links and send individual emails\n` +
                             `2. Use the "Copy all links" button and paste into your email\n\n` +
                             `Continue?`;
            
            if (confirm(confirmMsg)) {
                window.open(mailtoLink);
                
                // Also show option to copy email addresses
                const copyEmails = confirm('Would you like to copy all email addresses to your clipboard?');
                if (copyEmails) {
                    navigator.clipboard.writeText(bccEmails).then(() => {
                        const msg = document.getElementById('consentLinksMessage');
                        if (msg) msg.textContent = 'Email addresses copied to clipboard.';
                    });
                }
            }
        }

        function showAdmin() {
            // Admin panel is in Settings
            if (!canManageUsers()) {
                alert('Access denied. Admin privileges required.');
                return;
            }
            showSettings();
        }
        
        // Super Admin: load institutions into theme customizer dropdown
        async function loadInstitutionsForThemeCustomizer() {
            if (!supabaseClient || !isSuperAdmin()) return;
            const sel = document.getElementById('themeInstitutionSelect');
            if (!sel) return;
            try {
                const { data: institutions, error } = await supabaseClient
                    .from('institutions')
                    .select('id, name')
                    .order('name');
                if (error) throw error;
                const list = institutions || [];
                const opts = list.map(inst => `<option value="${inst.id}">${escapeHtml(inst.name)}</option>`).join('');
                sel.innerHTML = '<option value="">Select institution…</option>' + opts;
                loadInstitutionsForAssignTheme(list);
            } catch (e) {
                console.warn('loadInstitutionsForThemeCustomizer:', e);
            }
        }

        // Super Admin: populate Assign theme source/target dropdowns
        function loadInstitutionsForAssignTheme(institutions) {
            if (!isSuperAdmin()) return;
            const src = document.getElementById('assignThemeSourceSelect');
            const tgt = document.getElementById('assignThemeTargetSelect');
            if (!src || !tgt) return;
            const list = Array.isArray(institutions) ? institutions : [];
            const opts = list.map(inst => `<option value="${inst.id}">${escapeHtml(inst.name)}</option>`).join('');
            src.innerHTML = '<option value="">Select institution…</option>' + opts;
            tgt.innerHTML = '<option value="">Select institution…</option>' + opts;
        }

        // Super Admin: copy one institution's theme to another
        async function assignThemeToInstitution() {
            if (!isSuperAdmin()) {
                alert('Only Super Admins can assign themes to institutions.');
                return;
            }
            const statusEl = document.getElementById('assignThemeStatus');
            const sourceId = document.getElementById('assignThemeSourceSelect')?.value;
            const targetId = document.getElementById('assignThemeTargetSelect')?.value;
            if (!sourceId || !targetId) {
                if (statusEl) statusEl.innerHTML = '<p style="color: var(--error); font-size: 0.9rem;">Select both "Copy theme from" and "Assign to institution".</p>';
                return;
            }
            if (sourceId === targetId) {
                if (statusEl) statusEl.innerHTML = '<p style="color: var(--error); font-size: 0.9rem;">Source and target must be different institutions.</p>';
                return;
            }
            if (!supabaseClient) {
                if (statusEl) statusEl.innerHTML = '<p style="color: var(--error); font-size: 0.9rem;">Not connected to database.</p>';
                return;
            }
            if (statusEl) statusEl.innerHTML = '<p style="color: var(--text-light); font-size: 0.9rem;">Copying theme…</p>';
            try {
                const { data: sourceTheme, error: fetchErr } = await supabaseClient
                    .from('institution_themes')
                    .select('*')
                    .eq('institution_id', sourceId)
                    .maybeSingle();
                if (fetchErr) throw fetchErr;
                if (!sourceTheme) {
                    if (statusEl) statusEl.innerHTML = '<p style="color: var(--warning); font-size: 0.9rem;">The source institution has no theme to copy. Edit and save a theme for it first.</p>';
                    return;
                }
                // Exclude id so target row gets new PK on insert; exclude institution_id/created_at/updated_at (we set target id and updated_at)
                const { id, institution_id, created_at, updated_at, ...themeFields } = sourceTheme;
                const payload = {
                    institution_id: targetId,
                    ...themeFields,
                    updated_at: new Date().toISOString()
                };
                const { data: saved, error: upsertErr } = await supabaseClient
                    .from('institution_themes')
                    .upsert(payload, { onConflict: 'institution_id' })
                    .select();
                if (upsertErr) throw upsertErr;
                if (statusEl) statusEl.innerHTML = '<p style="color: var(--success); font-size: 0.9rem;"><span class="icon-with-text"><i data-lucide="check-circle" style="width:1em;height:1em;"></i> Theme assigned successfully. The target institution now uses the copied theme.</span></p>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statusEl });
                loadInstitutionsForThemeCustomizer();
            } catch (err) {
                console.error('assignThemeToInstitution:', err);
                if (statusEl) statusEl.innerHTML = '<p style="color: var(--error); font-size: 0.9rem;"><span class="icon-with-text"><i data-lucide="x-circle" style="width:1em;height:1em;"></i> ' + escapeHtml(err.message || 'Failed to assign theme.') + '</span></p>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statusEl });
            }
        }
        
        function onThemeInstitutionChange() {
            loadCurrentThemeToForm();
        }
        
        // Super Admin: create a new institution
        async function createNewInstitution() {
            if (!isSuperAdmin()) {
                alert('Only Super Admins can create institutions.');
                return;
            }
            const nameInput = document.getElementById('newInstitutionName');
            const statusEl = document.getElementById('createInstitutionStatus');
            const name = (nameInput && nameInput.value) ? nameInput.value.trim() : '';
            if (!name) {
                if (statusEl) statusEl.innerHTML = '<p style="color: var(--error); padding: 0.75rem; background: #fee2e2; border-radius: 0.5rem;">Enter an institution name.</p>';
                return;
            }
            if (!supabaseClient) {
                if (statusEl) statusEl.innerHTML = '<p style="color: var(--error); padding: 0.75rem; background: #fee2e2; border-radius: 0.5rem;">Not connected to database.</p>';
                return;
            }
            if (statusEl) statusEl.innerHTML = '<p style="color: var(--text-light); padding: 0.75rem;">Creating…</p>';
            try {
                const { data, error } = await supabaseClient
                    .from('institutions')
                    .insert({ name: name })
                    .select('id, name')
                    .single();
                if (error) throw error;
                if (nameInput) nameInput.value = '';
                if (statusEl) statusEl.innerHTML = '<p style="color: var(--success); padding: 0.75rem; background: #d1fae5; border-radius: 0.5rem; border-left: 4px solid var(--success);"><span class="icon-with-text"><i data-lucide="check-circle" style="width:1.1em;height:1.1em;"></i> Institution created: ' + escapeHtml(data.name) + '. You can now assign users and create a theme for it.</span></p>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statusEl });
                loadInstitutionsForThemeCustomizer();
                loadInstitutionsForFilter();
                if (typeof loadCourseScopeInstitutions === 'function') loadCourseScopeInstitutions();
            } catch (err) {
                console.error('createNewInstitution:', err);
                if (statusEl) statusEl.innerHTML = '<p style="color: var(--error); padding: 0.75rem; background: #fee2e2; border-radius: 0.5rem; border-left: 4px solid var(--error);"><span class="icon-with-text"><i data-lucide="x-circle" style="width:1.1em;height:1.1em;"></i> ' + escapeHtml(err.message || 'Failed to create institution.') + ' Run the RLS migration to allow Super Admins to insert institutions.</span></p>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statusEl });
            }
        }
        
        // Set theme form inputs from a branding package (default or UTK WDS)
        function setThemeFormToBrandingPackage(pkgId) {
            const pkg = BRANDING_PACKAGES[pkgId] || BRANDING_PACKAGES['default'];
            const primaryEl = document.getElementById('themePrimaryColor');
            const primaryText = document.getElementById('themePrimaryText');
            if (primaryEl) primaryEl.value = pkg.primary;
            if (primaryText) primaryText.value = pkg.primary;
            const headerEl = document.getElementById('themeHeaderColor');
            const headerText = document.getElementById('themeHeaderText');
            if (headerEl) headerEl.value = pkg.header;
            if (headerText) headerText.value = pkg.header;
            const secEl = document.getElementById('themeSecondaryColor');
            const secText = document.getElementById('themeSecondaryText');
            if (secEl) secEl.value = pkg.secondary;
            if (secText) secText.value = pkg.secondary;
            const textEl = document.getElementById('themeTextColor');
            const textText = document.getElementById('themeTextText');
            if (textEl) textEl.value = pkg.text;
            if (textText) textText.value = pkg.text;
            const headingFont = document.getElementById('themeHeadingFont');
            const bodyFont = document.getElementById('themeBodyFont');
            if (headingFont) headingFont.value = pkg.fontHeading;
            if (bodyFont) bodyFont.value = pkg.fontBody;
            if (typeof syncColorInputs === 'function') syncColorInputs();
        }

        function onBrandingPackageChange(value) {
            setThemeFormToBrandingPackage(value);
        }

        // Set theme form inputs to SpeechGradebook default (for creating new themes)
        function setThemeFormToDefaults() {
            setThemeFormToBrandingPackage('default');
            window.institutionLogoData = null;
            const logoImg = document.getElementById('logoPreviewImage');
            const logoPlaceholder = document.getElementById('logoPlaceholder');
            if (logoImg) { logoImg.src = ''; logoImg.style.display = 'none'; }
            if (logoPlaceholder) logoPlaceholder.style.display = 'block';
            const customList = document.getElementById('customFontsList');
            if (customList) customList.style.display = 'none';
            const container = document.getElementById('customFontsContainer');
            if (container) container.innerHTML = '';
            if (typeof syncColorInputs === 'function') syncColorInputs();
        }
        
        function getThemeFormInstitutionId() {
            if (isSuperAdmin()) {
                const sel = document.getElementById('themeInstitutionSelect');
                if (sel && sel.value) return sel.value;
                return null;
            }
            return currentUser?.institution_id || null;
        }
        
        // Load current institution theme into form
        async function loadCurrentThemeToForm() {
            const institutionId = getThemeFormInstitutionId();
            if (!institutionId && !isSuperAdmin()) {
                if (!currentUser || !currentUser.institution_id) {
                    console.warn('⚠️ Cannot load theme form: No user or institution');
                    return;
                }
            }
            if (isSuperAdmin() && !institutionId) {
                setThemeFormToDefaults();
                return;
            }
            const targetInstitutionId = institutionId || currentUser.institution_id;
            console.log('Loading theme form for institution:', targetInstitutionId);
            
            try {
                const { data: theme, error } = await supabaseClient
                    .from('institution_themes')
                    .select('*')
                    .eq('institution_id', targetInstitutionId)
                    .maybeSingle();
                
                if (error) {
                    console.error('Error loading theme form:', error);
                    if (isSuperAdmin()) setThemeFormToDefaults();
                    return;
                }
                
                if (theme) {
                    if (!isSuperAdmin() && theme.institution_id !== currentUser.institution_id) {
                        console.error('❌ SECURITY VIOLATION: Theme institution mismatch!');
                        alert('Security error: You do not have permission to edit this theme.');
                        return;
                    }
                    
                    console.log('✓ Loading theme form with data from institution:', theme.institution_id);
                    
                    document.getElementById('themePrimaryColor').value = theme.primary_color || '#1e3a5f';
                    document.getElementById('themePrimaryText').value = theme.primary_color || '#1e3a5f';
                    document.getElementById('themeHeaderColor').value = theme.header_bg_color || '#142940';
                    document.getElementById('themeHeaderText').value = theme.header_bg_color || '#142940';
                    document.getElementById('themeSecondaryColor').value = theme.secondary_color || '#8b9dc3';
                    document.getElementById('themeSecondaryText').value = theme.secondary_color || '#8b9dc3';
                    document.getElementById('themeTextColor').value = theme.text_primary || '#2c3e50';
                    document.getElementById('themeTextText').value = theme.text_primary || '#2c3e50';
                    
                    if (theme.font_heading) {
                        document.getElementById('themeHeadingFont').value = theme.font_heading;
                    }
                    if (theme.font_body) {
                        document.getElementById('themeBodyFont').value = theme.font_body;
                    }
                    
                    if (theme.logo_url) {
                        const logoImg = document.getElementById('logoPreviewImage');
                        const logoPlaceholder = document.getElementById('logoPlaceholder');
                        if (logoImg && logoPlaceholder) {
                            logoImg.src = theme.logo_url;
                            logoImg.style.display = 'block';
                            logoPlaceholder.style.display = 'none';
                            window.institutionLogoData = theme.logo_url;
                            console.log('✓ Logo loaded from database');
                        }
                    } else {
                        // Only clear preview; do NOT set institutionLogoData = null here, so a
                        // newly uploaded logo (not yet saved) is not lost when switching tabs or reloading form.
                        const logoImg = document.getElementById('logoPreviewImage');
                        const logoPlaceholder = document.getElementById('logoPlaceholder');
                        if (logoImg) { logoImg.src = ''; logoImg.style.display = 'none'; }
                        if (logoPlaceholder) logoPlaceholder.style.display = 'block';
                    }
                    
                    if (theme.custom_fonts) {
                        console.log('✓ Loading custom fonts into form');
                        loadCustomFonts(theme.custom_fonts);
                    } else {
                        const customList = document.getElementById('customFontsList');
                        if (customList) customList.style.display = 'none';
                        const container = document.getElementById('customFontsContainer');
                        if (container) container.innerHTML = '';
                    }
                    
                    syncColorInputs();
                    console.log('✓ Theme form loaded successfully');
                } else {
                    console.log('ℹ️ No theme for this institution; showing defaults for new theme.');
                    // University of Tennessee (UTK) defaults to UTK Torch / UTK WDS branding
                    const { data: institution } = await supabaseClient
                        .from('institutions')
                        .select('name')
                        .eq('id', targetInstitutionId)
                        .maybeSingle();
                    const isUTK = institution?.name && /tennessee/i.test(institution.name);
                    if (isUTK) {
                        setThemeFormToBrandingPackage('utk-wds');
                        const pkgSel = document.getElementById('brandingPackageSelect');
                        if (pkgSel) pkgSel.value = 'utk-wds';
                        console.log('✓ Defaulting to UTK Torch (UTK WDS) for University of Tennessee');
                    } else {
                        setThemeFormToDefaults();
                    }
                }
            } catch (err) {
                console.error('Error loading theme form:', err);
                if (isSuperAdmin()) setThemeFormToDefaults();
            }
        }
        
        // Load and display custom fonts
        function loadCustomFonts(customFontsData) {
            if (!customFontsData) return;
            
            let fonts = [];
            try {
                fonts = typeof customFontsData === 'string' ? JSON.parse(customFontsData) : customFontsData;
            } catch (e) {
                console.error('Error parsing custom fonts:', e);
                return;
            }
            
            if (!Array.isArray(fonts) || fonts.length === 0) return;
            
            const container = document.getElementById('customFontsContainer');
            const list = document.getElementById('customFontsList');
            
            if (!container || !list) return;
            
            // Show the list
            list.style.display = 'block';
            
            // Clear existing
            container.innerHTML = '';
            
            // Add each font
            fonts.forEach((font, index) => {
                // Inject font-face
                injectFontFace(font);
                
                // Add to selectors
                addFontToSelectors(font.name, font.family);
                
                // Display in list
                const fontItem = document.createElement('div');
                fontItem.style.cssText = 'padding: 0.75rem; background: var(--bg); border: 1px solid var(--border); border-radius: 0.25rem; display: flex; justify-content: space-between; align-items: center;';
                fontItem.innerHTML = `
                    <span style="font-family: ${escapeHtml(font.family)}, sans-serif; font-weight: 600;">${escapeHtml(font.name)}</span>
                    <button onclick="removeCustomFont(${index})" style="padding: 0.25rem 0.5rem; font-size: 0.85rem; background: var(--error); color: white; display: inline-flex; align-items: center; gap: 0.35rem;"><i data-lucide="trash-2" style="width:1rem;height:1rem;"></i> Remove</button>
                `;
                container.appendChild(fontItem);
            });
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: container });
        }
        
        // Inject @font-face CSS - ONLY Regular weight to prevent auto-matching
        function injectFontFace(font) {
            const styleId = `custom-font-${font.family.replace(/[^a-zA-Z0-9]/g, '-')}`;
            
            // Check if already injected
            if (document.getElementById(styleId)) return;
            
            // CRITICAL: Only use Regular (400) Normal style variant
            // This prevents browser from auto-applying bold/italic variants
            const regularFile = font.files.find(f => f.weight === '400' && f.style === 'normal');
            
            if (!regularFile) {
                console.warn(`No Regular variant found for ${font.family}, using first file`);
                // Fallback to first file but force it as Regular
                const fallbackFile = font.files[0];
                if (!fallbackFile) return;
                
                const style = document.createElement('style');
                style.id = styleId;
                style.textContent = `
                    @font-face {
                        font-family: '${font.family}';
                        src: url('${fallbackFile.data}') format('${fallbackFile.format}');
                        font-weight: 400;
                        font-style: normal;
                        font-display: swap;
                    }
                `;
                document.head.appendChild(style);
                console.log(`✓ Injected font-face for ${font.family} (forced as Regular)`);
                return;
            }
            
            // Inject ONLY the Regular variant
            const style = document.createElement('style');
            style.id = styleId;
            style.textContent = `
                @font-face {
                    font-family: '${font.family}';
                    src: url('${regularFile.data}') format('${regularFile.format}');
                    font-weight: 400;
                    font-style: normal;
                    font-display: swap;
                }
            `;
            
            document.head.appendChild(style);
            console.log(`✓ Injected font-face for ${font.family} (Regular only - ${font.files.length} total variants ignored to prevent auto-matching)`);
        }
        
        // Add font to selectors
        function addFontToSelectors(name, family) {
            const headingSelect = document.getElementById('themeHeadingFont');
            const bodySelect = document.getElementById('themeBodyFont');
            
            if (!headingSelect || !bodySelect) return;
            
            const value = `'${family}', sans-serif`;
            
            // Check if already exists
            const existsInHeading = Array.from(headingSelect.options).some(opt => opt.value === value);
            const existsInBody = Array.from(bodySelect.options).some(opt => opt.value === value);
            
            if (!existsInHeading) {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = `${name} (Custom)`;
                headingSelect.appendChild(option);
            }
            
            if (!existsInBody) {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = `${name} (Custom)`;
                bodySelect.appendChild(option);
            }
        }
        
        // Upload custom font
        async function uploadCustomFont() {
            const nameInput = document.getElementById('customFontName');
            const filesInput = document.getElementById('customFontFiles');
            
            // Check which input has files
            const files = filesInput.files;
            
            if (!nameInput.value.trim()) {
                alert('Please enter a font family name.');
                return;
            }
            
            if (!files || files.length === 0) {
                alert('Please select font files or a folder containing fonts.');
                return;
            }
            
            const fontName = nameInput.value.trim();
            const fontFamily = fontName.replace(/[^a-zA-Z0-9 ]/g, '');
            
            const statusDiv = document.getElementById('themeStatus');
            statusDiv.innerHTML = '<p style="color: var(--text-light);">Processing font files...</p>';
            
            try {
                let regularFile = null;
                let processedCount = 0;
                
                // Find ONLY the Regular variant - discard all others to save storage
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    
                    // Skip non-font files
                    if (!file.name.match(/\.(woff2|woff|ttf|otf)$/i)) {
                        console.log('Skipping non-font file:', file.name);
                        continue;
                    }
                    
                    processedCount++;
                    
                    // Detect if this is the Regular variant
                    const fileName = file.name.toLowerCase();
                    const isRegular = (fileName.includes('regular') || fileName.includes('normal')) && 
                                     !fileName.includes('italic') && 
                                     !fileName.includes('oblique');
                    
                    // If no explicit "Regular" found, use first non-bold, non-italic file as fallback
                    const isFallbackRegular = !fileName.includes('bold') && 
                                             !fileName.includes('italic') && 
                                             !fileName.includes('black') && 
                                             !fileName.includes('heavy') && 
                                             !fileName.includes('light') && 
                                             !fileName.includes('thin') && 
                                             !fileName.includes('medium') &&
                                             !fileName.includes('semi') &&
                                             !fileName.includes('extra');
                    
                    if (isRegular || (isFallbackRegular && !regularFile)) {
                        // Validate size (max 2MB)
                        if (file.size > 2 * 1024 * 1024) {
                            console.warn(`${file.name} is too large (max 2MB), skipping.`);
                            continue;
                        }
                        
                        // Determine format
                        const format = file.name.toLowerCase().endsWith('.woff2') ? 'woff2' :
                                      file.name.toLowerCase().endsWith('.woff') ? 'woff' :
                                      file.name.toLowerCase().endsWith('.ttf') ? 'truetype' :
                                      file.name.toLowerCase().endsWith('.otf') ? 'opentype' : 'woff';
                        
                        // Read as base64
                        const base64 = await readFileAsBase64(file);
                        
                        regularFile = {
                            name: file.name,
                            format: format,
                            data: base64,
                            weight: '400',
                            style: 'normal'
                        };
                        
                        console.log(`✓ Found Regular variant: ${file.name}`);
                        break; // Stop after finding Regular
                    } else {
                        console.log(`Skipping non-Regular variant: ${file.name} (not needed, saves storage)`);
                    }
                }
                
                if (!regularFile) {
                    throw new Error('No Regular (normal weight) font file found. Please include a Regular or Normal weight variant in your font package.');
                }
                
                // Create font package with ONLY Regular variant
                const fontPackage = {
                    name: fontName,
                    family: fontFamily,
                    files: [regularFile] // ONLY ONE FILE - saves storage!
                };
                
                // Get existing custom fonts
                let customFonts = [];
                if (currentInstitutionTheme && currentInstitutionTheme.custom_fonts) {
                    try {
                        customFonts = typeof currentInstitutionTheme.custom_fonts === 'string' 
                            ? JSON.parse(currentInstitutionTheme.custom_fonts)
                            : currentInstitutionTheme.custom_fonts;
                    } catch (e) {
                        customFonts = [];
                    }
                }
                
                // Add new font
                customFonts.push(fontPackage);
                
                // Temporarily store (will be saved with theme)
                window.pendingCustomFonts = customFonts;
                
                // Display the font
                loadCustomFonts(customFonts);
                
                // Clear inputs
                nameInput.value = '';
                filesInput.value = '';
                
                const discardedCount = processedCount - 1;
                
                statusDiv.innerHTML = 
                    '<p style="color: var(--success); padding: 1rem; background: #d1fae5; border-radius: 0.5rem;"><span class="icon-with-text"><i data-lucide="check-circle" style="width:1.25em;height:1.25em;"></i> Font "' + escapeHtml(fontName) + '" uploaded!</span><br>' +
                    '<span style="font-size: 0.9rem; color: var(--text-light); margin-top: 0.5rem; display: block;">' +
                    'Stored: 1 file (Regular variant, ' + (regularFile.data.length / 1024).toFixed(1) + 'KB)<br>' +
                    (discardedCount > 0 ? 'Discarded: ' + discardedCount + ' file' + (discardedCount !== 1 ? 's' : '') + ' (Bold, Italic, etc. - not needed, saves storage)<br>' : '') +
                    'Click "Save Theme" to apply permanently.</span></p>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statusDiv });
                
            } catch (error) {
                console.error('Error uploading font:', error);
                statusDiv.innerHTML = 
                    '<p style="color: var(--error); padding: 1rem; background: #fee; border-radius: 0.5rem;"><span class="icon-with-text"><i data-lucide="x-circle" style="width:1.25em;height:1.25em;"></i> Error uploading font: ' + escapeHtml(error.message) + '</span></p>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statusDiv });
            }
        }
        
        // Read file as base64
        function readFileAsBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        // Remove custom font
        function removeCustomFont(index) {
            if (typeof showConfirmModal !== 'function') {
                if (!confirm('Remove this custom font?')) return;
            } else {
                showConfirmModal('Remove custom font', 'Remove this custom font from the theme? You can add it again later.', function() {
                    doRemoveCustomFont(index);
                }, null, 'Remove');
                return;
            }
            doRemoveCustomFont(index);
        }
        function doRemoveCustomFont(index) {
            let customFonts = window.pendingCustomFonts || [];
            customFonts.splice(index, 1);
            window.pendingCustomFonts = customFonts;
            loadCustomFonts(customFonts);
            document.getElementById('themeStatus').innerHTML = '<p style="color: var(--text-light);">Font removed. Click "Save Theme" to apply changes.</p>';
        }
        
        // Handle logo upload for institution
        function handleLogoUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Validate file type
            if (!file.type.startsWith('image/')) {
                alert('Please upload an image file.');
                return;
            }
            
            // Validate file size (max 5MB)
            if (file.size > 5 * 1024 * 1024) {
                alert('Image must be less than 5MB.');
                return;
            }
            
            // Preview the image
            const reader = new FileReader();
            reader.onload = function(e) {
                const logoImg = document.getElementById('logoPreviewImage');
                const logoPlaceholder = document.getElementById('logoPlaceholder');
                
                if (logoImg && logoPlaceholder) {
                    logoImg.src = e.target.result;
                    logoImg.style.display = 'block';
                    logoPlaceholder.style.display = 'none';
                    
                    // Store base64 for saving
                    window.institutionLogoData = e.target.result;
                    
                    console.log('✓ Logo preview loaded');
                }
            };
            reader.onerror = function(error) {
                console.error('Error reading logo file:', error);
                alert('Error loading logo preview. Please try again.');
            };
            reader.readAsDataURL(file);
        }
        
        // --- HTML Color Codes–style picker: Hex/HSL conversion and panel ---
        function hexToRgb(hex) {
            const h = (hex || '').replace(/^#/, '');
            if (!/^[0-9A-Fa-f]{6}$/.test(h) && !/^[0-9A-Fa-f]{3}$/.test(h)) return { r: 0, g: 0, b: 0 };
            const expand = h.length === 3 ? h.split('').map(c => c + c).join('') : h;
            return {
                r: parseInt(expand.slice(0, 2), 16),
                g: parseInt(expand.slice(2, 4), 16),
                b: parseInt(expand.slice(4, 6), 16)
            };
        }
        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, Math.round(x))).toString(16).padStart(2, '0')).join('').toUpperCase();
        }
        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    default: h = ((r - g) / d + 4) / 6; break;
                }
            }
            return { h: Math.round(h * 360), s: Math.round(s * 100), l: Math.round(l * 100) };
        }
        function hslToRgb(h, s, l) {
            h /= 360; s /= 100; l /= 100;
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return { r: r * 255, g: g * 255, b: b * 255 };
        }
        function hue2rgb(p, q, t) {
            if (t < 0) t += 1; if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        }
        function hexToHsl(hex) {
            const rgb = hexToRgb(hex);
            return rgbToHsl(rgb.r, rgb.g, rgb.b);
        }
        function hslToHex(h, s, l) {
            const rgb = hslToRgb(h, s, l);
            return rgbToHex(rgb.r, rgb.g, rgb.b);
        }
        
        let themePickerState = { h: 0, s: 0, l: 50 };
        let themePickerTarget = { pickerId: null, textId: null };
        
        function updateThemePickerUI() {
            const panel = document.getElementById('themeColorPickerPanel');
            const marker2d = document.getElementById('themePicker2dMarker');
            const markerHue = document.getElementById('themePickerHueMarker');
            const wrap2d = document.getElementById('themePicker2dWrap');
            const hexInput = document.getElementById('themePickerHex');
            const rgbSpan = document.getElementById('themePickerRgb');
            const preview = document.getElementById('themePickerPreview');
            if (!panel || !marker2d || !markerHue || !wrap2d) return;
            const { h, s, l } = themePickerState;
            const hex = hslToHex(h, s, l);
            const rgb = hexToRgb(hex);
            panel.style.setProperty('--picker-hue-color', 'hsl(' + h + ', 100%, 50%)');
            marker2d.style.left = (s) + '%';
            marker2d.style.top = (100 - l) + '%';
            markerHue.style.left = (h / 360 * 100) + '%';
            if (hexInput) hexInput.value = hex;
            if (rgbSpan) rgbSpan.textContent = rgb.r + ', ' + rgb.g + ', ' + rgb.b;
            if (preview) preview.style.backgroundColor = hex;
        }
        
        function setThemePickerFromHSL(h, s, l) {
            themePickerState = { h: Math.round(h), s: Math.round(s), l: Math.round(l) };
            updateThemePickerUI();
        }
        
        function openThemeColorPicker(pickerId, textId, label) {
            const pickerEl = document.getElementById(pickerId);
            const textEl = document.getElementById(textId);
            const hex = (textEl && textEl.value.trim()) || (pickerEl && pickerEl.value) || '#1e3a5f';
            const normalized = normalizeHex(hex);
            themePickerTarget = { pickerId: pickerId, textId: textId };
            const hsl = hexToHsl(normalized);
            themePickerState = { h: hsl.h, s: hsl.s, l: hsl.l };
            const panel = document.getElementById('themeColorPickerPanel');
            const titleEl = document.getElementById('themeColorPickerTitle');
            if (titleEl) titleEl.textContent = label + ' — Color picker';
            if (panel) {
                panel.classList.add('open');
                updateThemePickerUI();
            }
            const wrap2d = document.getElementById('themePicker2dWrap');
            const hueWrap = document.getElementById('themePickerHueWrap');
            const hexInput = document.getElementById('themePickerHex');
            function on2d(ev) {
                const rect = wrap2d.getBoundingClientRect();
                const x = (ev.clientX - rect.left) / rect.width;
                const y = (ev.clientY - rect.top) / rect.height;
                const s = Math.max(0, Math.min(100, x * 100));
                const l = Math.max(0, Math.min(100, (1 - y) * 100));
                setThemePickerFromHSL(themePickerState.h, s, l);
            }
            function onHue(ev) {
                const rect = hueWrap.getBoundingClientRect();
                const x = (ev.clientX - rect.left) / rect.width;
                const h = Math.max(0, Math.min(360, x * 360));
                setThemePickerFromHSL(h, themePickerState.s, themePickerState.l);
            }
            function drag(ev) {
                ev.preventDefault();
                if (ev.target.closest('.picker-2d-wrap')) on2d(ev);
                else if (ev.target.closest('.picker-hue-wrap')) onHue(ev);
            }
            function up() {
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('mouseup', up);
            }
            if (wrap2d) {
                wrap2d.onmousedown = function(ev) { ev.preventDefault(); on2d(ev); document.addEventListener('mousemove', drag); document.addEventListener('mouseup', up); };
            }
            if (hueWrap) {
                hueWrap.onmousedown = function(ev) { ev.preventDefault(); onHue(ev); document.addEventListener('mousemove', drag); document.addEventListener('mouseup', up); };
            }
            if (hexInput) {
                hexInput.oninput = function() {
                    const val = hexInput.value.trim();
                    if (/^#[0-9A-Fa-f]{6}$/i.test(val) || /^[0-9A-Fa-f]{6}$/i.test(val)) {
                        const hex = val.startsWith('#') ? val : '#' + val;
                        const hsl = hexToHsl(hex);
                        setThemePickerFromHSL(hsl.h, hsl.s, hsl.l);
                    }
                };
            }
            document.getElementById('themePickerApply').onclick = function() {
                const hex = hslToHex(themePickerState.h, themePickerState.s, themePickerState.l);
                const picker = document.getElementById(themePickerTarget.pickerId);
                const text = document.getElementById(themePickerTarget.textId);
                if (picker) picker.value = hex;
                if (text) text.value = hex;
                closeThemeColorPicker();
            };
            window._themePickerEscape = function(e) {
                if (e.key === 'Escape') {
                    closeThemeColorPicker();
                    document.removeEventListener('keydown', window._themePickerEscape);
                }
            };
            document.addEventListener('keydown', window._themePickerEscape);
        }
        
        function closeThemeColorPicker() {
            const panel = document.getElementById('themeColorPickerPanel');
            if (panel) panel.classList.remove('open');
            document.removeEventListener('keydown', window._themePickerEscape);
        }
        
        // Normalize hex for display (# + 6 chars, uppercase)
        function normalizeHex(hex) {
            const h = (hex || '').replace(/^#/, '').trim();
            if (/^[0-9A-Fa-f]{6}$/.test(h)) return '#' + h.toUpperCase();
            if (/^[0-9A-Fa-f]{3}$/.test(h)) return '#' + h.split('').map(c => c + c).join('').toUpperCase();
            return hex || '#000000';
        }
        
        // Sync color picker with text input
        function syncColorInputs() {
            const pairs = [
                ['themePrimaryColor', 'themePrimaryText'],
                ['themeHeaderColor', 'themeHeaderText'],
                ['themeSecondaryColor', 'themeSecondaryText'],
                ['themeTextColor', 'themeTextText']
            ];
            
            pairs.forEach(([pickerId, textId]) => {
                const picker = document.getElementById(pickerId);
                const text = document.getElementById(textId);
                
                if (picker && text) {
                    picker.addEventListener('input', () => {
                        text.value = picker.value.toUpperCase();
                    });
                    
                    text.addEventListener('input', () => {
                        const val = text.value.trim();
                        if (/^#[0-9A-F]{6}$/i.test(val)) {
                            picker.value = val;
                        }
                    });
                }
            });
        }
        
        // Preview theme (temporary, doesn't save)
        function previewTheme() {
            const theme = {
                primary_color: document.getElementById('themePrimaryColor').value,
                header_bg_color: document.getElementById('themeHeaderColor').value,
                secondary_color: document.getElementById('themeSecondaryColor').value,
                text_primary: document.getElementById('themeTextColor').value,
                font_heading: document.getElementById('themeHeadingFont').value,
                font_body: document.getElementById('themeBodyFont').value
            };
            
            applyThemeToCSS(theme, currentInstitution?.name || null);
            
            // Apply fonts
            const root = document.documentElement;
            if (theme.font_heading) {
                root.style.setProperty('--heading-font', theme.font_heading);
            }
            if (theme.font_body) {
                root.style.setProperty('--body-font', theme.font_body);
            }
            
            // Preview logo if uploaded
            if (window.institutionLogoData) {
                const appLogo = document.getElementById('appLogo');
                if (appLogo) {
                    appLogo.style.backgroundColor = '#ffffff';
                    appLogo.innerHTML = `<img src="${window.institutionLogoData}" style="width: 100%; height: 100%; object-fit: contain; border-radius: 50%; padding: 12%;">`;
                }
            }
            
            var statusEl = document.getElementById('themeStatus');
            if (statusEl) {
                statusEl.innerHTML = '<p style="color: var(--success); padding: 1rem; background: var(--bg-alt); border-radius: 0.5rem;"><span class="icon-with-text"><i data-lucide="eye" style="width:1.1em;height:1.1em;"></i> Preview applied! Click "Save Theme" to make permanent.</span></p>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statusEl });
            }
        }
        
        // Save theme to database
        async function saveInstitutionTheme() {
            const targetInstitutionId = getThemeFormInstitutionId();
            if (!supabaseClient || !currentUser) {
                alert('Error: Not connected to database.');
                return;
            }
            if (!targetInstitutionId) {
                alert(isSuperAdmin() ? 'Please select an institution first.' : 'No institution assigned.');
                return;
            }
            
            const statusDiv = document.getElementById('themeStatus');
            if (statusDiv) statusDiv.innerHTML = '<p style="color: var(--text-light);">Saving theme...</p>';
            
            console.log('=== SAVING THEME ===');
            console.log('Target institution:', targetInstitutionId);
            console.log('User tier:', userTier);
            
            try {
                const themeData = {
                    primary_color: document.getElementById('themePrimaryColor').value,
                    header_bg_color: document.getElementById('themeHeaderColor').value,
                    secondary_color: document.getElementById('themeSecondaryColor').value,
                    text_primary: document.getElementById('themeTextColor').value,
                    text_secondary: document.getElementById('themeTextColor').value,
                    font_heading: document.getElementById('themeHeadingFont').value,
                    font_body: document.getElementById('themeBodyFont').value,
                    updated_at: new Date().toISOString()
                };
                
                if (window.institutionLogoData) {
                    themeData.logo_url = window.institutionLogoData;
                    console.log('✓ Logo data prepared for save');
                    console.log('  Logo size:', (themeData.logo_url.length / 1024).toFixed(1) + 'KB');
                } else {
                    console.log('ℹ️ No new logo data to save (keeping existing if any)');
                }
                
                if (window.pendingCustomFonts && window.pendingCustomFonts.length > 0) {
                    themeData.custom_fonts = window.pendingCustomFonts;
                    console.log('✓ Custom fonts prepared for save:', window.pendingCustomFonts.length, 'font(s)');
                    console.log('  Font data size:', JSON.stringify(window.pendingCustomFonts).length, 'characters');
                } else {
                    console.log('ℹ️ No custom fonts to save (keeping existing if any)');
                }
                
                console.log('Saving theme to institution_id:', targetInstitutionId);
                
                const { data, error } = await supabaseClient
                    .from('institution_themes')
                    .upsert({
                        institution_id: targetInstitutionId,
                        ...themeData
                    }, {
                        onConflict: 'institution_id'
                    })
                    .select();
                
                if (error) {
                    console.error('❌ Save failed:', error);
                    throw error;
                }
                
                if (!data || data.length === 0) {
                    console.error('❌ No data returned from upsert');
                    throw new Error('No data returned from save operation');
                }
                
                const savedTheme = data[0];
                console.log('✓ Theme saved to database');
                console.log('  Saved to institution_id:', savedTheme.institution_id);
                console.log('  Has logo:', !!savedTheme.logo_url);
                console.log('  Has custom fonts:', !!savedTheme.custom_fonts);
                
                const isForCurrentInstitution = currentUser.institution_id && savedTheme.institution_id === currentUser.institution_id;
                if (isForCurrentInstitution) {
                    currentInstitutionTheme = savedTheme;
                    currentUser.theme = savedTheme;
                    console.log('✓ Global theme variable updated');
                    applyThemeToCSS(savedTheme);
                    const root = document.documentElement;
                    if (savedTheme.font_heading) {
                        root.style.setProperty('--heading-font', savedTheme.font_heading);
                        console.log('✓ Applied heading font:', savedTheme.font_heading);
                    }
                    if (savedTheme.font_body) {
                        root.style.setProperty('--body-font', savedTheme.font_body);
                        console.log('✓ Applied body font:', savedTheme.font_body);
                    }
                    if (savedTheme.custom_fonts) {
                        console.log('Loading custom fonts from saved data...');
                        loadCustomFontsOnStartup(savedTheme.custom_fonts);
                    }
                    if (window.institutionLogoData) {
                        console.log('Updating logo display...');
                        await updateInstitutionLogo();
                    }
                } else {
                    console.log('Theme saved for another institution; not applying to current session.');
                }
                
                statusDiv.innerHTML = 
                    '<p style="color: var(--success); padding: 1rem; background: #d1fae5; border-radius: 0.5rem; border-left: 4px solid var(--success);"><span class="icon-with-text"><i data-lucide="check-circle" style="width:1.25em;height:1.25em;"></i> Theme saved successfully! ' + (isForCurrentInstitution ? 'All users in your institution will see these colors, fonts, and logo on next login.' : 'Users in that institution will see this theme on next login.') + '</span></p>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statusDiv });
                
                console.log('=== THEME SAVE COMPLETE ===');
                
                // Clear pending fonts (they're now saved)
                window.pendingCustomFonts = null;
                
            } catch (error) {
                console.error('Error saving theme:', error);
                statusDiv.innerHTML = 
                    '<p style="color: var(--error); padding: 1rem; background: #fee; border-radius: 0.5rem; border-left: 4px solid var(--error);"><span class="icon-with-text"><i data-lucide="x-circle" style="width:1.25em;height:1.25em;"></i> Error saving theme: ' + escapeHtml(error.message) + '</span></p>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statusDiv });
            }
        }
        
        // Create new theme: reset form to defaults; Super Admin must then select an institution and Save
        function createNewTheme() {
            setThemeFormToDefaults();
            window.pendingCustomFonts = null;
            window.institutionLogoData = null;
            document.getElementById('institutionLogoUpload').value = '';
            document.getElementById('customFontName').value = '';
            document.getElementById('customFontFiles').value = '';
            const logoImg = document.getElementById('logoPreviewImage');
            const logoPlaceholder = document.getElementById('logoPlaceholder');
            if (logoImg) { logoImg.src = ''; logoImg.style.display = 'none'; }
            if (logoPlaceholder) logoPlaceholder.style.display = 'block';
            const statusDiv = document.getElementById('themeStatus');
            if (isSuperAdmin()) {
                const sel = document.getElementById('themeInstitutionSelect');
                if (sel) sel.value = '';
                if (statusDiv) statusDiv.innerHTML = 
                    '<p style="color: var(--primary); padding: 1rem; background: var(--bg-alt); border-radius: 0.5rem; border-left: 4px solid var(--primary);">Select an institution above, customize colors and fonts, then click <strong>Save Theme</strong> to create a new theme for that institution.</p>';
            } else {
                if (statusDiv) statusDiv.innerHTML = 
                    '<p style="color: var(--text-light); padding: 1rem; background: var(--bg-alt); border-radius: 0.5rem;">Form reset to default palette. Edit as needed and click <strong>Save Theme</strong> to update your institution\'s theme.</p>';
            }
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statusDiv });
        }
        
        // Reset theme form to current saved values
        function resetThemeForm() {
            loadCurrentThemeToForm(); // This will reload logo from database
            window.pendingCustomFonts = null;
            document.getElementById('institutionLogoUpload').value = '';
            document.getElementById('customFontName').value = '';
            document.getElementById('customFontFiles').value = '';
            document.getElementById('themeStatus').innerHTML = 
                '<p style="color: var(--text-light);">Reset to saved theme.</p>';
        }
        
        // Load department instructors (for admins)
        async function loadDepartmentInstructors() {
            if (!supabaseClient || !isAdmin()) return;
            
            if (!currentUser.department_id) {
                var instContainer = document.getElementById('departmentInstructorsContainer');
                instContainer.innerHTML = '<p style="color: var(--warning);"><span class="icon-with-text"><i data-lucide="alert-triangle" style="width:1.1em;height:1.1em;"></i> You are not assigned to a department.</span></p>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: instContainer });
                return;
            }
            
            try {
                const { data: instructors, error } = await supabaseClient
                    .from('user_profiles')
                    .select(`
                        id,
                        email,
                        full_name,
                        account_tier,
                        is_research_partner,
                        created_at,
                        departments (
                            name
                        )
                    `)
                    .eq('department_id', currentUser.department_id)
                    .eq('account_tier', 'instructor')
                    .order('email', { ascending: true });
                
                if (error) throw error;
                
                // Batch load courses for all instructors (avoid N+1 queries)
                const instructorIds = instructors.map(i => i.id);
                const { data: allCourses } = await supabaseClient
                    .from('courses')
                    .select('id, name, semester, year, instructor_id')
                    .in('instructor_id', instructorIds);
                
                // Group courses by instructor_id
                const coursesByInstructor = {};
                (allCourses || []).forEach(course => {
                    if (!coursesByInstructor[course.instructor_id]) {
                        coursesByInstructor[course.instructor_id] = [];
                    }
                    coursesByInstructor[course.instructor_id].push(course);
                });
                
                const instructorsWithCourses = instructors.map(instructor => ({
                    ...instructor,
                    courses: coursesByInstructor[instructor.id] || []
                }));
                
                // Cache the full data
                cachedDepartmentInstructors = instructorsWithCourses;
                
                // Display all instructors initially
                displayDepartmentInstructors(instructorsWithCourses);
                
            } catch (error) {
                console.error('Error loading instructors:', error);
                document.getElementById('departmentInstructorsContainer').innerHTML = 
                    '<p style="color: var(--error);">Error loading instructors. Please try again.</p>';
            }
        }
        
        // Display department instructors (used by load and filter)
        function displayDepartmentInstructors(instructors) {
            const container = document.getElementById('departmentInstructorsContainer');
            
            if (!instructors || instructors.length === 0) {
                container.innerHTML = '<p style="color: var(--text-light);">No instructors found matching the filter.</p>';
                return;
            }
            
            // Build instructors list HTML
            let html = `
                <div style="background: var(--bg); border: 1px solid var(--border); border-radius: 0.5rem; overflow: hidden;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead style="background: var(--bg-alt);">
                            <tr>
                                <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Instructor</th>
                                <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Email</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Courses</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Research Partner</th>
                                <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            instructors.forEach(instructor => {
                const researchBadge = instructor.is_research_partner
                    ? '<span style="color: var(--success); font-size: 1.25rem;"><i data-lucide="check" style="width:1.25rem;height:1.25rem;"></i></span>'
                    : '<span style="color: var(--text-light);">—</span>';
                
                const courseCount = instructor.courses?.length || 0;
                
                html += `
                    <tr style="border-bottom: 1px solid var(--border);">
                        <td style="padding: 0.75rem;">${escapeHtml(instructor.full_name || '—')}</td>
                        <td style="padding: 0.75rem; color: var(--text-light);">${escapeHtml(instructor.email || '')}</td>
                        <td style="padding: 0.75rem; text-align: center;">${courseCount}</td>
                        <td style="padding: 0.75rem; text-align: center;">${researchBadge}</td>
                        <td style="padding: 0.75rem;">
                            <button onclick="viewInstructorCourses('${escapeHtml(instructor.id)}', '${escapeHtml(instructor.email)}')" 
                                    style="padding: 0.25rem 0.75rem; font-size: 0.875rem; margin-right: 0.5rem;"><span class="icon-with-text"><i data-lucide="book-open" style="width:1em;height:1em;"></i> View Courses</span></button>
                            <button onclick="viewInstructorDetails('${escapeHtml(instructor.id)}', '${escapeHtml(instructor.email)}')" 
                                    style="padding: 0.25rem 0.75rem; font-size: 0.875rem;"><span class="icon-with-text"><i data-lucide="user" style="width:1em;height:1em;"></i> Details</span></button>
                        </td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
                <p style="margin-top: 1rem; color: var(--text-light); font-size: 0.875rem;">
                    Showing ${instructors.length} instructor${instructors.length !== 1 ? 's' : ''}
                </p>
            `;
            
            container.innerHTML = html;
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: container });
            console.log('✓ Displayed', instructors.length, 'instructors');
        }
        
        // Filter instructors by semester
        function filterBySemester() {
            const filter = document.getElementById('semesterFilter').value;
            console.log('🔍 Filtering by semester:', filter);
            
            if (filter === 'all') {
                // Show all instructors
                displayDepartmentInstructors(cachedDepartmentInstructors);
                return;
            }
            
            // Filter instructors who have courses in the selected semester
            const filtered = cachedDepartmentInstructors.filter(instructor => {
                return instructor.courses.some(course => {
                    const courseSemester = course.semester && course.year 
                        ? `${course.semester} ${course.year}`
                        : '';
                    return courseSemester === filter;
                });
            });
            
            displayDepartmentInstructors(filtered);
        }
        
        // Institution API keys (Admin sets for department; instructors use as fallback)
        function getInstitutionIdForApiKeys() {
            if (typeof isSuperAdmin === 'function' && isSuperAdmin()) {
                const sel = document.getElementById('institutionApiKeysInstitutionSelect');
                if (sel && sel.value) return sel.value;
            }
            return currentUser?.institution_id || null;
        }
        
        async function loadInstitutionApiKeys() {
            // No-op: Only Qwen is used, institution API keys removed
            // Still handle deletion scope section visibility
            if (!supabaseClient || !(typeof canManageUsers === 'function' && canManageUsers())) return;
            const isSA = typeof isSuperAdmin === 'function' && isSuperAdmin();
            const deletionScopeSection = document.getElementById('deletionScopeSection');
            if (deletionScopeSection) deletionScopeSection.style.display = isSA ? 'block' : 'none';
            if (isSA && typeof loadDeletionScopeSettings === 'function') loadDeletionScopeSettings();
        }
        
        async function loadDepartmentApiKeys() {
            // No-op: Only Qwen is used, department API keys removed
        }
        
        async function loadDepartmentInstructorsForApiKeys() {
            // No-op: Only Qwen is used, department API keys removed
        }
        
        async function saveDepartmentApiKeys() {
            // No-op: Only Qwen is used, department API keys removed
        }
        
        async function saveInstitutionApiKeys() {
            // No-op: Only Qwen is used, institution API keys removed
        }
        
        /** Deletion scope: 'local' | 'supabase' | 'both'. Non-Super Admin always 'local'. */
        function getDeletionScope(entity) {
            if (typeof isSuperAdmin !== 'function' || !isSuperAdmin()) return 'local';
            const key = 'deletion_scope_' + entity;
            const val = localStorage.getItem(key);
            return (val === 'supabase' || val === 'both') ? val : 'local';
        }
        
        function loadDeletionScopeSettings() {
            ['rubrics', 'students', 'courses', 'evaluations'].forEach(function(entity) {
                const sel = document.getElementById('deletionScope' + entity.charAt(0).toUpperCase() + entity.slice(1));
                if (sel) sel.value = localStorage.getItem('deletion_scope_' + entity) || 'local';
            });
        }
        
        function saveDeletionScope(entity) {
            const sel = document.getElementById('deletionScope' + entity.charAt(0).toUpperCase() + entity.slice(1));
            if (sel) localStorage.setItem('deletion_scope_' + entity, sel.value);
        }
        
        async function getInstitutionApiKeysAsync() {
            if (!currentUser?.institution_id || !supabaseClient) return null;
            if (cachedInstitutionApiKeys !== null) return cachedInstitutionApiKeys;
            const { data, error } = await supabaseClient.from('institutions').select('api_keys').eq('id', currentUser.institution_id).single();
            if (error || !data || !data.api_keys) { cachedInstitutionApiKeys = {}; return cachedInstitutionApiKeys; }
            cachedInstitutionApiKeys = typeof data.api_keys === 'object' ? data.api_keys : {};
            return cachedInstitutionApiKeys;
        }
        
        async function getDepartmentApiKeysAsync() {
            if (!currentUser?.department_id || !supabaseClient) return null;
            if (cachedDepartmentApiKeys !== null) return cachedDepartmentApiKeys;
            const { data, error } = await supabaseClient.from('department_api_keys').select('api_keys, assigned_instructor_ids').eq('department_id', currentUser.department_id).maybeSingle();
            if (error || !data) { cachedDepartmentApiKeys = { api_keys: {}, assigned: [] }; return cachedDepartmentApiKeys; }
            const assigned = Array.isArray(data.assigned_instructor_ids) ? data.assigned_instructor_ids : [];
            if (assigned.indexOf(currentUser.id) === -1) { cachedDepartmentApiKeys = { api_keys: {}, assigned: [] }; return cachedDepartmentApiKeys; }
            cachedDepartmentApiKeys = { api_keys: typeof data.api_keys === 'object' ? data.api_keys : {}, assigned: assigned };
            return cachedDepartmentApiKeys;
        }
        
        async function getEvaluationApiKey(provider) {
            // Only Qwen is supported
            if (provider !== 'qwen') {
                console.warn('Only Qwen provider is supported. Requested provider:', provider);
                return '';
            }
            const url = (typeof getQwenApiUrl === 'function' ? getQwenApiUrl() : (localStorage.getItem('qwen_api_url') || (typeof window !== 'undefined' && window.QWEN_API_URL) || '')).trim().replace(/\/$/, '');
            return url;
        }
        
        // Enhanced analytics data cache
        // Analytics constants - must be defined before loadEnhancedAnalytics function
        const ANALYTICS_MAX_EVALUATIONS = 2000;  // Max evaluations to load at once (for performance)
        let analyticsEvaluationsPage = 0;
        let analyticsEvaluationsTruncated = false;  // True if more evaluations exist than loaded
        
        let analyticsData = {
            evaluations: [],
            instructors: [],
            courses: [],
            filtered: []
        };
        
        // User-customizable dashboards (add, remove, rename, hide, reorder)
        const DEFAULT_DASHBOARD_CONFIG = [
            { id: 'overview', name: 'Overview', type: 'builtin', visible: true },
            { id: 'comparisons', name: 'Comparisons', type: 'builtin', visible: true },
            { id: 'evaluations', name: 'Evaluations', type: 'builtin', visible: true },
            { id: 'export', name: 'Data Export', type: 'builtin', visible: false }
        ];
        // Instructor: hide Comparisons and Data Export tabs (Overview and Evaluations only - Export CSV is in Evaluations tab)
        const DEFAULT_DASHBOARD_CONFIG_INSTRUCTOR = [
            { id: 'overview', name: 'Overview', type: 'builtin', visible: true },
            { id: 'comparisons', name: 'Comparisons', type: 'builtin', visible: false },
            { id: 'evaluations', name: 'Evaluations', type: 'builtin', visible: true },
            { id: 'export', name: 'Data Export', type: 'builtin', visible: false }
        ];
        const BUILTIN_PANEL_IDS = { overview: 'analyticsOverviewTab', comparisons: 'analyticsComparisonsTab', evaluations: 'analyticsEvaluationsTab', export: 'analyticsExportTab' };
        const DEFAULT_OVERVIEW_WIDGETS = [
            { id: 'kpi-row', label: 'KPI cards', visible: true, order: 0 },
            { id: 'chart-outcome', label: 'Outcome attainment by outcome', visible: true, order: 1 },
            { id: 'chart-modality', label: 'Modality comparison', visible: true, order: 2 },
            { id: 'chart-course', label: 'Course comparisons', visible: true, order: 3 },
            { id: 'chart-section', label: 'Section variability map', visible: true, order: 4 },
            { id: 'chart-accreditation', label: 'Accreditation-ready summary', visible: true, order: 5 },
            { id: 'chart-modality-report', label: 'Modality report', visible: true, order: 6 },
            { id: 'chart-norming', label: 'Norming summary', visible: true, order: 7 }
        ];
        // Admin/Super Admin: fewer overview cards by default (key metrics only)
        const DEFAULT_OVERVIEW_WIDGETS_ADMIN = [
            { id: 'kpi-row', label: 'KPI cards', visible: true, order: 0 },
            { id: 'chart-outcome', label: 'Outcome attainment by outcome', visible: true, order: 1 },
            { id: 'chart-course', label: 'Course comparisons', visible: true, order: 2 },
            { id: 'chart-accreditation', label: 'Accreditation-ready summary', visible: true, order: 3 }
        ];
        const DEFAULT_TAB_WIDGETS = {
            comparisons: [
                { id: 'card-course', label: 'By course', visible: true, order: 0 },
                { id: 'card-instructor', label: 'By instructor', visible: true, order: 1 }
            ],
            evaluations: [
                { id: 'card-table', label: 'Evaluations table', visible: true, order: 0 }
            ],
            export: [
                { id: 'export-unified', label: 'Data export', visible: true, order: 0 }
            ]
        };
        
        function getDashboardConfig() {
            // One-time migration: apply tier-specific defaults to existing users
            const migratedKey = 'dashboard_config_migrated_v2';
            if (typeof getUserItem === 'function' && getUserItem(migratedKey) !== '1') {
                if (typeof setUserItem === 'function') {
                    setUserItem(migratedKey, '1');
                    const isInstructorOnly = (typeof userTier !== 'undefined' && userTier === 'instructor') || (typeof userTier !== 'undefined' && userTier === 'demo' && typeof demoViewAs !== 'undefined' && demoViewAs === 'instructor');
                    const defaultConfig = JSON.parse(JSON.stringify(isInstructorOnly ? DEFAULT_DASHBOARD_CONFIG_INSTRUCTOR : DEFAULT_DASHBOARD_CONFIG));
                    setUserItem('dashboard_config', JSON.stringify(defaultConfig));
                    return defaultConfig;
                }
            }
            try {
                const raw = typeof getUserItem === 'function' ? getUserItem('dashboard_config') : null;
                if (raw) {
                    const parsed = JSON.parse(raw);
                    if (Array.isArray(parsed) && parsed.length) {
                        parsed.forEach(function(d, i) {
                            if (d.visible === undefined) d.visible = true;
                            if (d.type === 'custom' && d.visible === undefined) d.visible = true;
                            if (d.id === 'evaluations' && d.name === 'All Evaluations') d.name = 'Evaluations';
                        });
                        // Migration: Remove energy tab from analytics if it exists (moved to Settings)
                        const energyTabIndex = parsed.findIndex(function(d) { return d.id === 'energy'; });
                        if (energyTabIndex !== -1) {
                            parsed.splice(energyTabIndex, 1);
                            if (typeof setUserItem === 'function') {
                                setUserItem('dashboard_config', JSON.stringify(parsed));
                            }
                        }
                        return parsed;
                    }
                }
            } catch (e) {}
            // Tier-specific defaults: instructor sees Overview, Evaluations, Data Export only; Admin/Super Admin see all tabs
            const isInstructorOnly = (typeof userTier !== 'undefined' && userTier === 'instructor') || (typeof userTier !== 'undefined' && userTier === 'demo' && typeof demoViewAs !== 'undefined' && demoViewAs === 'instructor');
            return JSON.parse(JSON.stringify(isInstructorOnly ? DEFAULT_DASHBOARD_CONFIG_INSTRUCTOR : DEFAULT_DASHBOARD_CONFIG));
        }
        function setDashboardConfig(config) {
            if (typeof setUserItem !== 'function') return;
            setUserItem('dashboard_config', JSON.stringify(config));
        }
        function getPanelIdForDashboard(dashboardId) {
            if (BUILTIN_PANEL_IDS[dashboardId]) return BUILTIN_PANEL_IDS[dashboardId];
            return 'analyticsPanel_' + dashboardId;
        }
        
        function renderDashboardTabs() {
            const config = getDashboardConfig();
            let visibleConfig = config.filter(function(d) { return d.visible !== false; });
            const tablist = document.getElementById('analyticsTablist');
            const wrapper = document.getElementById('analyticsPanelsWrapper');
            const customContainer = document.getElementById('analyticsCustomPanelsContainer');
            if (!tablist || !wrapper || !customContainer) return;
            
            tablist.innerHTML = '';
            tablist.setAttribute('aria-label', 'Analytics dashboards');
            
            visibleConfig.forEach(function(d, index) {
                const tabId = 'tab_' + d.id;
                const panelId = getPanelIdForDashboard(d.id);
                const isFirst = index === 0;
                const btn = document.createElement('button');
                btn.id = tabId;
                btn.setAttribute('role', 'tab');
                btn.setAttribute('aria-selected', isFirst ? 'true' : 'false');
                btn.setAttribute('aria-controls', panelId);
                btn.setAttribute('tabindex', isFirst ? 0 : -1);
                btn.className = 'analytics-tab' + (isFirst ? ' analytics-tab-active' : '');
                btn.textContent = d.name;
                btn.onclick = function() { switchAnalyticsTab(d.id); };
                tablist.appendChild(btn);
                
                if (d.type === 'custom') {
                    let panel = document.getElementById(panelId);
                    if (!panel) {
                        panel = document.createElement('div');
                        panel.id = panelId;
                        panel.setAttribute('role', 'tabpanel');
                        panel.setAttribute('aria-labelledby', tabId);
                        panel.setAttribute('data-dashboard-id', d.id);
                        panel.style.display = 'none';
                        panel.innerHTML = '<div class="chart-card"><div class="chart-title text-headline">' + escapeHtml(d.name) + '</div><div class="chart-subtitle text-caption">Custom dashboard. Add widgets from Overview or use other tabs for data.</div><div class="chart-body" style="min-height:120px;"><div class="empty-state" style="padding: 1.5rem 1rem;"><i data-lucide="layout-dashboard" class="empty-state-icon" aria-hidden="true"></i><p class="empty-state-title">This dashboard is empty</p><p class="empty-state-desc">Use the Overview tab for key metrics and charts, or add widgets in Customize tabs.</p><div class="empty-state-action"><button type="button" onclick="switchAnalyticsTab(\'overview\')" class="btn" style="background: var(--primary); color: white;">Go to Overview</button></div></div></div></div>';
                        customContainer.appendChild(panel);
                    }
                }
            });
            var customIds = config.filter(d => d.type === 'custom').map(d => d.id);
            customContainer.querySelectorAll('[id^="analyticsPanel_"]').forEach(panel => {
                var did = panel.id.replace('analyticsPanel_', '');
                if (did && !customIds.includes(did)) panel.remove();
            });
            
            var firstVisibleId = visibleConfig.length ? visibleConfig[0].id : null;
            wrapper.querySelectorAll('[data-dashboard-id]').forEach(function(el) {
                var did = el.getAttribute('data-dashboard-id');
                var inConfig = config.some(function(d) { return d.id === did; });
                var isVisible = config.find(function(d) { return d.id === did; });
                isVisible = isVisible && isVisible.visible !== false;
                el.style.display = inConfig && isVisible ? (did === firstVisibleId ? 'block' : 'none') : 'none';
            });
            customContainer.querySelectorAll('[id^="analyticsPanel_"]').forEach(function(panel) {
                var did = panel.id.replace('analyticsPanel_', '');
                var d = config.find(function(c) { return c.id === did; });
                var show = d && d.visible !== false && did === firstVisibleId;
                panel.style.display = show ? 'block' : 'none';
            });
        }
        
        var currentAnalyticsTabId = 'overview';
        function switchAnalyticsTab(dashboardId) {
            currentAnalyticsTabId = dashboardId;
            const config = getDashboardConfig();
            const panelId = getPanelIdForDashboard(dashboardId);
            const panel = document.getElementById(panelId);
            if (!panel) return;
            
            const wrapper = document.getElementById('analyticsPanelsWrapper');
            if (wrapper) {
                wrapper.querySelectorAll('[data-dashboard-id]').forEach(el => { el.style.display = 'none'; });
                const customContainer = document.getElementById('analyticsCustomPanelsContainer');
                if (customContainer) customContainer.querySelectorAll('[id^="analyticsPanel_"]').forEach(el => { el.style.display = 'none'; });
            }
            panel.style.display = 'block';
            
            config.forEach((d, i) => {
                const tab = document.getElementById('tab_' + d.id);
                if (tab) {
                    const selected = d.id === dashboardId;
                    tab.setAttribute('aria-selected', selected ? 'true' : 'false');
                    tab.setAttribute('tabindex', selected ? 0 : -1);
                    tab.classList.toggle('analytics-tab-active', selected);
                    if (selected) tab.focus({ preventScroll: true });
                }
            });
            // LLM Export tab removed - moved to Settings → Admin → Data Management
            if (dashboardId === 'overview') {
                // Show Overview stats section for instructors
                const overviewStats = document.getElementById('dashboardOverviewStats');
                if (overviewStats && (typeof userTier === 'undefined' || userTier === 'instructor')) {
                    overviewStats.style.display = 'block';
                    // Load stats after a brief delay to ensure tab is visible and data is available
                    setTimeout(() => {
                        // Verify elements exist before trying to update them
                        const coursesEl = document.getElementById('statTotalCourses');
                        const studentsEl = document.getElementById('statTotalStudents');
                        const evaluationsEl = document.getElementById('statTotalEvaluations');
                        const rubricsEl = document.getElementById('statTotalRubrics');
                        
                        if (coursesEl && studentsEl && evaluationsEl && rubricsEl && typeof refreshDashboardStats === 'function') {
                            try {
                                refreshDashboardStats();
                            } catch (error) {
                                console.error('Error refreshing dashboard stats:', error);
                            }
                        }
                    }, 500);
                } else if (overviewStats) {
                    overviewStats.style.display = 'none';
                }
                
                if (typeof isSuperAdmin === 'function' && isSuperAdmin() && typeof loadFilteredCoursesForSuperAdmin === 'function') loadFilteredCoursesForSuperAdmin();
                else if (typeof isAdmin === 'function' && isAdmin() && typeof loadFilteredCoursesForAdmin === 'function') loadFilteredCoursesForAdmin();
            } else {
                // Hide Overview stats when switching to other tabs
                const overviewStats = document.getElementById('dashboardOverviewStats');
                if (overviewStats) {
                    overviewStats.style.display = 'none';
                }
            }
            if (dashboardId === 'export' && typeof applyExportTabWidgets === 'function') applyExportTabWidgets();
        }
        
        // Load and display cost tracking dashboard
        async function loadCostTrackingDashboard() {
            if (!window.supabase) {
                console.error('Supabase client not available');
                return;
            }
            
            try {
                // Get current month start date
                const now = new Date();
                const monthStart = new Date(now.getFullYear(), now.getMonth(), 1).toISOString();
                
                // Load cost summary (current month)
                const { data: summaryData, error: summaryError } = await window.supabase
                    .from('cost_tracking')
                    .select('estimated_cost, gpu_seconds, processing_time_seconds')
                    .gte('created_at', monthStart);
                
                if (summaryError) throw summaryError;
                
                // Calculate totals
                const totalCost = summaryData.reduce((sum, row) => sum + parseFloat(row.estimated_cost || 0), 0);
                const totalEvaluations = summaryData.length;
                const avgCost = totalEvaluations > 0 ? totalCost / totalEvaluations : 0;
                const totalGPUSeconds = summaryData.reduce((sum, row) => sum + parseFloat(row.gpu_seconds || 0), 0);
                
                // Update summary cards
                const totalSpentEl = document.getElementById('costTotalSpent');
                const avgPerEvalEl = document.getElementById('costAvgPerEval');
                const totalEvalsEl = document.getElementById('costTotalEvaluations');
                const totalGPUSecondsEl = document.getElementById('costTotalGPUSeconds');
                
                if (totalSpentEl) totalSpentEl.textContent = `$${totalCost.toFixed(2)}`;
                if (avgPerEvalEl) avgPerEvalEl.textContent = `$${avgCost.toFixed(4)}`;
                if (totalEvalsEl) totalEvalsEl.textContent = totalEvaluations.toLocaleString();
                if (totalGPUSecondsEl) totalGPUSecondsEl.textContent = totalGPUSeconds.toFixed(0);
                
                // Load cost by instructor (current month)
                const { data: instructorData, error: instructorError } = await window.supabase
                    .rpc('cost_tracking_instructor_current_month')
                    .select('*');
                
                if (!instructorError && instructorData) {
                    const tbody = document.getElementById('costTrackingInstructorTableBody');
                    if (tbody) {
                        if (instructorData.length === 0) {
                            tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: var(--text-light); padding: 2rem;">No cost data for current month</td></tr>';
                        } else {
                            tbody.innerHTML = instructorData.map(row => {
                                const instructorName = row.instructor_id || 'Unknown';
                                return `<tr>
                                    <td>${instructorName}</td>
                                    <td>${row.evaluation_count || 0}</td>
                                    <td>$${(row.total_cost || 0).toFixed(2)}</td>
                                    <td>$${(row.avg_cost_per_evaluation || 0).toFixed(4)}</td>
                                    <td>${(row.total_gpu_seconds || 0).toFixed(0)}</td>
                                </tr>`;
                            }).join('');
                        }
                    }
                } else {
                    // Fallback: query directly if RPC doesn't exist
                    const { data: instructorCosts, error: instructorCostsError } = await window.supabase
                        .from('cost_tracking')
                        .select('instructor_id, estimated_cost, gpu_seconds')
                        .gte('created_at', monthStart)
                        .not('instructor_id', 'is', null);
                    
                    if (!instructorCostsError && instructorCosts) {
                        // Group by instructor
                        const instructorMap = {};
                        instructorCosts.forEach(row => {
                            const id = row.instructor_id;
                            if (!instructorMap[id]) {
                                instructorMap[id] = { count: 0, total: 0, gpu: 0 };
                            }
                            instructorMap[id].count++;
                            instructorMap[id].total += parseFloat(row.estimated_cost || 0);
                            instructorMap[id].gpu += parseFloat(row.gpu_seconds || 0);
                        });
                        
                        const tbody = document.getElementById('costTrackingInstructorTableBody');
                        if (tbody) {
                            const rows = Object.entries(instructorMap).map(([id, data]) => {
                                return `<tr>
                                    <td>${id.substring(0, 8)}...</td>
                                    <td>${data.count}</td>
                                    <td>$${data.total.toFixed(2)}</td>
                                    <td>$${(data.total / data.count).toFixed(4)}</td>
                                    <td>${data.gpu.toFixed(0)}</td>
                                </tr>`;
                            }).join('');
                            tbody.innerHTML = rows || '<tr><td colspan="5" style="text-align: center; color: var(--text-light); padding: 2rem;">No cost data</td></tr>';
                        }
                    }
                }
                
                // Load cost by institution (super admin only)
                if (typeof isSuperAdmin === 'function' && isSuperAdmin()) {
                    const institutionSection = document.getElementById('costTrackingInstitutionSection');
                    if (institutionSection) institutionSection.style.display = 'block';
                    
                    const { data: institutionData, error: institutionError } = await window.supabase
                        .from('cost_tracking')
                        .select('institution_id, estimated_cost, gpu_seconds')
                        .gte('created_at', monthStart)
                        .not('institution_id', 'is', null);
                    
                    if (!institutionError && institutionData) {
                        // Group by institution
                        const institutionMap = {};
                        institutionData.forEach(row => {
                            const id = row.institution_id;
                            if (!institutionMap[id]) {
                                institutionMap[id] = { count: 0, total: 0, gpu: 0 };
                            }
                            institutionMap[id].count++;
                            institutionMap[id].total += parseFloat(row.estimated_cost || 0);
                            institutionMap[id].gpu += parseFloat(row.gpu_seconds || 0);
                        });
                        
                        const tbody = document.getElementById('costTrackingInstitutionTableBody');
                        if (tbody) {
                            const rows = Object.entries(institutionMap).map(([id, data]) => {
                                return `<tr>
                                    <td>${id.substring(0, 8)}...</td>
                                    <td>${data.count}</td>
                                    <td>$${data.total.toFixed(2)}</td>
                                    <td>$${(data.total / data.count).toFixed(4)}</td>
                                    <td>${data.gpu.toFixed(0)}</td>
                                </tr>`;
                            }).join('');
                            tbody.innerHTML = rows || '<tr><td colspan="5" style="text-align: center; color: var(--text-light); padding: 2rem;">No cost data</td></tr>';
                        }
                    }
                }
                
                // Check for cost alert threshold ($100)
                if (totalCost > 100) {
                    const chartEl = document.getElementById('costTrackingChart');
                    if (chartEl) {
                        chartEl.innerHTML = `<div style="padding: 1rem; background: var(--warning-bg); border: 1px solid var(--warning-border); border-radius: 0.5rem; color: var(--warning-text);">
                            <strong>⚠️ Cost Alert:</strong> Monthly spending ($${totalCost.toFixed(2)}) exceeds $100 threshold.
                        </div>`;
                    }
                }
                
                // Update icons
                if (typeof lucide !== 'undefined' && lucide.createIcons) {
                    const costSection = document.getElementById('costTrackingSection');
                    if (costSection) lucide.createIcons({ root: costSection });
                }
                
            } catch (error) {
                console.error('Error loading cost tracking dashboard:', error);
                const tbody = document.getElementById('costTrackingInstructorTableBody');
                if (tbody) {
                    tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: var(--error); padding: 2rem;">Error loading cost data. Please try again.</td></tr>';
                }
            }
        }
        
        // Load and display energy dashboard
        async function loadEnergyDashboard() {
            const contentDiv = document.getElementById('energyDashboardContent');
            if (!contentDiv) return;
            
            contentDiv.innerHTML = '<p style="color: var(--text-light);">Loading energy data…</p><div class="spinner" style="margin: 1rem auto;" aria-hidden="true"></div>';
            
            if (!supabaseClient || !currentUser) {
                contentDiv.innerHTML = '<p style="color: var(--error-text);">Not logged in or Supabase not available.</p>';
                return;
            }
            
            try {
                // Determine user role for appropriate data access
                const isSuperAdminUser = typeof isSuperAdmin === 'function' && isSuperAdmin();
                const isAdminUser = typeof isAdmin === 'function' && isAdmin();
                const isInstructorUser = typeof userTier !== 'undefined' && userTier === 'instructor';
                
                let energyData, donationsData, netImpactData;
                
                if (isSuperAdminUser) {
                    // Super Admin: All data
                    const [energyRes, donationsRes, netRes] = await Promise.all([
                        supabaseClient.from('energy_usage').select('*').order('created_at', { ascending: false }),
                        supabaseClient.from('carbon_offset_donations').select('*').order('donation_date', { ascending: false }),
                        supabaseClient.rpc('get_net_carbon_impact_summary', {})
                    ]);
                    energyData = energyRes.data || [];
                    donationsData = donationsRes.data || [];
                    netImpactData = netRes.data || [];
                } else if (isAdminUser) {
                    // Admin: Institution data
                    const { data: profile } = await supabaseClient
                        .from('user_profiles')
                        .select('institution_id')
                        .eq('id', currentUser.id)
                        .single();
                    
                    if (profile && profile.institution_id) {
                        const [energyRes, donationsRes] = await Promise.all([
                            supabaseClient.from('energy_usage').select('*').eq('institution_id', profile.institution_id).order('created_at', { ascending: false }),
                            supabaseClient.from('carbon_offset_donations').select('*').eq('institution_id', profile.institution_id).order('donation_date', { ascending: false })
                        ]);
                        energyData = energyRes.data || [];
                        donationsData = donationsRes.data || [];
                    } else {
                        energyData = [];
                        donationsData = [];
                    }
                } else {
                    // Instructor: Own data
                    const [energyRes, donationsRes] = await Promise.all([
                        supabaseClient.from('energy_usage').select('*').eq('instructor_id', currentUser.id).order('created_at', { ascending: false }),
                        supabaseClient.from('carbon_offset_donations').select('*').eq('user_id', currentUser.id).order('donation_date', { ascending: false })
                    ]);
                    energyData = energyRes.data || [];
                    donationsData = donationsRes.data || [];
                }
                
                // Calculate summary statistics
                const totalEnergyKwh = energyData.reduce((sum, e) => sum + parseFloat(e.energy_kwh || 0), 0);
                const totalCo2Kg = energyData.reduce((sum, e) => sum + parseFloat(e.co2_kg || 0), 0);
                const totalCo2Tons = totalCo2Kg / 1000.0;
                const totalDonationsUsd = donationsData.filter(d => d.status === 'completed' || d.status === 'processed').reduce((sum, d) => sum + parseFloat(d.amount_usd || 0), 0);
                const totalOffsetKg = donationsData.filter(d => d.status === 'completed' || d.status === 'processed').reduce((sum, d) => sum + parseFloat(d.co2_offset_kg || 0), 0);
                const totalOffsetTons = totalOffsetKg / 1000.0;
                const netEmissionsKg = totalCo2Kg - totalOffsetKg;
                const netEmissionsTons = netEmissionsKg / 1000.0;
                
                // Group by provider
                const byProvider = {};
                energyData.forEach(e => {
                    const provider = e.ai_provider || 'unknown';
                    if (!byProvider[provider]) {
                        byProvider[provider] = { count: 0, energy_kwh: 0, co2_kg: 0 };
                    }
                    byProvider[provider].count++;
                    byProvider[provider].energy_kwh += parseFloat(e.energy_kwh || 0);
                    byProvider[provider].co2_kg += parseFloat(e.co2_kg || 0);
                });
                
                // Group by scope
                const byScope = {};
                energyData.forEach(e => {
                    const scope = e.scope || 'scope_3';
                    if (!byScope[scope]) {
                        byScope[scope] = { count: 0, co2_kg: 0 };
                    }
                    byScope[scope].count++;
                    byScope[scope].co2_kg += parseFloat(e.co2_kg || 0);
                });
                
                // Group by instructor (for Admin view)
                const byInstructor = {};
                energyData.forEach(e => {
                    const instructorId = e.instructor_id;
                    if (!instructorId) return;
                    if (!byInstructor[instructorId]) {
                        byInstructor[instructorId] = { count: 0, energy_kwh: 0, co2_kg: 0, name: null };
                    }
                    byInstructor[instructorId].count++;
                    byInstructor[instructorId].energy_kwh += parseFloat(e.energy_kwh || 0);
                    byInstructor[instructorId].co2_kg += parseFloat(e.co2_kg || 0);
                });
                
                // Get instructor names
                if (isAdminUser && !isSuperAdminUser && Object.keys(byInstructor).length > 0) {
                    const instructorIds = Object.keys(byInstructor);
                    try {
                        const { data: instructors } = await supabaseClient
                            .from('user_profiles')
                            .select('id, full_name, email')
                            .in('id', instructorIds);
                        
                        if (instructors) {
                            instructors.forEach(inst => {
                                if (byInstructor[inst.id]) {
                                    byInstructor[inst.id].name = inst.full_name || inst.email || 'Unknown';
                                }
                            });
                        }
                    } catch (err) {
                        console.error('Error fetching instructor names:', err);
                    }
                }
                
                // Group by institution (for Super Admin view)
                const byInstitution = {};
                if (isSuperAdminUser) {
                    energyData.forEach(e => {
                        const institutionId = e.institution_id;
                        if (!institutionId) return;
                        if (!byInstitution[institutionId]) {
                            byInstitution[institutionId] = { count: 0, energy_kwh: 0, co2_kg: 0, name: null };
                        }
                        byInstitution[institutionId].count++;
                        byInstitution[institutionId].energy_kwh += parseFloat(e.energy_kwh || 0);
                        byInstitution[institutionId].co2_kg += parseFloat(e.co2_kg || 0);
                    });
                    
                    // Get institution names
                    if (Object.keys(byInstitution).length > 0) {
                        const institutionIds = Object.keys(byInstitution);
                        try {
                            const { data: institutions } = await supabaseClient
                                .from('institutions')
                                .select('id, name')
                                .in('id', institutionIds);
                            
                            if (institutions) {
                                institutions.forEach(inst => {
                                    if (byInstitution[inst.id]) {
                                        byInstitution[inst.id].name = inst.name || 'Unknown';
                                    }
                                });
                            }
                        } catch (err) {
                            console.error('Error fetching institution names:', err);
                        }
                    }
                }
                
                // Render dashboard
                let html = '<div style="display: flex; flex-direction: column; gap: 1.5rem;">';
                
                // Summary KPIs - using enhanced kpi-card styles
                html += '<div class="dashboard-kpi-grid">';
                html += `<div class="kpi-card" style="display: flex; flex-direction: column; min-height: 120px;">
                    <div class="kpi-title text-caption"><i data-lucide="zap" style="width:14px;height:14px;display:inline-block;vertical-align:middle;margin-right:4px;"></i> Total Energy</div>
                    <div class="kpi-value">${totalEnergyKwh.toFixed(3)} kWh</div>
                    <div class="kpi-subtext">${energyData.length} evaluations</div>
                </div>`;
                html += `<div class="kpi-card" style="display: flex; flex-direction: column; min-height: 120px;">
                    <div class="kpi-title text-caption"><i data-lucide="cloud" style="width:14px;height:14px;display:inline-block;vertical-align:middle;margin-right:4px;"></i> Total CO₂ Emissions</div>
                    <div class="kpi-value" style="color: var(--error-text);">${totalCo2Kg.toFixed(2)} kg</div>
                    <div class="kpi-subtext">${energyData.length} evaluations</div>
                </div>`;
                html += `<div class="kpi-card" style="display: flex; flex-direction: column; min-height: 120px;">
                    <div class="kpi-title text-caption"><i data-lucide="leaf" style="width:14px;height:14px;display:inline-block;vertical-align:middle;margin-right:4px;"></i> CO₂ Offset</div>
                    <div class="kpi-value" style="color: var(--success-text);">${totalOffsetKg.toFixed(2)} kg</div>
                    <div class="kpi-subtext">${donationsData.filter(d => d.status === 'completed' || d.status === 'processed').length} donations</div>
                </div>`;
                html += `<div class="kpi-card" style="display: flex; flex-direction: column; min-height: 120px;">
                    <div class="kpi-title text-caption"><i data-lucide="trending-down" style="width:14px;height:14px;display:inline-block;vertical-align:middle;margin-right:4px;"></i> Net Emissions</div>
                    <div class="kpi-value" style="color: ${netEmissionsKg >= 0 ? 'var(--error-text)' : 'var(--success-text)'};">${Math.abs(netEmissionsKg).toFixed(2)} kg</div>
                    <div class="kpi-subtext">${netEmissionsKg >= 0 ? 'Net emissions' : 'Net offset'}</div>
                </div>`;
                html += '</div>';
                
                // Carbon offset donation section
                html += '<div style="padding: 1rem; background: var(--bg-alt); border: 1px solid var(--border); border-radius: var(--radius-md);">';
                html += '<h3 style="margin: 0 0 0.75rem 0; font-size: 1rem; color: var(--primary);"><span class="icon-with-text"><i data-lucide="leaf"></i> Carbon Offset Donations</span></h3>';
                html += '<p style="margin: 0 0 1rem 0; font-size: 0.875rem; color: var(--text);">Offset your carbon footprint by making a donation to verified carbon offset programs. Your donations will be reflected in your net emissions.</p>';
                html += `<div style="margin-bottom: 1rem; padding: 0.75rem; background: var(--card); border-radius: var(--radius-sm);">
                    <div style="font-size: 0.875rem; color: var(--text); margin-bottom: 0.5rem;">Total Donated: <strong>$${totalDonationsUsd.toFixed(2)}</strong></div>
                    <div style="font-size: 0.875rem; color: var(--text);">Offset: <strong>${totalOffsetKg.toFixed(2)} kg CO₂</strong></div>
                </div>`;
                html += '<button type="button" id="makeDonationBtn" class="btn" style="background: var(--success); color: white; padding: 0.5rem 1rem;" onclick="openDonationModal()"><span class="icon-with-text"><i data-lucide="heart"></i> Make a Donation</span></button>';
                html += '</div>';
                
                // Helper function for bar charts
                function energyBarRow(label, value, maxValue, unit, icon) {
                    const pct = maxValue > 0 ? Math.min(100, (value / maxValue) * 100) : 0;
                    const level = pct >= 80 ? 'high' : pct >= 50 ? 'medium' : 'low';
                    const iconHtml = icon ? '<i data-lucide="' + icon + '" style="width:16px;height:16px;color:var(--text-light);margin-right:8px;"></i>' : '';
                    return '<div class="chart-bar-row"><div role="img" aria-label="' + escapeHtml(label) + ': ' + value.toFixed(3) + ' ' + unit + '"><div class="chart-bar-label-row"><span class="chart-bar-label" style="display:flex;align-items:center;">' + iconHtml + escapeHtml(label) + '</span><span class="chart-bar-value">' + value.toFixed(3) + ' ' + unit + '</span></div><div class="chart-bar-track"><div class="chart-bar-fill data-' + level + '" style="width:' + pct + '%;" title="' + value.toFixed(3) + ' ' + unit + '"></div></div></div></div>';
                }
                
                // Charts section
                html += '<div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">';
                
                // Energy by Institution (Super Admin only)
                if (isSuperAdminUser && Object.keys(byInstitution).length > 0) {
                    const institutionMax = Math.max(...Object.values(byInstitution).map(i => i.co2_kg), 1);
                    const institutionRows = Object.entries(byInstitution)
                        .sort((a, b) => b[1].co2_kg - a[1].co2_kg)
                        .map(([id, data]) => {
                            const name = data.name || 'Unknown Institution';
                            return energyBarRow(name, data.co2_kg, institutionMax, 'kg', 'building-2');
                        }).join('');
                    
                    html += '<div class="chart-card" role="figure" aria-labelledby="chart-title-institution"><div class="chart-title text-headline" id="chart-title-institution"><span class="icon-with-text"><i data-lucide="building-2"></i> Energy by Institution</span></div><div class="chart-subtitle">CO₂ emissions by institution</div><div class="chart-body" style="min-height: 200px;"><div class="chart-bars">' + institutionRows + '</div></div></div>';
                }
                
                // Energy by Instructor (Admin only)
                if (isAdminUser && !isSuperAdminUser && Object.keys(byInstructor).length > 0) {
                    const instructorMax = Math.max(...Object.values(byInstructor).map(i => i.co2_kg), 1);
                    const instructorRows = Object.entries(byInstructor)
                        .sort((a, b) => b[1].co2_kg - a[1].co2_kg)
                        .map(([id, data]) => {
                            const name = data.name || 'Unknown Instructor';
                            return energyBarRow(name, data.co2_kg, instructorMax, 'kg', 'user');
                        }).join('');
                    
                    html += '<div class="chart-card" role="figure" aria-labelledby="chart-title-instructor"><div class="chart-title text-headline" id="chart-title-instructor"><span class="icon-with-text"><i data-lucide="users"></i> Energy by Instructor</span></div><div class="chart-subtitle">CO₂ emissions by instructor in your institution</div><div class="chart-body" style="min-height: 200px;"><div class="chart-bars">' + instructorRows + '</div></div></div>';
                }
                
                // GHG Protocol Scope Breakdown (Super Admin only) - Enhanced with bar chart
                if (isSuperAdminUser) {
                    const scopeMax = Math.max(...Object.values(byScope).map(s => s.co2_kg), 1);
                    const scopeRows = Object.keys(byScope).sort().map(scope => {
                        const data = byScope[scope];
                        const scopeName = scope === 'scope_1' ? 'Scope 1 (Direct)' : scope === 'scope_2' ? 'Scope 2 (Indirect Energy)' : 'Scope 3 (Other Indirect)';
                        const scopeIcon = scope === 'scope_1' ? 'factory' : scope === 'scope_2' ? 'zap' : 'globe';
                        return energyBarRow(scopeName, data.co2_kg, scopeMax, 'kg', scopeIcon);
                    }).join('');
                    
                    html += '<div class="chart-card" role="figure" aria-labelledby="chart-title-scope"><div class="chart-title text-headline" id="chart-title-scope"><span class="icon-with-text"><i data-lucide="layers"></i> GHG Protocol Scope Breakdown</span></div><div class="chart-subtitle">CO₂ emissions by scope category</div><div class="chart-body" style="min-height: 200px;"><div class="chart-bars">' + scopeRows + '</div></div></div>';
                }
                
                // Emissions vs Offset Donut Chart
                if (totalCo2Kg > 0 || totalOffsetKg > 0) {
                    const totalEmissionsAndOffset = totalCo2Kg + totalOffsetKg;
                    const emissionsPct = totalEmissionsAndOffset > 0 ? (totalCo2Kg / totalEmissionsAndOffset) * 100 : 0;
                    const offsetPct = totalEmissionsAndOffset > 0 ? (totalOffsetKg / totalEmissionsAndOffset) * 100 : 0;
                    const circumference = 2 * Math.PI * 40;
                    const emissionsArc = (emissionsPct / 100) * circumference;
                    const offsetArc = (offsetPct / 100) * circumference;
                    
                    const donutId = 'emissions-donut-' + Math.random().toString(36).slice(2, 8);
                    const donutDataTableId = donutId + '-data';
                    const donutDataTable = '<table class="sr-only" id="' + donutDataTableId + '"><caption>Emissions and offset data</caption><thead><tr><th scope="col">Category</th><th scope="col">Amount (kg)</th><th scope="col">Percentage</th></tr></thead><tbody><tr><td>Emissions</td><td>' + totalCo2Kg.toFixed(2) + '</td><td>' + emissionsPct.toFixed(1) + '%</td></tr><tr><td>Offset</td><td>' + totalOffsetKg.toFixed(2) + '</td><td>' + offsetPct.toFixed(1) + '%</td></tr><tr><td>Net Emissions</td><td>' + netEmissionsKg.toFixed(2) + '</td><td>—</td></tr></tbody></table>';
                    const emissionsAriaLabel = 'Emissions: ' + totalCo2Kg.toFixed(2) + ' kilograms, ' + emissionsPct.toFixed(1) + ' percent';
                    const offsetAriaLabel = 'Offset: ' + totalOffsetKg.toFixed(2) + ' kilograms, ' + offsetPct.toFixed(1) + ' percent';
                    const donutHtml = '<div class="chart-donut-container" style="position: relative;"><svg class="chart-donut-svg" viewBox="0 0 100 100" role="img" aria-label="Emissions versus offset donut chart" aria-describedby="' + donutDataTableId + '"><defs><pattern id="pattern-emissions-' + donutId + '" x="0" y="0" width="8" height="8" patternUnits="userSpaceOnUse"><line x1="0" y1="0" x2="8" y2="8" stroke="#ef4444" stroke-width="1" opacity="0.5" /></pattern><pattern id="pattern-offset-' + donutId + '" x="0" y="0" width="8" height="8" patternUnits="userSpaceOnUse"><circle cx="4" cy="4" r="2" fill="#10b981" opacity="0.5" /></pattern></defs><g><circle cx="50" cy="50" r="40" fill="none" stroke="#e5e7eb" stroke-width="8" aria-hidden="true" /><circle cx="50" cy="50" r="40" fill="none" stroke="#ef4444" stroke-width="8" stroke-dasharray="' + emissionsArc + ' ' + circumference + '" stroke-dashoffset="0" class="chart-donut-segment" role="button" aria-label="' + escapeHtml(emissionsAriaLabel) + '" tabindex="0" title="Emissions: ' + totalCo2Kg.toFixed(2) + ' kg" onkeydown="if(event.key===\'Enter\'||event.key===\' \'){event.preventDefault();showChartSegmentDetails(this);}" /><circle cx="50" cy="50" r="40" fill="none" stroke="#10b981" stroke-width="8" stroke-dasharray="' + offsetArc + ' ' + circumference + '" stroke-dashoffset="-' + emissionsArc + '" class="chart-donut-segment" role="button" aria-label="' + escapeHtml(offsetAriaLabel) + '" tabindex="0" title="Offset: ' + totalOffsetKg.toFixed(2) + ' kg" onkeydown="if(event.key===\'Enter\'||event.key===\' \'){event.preventDefault();showChartSegmentDetails(this);}" /></g></svg><div class="chart-donut-hit-area" style="top: 50%; left: 50%; transform: translate(-50%, -50%);" aria-hidden="true" onclick="document.querySelector(\'.chart-donut-segment\')?.focus()"></div><div class="chart-donut-center"><div class="chart-donut-center-value" style="color: ' + (netEmissionsKg >= 0 ? 'var(--error-text)' : 'var(--success-text)') + ';">' + Math.abs(netEmissionsKg).toFixed(2) + '</div><div class="chart-donut-center-label">Net<br>Emissions<br><span style="font-size:0.7rem;color:var(--text-light);">' + (netEmissionsKg >= 0 ? 'kg' : 'kg offset') + '</span></div></div></div>' + donutDataTable;
                    
                    html += '<div class="chart-card" role="figure" aria-labelledby="chart-title-emissions-offset"><div class="chart-title text-headline" id="chart-title-emissions-offset"><span class="icon-with-text"><i data-lucide="pie-chart"></i> Emissions vs Offset</span></div><div class="chart-subtitle">Visual breakdown of CO₂ emissions and offsets</div><div class="chart-body" style="min-height: 280px; display: flex; align-items: center; justify-content: center;">' + donutHtml + '</div></div>';
                }
                
                html += '</div>'; // Close charts grid
                html += '</div>'; // Close main container
                
                contentDiv.innerHTML = html;
                
                // Initialize icons
                if (typeof lucide !== 'undefined' && lucide.createIcons) {
                    lucide.createIcons({ root: contentDiv });
                }
                
            } catch (error) {
                console.error('Error loading energy dashboard:', error);
                contentDiv.innerHTML = `<p style="color: var(--error-text);">Error loading energy data: ${error.message}</p>`;
            }
        }
        
        // Open donation modal
        function openDonationModal() {
            // Create modal HTML
            const modalHtml = `
                <div id="donationModal" class="modal-overlay" style="display: flex; align-items: center; justify-content: center; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000;">
                    <div class="modal-box" style="background: var(--card); padding: 2rem; border-radius: var(--radius-lg); max-width: 500px; width: 90%; max-height: 90vh; overflow-y: auto;">
                        <h3 style="margin: 0 0 1rem 0; color: var(--primary);"><span class="icon-with-text"><i data-lucide="leaf"></i> Carbon Offset Donation</span></h3>
                        <p style="margin: 0 0 1.5rem 0; font-size: 0.875rem; color: var(--text);">Make a donation to offset your carbon footprint. The standard rate is approximately $10-15 per metric ton of CO₂.</p>
                        <div style="display: flex; flex-direction: column; gap: 1rem;">
                            <div>
                                <label style="display: block; margin-bottom: 0.5rem; font-size: 0.875rem; font-weight: 600; color: var(--text);">Donation Amount (USD)</label>
                                <input type="number" id="donationAmount" min="1" step="0.01" value="10" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: var(--radius-sm); font-size: 1rem;">
                            </div>
                            <div>
                                <label style="display: block; margin-bottom: 0.5rem; font-size: 0.875rem; font-weight: 600; color: var(--text);">Offset Rate (USD per metric ton)</label>
                                <input type="number" id="offsetRate" min="1" step="0.01" value="12" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: var(--radius-sm); font-size: 1rem;">
                            </div>
                            <div id="donationPreview" style="padding: 1rem; background: var(--bg-alt); border-radius: var(--radius-sm);">
                                <div style="font-size: 0.875rem; color: var(--text);">Estimated offset: <strong id="estimatedOffset">0.83 tons CO₂</strong></div>
                            </div>
                            <div style="display: flex; gap: 0.5rem; justify-content: flex-end; margin-top: 0.5rem;">
                                <button type="button" class="btn-secondary" onclick="closeDonationModal()" style="padding: 0.5rem 1rem;">Cancel</button>
                                <button type="button" class="btn" onclick="submitDonation()" style="background: var(--success); color: white; padding: 0.5rem 1rem;"><span class="icon-with-text"><i data-lucide="heart"></i> Submit Donation</span></button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            
            // Update preview on input
            const amountInput = document.getElementById('donationAmount');
            const rateInput = document.getElementById('offsetRate');
            const updatePreview = () => {
                const amount = parseFloat(amountInput.value) || 0;
                const rate = parseFloat(rateInput.value) || 12;
                const offsetTons = amount / rate;
                const offsetKg = offsetTons * 1000;
                document.getElementById('estimatedOffset').textContent = `${offsetTons.toFixed(3)} tons CO₂ (${offsetKg.toFixed(2)} kg)`;
            };
            amountInput.addEventListener('input', updatePreview);
            rateInput.addEventListener('input', updatePreview);
            updatePreview();
            
            // Initialize icons
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons({ root: document.getElementById('donationModal') });
            }
        }
        
        function closeDonationModal() {
            const modal = document.getElementById('donationModal');
            if (modal) modal.remove();
        }
        
        async function submitDonation() {
            const amountInput = document.getElementById('donationAmount');
            const rateInput = document.getElementById('offsetRate');
            const amount = parseFloat(amountInput.value);
            const rate = parseFloat(rateInput.value);
            
            if (!amount || amount <= 0) {
                alert('Please enter a valid donation amount.');
                return;
            }
            
            if (!rate || rate <= 0) {
                alert('Please enter a valid offset rate.');
                return;
            }
            
            if (!supabaseClient || !currentUser) {
                alert('Not logged in or Supabase not available.');
                return;
            }
            
            try {
                // Get user's institution_id
                let institutionId = null;
                const { data: profile } = await supabaseClient
                    .from('user_profiles')
                    .select('institution_id')
                    .eq('id', currentUser.id)
                    .single();
                if (profile) {
                    institutionId = profile.institution_id;
                }
                
                const offsetTons = amount / rate;
                const offsetKg = offsetTons * 1000;
                
                const { error } = await supabaseClient
                    .from('carbon_offset_donations')
                    .insert([{
                        user_id: currentUser.id,
                        institution_id: institutionId,
                        amount_usd: amount,
                        donation_date: new Date().toISOString().split('T')[0],
                        co2_offset_kg: offsetKg,
                        offset_rate_usd_per_ton: rate,
                        status: 'pending',
                        payment_method: 'direct_donation'
                    }]);
                
                if (error) {
                    throw error;
                }
                
                closeDonationModal();
                showNotification('Donation submitted successfully! It will be processed and reflected in your energy metrics.', 'success', 5000);
                
                // Reload energy dashboard
                loadEnergyDashboard();
                
            } catch (error) {
                console.error('Error submitting donation:', error);
                alert('Error submitting donation: ' + error.message);
            }
        }
        
        var _customizeModalPreviousFocus = null;
        function openCustomizeDashboardsModal() {
            const modal = document.getElementById('customizeDashboardsModal');
            const list = document.getElementById('customizeDashboardsList');
            if (!modal || !list) return;
            _customizeModalPreviousFocus = document.activeElement;
            const config = getDashboardConfig();
            list.innerHTML = config.map(function(d, idx) {
                var isCustom = d.type === 'custom';
                var safeId = String(d.id).replace(/'/g, "\\'");
                var visible = d.visible !== false;
                return '<li style="display: flex; align-items: center; gap: 0.35rem; padding: 0.5rem 0; border-bottom: 1px solid var(--border); flex-wrap: wrap;">' +
                    '<span style="flex: 1; min-width: 6rem;">' + escapeHtml(d.name) + (visible ? '' : ' <span style="font-size: 0.7rem; color: var(--text-light);">(hidden)</span>') + '</span>' +
                    '<button type="button" class="btn-secondary" style="padding: 0.2rem 0.4rem; font-size: 0.75rem;" onclick="renameDashboard(\'' + safeId + '\')">Rename</button>' +
                    '<button type="button" class="btn-secondary" style="padding: 0.2rem 0.4rem; font-size: 0.75rem;" onclick="toggleDashboardVisible(\'' + safeId + '\')">' + (visible ? 'Hide' : 'Show') + '</button>' +
                    '<button type="button" class="btn-secondary" style="padding: 0.2rem 0.35rem; font-size: 0.75rem;" onclick="moveDashboard(\'' + safeId + '\', \'up\')" title="Move left">↑</button>' +
                    '<button type="button" class="btn-secondary" style="padding: 0.2rem 0.35rem; font-size: 0.75rem;" onclick="moveDashboard(\'' + safeId + '\', \'down\')" title="Move right">↓</button>' +
                    (['overview', 'comparisons', 'evaluations', 'export'].indexOf(d.id) >= 0 ? ' <button type="button" class="btn-secondary" style="padding: 0.2rem 0.4rem; font-size: 0.75rem;" onclick="openEditCardsModal(\'' + safeId + '\')">Edit cards</button>' : '') +
                    (isCustom ? '<button type="button" class="btn-secondary" style="padding: 0.25rem 0.5rem; font-size: 0.8rem; color: var(--error);" onclick="removeDashboard(\'' + safeId + '\')">Remove</button>' : '') +
                    '</li>';
            }).join('');
            modal.style.display = 'flex';
            requestAnimationFrame(function() {
                var closeBtn = document.getElementById('customizeDashboardsClose');
                if (closeBtn) closeBtn.focus();
            });
        }
        function closeCustomizeDashboardsModal() {
            const modal = document.getElementById('customizeDashboardsModal');
            if (modal) modal.style.display = 'none';
            if (_customizeModalPreviousFocus && typeof _customizeModalPreviousFocus.focus === 'function') {
                _customizeModalPreviousFocus.focus();
                _customizeModalPreviousFocus = null;
            }
        }
        var _editCardsModalPreviousFocus = null;
        function openEditCardsModal(tabId) {
            tabId = tabId || 'overview';
            editCardsModalTabId = tabId;
            var m = document.getElementById('editCardsModal');
            if (!m) return;
            _editCardsModalPreviousFocus = document.activeElement;
            var list = document.getElementById('editCardsWidgetList');
            var titleEl = document.getElementById('editCardsTitle');
            if (!list) return;
            if (typeof ensureTabWidgets === 'function') ensureTabWidgets(tabId);
            var widgets = getTabWidgets(tabId);
            var tabNames = { overview: 'Overview', comparisons: 'Comparisons', evaluations: 'Evaluations', export: 'Data Export', energy: 'Energy & Sustainability' };
            if (titleEl) titleEl.textContent = 'Edit ' + (tabNames[tabId] || tabId) + ' cards';
            var safeTabId = String(tabId).replace(/'/g, "\\'");
            list.innerHTML = widgets.map(function(w) {
                var safeId = String(w.id).replace(/'/g, "\\'");
                var isCustom = w.custom === true || String(w.id).indexOf('custom_') === 0;
                var deleteBtn = isCustom ? '<button type="button" class="btn-secondary" style="padding: 0.2rem 0.4rem; font-size: 0.75rem; color: var(--error);" onclick="deleteTabWidget(\'' + safeTabId + '\', \'' + safeId + '\')">Delete</button>' : '';
                return '<li style="display: flex; align-items: center; gap: 0.35rem; padding: 0.4rem 0; border-bottom: 1px solid var(--border); flex-wrap: wrap;">' +
                    '<span style="flex: 1; min-width: 8rem;">' + escapeHtml(w.label) + (w.visible !== false ? '' : ' <span style="font-size: 0.7rem; color: var(--text-light);">(removed)</span>') + '</span>' +
                    '<button type="button" class="btn-secondary" style="padding: 0.2rem 0.4rem; font-size: 0.75rem;" onclick="toggleTabWidgetVisible(\'' + safeTabId + '\', \'' + safeId + '\')">' + (w.visible !== false ? 'Remove' : 'Add') + '</button>' +
                    '<button type="button" class="btn-secondary" style="padding: 0.2rem 0.35rem; font-size: 0.75rem;" onclick="moveTabWidget(\'' + safeTabId + '\', \'' + safeId + '\', \'up\')">↑</button>' +
                    '<button type="button" class="btn-secondary" style="padding: 0.2rem 0.35rem; font-size: 0.75rem;" onclick="moveTabWidget(\'' + safeTabId + '\', \'' + safeId + '\', \'down\')">↓</button>' +
                    deleteBtn + '</li>';
            }).join('');
            var addBtn = document.getElementById('editCardsAddNewSection');
            if (addBtn) { addBtn.onclick = function() { addNewSection(editCardsModalTabId); }; addBtn.style.display = ''; }
            m.style.display = 'flex';
            requestAnimationFrame(function() {
                var closeBtn = document.getElementById('editCardsClose');
                if (closeBtn) closeBtn.focus();
            });
        }
        function closeEditCardsModal() {
            var m = document.getElementById('editCardsModal');
            if (m) m.style.display = 'none';
            if (_editCardsModalPreviousFocus && typeof _editCardsModalPreviousFocus.focus === 'function') {
                _editCardsModalPreviousFocus.focus();
                _editCardsModalPreviousFocus = null;
            }
        }
        function applyExportTabWidgets() {
            var container = document.getElementById('analyticsExportTab');
            if (!container) return;
            var widgets = (typeof getTabWidgets === 'function' ? getTabWidgets('export') : []).filter(function(w) { return w.visible !== false; }).sort(function(a, b) { return (a.order || 0) - (b.order || 0); });
            if (!widgets.length) widgets = (DEFAULT_TAB_WIDGETS.export || []).filter(function(w) { return w.visible !== false; }).sort(function(a, b) { return a.order - b.order; });
            var orderedIds = widgets.map(function(w) { return w.id; });
            var cards = container.querySelectorAll('[data-widget-id]');
            cards.forEach(function(card) {
                var id = card.getAttribute('data-widget-id');
                if (orderedIds.indexOf(id) >= 0) { card.style.display = ''; } else { card.style.display = 'none'; }
            });
            widgets.forEach(function(w) {
                var el = container.querySelector('[data-widget-id="' + w.id + '"]');
                if (!el && (w.custom || String(w.id).indexOf('custom_') === 0)) {
                    el = document.createElement('div');
                    el.className = 'card';
                    el.setAttribute('data-widget-id', w.id);
                    el.style.marginTop = '1.25rem';
                    el.style.marginBottom = '0';
                    el.innerHTML = '<div class="card-header">' + (typeof escapeHtml === 'function' ? escapeHtml(w.label || 'Custom section') : (w.label || 'Custom section')) + '</div><div class="text-body-secondary" style="padding:1rem;">Custom section. Use Edit cards to remove or reorder.</div>';
                }
                if (el) container.appendChild(el);
            });
        }
        function addDashboard() {
            const name = prompt('Name for the new dashboard:', 'My dashboard');
            if (name == null || !name.trim()) return;
            const config = getDashboardConfig();
            const id = 'custom_' + Date.now();
            config.push({ id: id, name: name.trim(), type: 'custom', visible: true });
            setDashboardConfig(config);
            renderDashboardTabs();
            switchAnalyticsTab(id);
            openCustomizeDashboardsModal();
            if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Dashboard added.');
        }
        function removeDashboard(dashboardId) {
            const config = getDashboardConfig();
            const d = config.find(c => c.id === dashboardId);
            if (!d || d.type !== 'custom') return;
            var name = (d.name || 'this dashboard');
            showConfirmModal('Remove dashboard', 'Remove the dashboard "' + name + '"? You can add a new custom dashboard later.', function() {
                var next = config.filter(c => c.id !== dashboardId);
                setDashboardConfig(next);
                renderDashboardTabs();
                var visible = next.filter(function(x) { return x.visible !== false; });
                if (visible.length && typeof switchAnalyticsTab === 'function') switchAnalyticsTab(visible[0].id);
                openCustomizeDashboardsModal();
                if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Dashboard removed.');
            }, null, 'Remove');
        }
        function renameDashboard(dashboardId) {
            const config = getDashboardConfig();
            const d = config.find(c => c.id === dashboardId);
            if (!d) return;
            const name = prompt('New name:', d.name);
            if (name == null || !name.trim()) return;
            d.name = name.trim();
            setDashboardConfig(config);
            renderDashboardTabs();
            openCustomizeDashboardsModal();
            if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Dashboard renamed.');
        }
        function toggleDashboardVisible(dashboardId) {
            var config = getDashboardConfig();
            var d = config.find(function(c) { return c.id === dashboardId; });
            if (!d) return;
            d.visible = !d.visible;
            setDashboardConfig(config);
            renderDashboardTabs();
            var visible = config.filter(function(x) { return x.visible !== false; });
            if (visible.length && typeof switchAnalyticsTab === 'function') switchAnalyticsTab(visible[0].id);
            openCustomizeDashboardsModal();
            if (typeof showAnalyticsToast === 'function') showAnalyticsToast(d.visible ? 'Tab shown.' : 'Tab hidden. Re-add from Customize.');
        }
        function moveDashboard(dashboardId, direction) {
            var config = getDashboardConfig();
            var idx = config.findIndex(function(c) { return c.id === dashboardId; });
            if (idx < 0) return;
            var next = idx + (direction === 'up' ? -1 : 1);
            if (next < 0 || next >= config.length) return;
            var t = config[idx]; config[idx] = config[next]; config[next] = t;
            setDashboardConfig(config);
            renderDashboardTabs();
            openCustomizeDashboardsModal();
            if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Order updated.');
        }
        function getTabWidgets(dashboardId) {
            var config = getDashboardConfig();
            var d = config.find(function(x) { return x.id === dashboardId; });
            if (dashboardId === 'overview') {
                if (d && d.widgets && d.widgets.length) return d.widgets.slice();
                var isAdminView = (typeof userTier !== 'undefined' && userTier === 'demo' && typeof demoViewAs !== 'undefined' && demoViewAs === 'admin') || (typeof isAdmin === 'function' && isAdmin() && typeof currentUser !== 'undefined' && currentUser && currentUser.department_id) || (typeof isSuperAdmin === 'function' && isSuperAdmin());
                return JSON.parse(JSON.stringify(isAdminView ? DEFAULT_OVERVIEW_WIDGETS_ADMIN : DEFAULT_OVERVIEW_WIDGETS));
            }
            if (d && d.widgets && d.widgets.length) return d.widgets.slice();
            var def = DEFAULT_TAB_WIDGETS[dashboardId];
            return def ? JSON.parse(JSON.stringify(def)) : [];
        }
        function getOverviewWidgets() { return getTabWidgets('overview'); }
        function ensureTabWidgets(dashboardId) {
            var config = getDashboardConfig();
            var d = config.find(function(x) { return x.id === dashboardId; });
            var def = dashboardId === 'overview' ? getTabWidgets('overview') : (DEFAULT_TAB_WIDGETS[dashboardId] ? JSON.parse(JSON.stringify(DEFAULT_TAB_WIDGETS[dashboardId])) : []);
            if (!def.length) return;
            if (!d) { config.push({ id: dashboardId, name: dashboardId, type: 'builtin', visible: true, widgets: JSON.parse(JSON.stringify(def)) }); setDashboardConfig(config); return; }
            if (!d.widgets || !d.widgets.length) { d.widgets = JSON.parse(JSON.stringify(def)); setDashboardConfig(config); }
        }
        function ensureOverviewWidgets() { ensureTabWidgets('overview'); }
        function setTabWidgets(dashboardId, widgets) {
            var config = getDashboardConfig();
            var d = config.find(function(x) { return x.id === dashboardId; });
            if (d) d.widgets = widgets;
            else config.push({ id: dashboardId, name: dashboardId, type: 'builtin', visible: true, widgets: widgets });
            setDashboardConfig(config);
            if (dashboardId === 'overview' && typeof renderOverviewTab === 'function') renderOverviewTab();
            if (dashboardId === 'comparisons' && typeof renderComparisonsTab === 'function') renderComparisonsTab();
            if (dashboardId === 'evaluations' && typeof renderEvaluationsTab === 'function') renderEvaluationsTab();
            if (dashboardId === 'export' && typeof applyExportTabWidgets === 'function') applyExportTabWidgets();
            var editModal = document.getElementById('editCardsModal');
            if (editModal && editModal.style.display === 'flex') openEditCardsModal(editCardsModalTabId);
        }
        var editCardsModalTabId = 'overview';
        function setOverviewWidgets(widgets) { setTabWidgets('overview', widgets); }
        function toggleTabWidgetVisible(dashboardId, widgetId) {
            var widgets = getTabWidgets(dashboardId);
            var w = widgets.find(function(x) { return x.id === widgetId; });
            if (!w) return;
            w.visible = !w.visible;
            setTabWidgets(dashboardId, widgets);
            if (typeof showAnalyticsToast === 'function') showAnalyticsToast(w.visible ? 'Card shown.' : 'Card hidden. Re-add from Customize.');
        }
        function moveTabWidget(dashboardId, widgetId, direction) {
            var widgets = getTabWidgets(dashboardId);
            var idx = widgets.findIndex(function(x) { return x.id === widgetId; });
            if (idx < 0) return;
            var next = idx + (direction === 'up' ? -1 : 1);
            if (next < 0 || next >= widgets.length) return;
            var t = widgets[idx]; widgets[idx] = widgets[next]; widgets[next] = t;
            for (var i = 0; i < widgets.length; i++) widgets[i].order = i;
            setTabWidgets(dashboardId, widgets);
            if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Order updated.');
        }
        function toggleOverviewWidgetVisible(widgetId) { toggleTabWidgetVisible('overview', widgetId); }
        function moveOverviewWidget(widgetId, direction) { moveTabWidget('overview', widgetId, direction); }
        function addNewSection(tabId) {
            var name = prompt('Name for the new section:', 'My section');
            if (name == null || !name.trim()) return;
            var dataQuery = prompt('What data to show? (e.g. by course, by instructor, by modality, by student). Leave blank for a searchable list.', '');
            if (dataQuery === null) return;
            var widgets = getTabWidgets(tabId);
            var newWidget = { id: 'custom_' + Date.now(), label: name.trim(), visible: true, order: widgets.length, custom: true, dataQuery: (dataQuery && dataQuery.trim()) ? dataQuery.trim() : '' };
            widgets.push(newWidget);
            setTabWidgets(tabId, widgets);
            openEditCardsModal(tabId);
            if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Section added. Use search on the card or Edit query to change data.');
        }
        function updateTabWidgetDataQuery(dashboardId, widgetId, dataQuery) {
            var widgets = getTabWidgets(dashboardId);
            var w = widgets.find(function(x) { return x.id === widgetId; });
            if (!w || (!w.custom && String(widgetId).indexOf('custom_') !== 0)) return;
            w.dataQuery = dataQuery == null ? '' : String(dataQuery).trim();
            setTabWidgets(dashboardId, widgets);
            if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Data query updated.');
        }
        function deleteTabWidget(dashboardId, widgetId) {
            var widgets = getTabWidgets(dashboardId);
            var w = widgets.find(function(x) { return x.id === widgetId; });
            if (!w || (!w.custom && String(widgetId).indexOf('custom_') !== 0)) return;
            var label = w.label || widgetId;
            showConfirmModal('Delete section', 'Delete the section "' + label + '"? This cannot be undone.', function() {
                var next = widgets.filter(function(x) { return x.id !== widgetId; });
                for (var i = 0; i < next.length; i++) next[i].order = i;
                setTabWidgets(dashboardId, next);
                openEditCardsModal(dashboardId);
                if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Section deleted.');
            }, null, 'Delete');
        }
        
        // Filter custom card rows by search input (client-side)
        function filterCustomCardBySearch(inputEl) {
            var card = inputEl && inputEl.closest ? inputEl.closest('.chart-card') : null;
            if (!card) return;
            var content = card.querySelector('[data-custom-card-content]');
            if (!content) return;
            var term = (inputEl.value || '').toLowerCase();
            var rows = content.querySelectorAll('tr[data-searchable], .custom-card-row');
            if (!rows.length) rows = content.querySelectorAll('tbody tr');
            rows.forEach(function(r) {
                var text = (r.textContent || '').toLowerCase();
                r.style.display = term === '' || text.indexOf(term) >= 0 ? '' : 'none';
            });
        }
        
        // Build custom card body HTML from widget.dataQuery and evals (with search input)
        function renderCustomCardBody(widget, evals) {
            var q = (widget.dataQuery || '').toLowerCase();
            var instructors = (typeof analyticsData !== 'undefined' && analyticsData.instructors) ? analyticsData.instructors : [];
            var searchHtml = '<div style="margin-bottom:0.75rem;"><input type="text" class="custom-card-search" placeholder="Search in this card" style="width:100%;padding:0.5rem 0.75rem;border:1px solid var(--border);border-radius:0.5rem;font-size:0.9rem;" oninput="filterCustomCardBySearch(this)" aria-label="Search"></div>';
            if (!evals || !evals.length) return searchHtml + '<div data-custom-card-content><p style="color:var(--text-light);padding:1rem;">No data. Load analytics and set a data query (e.g. by course, by instructor) in Edit cards.</p></div>';
            function pct(e) { var p = typeof getOverallScorePct === 'function' ? getOverallScorePct(e) : null; return p != null ? p.toFixed(1) : '—'; }
            var rows = [];
            if (q.indexOf('course') >= 0) {
                var courseStats = {};
                evals.forEach(function(e) {
                    var cid = e.course_id; var name = (e.courses && e.courses.name) || 'Unknown';
                    if (!courseStats[cid]) courseStats[cid] = { name: name, pcts: [] };
                    var p = pct(e); if (p !== '—') courseStats[cid].pcts.push(parseFloat(p));
                });
                rows = Object.keys(courseStats).map(function(cid) {
                    var c = courseStats[cid]; var avg = c.pcts.length ? (c.pcts.reduce(function(a,b){return a+b;},0)/c.pcts.length).toFixed(1) : '—';
                    return { cells: [c.name, c.pcts.length, avg + '%'], text: c.name + ' ' + c.pcts.length + ' ' + avg };
                });
                var tableHtml = '<table class="data-table" style="width:100%;font-size:0.9rem;"><thead><tr><th style="text-align:left;">Course</th><th style="text-align:center;">N</th><th style="text-align:center;">Avg %</th></tr></thead><tbody>' + rows.map(function(r) { return '<tr data-searchable="true"><td>' + escapeHtml(r.cells[0]) + '</td><td style="text-align:center;">' + r.cells[1] + '</td><td style="text-align:center;">' + r.cells[2] + '</td></tr>'; }).join('') + '</tbody></table>';
                return searchHtml + '<div data-custom-card-content>' + tableHtml + '</div>';
            }
            if (q.indexOf('instructor') >= 0) {
                var instStats = {};
                evals.forEach(function(e) {
                    var id = e.instructor_id;
                    if (!instStats[id]) instStats[id] = { name: '', pcts: [] };
                    var inst = instructors.find(function(i){ return i.id === id; });
                    if (inst) instStats[id].name = inst.full_name || inst.email || 'Unknown';
                    var p = pct(e); if (p !== '—') instStats[id].pcts.push(parseFloat(p));
                });
                rows = Object.keys(instStats).map(function(id) {
                    var c = instStats[id]; var avg = c.pcts.length ? (c.pcts.reduce(function(a,b){return a+b;},0)/c.pcts.length).toFixed(1) : '—';
                    return { cells: [c.name || 'Unknown', c.pcts.length, avg + '%'], text: (c.name||'') + ' ' + c.pcts.length + ' ' + avg };
                });
                var tableHtml2 = '<table class="data-table" style="width:100%;font-size:0.9rem;"><thead><tr><th style="text-align:left;">Instructor</th><th style="text-align:center;">N</th><th style="text-align:center;">Avg %</th></tr></thead><tbody>' + rows.map(function(r) { return '<tr data-searchable="true"><td>' + escapeHtml(r.cells[0]) + '</td><td style="text-align:center;">' + r.cells[1] + '</td><td style="text-align:center;">' + r.cells[2] + '</td></tr>'; }).join('') + '</tbody></table>';
                return searchHtml + '<div data-custom-card-content>' + tableHtml2 + '</div>';
            }
            if (q.indexOf('modality') >= 0) {
                var byMod = {};
                evals.forEach(function(e) {
                    var mod = (e.courses && e.courses.modality) ? e.courses.modality : 'unknown';
                    if (!byMod[mod]) byMod[mod] = { n: 0, pcts: [] };
                    byMod[mod].n++;
                    var p = pct(e); if (p !== '—') byMod[mod].pcts.push(parseFloat(p));
                });
                rows = Object.keys(byMod).map(function(mod) {
                    var o = byMod[mod]; var avg = o.pcts.length ? (o.pcts.reduce(function(a,b){return a+b;},0)/o.pcts.length).toFixed(1) : '—';
                    return { cells: [mod.charAt(0).toUpperCase() + mod.slice(1), o.n, avg + '%'], text: mod + ' ' + o.n + ' ' + avg };
                });
                var tableHtml3 = '<table class="data-table" style="width:100%;font-size:0.9rem;"><thead><tr><th style="text-align:left;">Modality</th><th style="text-align:center;">N</th><th style="text-align:center;">Avg %</th></tr></thead><tbody>' + rows.map(function(r) { return '<tr data-searchable="true"><td>' + escapeHtml(r.cells[0]) + '</td><td style="text-align:center;">' + r.cells[1] + '</td><td style="text-align:center;">' + r.cells[2] + '</td></tr>'; }).join('') + '</tbody></table>';
                return searchHtml + '<div data-custom-card-content>' + tableHtml3 + '</div>';
            }
            if (q.indexOf('student') >= 0) {
                rows = evals.slice(0, 100).map(function(e) {
                    var name = e.course_students ? (e.course_students.first_name + ' ' + e.course_students.last_name) : 'Unknown';
                    var courseName = (e.courses && e.courses.name) || 'Unknown';
                    var score = pct(e);
                    return { cells: [name, courseName, score + '%'], text: name + ' ' + courseName + ' ' + score };
                });
                var tableHtml4 = '<table class="data-table" style="width:100%;font-size:0.9rem;"><thead><tr><th style="text-align:left;">Student</th><th style="text-align:left;">Course</th><th style="text-align:center;">Score %</th></tr></thead><tbody>' + rows.map(function(r) { return '<tr data-searchable="true"><td>' + escapeHtml(r.cells[0]) + '</td><td>' + escapeHtml(r.cells[1]) + '</td><td style="text-align:center;">' + r.cells[2] + '</td></tr>'; }).join('') + '</tbody></table>' + (evals.length > 100 ? '<p style="font-size:0.8rem;color:var(--text-light);margin-top:0.5rem;">Showing first 100. Use search to narrow.</p>' : '');
                return searchHtml + '<div data-custom-card-content>' + tableHtml4 + '</div>';
            }
            return searchHtml + '<div data-custom-card-content><p style="color:var(--text-light);padding:1rem;">Set data query in Edit cards: e.g. <strong>by course</strong>, <strong>by instructor</strong>, <strong>by modality</strong>, or <strong>by student</strong>.</p></div>';
        }
        
        // Switch analytics tabs (ARIA + classes) - legacy alias
        function switchAnalyticsTabByName(tabName) { switchAnalyticsTab(tabName); }
        
        // Toast helper for analytics success
        function showAnalyticsToast(message, durationMs) {
            durationMs = durationMs || 4000;
            const existing = document.getElementById('analyticsToast');
            if (existing) existing.remove();
            const el = document.createElement('div');
            el.id = 'analyticsToast';
            el.className = 'analytics-toast';
            el.setAttribute('role', 'status');
            el.setAttribute('aria-live', 'polite');
            el.setAttribute('aria-atomic', 'true');
            el.innerHTML = message;
            document.body.appendChild(el);
            setTimeout(() => { if (el.parentNode) el.remove(); }, durationMs);
        }
        
        // Prefill analytics date range from localStorage
        function prefillAnalyticsDateRange() {
            const startEl = document.getElementById('analyticsStartDate');
            const endEl = document.getElementById('analyticsEndDate');
            if (startEl && !startEl.value && localStorage.getItem('analyticsStartDate')) startEl.value = localStorage.getItem('analyticsStartDate');
            if (endEl && !endEl.value && localStorage.getItem('analyticsEndDate')) endEl.value = localStorage.getItem('analyticsEndDate');
        }
        
        // Load enhanced analytics
        async function loadEnhancedAnalytics(showToast = false) {
            // Check for required dependencies
            if (!supabaseClient || !currentUser) {
                const statsContainer = document.getElementById('overviewStatsContainer');
                if (statsContainer) {
                    statsContainer.innerHTML = '<div style="text-align: center; padding: 2rem 1.5rem; color: var(--text-light);"><p style="font-weight: 600; color: var(--text);">Sign in to load analytics</p><p style="font-size: 0.9rem;">Analytics are available for instructors and department heads.</p></div>';
                }
                return;
            }
            
            // Ensure ANALYTICS_MAX_EVALUATIONS is defined
            if (typeof ANALYTICS_MAX_EVALUATIONS === 'undefined') {
                console.error('ANALYTICS_MAX_EVALUATIONS is not defined');
                const statsContainer = document.getElementById('overviewStatsContainer');
                if (statsContainer) {
                    statsContainer.innerHTML = '<div style="text-align: center; padding: 2rem 1.5rem; color: var(--error);"><p style="font-weight: 600;">Configuration error</p><p style="font-size: 0.9rem;">Analytics configuration is missing. Please refresh the page.</p></div>';
                }
                return;
            }
            
            const isSuperAdminView = typeof isSuperAdmin === 'function' && isSuperAdmin();
            const isAdminView = typeof isAdmin === 'function' && isAdmin() && currentUser.department_id;
            
            if (isSuperAdminView) {
                // Platform-level analytics for SpeechGradebook managers
            } else if (isAdminView) {
                // Department head: load department-wide data
            } else if (userTier === 'instructor') {
                // Instructor: load own data only
            } else {
                alert('Analytics require an instructor or admin account with a department.');
                return;
            }
            
            const btnLoad = document.getElementById('btnLoadAnalytics');
            const originalBtnHtml = btnLoad ? btnLoad.innerHTML : '';
            if (btnLoad) {
                btnLoad.disabled = true;
                btnLoad.innerHTML = '<span style="display:inline-block;width:1rem;height:1rem;border:2px solid rgba(255,255,255,0.4);border-top-color:#fff;border-radius:50%;animation:spin 0.6s linear infinite;vertical-align:middle;margin-right:0.5rem;"></span> Loading...';
            }
            
            prefillAnalyticsDateRange();
            const startDate = document.getElementById('analyticsStartDate')?.value || '';
            const endDate = document.getElementById('analyticsEndDate')?.value || '';
            
            function clearLoading() {
                if (btnLoad) {
                    btnLoad.disabled = false;
                    btnLoad.innerHTML = originalBtnHtml;
                }
            }
            
            function setAnalyticsLoading(show) {
                const statsContainer = document.getElementById('overviewStatsContainer');
                if (!statsContainer) return;
                if (show) {
                    statsContainer.innerHTML = '<p style="color: var(--text-light); margin-bottom: 0.5rem;">Loading analytics…</p><div class="spinner" style="width: 40px; height: 40px; margin: 1rem auto;" aria-hidden="true"></div>';
                }
            }
            setAnalyticsLoading(true);
            try {
                var filterHintEl = document.getElementById('analyticsFilterHint');
                if (filterHintEl && !isSuperAdminView) filterHintEl.style.display = 'none';
                console.log('📊 Loading analytics...', isSuperAdminView ? '(platform)' : isAdminView ? '(department)' : '(my courses)');
                
                let instructors, evaluations;
                
                if (isSuperAdminView) {
                    // Platform stats for Super Admin (SpeechGradebook managers)
                    const [rInst, rUsers, rCourses, rEvals, rConsent, rInstList, rEvalsList] = await Promise.all([
                        supabaseClient.from('institutions').select('*', { count: 'exact', head: true }),
                        supabaseClient.from('user_profiles').select('*', { count: 'exact', head: true }),
                        supabaseClient.from('courses').select('*', { count: 'exact', head: true }).is('deleted_locally_at', null),
                        supabaseClient.from('evaluations').select('*', { count: 'exact', head: true }).is('deleted_locally_at', null),
                        supabaseClient.from('consent_forms').select('id, consent_given'),
                        supabaseClient.from('institutions').select('id, name').order('name'),
                        supabaseClient.from('evaluations').select('id, course_id').is('deleted_locally_at', null).limit(10000)
                    ]);
                    const institutionsCountVal = rInst.count ?? 0;
                    const usersCountVal = rUsers.count ?? 0;
                    const coursesCountVal = rCourses.count ?? 0;
                    const evaluationsCountVal = rEvals.count ?? 0;
                    const consentList = rConsent.data || [];
                    const consentGivenVal = consentList.filter(x => x.consent_given === true).length;
                    const consentTotalVal = consentList.length;
                    const instMap = {};
                    (rInstList.data || []).forEach(i => { instMap[i.id] = i.name; });
                    const rCoursesList = await supabaseClient.from('courses').select('id, instructor_id').is('deleted_locally_at', null);
                    const rUp = await supabaseClient.from('user_profiles').select('id, institution_id');
                    const upMap = {};
                    (rUp.data || []).forEach(u => { upMap[u.id] = u.institution_id; });
                    const courseToInst = {};
                    (rCoursesList.data || []).forEach(c => { courseToInst[c.id] = upMap[c.instructor_id]; });
                    const byInst = {};
                    (rEvalsList.data || []).forEach(e => {
                        const instId = courseToInst[e.course_id];
                        if (!instId) return; // skip evaluations for locally-deleted courses
                        if (!byInst[instId]) byInst[instId] = { name: instMap[instId] || 'Unknown', evaluations: 0, courses: new Set(), users: new Set() };
                        byInst[instId].evaluations++;
                        byInst[instId].courses.add(e.course_id);
                    });
                    const byInstitutionVal = Object.entries(byInst).map(([id, o]) => ({
                        id,
                        name: o.name,
                        evaluations: o.evaluations,
                        courses: o.courses.size,
                        instructors: 0
                    })).sort((a, b) => b.evaluations - a.evaluations);
                    analyticsData.superAdminPlatform = {
                        institutionsCount: institutionsCountVal,
                        usersCount: usersCountVal,
                        coursesCount: coursesCountVal,
                        evaluationsCount: evaluationsCountVal,
                        consentGiven: consentGivenVal,
                        consentTotal: consentTotalVal,
                        byInstitution: byInstitutionVal
                    };
                    // Load ALL instructors (all institutions) and ALL institutions for Super Admin dropdowns (resilient: one failure does not block the rest)
                    try {
                        const { data: instData, error: instErr } = await supabaseClient
                            .from('user_profiles')
                            .select('id, email, full_name, institution_id')
                            .eq('account_tier', 'instructor');
                        if (instErr) console.error('Platform Analytics: instructors API error', instErr);
                        instructors = (instErr ? null : instData) || [];
                    } catch (e) {
                        console.warn('Platform Analytics: instructors load failed', e);
                        instructors = [];
                    }
                    console.log('Platform Analytics: instructors loaded', instructors.length);
                    let allInstitutions = [];
                    try {
                        const { data: institutionsList, error: instListErr } = await supabaseClient
                            .from('institutions')
                            .select('id, name')
                            .order('name');
                        if (instListErr) console.warn('Platform Analytics: institutions API error', instListErr);
                        allInstitutions = (instListErr ? null : institutionsList) || [];
                    } catch (e) {
                        console.warn('Platform Analytics: institutions load failed', e);
                    }
                    console.log('Platform Analytics: institutions loaded', allInstitutions.length);
                    let evData = null;
                    let evalErr = null;
                    try {
                        let evalQuery = supabaseClient.from('evaluations').select(`
                            id, instructor_id, course_id, student_id, rubric_id, created_at, evaluation_data,
                            courses!fk_evaluations_course (id, name, semester, year, deleted_locally_at),
                            course_students!fk_evaluations_student (first_name, last_name),
                            rubric:rubrics!fk_evaluations_rubric(id, name)
                        `).is('deleted_locally_at', null);
                        if (startDate) evalQuery = evalQuery.gte('created_at', startDate);
                        if (endDate) evalQuery = evalQuery.lte('created_at', endDate + 'T23:59:59');
                        evalQuery = evalQuery.order('created_at', { ascending: false }).limit(ANALYTICS_MAX_EVALUATIONS + 1);  // +1 to detect truncation
                        const res = await evalQuery;
                        evData = res.data;
                        evalErr = res.error;
                    } catch (e) {
                        console.warn('Platform Analytics: evaluations query failed', e);
                    }
                    if (evalErr) console.error('Platform Analytics: evaluations API error', evalErr);
                    // Exclude evaluations from courses deleted locally by instructors
                    evaluations = (evData || []).filter(e => {
                        if (e.deleted_locally_at != null) return false;
                        const course = Array.isArray(e.courses) ? e.courses[0] : e.courses;
                        return !course || course.deleted_locally_at == null;
                    });
                    analyticsEvaluationsTruncated = evaluations.length > ANALYTICS_MAX_EVALUATIONS;
                    if (analyticsEvaluationsTruncated) {
                        evaluations = evaluations.slice(0, ANALYTICS_MAX_EVALUATIONS);
                        console.warn('Platform Analytics: results truncated to', ANALYTICS_MAX_EVALUATIONS, 'evaluations (use date filters to narrow)');
                    }
                    console.log('Platform Analytics: evaluations loaded', evaluations.length, analyticsEvaluationsTruncated ? '(truncated)' : '');
                    if (evaluations.length > 0 && typeof logAccess === 'function') {
                        try { await logAccess('view', 'evaluations', null, null, { evaluation_count: evaluations.length, purpose: 'platform_analytics' }); } catch (e) { console.warn('logAccess failed', e); }
                    }
                    const uniqueCoursesFromEvals = evaluations
                        .filter((e, i, arr) => arr.findIndex(x => x.course_id === e.course_id) === i)
                        .map(e => (Array.isArray(e.courses) ? e.courses[0] : e.courses))
                        .filter(c => c && (c.id != null));
                    // Super Admin: also load all non-deleted courses so Course dropdown has options even when 0 evaluations in date range
                    let coursesForDropdown = uniqueCoursesFromEvals.slice();
                    if (uniqueCoursesFromEvals.length === 0 || evaluations.length === 0) {
                        try {
                            const { data: allCourses } = await supabaseClient
                                .from('courses')
                                .select('id, name, semester, year')
                                .is('deleted_locally_at', null)
                                .order('name');
                            if (allCourses && allCourses.length > 0) {
                                const seen = new Set(coursesForDropdown.map(c => c.id));
                                allCourses.forEach(c => { if (!seen.has(c.id)) { seen.add(c.id); coursesForDropdown.push(c); } });
                            }
                        } catch (e) { console.warn('Platform Analytics: could not load courses for dropdown', e); }
                    }
                    analyticsData.evaluations = evaluations;
                    analyticsData.instructors = instructors;
                    analyticsData.courses = coursesForDropdown;
                    analyticsData.institutions = allInstitutions;
                    analyticsData.filtered = evaluations;
                    await loadAnalyticsRubricsById(evaluations);
                    if (startDate) try { localStorage.setItem('analyticsStartDate', startDate); } catch (e) {}
                    if (endDate) try { localStorage.setItem('analyticsEndDate', endDate); } catch (e) {}
                    updateAnalyticsUIForRole();
                    populateAnalyticsFilters();
                    // Sync All Institutions section dropdowns from same data so both analytics bar and All Institutions table have options
                    var instSel = document.getElementById('filterInstitution');
                    var instrSel = document.getElementById('filterInstructor');
                    if (instSel && (analyticsData.institutions || []).length > 0) {
                        var instOpts = (analyticsData.institutions || []).filter(function(i) { return i && (i.id != null && i.id !== ''); })
                            .map(function(i) { return '<option value="' + String(i.id) + '">' + escapeHtml(i.name || '') + '</option>'; }).join('');
                        instSel.innerHTML = '<option value="">All Institutions</option>' + instOpts;
                    }
                    if (instrSel && (analyticsData.instructors || []).length > 0) {
                        var instrOpts = (analyticsData.instructors || []).filter(function(i) { return i && (i.id != null && i.id !== ''); })
                            .map(function(i) { return '<option value="' + String(i.id) + '">' + escapeHtml((i.full_name || '').trim() || i.email || 'Instructor') + '</option>'; }).join('');
                        instrSel.innerHTML = '<option value="">All Instructors</option>' + instrOpts;
                    }
                    populateFocusCategoryDropdown();
                    filterAnalytics();
                    analyticsEvaluationsPage = 0;
                    renderOverviewTab();
                    renderComparisonsTab();
                    renderEvaluationsTab();
                    if (typeof renderExportPreview === 'function') renderExportPreview();
                    if (typeof currentAnalyticsTabId !== 'undefined' && currentAnalyticsTabId) {
                        if (typeof switchAnalyticsTab === 'function') switchAnalyticsTab(currentAnalyticsTabId);
                    } else {
                        if (typeof switchAnalyticsTab === 'function') switchAnalyticsTab('overview');
                    }
                    if (typeof setAnalyticsLastUpdated === 'function') setAnalyticsLastUpdated();
                    if (showToast && typeof showAnalyticsToast === 'function') showAnalyticsToast('Analytics updated.', 3000);
                    if (typeof loadFilteredCoursesForSuperAdmin === 'function') loadFilteredCoursesForSuperAdmin();
                    var hintEl = document.getElementById('analyticsFilterHint');
                    if (hintEl) {
                        const noInstructors = instructors.length === 0;
                        const noInstitutions = allInstitutions.length === 0;
                        const noCourses = coursesForDropdown.length === 0;
                        if (noInstructors && noInstitutions) {
                            hintEl.style.display = 'block';
                            hintEl.innerHTML = 'Institution and Instructor dropdowns have no options. <strong>Open DevTools (F12) → Console</strong> and click Apply again to see API counts and any errors. <strong>Most common fix:</strong> Your own <code>user_profiles</code> row must have <code>is_super_admin = true</code> and <code>account_tier = \'super_admin\'</code> or RLS will return 0 rows. In Supabase: Table Editor → user_profiles → find your row (by email) → set <code>is_super_admin</code> = true, <code>account_tier</code> = super_admin. Then run the SQL in <code>UPDATE_analytics_dropdowns.sql</code>. Loaded: ' + instructors.length + ' instructors, ' + evaluations.length + ' evaluations, ' + coursesForDropdown.length + ' courses, ' + allInstitutions.length + ' institutions.';
                        } else if (evaluations.length === 0 && (noCourses || uniqueCoursesFromEvals.length === 0)) {
                            hintEl.style.display = 'block';
                            hintEl.innerHTML = 'No evaluations in the selected <strong>date range</strong>, so overview stats and the Course dropdown may be empty. Widen the date range (or clear the dates) and click <strong>Apply</strong> to load evaluations. Institution and Instructor dropdowns are populated from your database. Loaded: ' + instructors.length + ' instructors, ' + evaluations.length + ' evaluations, ' + coursesForDropdown.length + ' courses, ' + allInstitutions.length + ' institutions.';
                        } else if (noCourses && noInstructors) {
                            hintEl.style.display = 'block';
                            hintEl.innerHTML = 'No courses or instructors loaded. Check date range and click Apply. If you have no instructors in <code>user_profiles</code> with <code>account_tier = \'instructor\'</code>, add them. Loaded: ' + instructors.length + ' instructors, ' + evaluations.length + ' evaluations, ' + coursesForDropdown.length + ' courses, ' + allInstitutions.length + ' institutions.';
                        } else {
                            hintEl.style.display = 'none';
                        }
                    }
                    console.log('✓ Platform analytics loaded (ALL institutions):', analyticsData.superAdminPlatform, { evaluations: evaluations.length, instructors: instructors.length, courses: coursesForDropdown.length, institutions: allInstitutions.length });
                    clearLoading();
                    return;
                }
                
                if (isAdminView) {
                    const { data: instData, error: instError } = await supabaseClient
                        .from('user_profiles')
                        .select('id, email, full_name')
                        .eq('department_id', currentUser.department_id)
                        .eq('account_tier', 'instructor');
                    if (instError) throw instError;
                    instructors = instData || [];
                    const instructorIds = instructors.map(i => i.id);
                    if (instructorIds.length === 0) {
                        const statsContainer = document.getElementById('overviewStatsContainer');
                        if (statsContainer) {
                        statsContainer.innerHTML = '<div style="text-align: center; padding: 2rem 1.5rem; color: var(--text-light);"><p style="font-size: 1.5rem; margin-bottom: 0.5rem;"><i data-lucide="users" style="width:2rem;height:2rem;display:inline-block;"></i></p><p style="font-weight: 600; margin-bottom: 0.25rem; color: var(--text);">No instructors in your department</p><p style="font-size: 0.9rem;">Add instructors to your department to see analytics here.</p></div>';
                        if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statsContainer });
                    }
                        clearLoading();
                        return;
                    }
                    let query = supabaseClient.from('evaluations').select(`
                        id, instructor_id, course_id, student_id, rubric_id, created_at, evaluation_data,
                        courses!fk_evaluations_course (id, name, semester, year, deleted_locally_at),
                        course_students!fk_evaluations_student (first_name, last_name),
                        rubric:rubrics!fk_evaluations_rubric(id, name)
                    `).in('instructor_id', instructorIds).is('deleted_locally_at', null);
                    if (startDate) query = query.gte('created_at', startDate);
                    if (endDate) query = query.lte('created_at', endDate + 'T23:59:59');
                    query = query.order('created_at', { ascending: false }).limit(ANALYTICS_MAX_EVALUATIONS + 1);
                    const { data: evData, error: evalError } = await query;
                    if (evalError) throw evalError;
                    // Exclude evaluations from courses deleted locally by instructors
                    evaluations = (evData || []).filter(e => {
                        const course = Array.isArray(e.courses) ? e.courses[0] : e.courses;
                        return !course || course.deleted_locally_at == null;
                    });
                    analyticsEvaluationsTruncated = evaluations.length > ANALYTICS_MAX_EVALUATIONS;
                    if (analyticsEvaluationsTruncated) evaluations = evaluations.slice(0, ANALYTICS_MAX_EVALUATIONS);
                    if (evaluations.length > 0) {
                        await logAccess('view', 'evaluations', null, null, { evaluation_count: evaluations.length, purpose: 'department_analytics' });
                    }
                } else {
                    instructors = [{ id: currentUser.id, email: currentUser.email || '', full_name: currentUser.full_name || currentUser.email || 'Me' }];
                    let query = supabaseClient.from('evaluations').select(`
                        id, instructor_id, course_id, student_id, rubric_id, created_at, evaluation_data,
                        courses!fk_evaluations_course (id, name, semester, year, deleted_locally_at),
                        course_students!fk_evaluations_student (first_name, last_name),
                        rubric:rubrics!fk_evaluations_rubric(id, name)
                    `).eq('instructor_id', currentUser.id).is('deleted_locally_at', null);
                    if (startDate) query = query.gte('created_at', startDate);
                    if (endDate) query = query.lte('created_at', endDate + 'T23:59:59');
                    query = query.order('created_at', { ascending: false }).limit(ANALYTICS_MAX_EVALUATIONS + 1);
                    const { data: evData, error: evalError } = await query;
                    if (evalError) throw evalError;
                    // Exclude evaluations from courses deleted locally
                    evaluations = (evData || []).filter(e => {
                        const course = Array.isArray(e.courses) ? e.courses[0] : e.courses;
                        return !course || course.deleted_locally_at == null;
                    });
                    analyticsEvaluationsTruncated = evaluations.length > ANALYTICS_MAX_EVALUATIONS;
                    if (analyticsEvaluationsTruncated) evaluations = evaluations.slice(0, ANALYTICS_MAX_EVALUATIONS);
                }
                
                const uniqueCourses = evaluations
                    .filter((e, i, arr) => arr.findIndex(x => x.course_id === e.course_id) === i)
                    .map(e => e.courses)
                    .filter(c => c);
                
                analyticsData.evaluations = evaluations;
                analyticsData.instructors = instructors;
                analyticsData.courses = uniqueCourses;
                analyticsData.filtered = evaluations;
                await loadAnalyticsRubricsById(evaluations);
                
                if (startDate) try { localStorage.setItem('analyticsStartDate', startDate); } catch (e) {}
                if (endDate) try { localStorage.setItem('analyticsEndDate', endDate); } catch (e) {}
                
                updateAnalyticsUIForRole();
                populateAnalyticsFilters();
                populateFocusCategoryDropdown();
                filterAnalytics();
                
                analyticsEvaluationsPage = 0;
                renderOverviewTab();
                renderComparisonsTab();
                renderEvaluationsTab();
                if (typeof renderExportPreview === 'function') renderExportPreview();
                
                // Stay on current tab instead of forcing switch to overview
                if (typeof currentAnalyticsTabId !== 'undefined' && currentAnalyticsTabId) {
                    if (typeof switchAnalyticsTab === 'function') switchAnalyticsTab(currentAnalyticsTabId);
                } else {
                    if (typeof switchAnalyticsTab === 'function') switchAnalyticsTab('overview');
                }
                if (typeof setAnalyticsLastUpdated === 'function') setAnalyticsLastUpdated();
                if (showToast && typeof showAnalyticsToast === 'function') showAnalyticsToast('Analytics updated.', 3000);
                
                console.log('✓ Analytics loaded:', { evaluations: evaluations.length, instructors: instructors.length, courses: uniqueCourses.length });
            } catch (error) {
                console.error('Error loading analytics:', error);
                const errorMessage = error?.message || error?.toString() || 'Unknown error';
                const errorDetails = error?.details || error?.hint || '';
                console.error('Error details:', { message: errorMessage, details: errorDetails, error });
                
                const statsContainer = document.getElementById('overviewStatsContainer');
                if (statsContainer) {
                    let errorHtml = '<div style="text-align: center; padding: 2rem 1.5rem;">';
                    errorHtml += '<p style="font-size: 1.5rem; margin-bottom: 0.5rem;"><i data-lucide="alert-triangle" style="width:2rem;height:2rem;display:inline-block;color:var(--error);"></i></p>';
                    errorHtml += '<p style="font-weight: 600; margin-bottom: 0.25rem; color: var(--error);">Error loading analytics</p>';
                    errorHtml += '<p style="font-size: 0.9rem; color: var(--text-light); margin-bottom: 0.5rem;">Please try again.</p>';
                    
                    // Show detailed error in development/debugging mode
                    if (errorDetails || (errorMessage && errorMessage !== 'Unknown error')) {
                        errorHtml += '<details style="text-align: left; margin: 1rem 0; padding: 0.75rem; background: var(--bg-alt); border-radius: 0.5rem; font-size: 0.85rem;">';
                        errorHtml += '<summary style="cursor: pointer; color: var(--text-light); margin-bottom: 0.5rem;">Error details (click to expand)</summary>';
                        errorHtml += '<pre style="margin: 0; color: var(--text); white-space: pre-wrap; word-wrap: break-word;">' + escapeHtml(errorMessage) + (errorDetails ? '\n' + escapeHtml(errorDetails) : '') + '</pre>';
                        errorHtml += '</details>';
                    }
                    
                    errorHtml += '<button type="button" onclick="loadEnhancedAnalytics()" class="btn" style="background: var(--primary); color: white; margin-top: 1rem;"><span class="icon-with-text"><i data-lucide="refresh-cw"></i> Try again</span></button>';
                    errorHtml += '</div>';
                    statsContainer.innerHTML = errorHtml;
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: statsContainer });
            }
                if (typeof showAnalyticsToast === 'function') {
                showAnalyticsToast('Error loading analytics. Please try again.', 5000);
                }
            }
            clearLoading();
        }
        
        // Demo mode: load fake analytics so dashboard renders (Instructor or Admin view)
        function loadDemoAnalytics(viewAs) {
            if (typeof analyticsData === 'undefined') return;
            var instructors, courses, evaluations;
            var baseDate = new Date();
            baseDate.setMonth(baseDate.getMonth() - 2);
            function iso(d) { return d.toISOString().slice(0, 10) + 'T12:00:00Z'; }
            function mockEvalData(scorePct) {
                var s = Math.max(0, Math.min(100, scorePct));
                return { sections: { Content: { score: s * 0.4, maxScore: 40, subcategories: [{ name: 'Organization', points: s * 0.15, maxPoints: 15 }, { name: 'Delivery', points: s * 0.25, maxPoints: 25 }] }, Delivery: { score: s * 0.3, maxScore: 30, subcategories: [{ name: 'Eye contact', points: s * 0.15, maxPoints: 15 }] } } };
            }
            if (viewAs === 'admin') {
                instructors = [{ id: 'demo-i1', email: 'jane@example.edu', full_name: 'Jane Smith' }, { id: 'demo-i2', email: 'bob@example.edu', full_name: 'Bob Jones' }, { id: 'demo-i3', email: 'alex@example.edu', full_name: 'Alex Lee' }];
                courses = [{ id: 'demo-c1', name: 'COMM 101', semester: 'Fall', year: '2025', modality: 'in-person' }, { id: 'demo-c2', name: 'COMM 205', semester: 'Fall', year: '2025', modality: 'online' }, { id: 'demo-c3', name: 'SPCH 110', semester: 'Spring', year: '2025', modality: 'hybrid' }];
                evaluations = [];
                [72, 85, 91, 68, 78, 88, 65, 82, 90, 74, 79, 86, 70, 84, 92].forEach(function(pct, i) {
                    var inst = instructors[i % 3]; var course = courses[i % 3];
                    evaluations.push({ id: 'demo-e' + i, instructor_id: inst.id, course_id: course.id, student_id: 'demo-s' + i, rubric_id: 'default', created_at: iso(new Date(baseDate.getTime() + i * 86400000 * 3)), evaluation_data: mockEvalData(pct), courses: course, course_students: { first_name: 'Student', last_name: String(i + 1) } });
                });
            } else {
                instructors = [{ id: 'demo-me', email: 'instructor@example.edu', full_name: 'Demo Instructor' }];
                courses = [{ id: 'demo-c1', name: 'COMM 101', semester: 'Fall', year: '2025', modality: 'in-person' }, { id: 'demo-c2', name: 'COMM 205', semester: 'Fall', year: '2025', modality: 'online' }];
                evaluations = [];
                [75, 82, 88, 70, 79, 85, 68, 80, 90, 73, 78, 86].forEach(function(pct, i) {
                    var course = courses[i % 2];
                    evaluations.push({ id: 'demo-e' + i, instructor_id: 'demo-me', course_id: course.id, student_id: 'demo-s' + i, rubric_id: 'default', created_at: iso(new Date(baseDate.getTime() + i * 86400000 * 4)), evaluation_data: mockEvalData(pct), courses: course, course_students: { first_name: 'Student', last_name: String(i + 1) } });
                });
            }
            analyticsData.evaluations = evaluations;
            analyticsData.instructors = instructors;
            analyticsData.courses = courses;
            analyticsData.filtered = evaluations;
            analyticsData.rubricsById = {};  // demo data has no Supabase rubrics
            if (typeof updateAnalyticsUIForRole === 'function') updateAnalyticsUIForRole();
            if (typeof populateAnalyticsFilters === 'function') populateAnalyticsFilters();
            if (typeof populateFocusCategoryDropdown === 'function') populateFocusCategoryDropdown();
            if (typeof filterAnalytics === 'function') filterAnalytics();
            if (typeof renderOverviewTab === 'function') renderOverviewTab();
            if (typeof renderComparisonsTab === 'function') renderComparisonsTab();
            if (typeof renderEvaluationsTab === 'function') renderEvaluationsTab();
            if (typeof switchAnalyticsTab === 'function') switchAnalyticsTab('overview');
            if (typeof setAnalyticsLastUpdated === 'function') setAnalyticsLastUpdated();
            // Demo data loaded (no toast needed)
        }
        
        function updateAnalyticsUIForRole() {
            const isAdminView = (userTier === 'demo' && typeof demoViewAs !== 'undefined' && demoViewAs === 'admin') || (typeof isAdmin === 'function' && isAdmin() && currentUser);
            const isSuperAdminView = typeof isSuperAdmin === 'function' && isSuperAdmin();
            const titleEl = document.getElementById('analyticsSectionTitle');
            const exportBtn = document.getElementById('analyticsExportBtn');
            if (titleEl) {
                if (isSuperAdminView) titleEl.innerHTML = '<span class="icon-with-text"><i data-lucide="bar-chart-2"></i> Platform Analytics</span>';
                else if (isAdminView) titleEl.innerHTML = '<span class="icon-with-text"><i data-lucide="bar-chart-2"></i> Department Outcomes & Teaching Insights</span>';
                else titleEl.innerHTML = '<span class="icon-with-text"><i data-lucide="bar-chart-2"></i> Course Insights</span>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: titleEl });
            }
            if (exportBtn) exportBtn.style.display = (isAdminView || isSuperAdminView) ? '' : 'none';
            var institutionDropdown = document.getElementById('filter-dropdown-institution');
            if (institutionDropdown) institutionDropdown.style.display = isSuperAdminView ? 'flex' : 'none';
        }
        
        // Metric definitions database
        const METRIC_DEFINITIONS = {
            'overall-performance': {
                title: 'Overall Performance',
                definition: 'The average score across all evaluations in the selected date range and filters. This represents the mean percentage score calculated from all rubric dimensions.',
                measurement: 'Calculated by averaging the overall percentage scores from each evaluation. Each evaluation\'s score is computed by taking the weighted average of all rubric categories and subcategories.',
                limitations: 'This metric provides a high-level view but may mask variation across different rubric dimensions. Use the detailed charts below to understand performance by specific categories.'
            },
            'top-strength': {
                title: 'Top Strength',
                definition: 'The rubric dimension or category where students scored highest on average. This identifies the area of strongest performance across all evaluations.',
                measurement: 'Determined by calculating the average percentage score for each rubric dimension across all evaluations, then identifying the dimension with the highest average.',
                limitations: 'Represents aggregate performance and may not reflect individual student variation. Some dimensions may have fewer data points than others.'
            },
            'top-opportunity': {
                title: 'Top Opportunity',
                definition: 'The rubric dimension or category where students scored lowest on average. This identifies the area with the greatest potential for improvement and targeted instruction.',
                measurement: 'Determined by calculating the average percentage score for each rubric dimension across all evaluations, then identifying the dimension with the lowest average.',
                limitations: 'Represents aggregate performance. Consider reviewing individual evaluations to understand specific patterns and student needs.'
            },
            'completion': {
                title: 'Completion',
                definition: 'The total number of evaluations completed in the selected date range and filter criteria. This indicates the volume of assessment data available for analysis.',
                measurement: 'Simple count of all evaluation records that match the current filters (date range, course, term, instructor).',
                limitations: 'Does not reflect evaluation quality or depth. A higher number provides more reliable aggregate statistics.'
            },
            'total-evaluations': {
                title: 'Total Evaluations',
                definition: 'The total number of evaluations completed in the selected date range and filter criteria. This indicates the volume of assessment data available for analysis.',
                measurement: 'Simple count of all evaluation records that match the current filters (date range, course, term, instructor).',
                limitations: 'Does not reflect evaluation quality or depth. A higher number provides more reliable aggregate statistics.'
            },
            'outcome-attainment': {
                title: 'Outcome Attainment',
                definition: 'The percentage of evaluations where students met the threshold (≥60%) across all rubric dimensions. This is a key indicator for accreditation and program assessment.',
                measurement: 'For each evaluation, determines if the overall score is 60% or higher. The percentage represents the proportion of evaluations meeting this threshold.',
                limitations: 'The 60% threshold is a standard benchmark but may not reflect your institution\'s specific standards. Adjust interpretation based on your program goals.'
            },
            'across-section-variability': {
                title: 'Across-section Variability',
                definition: 'Measures consistency in student performance across different course sections. Lower variability suggests more consistent instruction and assessment.',
                measurement: 'Calculated using standard deviation of mean scores across different sections or instructors. Requires multiple sections for meaningful analysis.',
                limitations: 'High variability may reflect differences in student populations, not just instructional quality. Use for calibration, not ranking.'
            },
            'modality-gap': {
                title: 'Modality Gap',
                definition: 'The difference in average performance between online and in-person course sections. Helps identify if modality affects student outcomes.',
                measurement: 'Compares mean scores between courses tagged as "online" vs "in-person" in course settings. Requires course modality data.',
                limitations: 'Differences may reflect student self-selection, not modality effects. Requires sufficient sample size (n≥5) per modality.'
            },
            'calibration-signals': {
                title: 'Calibration Signals',
                definition: 'Indicates consistency in evaluation scoring over time. "Stable" means no significant drift detected; changes may suggest need for rater recalibration.',
                measurement: 'Monitors score distributions over time using statistical process control methods. Flags significant shifts in mean or variance.',
                limitations: 'For professional development only. Not intended for punitive evaluation of instructors.'
            },
            'completion-rate': {
                title: 'Completion Rate',
                definition: 'Total number of completed evaluations. Higher completion rates provide more robust data for analysis and decision-making.',
                measurement: 'Count of all evaluation records in the system matching current filters.',
                limitations: 'Quantity does not equal quality. Ensure evaluations are completed thoughtfully and thoroughly.'
            },
            'access-quality-flags': {
                title: 'Access / Quality Flags',
                definition: 'Indicators of potential data quality issues or access concerns, such as missing consent, incomplete evaluations, or data anomalies.',
                measurement: 'Automated checks for missing required fields, outlier scores, or consent-related restrictions.',
                limitations: 'Flags require human review. Not all flagged items indicate actual problems.'
            },
            'outcome-attainment-by-outcome': {
                title: 'Outcome attainment by outcome',
                definition: 'Shows the percentage of students meeting the threshold (≥60%) for each individual rubric dimension. Helps identify which learning outcomes are being met consistently.',
                measurement: 'For each rubric dimension, calculates the percentage of evaluations where that dimension scored 60% or higher.',
                limitations: 'Dimensions with fewer evaluations may show more variability. Consider sample size when interpreting results.'
            },
            'modality-comparison': {
                title: 'Modality comparison',
                definition: 'Compares student performance across different course delivery modalities (online, in-person, hybrid). Helps assess if delivery method impacts outcomes.',
                measurement: 'Aggregates scores by course modality setting. Suppresses cells with n<5 to protect privacy.',
                limitations: 'Modality must be set in course settings. Differences may reflect student populations, not just delivery method.'
            },
            'course-comparisons': {
                title: 'Course comparisons',
                definition: 'Shows average performance across different courses. Useful for identifying courses that may need additional support or represent best practices.',
                measurement: 'Calculates mean score for each course across all evaluations in that course.',
                limitations: 'Courses may have different rubrics, student populations, or difficulty levels. Use for exploration, not ranking.'
            },
            'section-variability-map': {
                title: 'Section variability map',
                definition: 'Displays mean scores and standard deviations for each rubric dimension across all sections. Helps identify where consistency is strong or where calibration may be needed.',
                measurement: 'For each dimension, calculates mean and standard deviation across all evaluations. Higher SD indicates more variability.',
                limitations: 'Use for professional development and calibration, not for punitive instructor comparison.'
            },
            'accreditation-ready-summary': {
                title: 'Accreditation-ready summary',
                definition: 'Provides a high-level summary of outcome attainment suitable for accreditation reports. Shows percentage meeting threshold with export options.',
                measurement: 'Calculates overall percentage of evaluations meeting the 60% threshold, formatted for external reporting.',
                limitations: 'Represents aggregate data only. Accreditation bodies may require additional context and disaggregation.'
            },
            'modality-report': {
                title: 'Modality report',
                definition: 'Detailed comparison of performance across course modalities with sample sizes and suppression thresholds applied for privacy.',
                measurement: 'Tabulates mean scores and sample sizes by modality. Suppresses cells with n<5.',
                limitations: 'Requires modality data in course settings. Small samples may not be representative.'
            },
            'norming-summary': {
                title: 'Norming summary',
                definition: 'Calibration and norming indicators showing whether scoring is stable over time. Helps ensure consistent standards across evaluators.',
                measurement: 'Monitors score distributions for significant shifts using statistical process control methods.',
                limitations: 'For calibration and professional development only. Does not assess evaluator quality.'
            },
            'opi-distribution': {
                title: 'OPI Distribution',
                definition: 'Overall Performance Index distribution showing the spread of scores across all evaluations. Helps visualize whether most students are meeting expectations.',
                measurement: 'Displays the distribution of overall percentage scores, typically shown as a histogram or summary statistics.',
                limitations: 'Aggregate view may mask important subgroup differences. Review by course or dimension for deeper insights.'
            },
            'students-needing-targeted-feedback': {
                title: 'Students Needing Targeted Feedback',
                definition: 'Identifies students who may benefit from additional support based on evaluation scores. Typically includes students scoring below 60%.',
                measurement: 'Filters evaluations to show those with overall scores below the threshold, allowing instructors to follow up.',
                limitations: 'Low scores may reflect various factors. Review individual evaluations for context before intervening.'
            }
        };
        
        function showMetricDefinition(slug, title) {
            const modal = document.getElementById('metricDefinitionModal');
            const titleEl = document.getElementById('metricDefinitionTitle');
            const contentEl = document.getElementById('metricDefinitionContent');
            
            if (!modal || !titleEl || !contentEl) return;
            
            const def = METRIC_DEFINITIONS[slug];
            
            if (def) {
                titleEl.textContent = def.title;
                contentEl.innerHTML = `
                    <div style="margin-bottom: 1rem;">
                        <h4 style="margin: 0 0 0.5rem 0; font-size: 0.95rem; color: var(--primary);">Definition</h4>
                        <p style="margin: 0; font-size: 0.9rem;">${def.definition}</p>
                    </div>
                    <div style="margin-bottom: 1rem;">
                        <h4 style="margin: 0 0 0.5rem 0; font-size: 0.95rem; color: var(--primary);">How it's measured</h4>
                        <p style="margin: 0; font-size: 0.9rem;">${def.measurement}</p>
                    </div>
                    <div>
                        <h4 style="margin: 0 0 0.5rem 0; font-size: 0.95rem; color: var(--primary);">Limitations & context</h4>
                        <p style="margin: 0; font-size: 0.9rem;">${def.limitations}</p>
                    </div>
                `;
            } else {
                titleEl.textContent = title;
                contentEl.innerHTML = `
                    <p style="margin: 0; font-size: 0.9rem; color: var(--text-light);">
                        Detailed information about this metric is being developed. 
                        For now, you can explore the data in the Evaluations tab or export to CSV for further analysis.
                    </p>
                `;
            }
            
            var previousFocus = document.activeElement;
            modal._focusReturn = previousFocus && previousFocus.nodeName ? previousFocus : null;
            modal.style.display = 'flex';
            var closeBtn = modal.querySelector('button[onclick*="closeMetricDefinition"]');
            if (closeBtn) closeBtn.focus(); else modal.setAttribute('tabindex', '-1');
        }
        
        function closeMetricDefinition() {
            const modal = document.getElementById('metricDefinitionModal');
            if (modal) {
                modal.style.display = 'none';
                var returnEl = modal._focusReturn;
                if (returnEl && typeof returnEl.focus === 'function') returnEl.focus();
            }
        }
        
        function populateFocusCategoryDropdown() {
            const sel = document.getElementById('analyticsFocusCategory');
            if (!sel) return;
            const evals = analyticsData.evaluations || [];
            const categories = new Set();
            evals.forEach(e => {
                let d = e.evaluation_data;
                if (typeof d === 'string') try { d = JSON.parse(d); } catch (e) { return; }
                if (d?.sections && typeof d.sections === 'object') {
                    Object.keys(d.sections).forEach(k => categories.add(k));
                    Object.values(d.sections).forEach(s => {
                        (s.subcategories || s.feedback || []).forEach(item => { if (item.name) categories.add(item.name); });
                    });
                }
            });
            sel.innerHTML = '<option value="">All categories</option>' + Array.from(categories).sort().map(c => `<option value="${escapeHtml(c)}">${escapeHtml(c)}</option>`).join('');
        }
        
        function applyInsightFilters() {
            filterAnalytics();
        }
        
        // Filter dropdown key -> select id and default label (order: institution, instructor, course; institution shown only for Super Admin)
        var FILTER_DROPDOWN_KEYS = [
            { key: 'institution', selectId: 'analyticsGlobalInstitution', allLabel: 'All institutions' },
            { key: 'instructor', selectId: 'analyticsGlobalInstructor', allLabel: 'All instructors' },
            { key: 'course', selectId: 'analyticsGlobalCourse', allLabel: 'All courses' }
        ];
        
        function updateFilterDropdownTrigger(filterKey) {
            var meta = FILTER_DROPDOWN_KEYS.find(function(m) { return m.key === filterKey; });
            if (!meta) return;
            var sel = document.getElementById(meta.selectId);
            var trigger = document.getElementById('filter-trigger-' + filterKey);
            if (!sel || !trigger) return;
            var selected = getMultiSelectValues(sel);
            var labels = [];
            for (var i = 0; i < sel.options.length; i++) {
                var opt = sel.options[i];
                if (opt.value && selected.indexOf(opt.value) !== -1) labels.push(opt.text);
            }
            if (labels.length === 0) {
                trigger.textContent = meta.allLabel;
            } else if (labels.length <= 3) {
                trigger.textContent = labels.join(', ');
            } else {
                trigger.textContent = labels.length + ' selected';
            }
            var panel = document.getElementById('filter-panel-' + filterKey);
            if (panel) {
                panel.querySelectorAll('.filter-dropdown-item').forEach(function(item) {
                    var val = item.getAttribute('data-value');
                    item.classList.toggle('selected', selected.indexOf(val) !== -1);
                });
            }
        }
        
        function buildFilterDropdownPanel(filterKey) {
            var meta = FILTER_DROPDOWN_KEYS.find(function(m) { return m.key === filterKey; });
            if (!meta) return;
            var sel = document.getElementById(meta.selectId);
            var panel = document.getElementById('filter-panel-' + filterKey);
            if (!sel || !panel) {
                console.warn('buildFilterDropdownPanel: missing elements for', filterKey, 'sel=', sel, 'panel=', panel);
                return;
            }
            var options = [];
            for (var i = 0; i < sel.options.length; i++) {
                var opt = sel.options[i];
                if (opt.value) options.push({ value: opt.value, text: opt.text });
            }
            console.log('buildFilterDropdownPanel(' + filterKey + '): ' + options.length + ' options from select (total options in select: ' + sel.options.length + ')');
            if (options.length === 0) {
                var label = filterKey === 'course' ? 'courses' : filterKey === 'institution' ? 'institutions' : 'instructors';
                panel.innerHTML = '<div style="padding: 0.75rem 1rem; color: var(--text-light); font-size: 0.875rem; min-height: 2.5rem;">No ' + label + ' loaded. Set date range and click Apply to load data.</div>';
            } else {
                panel.innerHTML = options.map(function(o) {
                    return '<div class="filter-dropdown-item" data-value="' + escapeHtml(o.value) + '" role="option" tabindex="0">' +
                        '<span class="filter-dropdown-check" aria-hidden="true"><i data-lucide="check"></i></span>' +
                        '<span>' + escapeHtml(o.text) + '</span></div>';
                }).join('');
            }
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: panel });
        }
        
        function initFilterDropdownBehavior() {
            if (window._filterDropdownBehaviorInited) return;
            window._filterDropdownBehaviorInited = true;
            document.addEventListener('click', function(e) {
                var open = document.querySelector('.filter-dropdown.open');
                if (open && !open.contains(e.target)) {
                    open.classList.remove('open');
                    var trigger = open.querySelector('.filter-dropdown-trigger');
                    if (trigger) trigger.setAttribute('aria-expanded', 'false');
                }
            });
            FILTER_DROPDOWN_KEYS.forEach(function(meta) {
                var key = meta.key;
                var wrapper = document.getElementById('filter-dropdown-' + key);
                var trigger = document.getElementById('filter-trigger-' + key);
                var panel = document.getElementById('filter-panel-' + key);
                if (!wrapper || !trigger || !panel) return;
                trigger.addEventListener('click', function(ev) {
                    ev.stopPropagation();
                    var isOpen = wrapper.classList.toggle('open');
                    console.log('Filter dropdown clicked:', key, 'isOpen=', isOpen, 'panel=', panel);
                    trigger.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
                    panel.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
                    if (isOpen) {
                        document.querySelectorAll('.filter-dropdown.open').forEach(function(d) {
                            if (d !== wrapper) {
                                d.classList.remove('open');
                                var t = d.querySelector('.filter-dropdown-trigger');
                                if (t) t.setAttribute('aria-expanded', 'false');
                            }
                        });
                    }
                });
                panel.addEventListener('click', function(ev) {
                    var item = ev.target.closest('.filter-dropdown-item');
                    if (!item) return;
                    ev.preventDefault();
                    var value = item.getAttribute('data-value');
                    var sel = document.getElementById(meta.selectId);
                    if (!sel) return;
                    var opt = Array.from(sel.options).find(function(o) { return o.value === value; });
                    if (opt) {
                        opt.selected = !opt.selected;
                        item.classList.toggle('selected', opt.selected);
                        updateFilterDropdownTrigger(key);
                        if (typeof applyGlobalFilters === 'function') applyGlobalFilters();
                    }
                });
            });
        }
        
        // Populate filter dropdowns (hidden selects + custom dropdown panels)
        function populateAnalyticsFilters() {
            // Populate instructors (ensure each has id for option value)
            const instFilter = document.getElementById('analyticsInstructorFilter');
            const globalInstructor = document.getElementById('analyticsGlobalInstructor');
            const instructorsList = (analyticsData.instructors || []).filter(function(inst) { return inst && (inst.id != null && inst.id !== ''); });
            const instructorOptions = instructorsList
                .map(inst => `<option value="${String(inst.id)}">${escapeHtml((inst.full_name || '').trim() || inst.email || 'Instructor')}</option>`).join('');
            if (instFilter) instFilter.innerHTML = '<option value="all">All Instructors</option>' + instructorOptions;
            if (globalInstructor) globalInstructor.innerHTML = '<option value="">All instructors</option>' + instructorOptions;
            
            // Populate courses (ensure each has id; handle joined object shape)
            const courseFilter = document.getElementById('analyticsCourseFilter');
            const globalCourse = document.getElementById('analyticsGlobalCourse');
            const coursesList = (analyticsData.courses || []).filter(function(c) { return c && (c.id != null && c.id !== ''); });
            const courseOptions = coursesList
                .map(c => `<option value="${String(c.id)}">${escapeHtml(c.name || '')}</option>`).join('');
            if (courseFilter) courseFilter.innerHTML = '<option value="all">All courses</option>' + courseOptions;
            if (globalCourse) globalCourse.innerHTML = '<option value="">All courses</option>' + courseOptions;
            
            // Populate institution dropdown (Super Admin: analyticsData.institutions set)
            const globalInstitution = document.getElementById('analyticsGlobalInstitution');
            const institutionsList = (analyticsData.institutions || []).filter(function(inst) { return inst && (inst.id != null && inst.id !== ''); });
            const institutionOptions = institutionsList
                .map(inst => `<option value="${String(inst.id)}">${escapeHtml(inst.name || '')}</option>`).join('');
            if (globalInstitution) globalInstitution.innerHTML = '<option value="">All institutions</option>' + institutionOptions;
            
            // Build custom dropdown panels and sync trigger text
            FILTER_DROPDOWN_KEYS.forEach(function(m) {
                buildFilterDropdownPanel(m.key);
                updateFilterDropdownTrigger(m.key);
            });
            initFilterDropdownBehavior();
        }
        
        // Apply global filters (concurrent multi-category filtering)
        function applyGlobalFilters() {
            updateActiveFiltersDisplay();
            filterAnalytics();
        }
        
        // Get selected values from multi-select
        function getMultiSelectValues(selectElement) {
            if (!selectElement) return [];
            const selected = Array.from(selectElement.selectedOptions)
                .map(opt => opt.value)
                .filter(val => val !== '');
            return selected;
        }
        
        // Clear one global filter by type and value (used by active-filter badge buttons; no closure serialization)
        function clearGlobalFilter(type, value) {
            const selectIds = {
                course: 'analyticsGlobalCourse',
                instructor: 'analyticsGlobalInstructor',
                institution: 'analyticsGlobalInstitution'
            };
            if (type === 'date') {
                var startEl = document.getElementById('analyticsStartDate');
                var endEl = document.getElementById('analyticsEndDate');
                if (startEl) startEl.value = '';
                if (endEl) endEl.value = '';
                if (typeof loadEnhancedAnalytics === 'function') loadEnhancedAnalytics(true); // Show toast on date reset
                return;
            }
            var id = selectIds[type];
            var sel = id ? document.getElementById(id) : null;
            if (!sel) return;
            var opt = Array.from(sel.options).find(function(o) { return o.value === value; });
            if (opt) opt.selected = false;
            if (typeof applyGlobalFilters === 'function') applyGlobalFilters();
        }
        
        // Called from badge button onclick; reads data-filter-* from parent span
        function clearGlobalFilterFromNode(btn) {
            var span = btn && btn.closest ? btn.closest('span[data-filter-type]') : null;
            if (!span) return;
            var type = span.getAttribute('data-filter-type');
            var value = span.getAttribute('data-filter-value') || '';
            clearGlobalFilter(type, value);
            if (typeof updateFilterDropdownTrigger === 'function') updateFilterDropdownTrigger(type);
            if (typeof updateActiveFiltersDisplay === 'function') updateActiveFiltersDisplay();
        }
        
        // Update active filters display with removable badges
        function updateActiveFiltersDisplay() {
            const display = document.getElementById('activeFiltersDisplay');
            if (!display) return;
            
            const filters = [];
            
            // Check each multi-select filter
            const courses = getMultiSelectValues(document.getElementById('analyticsGlobalCourse'));
            const instructors = getMultiSelectValues(document.getElementById('analyticsGlobalInstructor'));
            const institutions = getMultiSelectValues(document.getElementById('analyticsGlobalInstitution'));
            const startDate = document.getElementById('analyticsStartDate')?.value;
            const endDate = document.getElementById('analyticsEndDate')?.value;
            
            if (courses.length > 0) {
                const courseEl = document.getElementById('analyticsGlobalCourse');
                courses.forEach(crs => {
                    const option = Array.from(courseEl.options).find(opt => opt.value === crs);
                    if (option) filters.push({ type: 'course', value: crs, label: 'Course: ' + option.text });
                });
            }
            
            if (instructors.length > 0) {
                const instEl = document.getElementById('analyticsGlobalInstructor');
                instructors.forEach(inst => {
                    const option = Array.from(instEl.options).find(opt => opt.value === inst);
                    if (option) filters.push({ type: 'instructor', value: inst, label: 'Instructor: ' + option.text });
                });
            }
            
            if (institutions.length > 0) {
                const instEl = document.getElementById('analyticsGlobalInstitution');
                institutions.forEach(inst => {
                    const option = Array.from(instEl.options).find(opt => opt.value === inst);
                    if (option) filters.push({ type: 'institution', value: inst, label: 'Institution: ' + option.text });
                });
            }
            
            if (startDate || endDate) {
                const dateLabel = startDate && endDate ? `Date: ${startDate} to ${endDate}` : startDate ? `Date: from ${startDate}` : `Date: until ${endDate}`;
                filters.push({ type: 'date', value: '', label: dateLabel });
            }
            
            if (filters.length === 0) {
                display.style.display = 'none';
                return;
            }
            
            display.style.display = 'flex';
            display.innerHTML = '<span style="font-size: 0.75rem; font-weight: 600; color: var(--text-light); align-self: center;">Active filters:</span>' +
                filters.map(f => {
                    const typeAttr = escapeHtml(f.type);
                    const valueAttr = escapeHtml(f.value || '');
                    return `<span style="display: inline-flex; align-items: center; gap: 0.35rem; padding: 0.25rem 0.5rem; background: var(--primary); color: white; border-radius: 9999px; font-size: 0.75rem;" data-filter-type="${typeAttr}" data-filter-value="${valueAttr}">
                        ${escapeHtml(f.label)}
                        <button type="button" onclick="clearGlobalFilterFromNode(this)" style="background: none; border: none; color: white; cursor: pointer; padding: 0; width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; border-radius: 50%; font-weight: bold;" title="Remove filter">×</button>
                    </span>`;
                }).join('');
        }
        function setAnalyticsLastUpdated() {
            const el = document.getElementById('analyticsLastUpdated');
            if (el) el.textContent = 'Last updated: ' + (new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }));
        }
        
        function getOverallScorePct(eval) {
            let d = eval.evaluation_data;
            if (typeof d === 'string') try { d = JSON.parse(d); } catch (e) { return null; }
            if (!d?.sections || typeof d.sections !== 'object') return null;
            const pcts = [];
            Object.values(d.sections).forEach(section => {
                if (section.score != null && section.maxScore) pcts.push((parseFloat(section.score) / parseFloat(section.maxScore)) * 100);
                (section.subcategories || section.feedback || []).forEach(item => {
                    if (item.points != null && item.maxPoints) pcts.push((parseFloat(item.points) / parseFloat(item.maxPoints)) * 100);
                });
            });
            return pcts.length ? pcts.reduce((a, b) => a + b, 0) / pcts.length : null;
        }
        
        // Filter analytics data (concurrent multi-select filtering)
        function filterAnalytics() {
            // Get all multi-select filter values
            const courseIds = getMultiSelectValues(document.getElementById('analyticsGlobalCourse'));
            const instructorIds = getMultiSelectValues(document.getElementById('analyticsGlobalInstructor'));
            const institutionIds = getMultiSelectValues(document.getElementById('analyticsGlobalInstitution'));
            
            // Get single-select filters from Export tab
            const instSel = document.getElementById('analyticsInstructorFilter');
            const courseSel = document.getElementById('analyticsCourseFilter');
            const searchEl = document.getElementById('analyticsSearch');
            const scoreBandEl = document.getElementById('analyticsScoreBand');
            
            let filtered = analyticsData.evaluations || [];
            
            // Filter by institution (Super Admin: instructor's institution_id in selected set)
            if (institutionIds.length > 0 && analyticsData.instructors) {
                const instructorIdsInInstitutions = (analyticsData.instructors || [])
                    .filter(function(i) { return i.institution_id && institutionIds.indexOf(i.institution_id) !== -1; })
                    .map(function(i) { return i.id; });
                filtered = filtered.filter(function(e) { return instructorIdsInInstitutions.indexOf(e.instructor_id) !== -1; });
            }
            
            // Filter by course (multi-select OR logic)
            if (courseIds.length > 0) {
                filtered = filtered.filter(e => courseIds.includes(e.course_id));
            } else if (courseSel && courseSel.value !== 'all') {
                // Fallback to single-select from Export tab
                filtered = filtered.filter(e => e.course_id === courseSel.value);
            }
            
            // Filter by instructor (multi-select OR logic)
            if (instructorIds.length > 0) {
                filtered = filtered.filter(e => instructorIds.includes(e.instructor_id));
            } else if (instSel && instSel.value !== 'all') {
                // Fallback to single-select from Export tab
                filtered = filtered.filter(e => e.instructor_id === instSel.value);
            }
            
            // Filter by search term
            const searchTerm = (searchEl && searchEl.value || '').toLowerCase();
            if (searchTerm) {
                filtered = filtered.filter(e => {
                    const studentName = e.course_students ? `${e.course_students.first_name} ${e.course_students.last_name}`.toLowerCase() : '';
                    const courseName = e.courses?.name?.toLowerCase() || '';
                    return studentName.includes(searchTerm) || courseName.includes(searchTerm);
                });
            }
            
            // Filter by score band
            const scoreBand = scoreBandEl ? scoreBandEl.value : 'all';
            if (scoreBand !== 'all') {
                filtered = filtered.filter(e => {
                    const pct = getOverallScorePct(e);
                    if (pct == null) return scoreBand === 'all';
                    if (scoreBand === 'at-risk') return pct < 60;
                    if (scoreBand === 'strong') return pct >= 80;
                    return true;
                });
            }
            
            analyticsData.filtered = filtered;
            analyticsEvaluationsPage = 0;
            renderOverviewTab();
            renderComparisonsTab();
            renderEvaluationsTab();
            if (typeof renderExportPreview === 'function') renderExportPreview();
        }
        
        // Search evaluations (delegate to filterAnalytics so search + score band + filters stay in sync)
        function searchEvaluations() {
            filterAnalytics();
        }
        
        // Render Overview Tab (stats only; Department/All Institutions courses are in wrappers above)
        function renderOverviewTab() {
            const container = document.getElementById('overviewStatsContainer');
            if (!container) return;
            
            // Super Admin: platform-level analytics; stats derived from filtered data so filters apply
            const platform = analyticsData.superAdminPlatform;
            if (typeof isSuperAdmin === 'function' && isSuperAdmin() && platform) {
                const evals = analyticsData.filtered || [];
                const instIds = [...new Set(evals.map(e => e.instructor_id))];
                const instructorsList = (analyticsData.instructors || []).filter(i => instIds.includes(i.id));
                const institutionIds = [...new Set(instructorsList.map(i => i.institution_id).filter(Boolean))];
                const institutionsCountVal = institutionIds.length;
                const usersCountVal = instIds.length;
                const evaluationsCountVal = evals.length;
                const coursesCountVal = new Set(evals.map(e => e.course_id)).size;
                const byInstMap = {};
                evals.forEach(e => {
                    const inst = instructorsList.find(i => i.id === e.instructor_id);
                    const instId = inst?.institution_id;
                    if (!instId) return;
                    if (!byInstMap[instId]) byInstMap[instId] = { name: (analyticsData.institutions || []).find(inst => inst.id === instId)?.name || 'Unknown', evaluations: 0, courses: new Set() };
                    byInstMap[instId].evaluations++;
                    byInstMap[instId].courses.add(e.course_id);
                });
                const byInstitutionVal = Object.entries(byInstMap).map(([id, o]) => ({ id, name: o.name, evaluations: o.evaluations, courses: o.courses.size })).sort((a, b) => b.evaluations - a.evaluations);
                const consentPct = platform.consentTotal > 0 ? Math.round((platform.consentGiven / platform.consentTotal) * 100) : 0;
                function kpiCard(title, value, subtext, status) {
                    const statusClass = (status === 'Limited' || status === 'Insufficient N') ? (status === 'Insufficient N' ? 'insufficient' : 'limited') : 'ok';
                    return '<div class="kpi-card" style="display: flex; flex-direction: column; min-height: 120px;"><div class="kpi-title text-caption">' + escapeHtml(title) + '</div><div class="kpi-value">' + escapeHtml(String(value)) + '</div>' + (subtext ? '<div class="kpi-subtext">' + escapeHtml(subtext) + '</div>' : '') + '<div style="flex: 1;"></div><div class="kpi-meta" style="margin-top: auto;">' + (status ? '<span class="kpi-badge ' + statusClass + '">' + escapeHtml(status) + '</span>' : '') + '</div></div>';
                }
                function chartCard(title, subtitle, bodyContent) {
                    var idTitle = 'chart-title-evals-by-inst-' + Math.random().toString(36).slice(2, 8);
                    return '<div class="chart-card" role="figure" aria-labelledby="' + idTitle + '" aria-describedby="' + idTitle + '-desc"><div class="chart-title text-headline" id="' + idTitle + '">' + escapeHtml(title) + '</div>' + (subtitle ? '<div class="chart-subtitle" id="' + idTitle + '-desc">' + escapeHtml(subtitle) + '</div>' : '') + '<div class="chart-body" style="min-height: 180px;">' + (bodyContent || '') + '</div></div>';
                }
                let html = '<div class="dashboard-kpi-grid">';
                html += kpiCard('Institutions', institutionsCountVal, 'in filter', '');
                html += kpiCard('Users', usersCountVal, 'in filter', '');
                html += kpiCard('Courses', coursesCountVal, 'in filter', '');
                html += kpiCard('Evaluations', evaluationsCountVal, 'in filter', '');
                html += kpiCard('Consent rate', platform.consentTotal > 0 ? consentPct + '%' : '—', platform.consentTotal > 0 ? platform.consentGiven + ' of ' + platform.consentTotal + ' responses' : 'no consent data', '');
                html += '</div>';
                const tableBody = byInstitutionVal.length ? '<table class="data-table"><caption>Evaluation and course count per institution for current filters.</caption><thead><tr><th scope="col">Institution</th><th scope="col" class="num">Evaluations</th><th scope="col" class="num">Courses</th></tr></thead><tbody>' + byInstitutionVal.map(r => '<tr><td>' + escapeHtml(r.name) + '</td><td class="num">' + r.evaluations + '</td><td class="num">' + (r.courses || 0) + '</td></tr>').join('') + '</tbody></table>' : '<div class="empty-state" style="padding: 1.5rem 1rem;"><i data-lucide="building-2" class="empty-state-icon" aria-hidden="true"></i><p class="empty-state-title">No evaluation data by institution</p><p class="empty-state-desc">Use the filters above and click Apply, or load data from the Evaluations tab.</p></div>';
                html += '<div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">';
                html += chartCard('Evaluations by institution', 'Usage breakdown (respects filters above).', tableBody);
                html += '</div>';
                html += '<div style="background: var(--bg-alt); padding: 0.75rem 1rem; border-radius: 0.5rem; border-left: 4px solid var(--primary); margin-top: 1rem;"><p style="margin: 0; color: var(--text); font-size: 0.85rem;"><strong>Tip:</strong> Use Institution, Instructor, and Course filters above and click Apply to narrow results. Use <strong>Evaluations</strong> and <strong>Data Export</strong> tabs for detailed data.</p></div>';
                container.innerHTML = html;
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: container });
                return;
            }
            
            const evals = analyticsData.filtered;
            if (evals.length === 0) {
                const isFiltered = analyticsData.evaluations && analyticsData.evaluations.length > 0;
                container.innerHTML = isFiltered
                    ? '<div class="empty-state"><i data-lucide="search" class="empty-state-icon"></i><p class="empty-state-title">No evaluations match your filters</p><p class="empty-state-desc">Try broadening the date range or clearing filters above.</p></div>'
                    : '<div class="empty-state"><i data-lucide="bar-chart-2" class="empty-state-icon"></i><p class="empty-state-title">No evaluation data yet</p><p class="empty-state-desc">Set a date range in the filter bar above and click Apply to load analytics.</p><div class="empty-state-action"><button type="button" onclick="document.getElementById(\'analyticsGlobalApply\') && document.getElementById(\'analyticsGlobalApply\').click()" class="btn" style="background: var(--primary); color: white;">Apply</button></div></div>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: container });
                return;
            }
            
            const uniqueStudents = new Set(evals.map(e => e.student_id)).size;
            const uniqueCourses = new Set(evals.map(e => e.course_id)).size;
            const uniqueInstructorIds = new Set(evals.map(e => e.instructor_id));
            const isFiltered = analyticsData.filtered.length !== analyticsData.evaluations.length;
            const isAdminView = (typeof userTier !== 'undefined' && userTier === 'demo' && typeof demoViewAs !== 'undefined' && demoViewAs === 'admin') || (typeof isAdmin === 'function' && isAdmin() && typeof currentUser !== 'undefined' && currentUser && currentUser.department_id);
            
            const byInstructor = [];
            uniqueInstructorIds.forEach(instId => {
                const inst = analyticsData.instructors.find(i => i.id === instId);
                const count = evals.filter(e => e.instructor_id === instId).length;
                byInstructor.push({ name: inst?.full_name || inst?.email || 'Unknown', count });
            });
            byInstructor.sort((a, b) => b.count - a.count);
            
            const byMonth = {};
            evals.forEach(e => {
                const key = (e.created_at || '').slice(0, 7);
                if (key) byMonth[key] = (byMonth[key] || 0) + 1;
            });
            const volumeRows = Object.entries(byMonth).sort((a, b) => b[0].localeCompare(a[0])).slice(0, 12);
            
            let high = 0, medium = 0, low = 0;
            const pctList = [];
            evals.forEach(e => {
                const pct = getOverallScorePct(e);
                if (pct != null) { pctList.push(pct); if (pct >= 80) high++; else if (pct >= 60) medium++; else low++; }
            });
            const totalScored = high + medium + low;
            const outcomeAttainmentPct = totalScored ? Math.round(((high + medium) / totalScored) * 100) : 0;
            const avgPct = pctList.length ? (pctList.reduce((a, b) => a + b, 0) / pctList.length).toFixed(1) : '—';
            
            const categoryAvgs = {};
            evals.forEach(e => {
                let d = e.evaluation_data;
                if (typeof d === 'string') try { d = JSON.parse(d); } catch (err) { return; }
                if (!d?.sections || typeof d.sections !== 'object') return;
                var seenThisEval = {}; // at most one score per dimension per evaluation
                Object.entries(d.sections).forEach(([name, section]) => {
                    if (!categoryAvgs[name]) categoryAvgs[name] = [];
                    if (!seenThisEval[name] && section.score != null && section.maxScore) {
                        categoryAvgs[name].push((parseFloat(section.score) / parseFloat(section.maxScore)) * 100);
                        seenThisEval[name] = true;
                    }
                    (section.subcategories || section.feedback || []).forEach(item => {
                        if (item.name && item.points != null && item.maxPoints) {
                            if (!seenThisEval[item.name]) {
                                if (!categoryAvgs[item.name]) categoryAvgs[item.name] = [];
                                categoryAvgs[item.name].push((parseFloat(item.points) / parseFloat(item.maxPoints)) * 100);
                                seenThisEval[item.name] = true;
                            }
                        }
                    });
                });
            });
            const focusAreasAll = Object.entries(categoryAvgs)
                .map(([name, arr]) => ({ name, avg: arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : 0 }))
                .filter(c => c.avg > 0)
                .sort((a, b) => a.avg - b.avg);
            const focusAreas = focusAreasAll.slice(0, 3);
            const topOpportunity = focusAreas[0];
            const topStrength = focusAreasAll.length ? focusAreasAll[focusAreasAll.length - 1] : null;
            
            function kpiCard(title, value, subtext, delta, status) {
                const statusClass = status === 'Limited' ? 'limited' : status === 'Insufficient N' ? 'insufficient' : 'ok';
                const titleSlug = title.toLowerCase().replace(/[^a-z0-9]+/g, '-');
                return `<div class="kpi-card" style="display: flex; flex-direction: column; min-height: 120px;">
                    <div class="kpi-title text-caption" style="cursor: pointer; text-decoration: underline; text-decoration-style: dotted;" onclick="showMetricDefinition('${titleSlug}', '${escapeHtml(title).replace(/'/g, '\\\'')}')" title="Click for definition">${escapeHtml(title)}</div>
                    <div class="kpi-value">${escapeHtml(String(value))}</div>
                    ${subtext ? `<div class="kpi-subtext">${escapeHtml(subtext)}</div>` : ''}
                    <div style="flex: 1;"></div>
                    <div class="kpi-meta" style="margin-top: auto;">${status ? `<span class="kpi-badge ${statusClass}">${escapeHtml(status)}</span>` : ''}${delta ? `<span>${escapeHtml(delta)}</span>` : ''}</div>
                </div>`;
            }
            function chartCard(title, subtitle, height, bodyContent, description) {
                var h = height || 180;
                var body = bodyContent != null ? '<div class="chart-body" style="min-height:' + h + 'px;">' + bodyContent + '</div>' : '<div class="chart-body" style="min-height:' + h + 'px;"></div>';
                const titleSlug = title.toLowerCase().replace(/[^a-z0-9]+/g, '-');
                var idTitle = 'chart-title-' + titleSlug.replace(/-/g, '') + '-' + Math.random().toString(36).slice(2, 8);
                var idDesc = description ? 'chart-desc-' + titleSlug.replace(/-/g, '') + '-' + Math.random().toString(36).slice(2, 8) : '';
                var descBlock = description ? '<p class="chart-description" id="' + idDesc + '">' + escapeHtml(description) + '</p>' : '';
                var ariaAttrs = ' role="figure" aria-labelledby="' + idTitle + '"' + (idDesc ? ' aria-describedby="' + idDesc + '"' : '');
                return '<div class="chart-card"' + ariaAttrs + '><div class="chart-title text-headline" id="' + idTitle + '" style="cursor: pointer; text-decoration: underline; text-decoration-style: dotted;" onclick="showMetricDefinition(\'' + titleSlug + '\', \'' + escapeHtml(title).replace(/'/g, '\\\'') + '\')" title="Click for definition">' + escapeHtml(title) + '</div>' + (subtitle ? '<div class="chart-subtitle">' + escapeHtml(subtitle) + '</div>' : '') + descBlock + body + '</div>';
            }
            
            // Per-outcome % meeting threshold (60%): for each dimension, share of evaluations where that dimension's score >= 60%
            // categoryAvgs has at most one score per eval per dimension, so meeting/evals.length is in [0,1]
            var outcomeByCategory = focusAreasAll.map(function(c) {
                var arr = categoryAvgs[c.name];
                if (!arr || !arr.length) return { name: c.name, pct: 0 };
                var meeting = arr.filter(function(p) { return p >= 60; }).length;
                var pct = evals.length ? Math.round((meeting / evals.length) * 100) : 0;
                return { name: c.name, pct: pct };
            }).sort(function(a, b) { return b.pct - a.pct; });
            var courseStats = {};
            evals.forEach(function(e) {
                var cid = e.course_id; var name = (e.courses && e.courses.name) || 'Unknown';
                if (!courseStats[cid]) courseStats[cid] = { name: name, pcts: [] };
                var p = getOverallScorePct(e); if (p != null) courseStats[cid].pcts.push(p);
            });
            var courseRows = Object.keys(courseStats).map(function(cid) {
                var c = courseStats[cid]; var avg = c.pcts.length ? (c.pcts.reduce(function(a, b) { return a + b; }, 0) / c.pcts.length).toFixed(1) : '—';
                return { name: c.name, avg: avg, n: c.pcts.length };
            }).sort(function(a, b) { return parseFloat(b.avg) - parseFloat(a.avg); });
            // Section variability: mean and SD per dimension (hover/title for N)
            function stdDev(arr) {
                if (!arr || arr.length < 2) return 0;
                var mean = arr.reduce(function(a, b) { return a + b; }, 0) / arr.length;
                var sq = arr.reduce(function(s, x) { return s + (x - mean) * (x - mean); }, 0);
                return Math.sqrt(sq / (arr.length - 1));
            }
            var sectionVariabilityRows = focusAreasAll.map(function(c) {
                var arr = categoryAvgs[c.name] || [];
                var sd = arr.length ? stdDev(arr).toFixed(1) : '—';
                return { name: c.name, mean: c.avg.toFixed(1), sd: sd, n: arr.length };
            });
            // Modality: aggregate by course modality (in-person / online / hybrid)
            var byModality = {};
            evals.forEach(function(e) {
                var mod = (e.courses && e.courses.modality) ? e.courses.modality : 'unknown';
                if (!byModality[mod]) byModality[mod] = { n: 0, pcts: [] };
                byModality[mod].n++;
                var p = getOverallScorePct(e); if (p != null) byModality[mod].pcts.push(p);
            });
            var modalityRows = Object.keys(byModality).map(function(mod) {
                var o = byModality[mod];
                var avg = o.pcts.length ? (o.pcts.reduce(function(a, b) { return a + b; }, 0) / o.pcts.length).toFixed(1) : '—';
                return { modality: mod, n: o.n, avg: avg };
            }).sort(function(a, b) { return b.n - a.n; });
            function barRow(label, pct, icon) {
                var w = Math.min(100, Math.max(0, pct));
                var level = w >= 80 ? 'high' : w >= 60 ? 'medium' : 'low';
                var ariaLabel = escapeHtml(label) + ': ' + pct + ' percent (' + level + ')';
                var iconHtml = icon ? '<i data-lucide="' + icon + '" style="width:16px;height:16px;color:var(--text-light);margin-right:8px;"></i>' : '';
                return '<div class="chart-bar-row"><div role="img" aria-label="' + ariaLabel + '"><div class="chart-bar-label-row"><span class="chart-bar-label" style="display:flex;align-items:center;">' + iconHtml + escapeHtml(label) + '</span><span class="chart-bar-value">' + pct + '%</span></div><div class="chart-bar-track"><div class="chart-bar-fill data-' + level + '" style="width:' + w + '%;" title="' + pct + '%"></div></div></div></div>';
            }
            var outcomeIcons = { 'Content': 'file-text', 'Delivery': 'mic', 'Organization': 'list', 'Eye contact': 'eye', 'Body language': 'user', 'Vocal delivery': 'volume-2' };
            var outcomeBody = outcomeByCategory.length ? '<div class="chart-bars">' + outcomeByCategory.map(function(r) { 
                var icon = outcomeIcons[r.name] || 'circle';
                return barRow(r.name, r.pct, icon);
            }).join('') + '</div>' : '<p style="color:var(--text-light);padding:1rem;">No category data.</p>';
            var suppressN = 5;
            var modalityBody = modalityRows.length ? '<div class="chart-bars">' + modalityRows.map(function(r) {
                var show = r.n >= suppressN;
                var pctVal = (typeof r.avg === 'string' && r.avg !== '—') ? parseFloat(r.avg) : (typeof r.avg === 'number' ? r.avg : null);
                var pctNum = (pctVal != null && !isNaN(pctVal)) ? Math.round(pctVal) : 0;
                return show ? barRow(r.modality.charAt(0).toUpperCase() + r.modality.slice(1) + ' (n=' + r.n + ')', pctNum) : '<div class="chart-bar-row" style="font-size:0.875rem;color:var(--text-light);">' + escapeHtml(r.modality.charAt(0).toUpperCase() + r.modality.slice(1)) + ': <em>Suppressed (n&lt;' + suppressN + ')</em></div>';
            }).join('') + '</div>' : '<p style="color:var(--text-light);padding:1rem;">Add course modality to see comparison. Use Data Export to load data.</p>';
            var courseBody = courseRows.length ? '<table class="data-table"><caption>Average score and evaluation count per course</caption><thead><tr><th scope="col">Course</th><th scope="col" class="num">N</th><th scope="col" class="num">Avg %</th></tr></thead><tbody>' + courseRows.map(function(r) { return '<tr><td>' + escapeHtml(r.name) + '</td><td class="num">' + r.n + '</td><td class="num">' + r.avg + '%</td></tr>'; }).join('') + '</tbody></table>' : '<p style="color:var(--text-light);padding:1rem;">No course data.</p>';
            var sectionBody = sectionVariabilityRows.length ? '<table class="data-table"><caption>Mean percentage and standard deviation by rubric dimension</caption><thead><tr><th scope="col">Dimension</th><th scope="col" class="num">Mean %</th><th scope="col" class="num">SD</th><th scope="col" class="num">N</th></tr></thead><tbody>' + sectionVariabilityRows.map(function(r) { return '<tr title="N=' + r.n + '"><td>' + escapeHtml(r.name) + '</td><td class="num">' + r.mean + '%</td><td class="num">' + r.sd + '</td><td class="num">' + r.n + '</td></tr>'; }).join('') + '</tbody></table>' : '<p style="color:var(--text-light);padding:1rem;">No section data.</p>';
            var accreditationBody = '<p style="font-size:0.875rem;margin-bottom:0.75rem;">' + (totalScored ? outcomeAttainmentPct + '% of evaluations met threshold (≥60%) across selected courses/terms.' : 'No outcome data yet.') + '</p><p style="font-size:0.8rem;color:var(--text-light);">Export outcomes report with definitions appendix from the <strong>Data Export</strong> tab (CSV).</p>';
            var modalityReportBody = modalityRows.length ? '<table class="data-table"><caption>Average score and count by delivery modality (n &lt; ' + suppressN + ' suppressed)</caption><thead><tr><th scope="col">Modality</th><th scope="col" class="num">N</th><th scope="col" class="num">Avg %</th></tr></thead><tbody>' + modalityRows.filter(function(r) { return r.n >= suppressN; }).map(function(r) { return '<tr><td>' + escapeHtml(r.modality.charAt(0).toUpperCase() + r.modality.slice(1)) + '</td><td class="num">' + r.n + '</td><td class="num">' + r.avg + '%</td></tr>'; }).join('') + '</tbody></table>' + (modalityRows.some(function(r) { return r.n < suppressN; }) ? '<p style="font-size:0.75rem;color:var(--text-light);margin-top:0.5rem;">Cells with n&lt;' + suppressN + ' suppressed.</p>' : '') : '<p style="font-size:0.875rem;color:var(--text-light);">Add course modality to compare online vs in-person. Suppression applied for n&lt;' + suppressN + '.</p>';
            var normingBody = '<p style="font-size:0.875rem;margin-bottom:0.5rem;">Calibration: <strong>Stable</strong>. No drift detected in the selected period.</p><p style="font-size:0.8rem;color:var(--text-light);">Use for rater alignment only; not for punitive ranking.</p>';
            
            let html = '';
            
            if (isAdminView) {
                var blocks = {};
                blocks['kpi-row'] = kpiCard('Outcome Attainment', totalScored ? outcomeAttainmentPct + '%' : '—', 'meeting threshold', '', totalScored ? 'OK' : 'Insufficient N') + kpiCard('Across-section Variability', byInstructor.length > 1 ? '—' : '—', '', '', 'OK') + kpiCard('Modality Gap', '—', 'online vs in-person', '', 'Limited') + kpiCard('Calibration Signals', 'Stable', 'alignment indicator', '', 'OK') + kpiCard('Total Evaluations', evals.length, '') + kpiCard('Access / Quality Flags', '—', '', '', 'Limited');
                blocks['chart-outcome'] = chartCard('Outcome attainment by outcome', '% meeting threshold across selected courses/terms.', 260, outcomeBody, 'Share of evaluations that met the 60% threshold for each rubric dimension.');
                blocks['chart-modality'] = chartCard('Modality comparison', 'Distribution comparison by modality (suppressed below thresholds).', 260, modalityBody, 'Average score by delivery mode (in-person, online, hybrid).');
                blocks['chart-course'] = chartCard('Course comparisons', 'OPI distributions across course types.', 260, courseBody, 'Average score and count per course for the selected filters.');
                blocks['chart-section'] = chartCard('Section variability map', 'Sections × rubric dimensions (mean; hover for N/SD).', 260, sectionBody, 'Mean and standard deviation per rubric dimension; hover for sample size.');
                blocks['chart-accreditation'] = chartCard('Accreditation-ready summary', 'Export outcomes report with definitions appendix.', 150, accreditationBody, 'Outcome attainment rate and link to export a full report.');
                blocks['chart-modality-report'] = chartCard('Modality report', 'Compare online vs in-person patterns with suppression thresholds.', 150, modalityReportBody, 'Table of average score and N by modality; small N suppressed.');
                blocks['chart-norming'] = chartCard('Norming summary', 'Calibration signals and drift checks (carefully framed).', 150, normingBody, 'Rater alignment indicator for the selected period.');
                var overviewWidgets = (typeof getOverviewWidgets === 'function' ? getOverviewWidgets() : []).filter(function(w) { return w.visible !== false; }).sort(function(a, b) { return (a.order || 0) - (b.order || 0); });
                if (!overviewWidgets.length) overviewWidgets = DEFAULT_OVERVIEW_WIDGETS.filter(function(w) { return w.visible !== false; }).sort(function(a, b) { return a.order - b.order; });
                var kpiDone = false;
                var chartParts = [];
                overviewWidgets.forEach(function(w) {
                    if (w.id === 'kpi-row' && blocks['kpi-row']) { html += '<div class="dashboard-kpi-grid">' + blocks['kpi-row'] + '</div>'; kpiDone = true; }
                    else if (blocks[w.id]) chartParts.push(blocks[w.id]);
                    else if (w.custom === true || String(w.id).indexOf('custom_') === 0) chartParts.push(chartCard(w.label || 'Custom section', (w.dataQuery ? 'Data: ' + w.dataQuery : 'Set data query in Edit cards (e.g. by course, by instructor).'), 200, typeof renderCustomCardBody === 'function' ? renderCustomCardBody(w, evals) : '<p style="color:var(--text-light);padding:1rem;">Use Edit cards to set a data query.</p>'));
                });
                if (chartParts.length) html += '<div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">' + chartParts.join('') + '</div>';
            } else {
                // Instructor: enhanced with engaging charts
                html += '<div class="dashboard-kpi-grid">';
                html += kpiCard('Overall Performance', avgPct !== '—' ? avgPct + '%' : '—', 'avg score', '', totalScored ? 'OK' : 'Insufficient N');
                html += kpiCard('Top Strength', topStrength ? escapeHtml(topStrength.name) : '—', '', '', 'OK');
                html += kpiCard('Top Opportunity', topOpportunity ? escapeHtml(topOpportunity.name) : '—', '', '', 'Limited');
                html += kpiCard('Total Evaluations', evals.length, '');
                html += '</div>';
                
                // Enhanced OPI Distribution with histogram
                var scoreBins = { '0-20': 0, '21-40': 0, '41-60': 0, '61-80': 0, '81-100': 0 };
                pctList.forEach(function(pct) {
                    if (pct <= 20) scoreBins['0-20']++;
                    else if (pct <= 40) scoreBins['21-40']++;
                    else if (pct <= 60) scoreBins['41-60']++;
                    else if (pct <= 80) scoreBins['61-80']++;
                    else scoreBins['81-100']++;
                });
                var maxBin = Math.max(...Object.values(scoreBins));
                var histogramHtml = '<div class="chart-histogram" role="img" aria-label="Score distribution histogram">';
                var histogramDataTable = '<table class="sr-only" id="histogram-data-table"><caption>Score distribution data</caption><thead><tr><th scope="col">Score Range</th><th scope="col">Count</th></tr></thead><tbody>';
                Object.entries(scoreBins).forEach(function([range, count]) {
                    var height = maxBin > 0 ? Math.max(4, (count / maxBin) * 100) : 4;
                    var ariaLabel = 'Score range ' + range + ': ' + count + ' evaluation' + (count !== 1 ? 's' : '');
                    histogramHtml += '<div class="chart-histogram-bar" style="height: ' + height + '%;" role="img" aria-label="' + escapeHtml(ariaLabel) + '" tabindex="0" title="' + range + ': ' + count + ' evaluations" onkeydown="if(event.key===\'Enter\'||event.key===\' \'){event.preventDefault();this.click();}"><span class="chart-histogram-label">' + range + '</span></div>';
                    histogramDataTable += '<tr><td>' + escapeHtml(range) + '</td><td>' + count + '</td></tr>';
                });
                histogramDataTable += '</tbody></table>';
                histogramHtml += '</div>' + histogramDataTable;
                
                // Performance trend over time (line chart)
                var trendData = [];
                var byMonthTrend = {};
                evals.forEach(function(e) {
                    var key = (e.created_at || '').slice(0, 7);
                    if (!key) return;
                    if (!byMonthTrend[key]) byMonthTrend[key] = { count: 0, total: 0 };
                    var pct = getOverallScorePct(e);
                    if (pct != null) {
                        byMonthTrend[key].count++;
                        byMonthTrend[key].total += pct;
                    }
                });
                var sortedMonths = Object.keys(byMonthTrend).sort();
                sortedMonths.forEach(function(month) {
                    var data = byMonthTrend[month];
                    var avg = data.count > 0 ? (data.total / data.count).toFixed(1) : 0;
                    trendData.push({ month: month, avg: parseFloat(avg), count: data.count });
                });
                
                var trendChartHtml = '';
                if (trendData.length > 0) {
                    var maxTrend = Math.max(...trendData.map(d => d.avg), 100);
                    var minTrend = Math.min(...trendData.map(d => d.avg), 0);
                    var range = maxTrend - minTrend || 100;
                    var points = trendData.map(function(d, i) {
                        var x = (i / (trendData.length - 1 || 1)) * 100;
                        var y = 100 - ((d.avg - minTrend) / range) * 100;
                        return x + ',' + y;
                    }).join(' ');
                    var areaPoints = '0,100 ' + points + ' 100,100';
                    var trendId = 'trend-chart-' + Math.random().toString(36).slice(2, 8);
                    var trendDataTableId = trendId + '-data';
                    var trendDataTable = '<table class="sr-only" id="' + trendDataTableId + '"><caption>Performance trend data</caption><thead><tr><th scope="col">Month</th><th scope="col">Average %</th><th scope="col">Count</th></tr></thead><tbody>' + trendData.map(function(d) {
                        return '<tr><td>' + escapeHtml(d.month) + '</td><td>' + d.avg.toFixed(1) + '%</td><td>' + d.count + '</td></tr>';
                    }).join('') + '</tbody></table>';
                    trendChartHtml = '<div class="chart-line-container"><svg class="chart-line-svg" viewBox="0 0 100 100" preserveAspectRatio="none" role="img" aria-label="Performance trend line chart" aria-describedby="' + trendDataTableId + '"><defs><linearGradient id="trendGradient' + trendId + '" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" style="stop-color:var(--primary);stop-opacity:0.3" /><stop offset="100%" style="stop-color:var(--primary);stop-opacity:0.05" /></linearGradient></defs><polyline points="' + points + '" class="chart-line-path primary" fill="none" aria-label="Average score trend line" /><polygon points="' + areaPoints + '" class="chart-line-area" fill="url(#trendGradient' + trendId + ')" aria-hidden="true" />' + trendData.map(function(d, i) {
                        var x = (i / (trendData.length - 1 || 1)) * 100;
                        var y = 100 - ((d.avg - minTrend) / range) * 100;
                        var ariaLabel = 'Month ' + d.month + ': ' + d.avg.toFixed(1) + ' percent average, ' + d.count + ' evaluation' + (d.count !== 1 ? 's' : '');
                        return '<circle cx="' + x + '" cy="' + y + '" class="chart-line-dot" role="button" aria-label="' + escapeHtml(ariaLabel) + '" tabindex="0" title="' + d.month + ': ' + d.avg.toFixed(1) + '% (n=' + d.count + ')" onkeydown="if(event.key===\'Enter\'||event.key===\' \'){event.preventDefault();showChartPointDetails(this);}" />';
                    }).join('') + '</svg><div style="display: flex; justify-content: space-between; margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-light);"><span>' + (trendData[0]?.month || '') + '</span><span>' + (trendData[trendData.length - 1]?.month || '') + '</span></div></div>' + trendDataTable;
                } else {
                    trendChartHtml = '<p style="color:var(--text-light);padding:1rem;text-align:center;">No trend data available. Add evaluations with dates to see performance over time.</p>';
                }
                
                // Outcome distribution donut chart - showing overall attainment
                var outcomeDonutHtml = '';
                if (totalScored > 0) {
                    var circumference = 2 * Math.PI * 40; // radius 40
                    var attainmentPct = outcomeAttainmentPct;
                    var notAttainingPct = 100 - attainmentPct;
                    var attainmentArc = (attainmentPct / 100) * circumference;
                    var notAttainingArc = (notAttainingPct / 100) * circumference;
                    var donutId = 'donut-chart-' + Math.random().toString(36).slice(2, 8);
                    var donutDataTableId = donutId + '-data';
                    var donutDataTable = '<table class="sr-only" id="' + donutDataTableId + '"><caption>Outcome attainment data</caption><thead><tr><th scope="col">Status</th><th scope="col">Percentage</th><th scope="col">Count</th></tr></thead><tbody><tr><td>Meeting threshold (≥60%)</td><td>' + attainmentPct + '%</td><td>' + (high + medium) + '</td></tr><tr><td>Below threshold</td><td>' + notAttainingPct + '%</td><td>' + low + '</td></tr></tbody></table>';
                    var ariaLabel = attainmentPct + ' percent of evaluations meeting the 60 percent threshold';
                    outcomeDonutHtml = '<div class="chart-donut-container" style="position: relative;"><svg class="chart-donut-svg" viewBox="0 0 100 100" role="img" aria-label="' + escapeHtml(ariaLabel) + '" aria-describedby="' + donutDataTableId + '"><g><circle cx="50" cy="50" r="40" fill="none" stroke="#e5e7eb" stroke-width="8" aria-hidden="true" /><circle cx="50" cy="50" r="40" fill="none" stroke="#10b981" stroke-width="8" stroke-dasharray="' + attainmentArc + ' ' + circumference + '" stroke-dashoffset="0" class="chart-donut-segment" role="button" aria-label="' + escapeHtml(attainmentPct + ' percent meeting threshold, ' + (high + medium) + ' evaluations') + '" tabindex="0" title="' + attainmentPct + '% meeting threshold" onkeydown="if(event.key===\'Enter\'||event.key===\' \'){event.preventDefault();showChartSegmentDetails(this);}" /></g></svg><div class="chart-donut-hit-area" style="top: 50%; left: 50%; transform: translate(-50%, -50%);" aria-hidden="true" onclick="document.querySelector(\'.chart-donut-segment\')?.focus()"></div><div class="chart-donut-center"><div class="chart-donut-center-value">' + attainmentPct + '%</div><div class="chart-donut-center-label">Meeting<br>Threshold</div></div></div>' + donutDataTable;
                } else {
                    outcomeDonutHtml = '<p style="color:var(--text-light);padding:1rem;text-align:center;">No outcome data available.</p>';
                }
                
                html += '<div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">';
                html += chartCard('OPI Distribution', 'Score distribution across all evaluations.', 280, histogramHtml, 'Histogram showing the distribution of overall performance scores.');
                html += chartCard('Performance Trend', 'Average score over time by month.', 280, trendChartHtml, 'Line chart showing performance trends across the selected date range.');
                html += chartCard('Outcome Attainment', 'Percentage meeting 60% threshold by dimension.', 280, outcomeDonutHtml, 'Donut chart showing the proportion of evaluations meeting the threshold across different rubric dimensions.');
                html += '<div class="chart-card" role="figure" aria-labelledby="chart-title-targeted-feedback"><div class="chart-title text-headline" id="chart-title-targeted-feedback">Students Needing Targeted Feedback</div><div class="chart-subtitle">View student timeline or evidence from Evaluations.</div><p class="chart-description">Open the Evaluations tab to find and review individual students.</p><div style="padding:0.5rem 0;"><a href="#" onclick="switchAnalyticsTab(\'evaluations\'); return false;" class="btn" style="background: var(--primary); color: white; font-size: 0.875rem;">View Evaluations</a></div><div class="chart-footer"><a href="#" onclick="return false;">Definitions &amp; limitations</a></div></div>';
                html += '</div>';
            }
            html += '<div style="background: var(--bg-alt); padding: 0.75rem 1rem; border-radius: 0.5rem; border-left: 4px solid var(--primary); margin-top: 1rem;"><p style="margin: 0; color: var(--text); font-size: 0.85rem;"><strong>Tip:</strong> Set date range above and click <strong>Apply</strong> to refresh. Use <strong>Evaluations</strong> to search and open records; <strong>Data Export</strong> to export CSV. Chart and table data are labeled for screen readers; click metric titles for definitions.</p></div>';
            
            container.innerHTML = html;
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons({ root: container });
            }
        }
        
        // Render Rubrics Tab - Rubric dropdown + structure + category analysis
        async function renderRubricsTab() {
            const container = document.getElementById('analyticsRubricsTab');
            if (!container) return;
            
            const savedSelection = document.getElementById('analyticsRubricSelect')?.value || '';
            const allRubrics = typeof getAllRubrics === 'function' ? await getAllRubrics() : [];
            const evalsAll = analyticsData.filtered || [];
            
            const rubricOptions = allRubrics.length ? allRubrics.map(r => `<option value="${escapeHtml(String(r.id))}">${escapeHtml(r.name || 'Unnamed')}</option>`).join('') : '';
            const dropdownHtml = `
                <div class="card" style="margin-bottom: 1.5rem;">
                    <div class="card-header" style="margin-bottom: 0;">Select rubric</div>
                    <div style="padding: 1rem;">
                        <label for="analyticsRubricSelect" style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Rubric</label>
                        <select id="analyticsRubricSelect" onchange="renderRubricsTab()" style="padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; font-size: 0.9rem; min-width: 14rem;">
                            <option value="">All rubrics (combined)</option>
                            ${rubricOptions}
                        </select>
                        <p style="margin-top: 0.5rem; font-size: 0.85rem; color: var(--text-light);">View the rubric structure and performance analysis for the selected rubric.</p>
                    </div>
                </div>`;
            
            if (evalsAll.length === 0) {
                container.innerHTML = dropdownHtml + `
                    <div class="empty-state" style="max-width: 28rem;">
                        <i data-lucide="clipboard-list" class="empty-state-icon" aria-hidden="true"></i>
                        <p class="empty-state-title">No evaluation data</p>
                        <p class="empty-state-desc">Load analytics to see rubric structure and performance.</p>
                        <div class="empty-state-action">
                            <button type="button" onclick="switchAnalyticsTab('evaluations')" class="btn" style="background: var(--primary); color: white;">Load data</button>
                        </div>
                    </div>`;
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: container });
                const sel = document.getElementById('analyticsRubricSelect');
                if (sel && savedSelection) sel.value = savedSelection;
                return;
            }
            
            const selectedRubricId = savedSelection || document.getElementById('analyticsRubricSelect')?.value || '';
            const evals = selectedRubricId ? evalsAll.filter(e => (e.rubric_id || e.rubric?.id) == selectedRubricId) : evalsAll;
            const selectedRubric = selectedRubricId && typeof getRubricById === 'function' ? await getRubricById(selectedRubricId) : null;
            
            let structureHtml = '';
            if (selectedRubric && selectedRubric.categories && selectedRubric.categories.length) {
                structureHtml = `
                <div class="card" style="margin-bottom: 1.5rem;">
                    <div class="card-header" style="margin-bottom: 0;">Rubric structure — ${escapeHtml(selectedRubric.name || 'Unnamed')}</div>
                    <div style="padding: 1rem;">
                        <p style="color: var(--text-light); font-size: 0.9rem; margin-bottom: 1rem;">${selectedRubric.totalPoints || 0} points total${selectedRubric.speechType ? ' • ' + escapeHtml(selectedRubric.speechType) : ''}</p>
                        <ul style="margin: 0; padding-left: 1.25rem;">
                            ${(selectedRubric.categories || []).map(cat => {
                                const c = typeof cat === 'object' && cat !== null ? cat : { name: String(cat), subcategories: [] };
                                const subs = (c.subcategories || c.feedback || []).map(s => typeof s === 'object' && s !== null ? `<li style="margin-left: 1rem; font-size: 0.9rem;">${escapeHtml(s.name || '')} ${s.maxPoints != null ? `(${s.points != null ? s.points : 0}/${s.maxPoints})` : ''}</li>` : '').join('');
                                return `<li style="margin-bottom: 0.35rem;"><strong>${escapeHtml(c.name || '')}</strong>${c.maxScore != null ? ` — ${c.score != null ? c.score : 0}/${c.maxScore} pts` : ''}${subs ? `<ul style="margin: 0.25rem 0 0 0;">${subs}</ul>` : ''}</li>`;
                            }).join('')}
                        </ul>
                    </div>
                </div>`;
            } else if (selectedRubricId && !selectedRubric) {
                structureHtml = '<p style="color: var(--text-light); font-size: 0.9rem; margin-bottom: 1rem;">Rubric structure not found for selected rubric.</p>';
            }
            
            const categoryStats = {};
            evals.forEach(eval => {
                let evalData = eval.evaluation_data;
                if (typeof evalData === 'string') { try { evalData = JSON.parse(evalData); } catch (e) { return; } }
                if (!evalData || !evalData.sections || typeof evalData.sections !== 'object') return;
                Object.entries(evalData.sections).forEach(([sectionName, section]) => {
                    if (!categoryStats[sectionName]) categoryStats[sectionName] = { name: sectionName, percentages: [], total: 0, count: 0 };
                    if (section.score != null && section.maxScore) {
                        const pct = (parseFloat(section.score) / parseFloat(section.maxScore)) * 100;
                        categoryStats[sectionName].percentages.push(pct);
                        categoryStats[sectionName].total += pct;
                        categoryStats[sectionName].count++;
                    }
                    (section.subcategories || section.feedback || []).forEach(item => {
                        if (!item || !item.name) return;
                        if (!categoryStats[item.name]) categoryStats[item.name] = { name: item.name, percentages: [], total: 0, count: 0 };
                        if (item.points != null && item.maxPoints) {
                            const pct = (parseFloat(item.points) / parseFloat(item.maxPoints)) * 100;
                            categoryStats[item.name].percentages.push(pct);
                            categoryStats[item.name].total += pct;
                            categoryStats[item.name].count++;
                        }
                    });
                });
            });
            
            let categories = Object.values(categoryStats).map(cat => ({
                ...cat,
                average: cat.count > 0 ? (cat.total / cat.count).toFixed(1) : 0,
                min: cat.percentages.length ? Math.min(...cat.percentages).toFixed(1) : 0,
                max: cat.percentages.length ? Math.max(...cat.percentages).toFixed(1) : 0
            })).sort((a, b) => parseFloat(b.average) - parseFloat(a.average));
            const focusCat = document.getElementById('analyticsFocusCategory')?.value;
            if (focusCat) categories = categories.filter(c => c.name === focusCat);
            
            let tableHtml = '';
            if (categories.length) {
                tableHtml = `
                <div class="card" style="margin-bottom: 1.5rem;">
                    <div class="card-header">Performance analysis${selectedRubricId ? ' — ' + escapeHtml(selectedRubric?.name || 'Selected rubric') : ' (all rubrics)'}</div>
                    <div style="padding: 1rem;">
                        <p style="color: var(--text-light); margin: 0 0 1rem 0; font-size: 0.9rem;">
                            Normalized averages (0–100%) across ${evals.length} evaluation${evals.length !== 1 ? 's' : ''}.
                        </p>
                        <div style="overflow-x: auto;">
                            <table class="data-table" style="width: 100%; min-width: 480px;">
                                <thead><tr><th style="text-align: left;">Category</th><th style="text-align: center;">Avg %</th><th style="text-align: center;">Min</th><th style="text-align: center;">Max</th><th style="text-align: center;">Count</th><th style="text-align: left;">Distribution</th></tr></thead>
                                <tbody>
                                    ${categories.map(cat => {
                                        const avgPct = parseFloat(cat.average);
                                        const barColor = avgPct >= 80 ? 'var(--success)' : avgPct >= 60 ? 'var(--warning)' : 'var(--error)';
                                        const barWidth = Math.min(100, Math.max(0, avgPct));
                                        return `<tr><td><strong>${escapeHtml(cat.name)}</strong></td><td style="text-align: center; font-weight: 600; color: ${barColor};">${cat.average}%</td><td style="text-align: center; color: var(--text-light); font-size: 0.9rem;">${cat.min}%</td><td style="text-align: center; color: var(--text-light); font-size: 0.9rem;">${cat.max}%</td><td style="text-align: center;">${cat.count}</td><td><div style="background: var(--bg-alt); height: 18px; border-radius: 9px; overflow: hidden; max-width: 160px;"><div style="background: ${barColor}; width: ${barWidth}%; height: 100%;"></div></div></td></tr>`;
                                    }).join('')}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>`;
            } else if (evals.length > 0) {
                tableHtml = '<p style="color: var(--text-light); font-size: 0.9rem;">No category scores in evaluations for this selection.</p>';
            }
            
            container.innerHTML = dropdownHtml + structureHtml + tableHtml;
            const sel = document.getElementById('analyticsRubricSelect');
            if (sel && (savedSelection || selectedRubricId)) sel.value = selectedRubricId || savedSelection;
        }
        
        // Render Comparisons Tab - Course and instructor comparisons
        function renderComparisonsTab() {
            const evals = analyticsData.filtered;
            const container = document.getElementById('analyticsComparisonsTab');
            
            if (evals.length === 0) {
                container.innerHTML = `
                    <div class="card" style="text-align: center; padding: 3rem 1.5rem; color: var(--text-light); max-width: 28rem; margin: 0 auto;">
                        <p style="font-size: 2rem; margin-bottom: 0.5rem;"><i data-lucide="trending-up" style="width:2rem;height:2rem; color: var(--text-light);"></i></p>
                        <p style="font-weight: 600; margin-bottom: 0.25rem; color: var(--text);">No comparison data</p>
                        <p style="font-size: 0.9rem; margin-bottom: 1.25rem;">Load analytics to compare courses and instructors.</p>
                        <button type="button" onclick="switchAnalyticsTab('evaluations')" class="btn" style="background: var(--primary); color: white;">Load data</button>
                    </div>`;
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: container });
                return;
            }
            
            function avgPctForEvals(evaluations) {
                let all = [];
                evaluations.forEach(e => {
                    let d = e.evaluation_data;
                    if (typeof d === 'string') try { d = JSON.parse(d); } catch (err) { return; }
                    if (!d?.sections || typeof d.sections !== 'object') return;
                    Object.values(d.sections).forEach(section => {
                        if (section.score != null && section.maxScore) all.push((parseFloat(section.score) / parseFloat(section.maxScore)) * 100);
                        (section.subcategories || section.feedback || []).forEach(item => {
                            if (item.points != null && item.maxPoints) all.push((parseFloat(item.points) / parseFloat(item.maxPoints)) * 100);
                        });
                    });
                });
                return all.length ? (all.reduce((a, b) => a + b, 0) / all.length).toFixed(1) : 0;
            }
            
            // By course
            const courseStats = {};
            evals.forEach(eval => {
                const courseId = eval.course_id;
                if (!courseStats[courseId]) {
                    courseStats[courseId] = {
                        name: eval.courses?.name || 'Unknown',
                        semester: eval.courses?.semester && eval.courses?.year ? `${eval.courses.semester} ${eval.courses.year}` : '—',
                        evaluations: []
                    };
                }
                courseStats[courseId].evaluations.push(eval);
            });
            const courseComparisons = Object.values(courseStats).map(c => ({
                ...c,
                count: c.evaluations.length,
                average: parseFloat(avgPctForEvals(c.evaluations))
            })).sort((a, b) => b.average - a.average);
            
            // By instructor
            const instStats = {};
            evals.forEach(eval => {
                const id = eval.instructor_id;
                if (!instStats[id]) instStats[id] = { evaluations: [] };
                instStats[id].evaluations.push(eval);
            });
            const instComparisons = Object.entries(instStats).map(([id, o]) => {
                const inst = analyticsData.instructors.find(i => i.id === id);
                return {
                    name: inst?.full_name || inst?.email || 'Unknown',
                    count: o.evaluations.length,
                    average: parseFloat(avgPctForEvals(o.evaluations))
                };
            }).sort((a, b) => b.average - a.average);
            
            var byCourseHtml = `
                <div class="card" data-widget-id="card-course" style="margin-bottom: 2rem;">
                    <div class="card-header">By course</div>
                    <div style="padding: 1rem;">
                        <p style="color: var(--text-light); margin: 0 0 1rem 0; font-size: 0.9rem;">Normalized average score (0–100%) per course.</p>
                        <div style="overflow-x: auto;">
                            <table class="data-table" style="width: 100%; min-width: 420px;">
                                <thead><tr><th style="text-align: left;">Course</th><th style="text-align: left;">Term</th><th style="text-align: center;">Evaluations</th><th style="text-align: center;">Avg %</th><th style="text-align: left;">Performance</th></tr></thead>
                                <tbody>
            `;
            courseComparisons.forEach(course => {
                const barColor = course.average >= 80 ? 'var(--success)' : course.average >= 60 ? 'var(--warning)' : 'var(--error)';
                const barWidth = Math.min(100, Math.max(0, course.average));
                byCourseHtml += `<tr>
                    <td><strong>${escapeHtml(course.name)}</strong></td>
                    <td style="color: var(--text-light); font-size: 0.9rem;">${escapeHtml(course.semester)}</td>
                    <td style="text-align: center;">${course.count}</td>
                    <td style="text-align: center; font-weight: 600; color: ${barColor};">${course.average}%</td>
                    <td><div style="background: var(--bg-alt); height: 18px; border-radius: 9px; overflow: hidden; max-width: 140px;"><div style="background: ${barColor}; width: ${barWidth}%; height: 100%;"></div></div></td>
                </tr>`;
            });
            byCourseHtml += `</tbody></table></div></div></div>`;
            var byInstructorHtml = `
                <div class="card" data-widget-id="card-instructor">
                    <div class="card-header">By instructor</div>
                    <div style="padding: 1rem;">
                        <p style="color: var(--text-light); margin: 0 0 1rem 0; font-size: 0.9rem;">Normalized average score (0–100%) per instructor.</p>
                        <div style="overflow-x: auto;">
                            <table class="data-table" style="width: 100%; min-width: 360px;">
                                <thead><tr><th style="text-align: left;">Instructor</th><th style="text-align: center;">Evaluations</th><th style="text-align: center;">Avg %</th><th style="text-align: left;">Performance</th></tr></thead>
                                <tbody>
            `;
            instComparisons.forEach(inst => {
                const barColor = inst.average >= 80 ? 'var(--success)' : inst.average >= 60 ? 'var(--warning)' : 'var(--error)';
                const barWidth = Math.min(100, Math.max(0, inst.average));
                byInstructorHtml += `<tr>
                    <td><strong>${escapeHtml(inst.name)}</strong></td>
                    <td style="text-align: center;">${inst.count}</td>
                    <td style="text-align: center; font-weight: 600; color: ${barColor};">${inst.average}%</td>
                    <td><div style="background: var(--bg-alt); height: 18px; border-radius: 9px; overflow: hidden; max-width: 140px;"><div style="background: ${barColor}; width: ${barWidth}%; height: 100%;"></div></div></td>
                </tr>`;
            });
            byInstructorHtml += `</tbody></table></div></div></div>`;
            function customCardHtml(w) {
                return '<div class="card" data-widget-id="' + escapeHtml(w.id) + '"><div class="card-header">' + escapeHtml(w.label || 'Custom section') + '</div><div style="padding:1rem;color:var(--text-light);font-size:0.9rem;">Custom section. Use Edit cards to remove or reorder.</div></div>';
            }
            var blocks = { 'card-course': byCourseHtml, 'card-instructor': byInstructorHtml };
            var tabWidgets = (typeof getTabWidgets === 'function' ? getTabWidgets('comparisons') : []).filter(function(w) { return w.visible !== false; }).sort(function(a, b) { return (a.order || 0) - (b.order || 0); });
            if (!tabWidgets.length) tabWidgets = (DEFAULT_TAB_WIDGETS.comparisons || []).filter(function(w) { return w.visible !== false; }).sort(function(a, b) { return a.order - b.order; });
            var html = tabWidgets.map(function(w) { return blocks[w.id] || (w.custom || String(w.id).indexOf('custom_') === 0 ? customCardHtml(w) : ''); }).filter(Boolean).join('');
            container.innerHTML = html || '<p style="color: var(--text-light); padding: 1rem;">No cards visible. Use Customize → Edit cards to show cards.</p>';
        }
        
        // Render Evaluations Tab - Searchable list with drill-down
        const ANALYTICS_EVALS_PAGE_SIZE = 50;
        // ANALYTICS_MAX_EVALUATIONS, analyticsEvaluationsPage, and analyticsEvaluationsTruncated are defined earlier (before loadEnhancedAnalytics)
        
        // Export preview sort state (Excel-style column header sort)
        var exportPreviewSortColumn = 'date';
        var exportPreviewSortDir = 'desc';
        var EXPORT_PREVIEW_HEADER_LABELS = { date: 'Date', student: 'Student', course: 'Course', instructor: 'Instructor', score: 'Score %', rubric: 'Rubric', assignmentType: 'Assignment Type' };
        // Column filter state: each key is column id, value is array of selected display values (empty = no filter)
        var exportPreviewColumnFilters = { date: [], student: [], course: [], instructor: [], score: [], rubric: [], assignmentType: [] };
        var exportHeaderFilterPanelOpen = null;
        
        function sortExportPreviewBy(column) {
            if (column === exportPreviewSortColumn) {
                exportPreviewSortDir = exportPreviewSortDir === 'asc' ? 'desc' : 'asc';
            } else {
                exportPreviewSortColumn = column;
                exportPreviewSortDir = 'asc';
            }
            renderExportPreview();
        }
        
        // Extract assignment type from evaluation (evaluation_data.assignmentType)
        function getAssignmentTypeFromEval(e) {
            if (!e || !e.evaluation_data) return '\u2014';
            var data = e.evaluation_data;
            if (typeof data === 'string') try { data = JSON.parse(data); } catch (err) { return '\u2014'; }
            return (data && data.assignmentType) ? data.assignmentType : '\u2014';
        }
        // Extract rubric from evaluation row (Supabase join, rubricsById lookup, or evaluation_data.rubricUsed when RLS blocks rubrics read)
        function getRubricFromEval(e) {
            if (!e) return null;
            var r = e.rubric;
            if (r && typeof r === 'object' && (r.id != null || r.name != null)) return Array.isArray(r) ? r[0] : r;
            r = e.rubrics;
            if (r && typeof r === 'object') return Array.isArray(r) ? r[0] : r;
            if (e.rubric_id && typeof analyticsData !== 'undefined' && analyticsData.rubricsById && analyticsData.rubricsById[e.rubric_id])
                return analyticsData.rubricsById[e.rubric_id];
            var data = e.evaluation_data;
            if (data != null) {
                if (typeof data === 'string') try { data = JSON.parse(data); } catch (err) { data = null; }
                if (data && data.rubricUsed) return { name: data.rubricUsed };
            }
            return null;
        }
        
        async function loadAnalyticsRubricsById(evals) {
            if (typeof analyticsData === 'undefined') return;
            var ids = [...new Set((evals || []).map(function(e) { return e.rubric_id; }).filter(Boolean))];
            analyticsData.rubricsById = {};
            if (ids.length === 0) return;
            try {
                var res = await supabaseClient.from('rubrics').select('id, name').in('id', ids);
                (res.data || []).forEach(function(r) { analyticsData.rubricsById[r.id] = r; });
            } catch (e) { console.warn('Analytics: could not load rubric names for export', e); }
        }
        
        function getExportPreviewSortValue(e, column) {
            switch (column) {
                case 'date': return e.created_at ? new Date(e.created_at).getTime() : 0;
                case 'student': return (e.course_students ? (e.course_students.first_name || '') + ' ' + (e.course_students.last_name || '') : '').toLowerCase();
                case 'course': return (e.courses?.name || '').toLowerCase();
                case 'instructor': {
                    var inst = analyticsData.instructors && analyticsData.instructors.find(function(i) { return i.id === e.instructor_id; });
                    return ((inst && (inst.full_name || inst.email)) || '').toLowerCase();
                }
                case 'score': return getOverallScorePct(e) != null ? getOverallScorePct(e) : -1;
                case 'rubric': { var r = getRubricFromEval(e); return (r && r.name ? r.name : '').toLowerCase(); }
                case 'assignmentType': return (getAssignmentTypeFromEval(e) || '').toLowerCase();
                default: return '';
            }
        }
        
        function getExportPreviewDisplayValue(e, column, ctx) {
            switch (column) {
                case 'date': return e.created_at ? new Date(e.created_at).toLocaleDateString() : '\u2014';
                case 'student': return e.course_students ? (e.course_students.first_name || '') + ' ' + (e.course_students.last_name || '') : '\u2014';
                case 'course': return e.courses && e.courses.name ? e.courses.name : '\u2014';
                case 'instructor': {
                    if (ctx && ctx.instructorMap && ctx.instructorMap[e.instructor_id]) {
                        var inst = ctx.instructorMap[e.instructor_id];
                        return (inst.full_name || inst.email || '') || '\u2014';
                    }
                    var inst = analyticsData.instructors && analyticsData.instructors.find(function(i) { return i.id === e.instructor_id; });
                    return inst && (inst.full_name || inst.email) ? (inst.full_name || inst.email) : '\u2014';
                }
                case 'score': var s = getOverallScorePct(e); return s != null ? s.toFixed(1) + '%' : '\u2014';
                case 'rubric': { var r = getRubricFromEval(e); return r && r.name ? r.name : '\u2014'; }
                case 'assignmentType': return getAssignmentTypeFromEval(e);
                default: return '';
            }
        }
        
        /** Apply export column filters to a list of evaluations. Returns filtered list. ctx.instructorMap for instructor display. */
        function getExportColumnFilteredEvaluations(evals, ctx) {
            if (!evals || !Array.isArray(evals)) return [];
            var cols = ['date', 'student', 'course', 'instructor', 'score', 'rubric', 'assignmentType'];
            var filtered = evals.slice();
            cols.forEach(function(col) {
                var sel = exportPreviewColumnFilters[col];
                if (sel && sel.length > 0) {
                    filtered = filtered.filter(function(e) { return sel.indexOf(getExportPreviewDisplayValue(e, col, ctx)) !== -1; });
                }
            });
            return filtered;
        }
        
        function getUniqueColumnValues(column) {
            var evals = analyticsData.filtered || [];
            var set = {};
            evals.forEach(function(e) {
                var v = getExportPreviewDisplayValue(e, column);
                if (v !== undefined && v !== null) set[v] = true;
            });
            var arr = Object.keys(set);
            arr.sort(function(a, b) { return String(a).localeCompare(String(b), undefined, { numeric: true }); });
            return arr;
        }
        
        function openExportHeaderFilter(column, button) {
            if (exportHeaderFilterPanelOpen) {
                exportHeaderFilterPanelOpen.remove();
                if (exportHeaderFilterPanelOpen.getAttribute('data-column') === column) {
                    exportHeaderFilterPanelOpen = null;
                    return;
                }
            }
            var evals = analyticsData.filtered || [];
            var unique = getUniqueColumnValues(column);
            var selected = exportPreviewColumnFilters[column] || [];
            var panel = document.createElement('div');
            panel.className = 'export-header-filter-panel';
            panel.setAttribute('data-column', column);
            var rect = button.getBoundingClientRect();
            panel.style.left = rect.left + 'px';
            panel.style.top = (rect.bottom + 4) + 'px';
            panel.innerHTML = '<div class="export-filter-toolbar"><a href="#" role="button" data-action="selectall">Select all</a><a href="#" role="button" data-action="clear">Clear</a></div><div class="export-filter-list"></div>';
            var list = panel.querySelector('.export-filter-list');
            unique.forEach(function(value) {
                var checked = selected.length === 0 || selected.indexOf(value) !== -1;
                var item = document.createElement('label');
                item.className = 'export-filter-item';
                item.innerHTML = '<input type="checkbox" ' + (checked ? 'checked' : '') + ' data-value="' + escapeHtml(value) + '"><span>' + escapeHtml(value) + '</span>';
                list.appendChild(item);
            });
            panel.querySelector('.export-filter-toolbar [data-action="selectall"]').addEventListener('click', function(e) {
                e.preventDefault();
                exportPreviewColumnFilters[column] = unique.slice();
                renderExportPreview();
                updateExportFilterPanelCheckboxes(panel, column);
            });
            panel.querySelector('.export-filter-toolbar [data-action="clear"]').addEventListener('click', function(e) {
                e.preventDefault();
                exportPreviewColumnFilters[column] = [];
                renderExportPreview();
                updateExportFilterPanelCheckboxes(panel, column);
            });
            list.addEventListener('change', function(e) {
                if (e.target.type !== 'checkbox') return;
                var value = e.target.getAttribute('data-value');
                var arr = exportPreviewColumnFilters[column] || [];
                var idx = arr.indexOf(value);
                if (e.target.checked) {
                    if (idx === -1) arr.push(value);
                } else {
                    if (idx !== -1) arr.splice(idx, 1);
                }
                exportPreviewColumnFilters[column] = arr;
                renderExportPreview();
            });
            document.body.appendChild(panel);
            exportHeaderFilterPanelOpen = panel;
        }
        
        function updateExportFilterPanelCheckboxes(panel, column) {
            if (!panel || !panel.parentNode) return;
            var selected = exportPreviewColumnFilters[column] || [];
            var allSelected = selected.length === 0;
            panel.querySelectorAll('.export-filter-item input').forEach(function(cb) {
                var value = cb.getAttribute('data-value');
                cb.checked = allSelected || selected.indexOf(value) !== -1;
            });
        }
        
        function closeExportHeaderFilterPanel() {
            if (exportHeaderFilterPanelOpen) {
                exportHeaderFilterPanelOpen.remove();
                exportHeaderFilterPanelOpen = null;
            }
        }
        
        function renderExportPreview() {
            const tbody = document.getElementById('exportPreviewTableBody');
            const countEl = document.getElementById('exportPreviewCount');
            const table = document.getElementById('exportPreviewTable');
            
            if (!tbody || !analyticsData.filtered) return;
            
            var evals = (analyticsData.filtered || []).slice();
            var previewLimit = 50;
            
            // Apply column filters (multi-select: row included if each column's value is in selected set, or no filter)
            var cols = ['date', 'student', 'course', 'instructor', 'score', 'rubric', 'assignmentType'];
            cols.forEach(function(col) {
                var sel = exportPreviewColumnFilters[col];
                if (sel && sel.length > 0) {
                    evals = evals.filter(function(e) { return sel.indexOf(getExportPreviewDisplayValue(e, col)) !== -1; });
                }
            });
            
            if (countEl) countEl.textContent = evals.length;
            
            // Update header: sort label + arrow on .export-th-sort, .has-filter on .export-th-filter
            if (table && table.tHead && table.tHead.rows[0]) {
                var row = table.tHead.rows[0];
                for (var i = 0; i < row.cells.length; i++) {
                    var th = row.cells[i];
                    var col = th.getAttribute('data-sort');
                    if (!col) continue;
                    var sortSpan = th.querySelector('.export-th-sort');
                    var filterBtn = th.querySelector('.export-th-filter');
                    if (sortSpan) {
                        var label = EXPORT_PREVIEW_HEADER_LABELS[col] || col;
                        var arrow = col === exportPreviewSortColumn ? (exportPreviewSortDir === 'asc' ? ' \u2191' : ' \u2193') : '';
                        sortSpan.textContent = label + arrow;
                    }
                    if (filterBtn) {
                        var hasFilter = exportPreviewColumnFilters[col] && exportPreviewColumnFilters[col].length > 0;
                        filterBtn.classList.toggle('has-filter', hasFilter);
                    }
                }
            }
            
            if (evals.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; padding: 2rem; color: var(--text-light);">No evaluations match the current filters</td></tr>';
                return;
            }
            
            // Sort by current column/direction
            evals.sort(function(a, b) {
                var va = getExportPreviewSortValue(a, exportPreviewSortColumn);
                var vb = getExportPreviewSortValue(b, exportPreviewSortColumn);
                var cmp = 0;
                if (typeof va === 'number' && typeof vb === 'number') cmp = va - vb;
                else cmp = String(va).localeCompare(String(vb), undefined, { numeric: true });
                return exportPreviewSortDir === 'asc' ? cmp : -cmp;
            });
            
            var html = '';
            evals.slice(0, previewLimit).forEach(function(e) {
                var date = getExportPreviewDisplayValue(e, 'date');
                var studentName = getExportPreviewDisplayValue(e, 'student');
                var courseName = getExportPreviewDisplayValue(e, 'course');
                var instructorName = getExportPreviewDisplayValue(e, 'instructor');
                var scoreDisplay = getExportPreviewDisplayValue(e, 'score');
                var rubricName = getExportPreviewDisplayValue(e, 'rubric');
                var assignmentTypeDisplay = getExportPreviewDisplayValue(e, 'assignmentType');
                html += '<tr>' +
                    '<td style="padding: 0.75rem;">' + escapeHtml(date) + '</td>' +
                    '<td style="padding: 0.75rem;">' + escapeHtml(studentName) + '</td>' +
                    '<td style="padding: 0.75rem;">' + escapeHtml(courseName) + '</td>' +
                    '<td style="padding: 0.75rem;">' + escapeHtml(instructorName) + '</td>' +
                    '<td style="text-align: center; padding: 0.75rem;">' + scoreDisplay + '</td>' +
                    '<td style="padding: 0.75rem;">' + escapeHtml(rubricName) + '</td>' +
                    '<td style="padding: 0.75rem;">' + escapeHtml(assignmentTypeDisplay) + '</td>' +
                    '</tr>';
            });
            
            if (evals.length > previewLimit) {
                html += '<tr><td colspan="7" style="text-align: center; padding: 1rem; background: var(--bg-alt); color: var(--text-light); font-style: italic;">Showing first ' + previewLimit + ' of ' + evals.length + ' evaluations. Export CSV to see all records.</td></tr>';
            }
            
            tbody.innerHTML = html;
        }
        
        // Delegate click on export preview table headers: sort (label) or open filter (button)
        (function initExportPreviewSort() {
            var table = document.getElementById('exportPreviewTable');
            if (!table) return;
            table.addEventListener('click', function(ev) {
                var filterBtn = ev.target && ev.target.classList && ev.target.classList.contains('export-th-filter') ? ev.target : (ev.target && ev.target.closest ? ev.target.closest('.export-th-filter') : null);
                if (filterBtn && filterBtn.getAttribute('data-sort')) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    openExportHeaderFilter(filterBtn.getAttribute('data-sort'), filterBtn);
                    return;
                }
                var sortSpan = ev.target && ev.target.classList && ev.target.classList.contains('export-th-sort') ? ev.target : (ev.target && ev.target.closest ? ev.target.closest('.export-th-sort') : null);
                var th = ev.target && ev.target.nodeName === 'TH' ? ev.target : (ev.target && ev.target.closest ? ev.target.closest('th') : null);
                if ((sortSpan || th) && !filterBtn && th && th.getAttribute('data-sort')) sortExportPreviewBy(th.getAttribute('data-sort'));
            });
            document.addEventListener('click', function(ev) {
                if (exportHeaderFilterPanelOpen && !exportHeaderFilterPanelOpen.contains(ev.target)) {
                    var btn = document.querySelector('#exportPreviewTable .export-th-filter[data-sort="' + exportHeaderFilterPanelOpen.getAttribute('data-column') + '"]');
                    if (!btn || !btn.contains(ev.target)) closeExportHeaderFilterPanel();
                }
                if (evaluationsHeaderFilterPanelOpen && !evaluationsHeaderFilterPanelOpen.contains(ev.target)) {
                    var tbl = document.getElementById('analyticsEvaluationsTable');
                    var btn = tbl && tbl.querySelector('.export-th-filter[data-sort="' + evaluationsHeaderFilterPanelOpen.getAttribute('data-column') + '"]');
                    if (!btn || !btn.contains(ev.target)) closeEvaluationsHeaderFilterPanel();
                }
            });
            var evalTab = document.getElementById('analyticsEvaluationsTab');
            if (evalTab) evalTab.addEventListener('click', function(ev) {
                var table = ev.target.closest && ev.target.closest('#analyticsEvaluationsTable');
                if (!table) return;
                var filterBtn = ev.target.closest && ev.target.closest('.export-th-filter');
                if (filterBtn && filterBtn.getAttribute('data-sort')) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    openEvaluationsHeaderFilter(filterBtn.getAttribute('data-sort'), filterBtn);
                    return;
                }
                var th = ev.target.closest && ev.target.closest('th[data-sort]');
                if (th && !ev.target.closest('.export-th-filter')) sortEvaluationsByColumn(th.getAttribute('data-sort'));
            });
        })();
        
        var evaluationsColumnFilters = { date: [], student: [], course: [], instructor: [], score: [] };
        var evaluationsSortColumn = 'date';
        var evaluationsSortDir = 'desc';
        var EVALUATIONS_HEADER_LABELS = { date: 'Date', student: 'Student', course: 'Course', instructor: 'Instructor', score: 'Score %' };
        var evaluationsHeaderFilterPanelOpen = null;
        
        function getEvaluationsDisplayValue(e, column) {
            switch (column) {
                case 'date': return e.created_at ? new Date(e.created_at).toLocaleDateString() : '\u2014';
                case 'student': return e.course_students ? (e.course_students.first_name || '') + ' ' + (e.course_students.last_name || '') : '\u2014';
                case 'course': return e.courses && e.courses.name ? e.courses.name : '\u2014';
                case 'instructor': return e.instructorName || '\u2014';
                case 'score': return e.overallScore === 'N/A' ? 'N/A' : (e.overallScore + '%');
                default: return '\u2014';
            }
        }
        
        function getUniqueEvaluationsColumnValues(column, evalsWithDetails) {
            var set = {};
            (evalsWithDetails || []).forEach(function(e) {
                var v = getEvaluationsDisplayValue(e, column);
                if (v !== undefined && v !== null) set[v] = true;
            });
            var arr = Object.keys(set);
            arr.sort(function(a, b) { return String(a).localeCompare(String(b), undefined, { numeric: true }); });
            return arr;
        }
        
        function sortEvaluationsByColumn(column) {
            if (column === evaluationsSortColumn) evaluationsSortDir = evaluationsSortDir === 'asc' ? 'desc' : 'asc';
            else { evaluationsSortColumn = column; evaluationsSortDir = 'asc'; }
            renderEvaluationsTab();
        }
        
        function openEvaluationsHeaderFilter(column, button) {
            if (evaluationsHeaderFilterPanelOpen) {
                evaluationsHeaderFilterPanelOpen.remove();
                if (evaluationsHeaderFilterPanelOpen.getAttribute('data-column') === column) {
                    evaluationsHeaderFilterPanelOpen = null;
                    return;
                }
            }
            var evals = window.evaluationsFullListWithDetails || window.allEvaluationsList || [];
            var unique = getUniqueEvaluationsColumnValues(column, evals);
            var selected = evaluationsColumnFilters[column] || [];
            var panel = document.createElement('div');
            panel.className = 'export-header-filter-panel';
            panel.setAttribute('data-column', column);
            var rect = button.getBoundingClientRect();
            panel.style.left = rect.left + 'px';
            panel.style.top = (rect.bottom + 4) + 'px';
            panel.innerHTML = '<div class="export-filter-toolbar"><a href="#" role="button" data-action="selectall">Select all</a><a href="#" role="button" data-action="clear">Clear</a></div><div class="export-filter-list"></div>';
            var list = panel.querySelector('.export-filter-list');
            unique.forEach(function(value) {
                var checked = selected.length === 0 || selected.indexOf(value) !== -1;
                list.appendChild((function() {
                    var item = document.createElement('label');
                    item.className = 'export-filter-item';
                    item.innerHTML = '<input type="checkbox" ' + (checked ? 'checked' : '') + ' data-value="' + escapeHtml(value) + '"><span>' + escapeHtml(value) + '</span>';
                    return item;
                })());
            });
            panel.querySelector('.export-filter-toolbar [data-action="selectall"]').addEventListener('click', function(e) { e.preventDefault(); evaluationsColumnFilters[column] = unique.slice(); renderEvaluationsTab(); updateEvaluationsFilterPanelCheckboxes(panel, column); });
            panel.querySelector('.export-filter-toolbar [data-action="clear"]').addEventListener('click', function(e) { e.preventDefault(); evaluationsColumnFilters[column] = []; renderEvaluationsTab(); updateEvaluationsFilterPanelCheckboxes(panel, column); });
            list.addEventListener('change', function(e) {
                if (e.target.type !== 'checkbox') return;
                var value = e.target.getAttribute('data-value');
                var arr = evaluationsColumnFilters[column] || [];
                var idx = arr.indexOf(value);
                if (e.target.checked) { if (idx === -1) arr.push(value); } else { if (idx !== -1) arr.splice(idx, 1); }
                evaluationsColumnFilters[column] = arr;
                renderEvaluationsTab();
            });
            document.body.appendChild(panel);
            evaluationsHeaderFilterPanelOpen = panel;
        }
        
        function updateEvaluationsFilterPanelCheckboxes(panel, column) {
            if (!panel || !panel.parentNode) return;
            var selected = evaluationsColumnFilters[column] || [];
            var allSelected = selected.length === 0;
            panel.querySelectorAll('.export-filter-item input').forEach(function(cb) {
                cb.checked = allSelected || selected.indexOf(cb.getAttribute('data-value')) !== -1;
            });
        }
        
        function closeEvaluationsHeaderFilterPanel() {
            if (evaluationsHeaderFilterPanelOpen) { evaluationsHeaderFilterPanelOpen.remove(); evaluationsHeaderFilterPanelOpen = null; }
        }
        
        function renderEvaluationsTab() {
            const evals = analyticsData.filtered;
            const container = document.getElementById('analyticsEvaluationsTab');
            const totalLoaded = analyticsData.evaluations ? analyticsData.evaluations.length : 0;
            const isFilteredToZero = totalLoaded > 0 && evals.length === 0;
            
            if (evals.length === 0) {
                container.innerHTML = '<div class="card" style="text-align: center; padding: 3rem 1.5rem; color: var(--text-light); max-width: 28rem; margin: 0 auto;"><p style="font-size: 2rem; margin-bottom: 0.5rem;"><i data-lucide="file-text" style="width:2rem;height:2rem;display:inline-block;"></i></p><p style="font-weight: 600; margin-bottom: 0.25rem; color: var(--text);">' + (isFilteredToZero ? 'No evaluations match your filters' : 'No evaluations found') + '</p><p style="font-size: 0.9rem; margin-bottom: 1.25rem;">' + (isFilteredToZero ? 'Try broadening the date range or clearing filters above.' : 'Apply filters above to load evaluation data.') + '</p></div>';
                if (typeof isSuperAdmin === 'function' && isSuperAdmin()) {
                    var llmCardEmpty = document.createElement('div');
                    llmCardEmpty.id = 'llmTrainingExportCard';
                    llmCardEmpty.className = 'card';
                    llmCardEmpty.style.marginTop = '1rem';
                    llmCardEmpty.innerHTML = '<div style="padding: 1rem; border-bottom: 1px solid var(--border); background: var(--bg-alt);"><h3 style="margin: 0 0 0.35rem 0; font-size: 1rem;"><span class="icon-with-text"><i data-lucide="cpu"></i> LLM training data</span> <span class="support-tier-badge" data-tier="super_admin">Super Admin</span></h3><p style="margin: 0; font-size: 0.85rem; color: var(--text-light);">Export for Mistral or Qwen. Go to <strong>Settings → Admin → Data Management</strong> for Export buttons and full instructions.</p></div><div style="padding: 1rem; display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;"><button type="button" id="exportLLMTrainingBtn" onclick="downloadLLMTrainingData()" class="btn" style="background: var(--primary); color: white;"><span class="icon-with-text"><i data-lucide="download"></i> Download for Mistral (exported.json)</span></button><span id="llmExportStatus" style="font-size: 0.85rem; color: var(--text-light);"></span></div>';
                    container.appendChild(llmCardEmpty);
                    if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: llmCardEmpty });
                }
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: container });
                return;
            }
            
            // Add instructor names and calculate average scores
            let evalsWithDetails = evals.map(e => {
                const instructor = analyticsData.instructors.find(i => i.id === e.instructor_id);
                
                // Calculate overall score for this evaluation (normalized to percentage)
                let rawScores = [];
                let normalizedScores = [];
                let evalData = e.evaluation_data;
                if (typeof evalData === 'string') {
                    try {
                        evalData = JSON.parse(evalData);
                    } catch (err) {
                        console.error('Parse error for eval', e.id, err);
                        evalData = null;
                    }
                }
                
                // Handle sections as object (not array)
                if (evalData?.sections && typeof evalData.sections === 'object') {
                    // sections is an object like { "Content": {...}, "Delivery": {...} }
                    Object.values(evalData.sections).forEach(section => {
                        // Each section has a score and maxScore
                        if (section.score !== undefined && section.score !== null && section.maxScore) {
                            const raw = parseFloat(section.score);
                            const max = parseFloat(section.maxScore);
                            rawScores.push(raw);
                            // Normalize to 0-100 scale
                            normalizedScores.push((raw / max) * 100);
                        }
                        
                        // Also check subcategories/feedback arrays for individual item scores
                        const items = section.subcategories || section.feedback || [];
                        if (Array.isArray(items)) {
                            items.forEach(item => {
                                if (item.points !== undefined && item.points !== null && item.maxPoints) {
                                    const raw = parseFloat(item.points);
                                    const max = parseFloat(item.maxPoints);
                                    rawScores.push(raw);
                                    // Normalize to 0-100 scale
                                    normalizedScores.push((raw / max) * 100);
                                }
                            });
                        }
                    });
                }
                
                // Use normalized average for fair comparison across different rubrics
                const overallScore = normalizedScores.length > 0 
                    ? (normalizedScores.reduce((a, b) => a + b, 0) / normalizedScores.length).toFixed(1)
                    : 'N/A';
                
                return {
                    ...e,
                    instructorName: instructor?.full_name || instructor?.email || 'Unknown',
                    overallScore: overallScore, // Percentage
                    rawTotal: rawScores.length > 0 ? rawScores.reduce((a, b) => a + b, 0).toFixed(1) : 'N/A'
                };
            });
            
            const totalCount = analyticsData.evaluations.length;
            window.evaluationsFullListWithDetails = evalsWithDetails;
            
            // Apply search filter if unified search is active and we're on evaluations tab
            const unifiedSearchInput = document.getElementById('unifiedSearchInput');
            // Check both the variable and the actual tab button state
            const activeTabId = typeof currentAnalyticsTabId !== 'undefined' && currentAnalyticsTabId ? currentAnalyticsTabId : 'overview';
            const evaluationsTabBtn = document.getElementById('tab_evaluations');
            const isEvaluationsTabActive = evaluationsTabBtn && evaluationsTabBtn.classList.contains('analytics-tab-active');
            const isEvaluationsTab = activeTabId === 'evaluations' || isEvaluationsTabActive;
            
            if (unifiedSearchInput && unifiedSearchInput.value && unifiedSearchInput.value.trim() && isEvaluationsTab) {
                const searchTerm = unifiedSearchInput.value.toLowerCase().trim();
                if (searchTerm) {
                    const beforeCount = evalsWithDetails.length;
                    evalsWithDetails = evalsWithDetails.filter(function(e) {
                        if (!e) return false;
                        try {
                            // Search across multiple fields - use both display values and raw data
                            const studentName = getEvaluationsDisplayValue(e, 'student').toLowerCase();
                            const courseName = getEvaluationsDisplayValue(e, 'course').toLowerCase();
                            const instructorName = getEvaluationsDisplayValue(e, 'instructor').toLowerCase();
                            const date = getEvaluationsDisplayValue(e, 'date').toLowerCase();
                            const score = getEvaluationsDisplayValue(e, 'score').toLowerCase();
                            
                            // Also search raw data fields in case display value returns '—'
                            const rawStudentName = (e.course_students ? 
                                ((e.course_students.first_name || '') + ' ' + (e.course_students.last_name || '')).trim() : 
                                '').toLowerCase();
                            const rawCourseName = (e.courses && e.courses.name ? e.courses.name : '').toLowerCase();
                            const rawInstructorName = (e.instructorName || '').toLowerCase();
                            
                            const matches = studentName.includes(searchTerm) || 
                                           courseName.includes(searchTerm) || 
                                           instructorName.includes(searchTerm) ||
                                           date.includes(searchTerm) ||
                                           score.includes(searchTerm) ||
                                           rawStudentName.includes(searchTerm) ||
                                           rawCourseName.includes(searchTerm) ||
                                           rawInstructorName.includes(searchTerm);
                            
                            return matches;
                        } catch (err) {
                            console.warn('Error filtering evaluation:', err, e);
                            return false;
                        }
                    });
                    const afterCount = evalsWithDetails.length;
                    console.log(`Search filter applied: "${searchTerm}" - ${beforeCount} → ${afterCount} evaluations`);
                }
            }
            
            // Apply column filters (Evaluations tab dropdown filters)
            var cols = ['date', 'student', 'course', 'instructor', 'score'];
            cols.forEach(function(col) {
                var sel = evaluationsColumnFilters[col];
                if (sel && sel.length > 0) {
                    evalsWithDetails = evalsWithDetails.filter(function(e) { return sel.indexOf(getEvaluationsDisplayValue(e, col)) !== -1; });
                }
            });
            var isFiltered = evalsWithDetails.length !== totalCount;
            
            // Sort by evaluations column/direction
            evalsWithDetails.sort(function(a, b) {
                var va = getEvaluationsDisplayValue(a, evaluationsSortColumn);
                var vb = getEvaluationsDisplayValue(b, evaluationsSortColumn);
                var cmp = 0;
                if (evaluationsSortColumn === 'date') {
                    var ta = a.created_at ? new Date(a.created_at).getTime() : 0;
                    var tb = b.created_at ? new Date(b.created_at).getTime() : 0;
                    cmp = ta - tb;
                } else if (evaluationsSortColumn === 'score') {
                    var sa = a.overallScore === 'N/A' ? -1 : parseFloat(a.overallScore);
                    var sb = b.overallScore === 'N/A' ? -1 : parseFloat(b.overallScore);
                    cmp = sa - sb;
                } else cmp = String(va).localeCompare(String(vb), undefined, { numeric: true });
                return evaluationsSortDir === 'asc' ? cmp : -cmp;
            });
            
            window.currentEvaluationsList = evalsWithDetails;
            window.allEvaluationsList = evalsWithDetails;
            
            var headerLabels = EVAL_HEADER_LABELS;
            var sortCol = evaluationsSortColumn;
            var sortDir = evaluationsSortDir;
            var colFilters = evaluationsColumnFilters;
            var theadRow = ['date', 'student', 'course', 'instructor', 'score'].map(function(col) {
                var label = headerLabels[col] || col;
                var arrow = col === sortCol ? (sortDir === 'asc' ? ' \u2191' : ' \u2193') : '';
                var hasFilter = colFilters[col] && colFilters[col].length > 0;
                var centerClass = col === 'score' ? ' export-th-center' : '';
                return '<th data-sort="' + col + '" style="text-align: left; padding: 0.75rem; color: #fff; font-weight: 600; background: var(--primary);" title="Click label to sort; click \u25BE to filter"><div class="export-th-inner' + centerClass + '"><span class="export-th-sort">' + escapeHtml(label) + arrow + '</span><button type="button" class="export-th-filter' + (hasFilter ? ' has-filter' : '') + '" data-sort="' + col + '" aria-label="Filter ' + escapeHtml(label) + '">\u25BE</button></div></th>';
            }).join('');
            
            var tableCardHtmlStart = `
                <div class="card" data-widget-id="card-table" style="overflow: hidden;">
                    <div style="padding: 0.75rem 1rem; border-bottom: 1px solid var(--border); background: var(--bg-alt); display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
                        <span style="color: var(--text-light); font-size: 0.85rem; flex: 1;">${isFiltered ? `${evalsWithDetails.length} of ${totalCount} evaluations` : `${evalsWithDetails.length} evaluation${evalsWithDetails.length !== 1 ? 's' : ''}`}</span>
                        <div id="bulkActionsBar" style="display: none; align-items: center; gap: 0.75rem; flex-wrap: wrap;">
                            <span id="bulkSelectionCount" style="font-size: 0.875rem; color: var(--text); font-weight: 500;"></span>
                            <button type="button" onclick="bulkDeleteEvaluations()" class="btn" style="background: var(--error); color: white; padding: 0.5rem 1rem; font-size: 0.875rem;"><span class="icon-with-text"><i data-lucide="trash-2" style="width:0.875rem;height:0.875rem;"></i> Delete Selected</span></button>
                            <button type="button" onclick="bulkMoveEvaluations()" class="btn" style="background: var(--secondary); color: white; padding: 0.5rem 1rem; font-size: 0.875rem;"><span class="icon-with-text"><i data-lucide="move" style="width:0.875rem;height:0.875rem;"></i> Move Selected</span></button>
                            <button type="button" onclick="bulkExportEvaluations()" class="btn" style="background: var(--primary); color: white; padding: 0.5rem 1rem; font-size: 0.875rem;"><span class="icon-with-text"><i data-lucide="download" style="width:0.875rem;height:0.875rem;"></i> Export Selected</span></button>
                            <button type="button" onclick="clearBulkSelection()" class="btn-secondary" style="padding: 0.5rem 1rem; font-size: 0.875rem;">Clear Selection</button>
                        </div>
                        <button type="button" onclick="exportDepartmentData()" class="btn" style="background: var(--primary); color: white; padding: 0.5rem 1rem; font-size: 0.875rem;"><span class="icon-with-text"><i data-lucide="download"></i> Export CSV</span></button>
                    </div>
                    <div style="overflow-x: auto;">
                        <table id="analyticsEvaluationsTable" class="data-table" style="width: 100%; min-width: 560px;">
                            <thead style="background: var(--primary); color: #fff;">
                                <tr>
                                    <th style="text-align: center; padding: 0.75rem; color: #fff; font-weight: 600; background: var(--primary); width: 50px;">
                                        <input type="checkbox" id="selectAllEvaluations" onchange="toggleSelectAllEvaluations(this)" aria-label="Select all evaluations" style="cursor: pointer; width: 1.125rem; height: 1.125rem;">
                                    </th>
                                    ${theadRow}
                                    <th style="text-align: center; padding: 0.75rem; color: #fff; font-weight: 600; background: var(--primary);">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="evaluationsTableBody">
            `;
            var html = tableCardHtmlStart;
            
            const totalEvals = evalsWithDetails.length;
            const totalPages = Math.max(1, Math.ceil(totalEvals / ANALYTICS_EVALS_PAGE_SIZE));
            if (analyticsEvaluationsPage >= totalPages) analyticsEvaluationsPage = totalPages - 1;
            if (analyticsEvaluationsPage < 0) analyticsEvaluationsPage = 0;
            const start = analyticsEvaluationsPage * ANALYTICS_EVALS_PAGE_SIZE;
            const pageEvals = evalsWithDetails.slice(start, start + ANALYTICS_EVALS_PAGE_SIZE);
            
            pageEvals.forEach(eval => {
                const studentName = eval.course_students 
                    ? `${eval.course_students.first_name} ${eval.course_students.last_name}`
                    : 'Unknown';
                const courseName = eval.courses?.name || 'Unknown';
                const date = new Date(eval.created_at).toLocaleDateString();
                const evalId = eval.id;
                const scoreColor = eval.overallScore === 'N/A' ? 'var(--text-light)' :
                                  eval.overallScore >= 80 ? 'var(--success)' : 
                                  eval.overallScore >= 60 ? 'var(--warning)' : 'var(--error)';
                
                html += `
                    <tr data-eval-id="${evalId}" style="transition: background 0.15s ease;" onmouseover="this.style.background='var(--bg-alt)'" onmouseout="this.style.background=''">
                        <td style="text-align: center; padding: 0.75rem;">
                            <input type="checkbox" class="eval-checkbox" data-eval-id="${evalId}" data-student-id="${eval.student_id || ''}" onchange="updateBulkActionsBar()" aria-label="Select evaluation" style="cursor: pointer; width: 1.125rem; height: 1.125rem;">
                        </td>
                        <td style="color: var(--text-light); font-size: 0.9rem;">${date}</td>
                        <td><strong>${escapeHtml(studentName)}</strong></td>
                        <td style="color: var(--text-light); font-size: 0.9rem;">${escapeHtml(courseName)}</td>
                        <td style="color: var(--text-light); font-size: 0.9rem;">${escapeHtml(eval.instructorName)}</td>
                        <td style="text-align: center; font-weight: 600; color: ${scoreColor};">${eval.overallScore === 'N/A' ? 'N/A' : `${eval.overallScore}%`}</td>
                        <td style="text-align: center;">
                            <div class="eval-actions-dropdown" style="position: relative; display: inline-block;">
                                <button type="button" class="btn-secondary eval-actions-btn" id="evalActionsBtn_${evalId}" onclick="toggleEvalActionsDropdown('${evalId}')" style="padding: 0.25rem 0.6rem; font-size: 0.875rem; display: inline-flex; align-items: center; gap: 0.25rem;">
                                    Actions <i data-lucide="chevron-down" style="width:0.75rem;height:0.75rem;"></i>
                                </button>
                                <div class="eval-actions-menu hidden" id="evalActionsMenu_${evalId}" style="position: absolute; top: 100%; left: 0; margin-top: 0.25rem; background: white; border: 1px solid var(--border); border-radius: var(--radius-md); box-shadow: var(--elevation-3); z-index: 1000; min-width: 150px; padding: 0.25rem 0;">
                                    <button type="button" onclick="viewEvaluationDetails('${evalId}'); closeEvalActionsDropdown('${evalId}'); return false;" style="width: 100%; text-align: left; padding: 0.5rem 0.75rem; border: none; background: none; cursor: pointer; font-size: 0.875rem; color: var(--text); display: flex; align-items: center; gap: 0.5rem;">
                                        <i data-lucide="eye" style="width:1rem;height:1rem;"></i> View
                                    </button>
                                    <button type="button" onclick="openMoveEvalModal('${evalId}', '${eval.course_id || ''}', '${eval.student_id || ''}'); closeEvalActionsDropdown('${evalId}'); return false;" style="width: 100%; text-align: left; padding: 0.5rem 0.75rem; border: none; background: none; cursor: pointer; font-size: 0.875rem; color: var(--text); display: flex; align-items: center; gap: 0.5rem; border-top: 1px solid var(--border);">
                                        <i data-lucide="move" style="width:1rem;height:1rem;"></i> Move
                                    </button>
                                    <button type="button" onclick="deleteEvaluation('${evalId}', '${eval.student_id || ''}'); closeEvalActionsDropdown('${evalId}'); return false;" style="width: 100%; text-align: left; padding: 0.5rem 0.75rem; border: none; background: none; cursor: pointer; font-size: 0.875rem; color: var(--error); display: flex; align-items: center; gap: 0.5rem; border-top: 1px solid var(--border);" onmouseover="this.style.background='var(--bg-alt)'" onmouseout="this.style.background='white'">
                                        <i data-lucide="trash-2" style="width:1rem;height:1rem;"></i> Delete
                                    </button>
                                </div>
                            </div>
                        </td>
                    </tr>
                `;
            });
            
            html += `
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
            
            // Initialize Lucide icons for action buttons in the table
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons({ root: tempDiv });
            }
            html = tempDiv.innerHTML;
            
            // Pagination controls
            const from = start + 1;
            const to = Math.min(start + ANALYTICS_EVALS_PAGE_SIZE, totalEvals);
            const truncatedWarning = analyticsEvaluationsTruncated ? `<span style="color: var(--warning); margin-left: 0.5rem;" title="Use date filters to narrow results">⚠️ Results limited to ${ANALYTICS_MAX_EVALUATIONS}</span>` : '';
            html += `
            <div id="analyticsEvaluationsPagination" class="card" style="margin-top: 0.5rem; padding: 0.75rem 1rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.75rem;">
                <p style="color: var(--text-light); margin: 0; font-size: 0.9rem;">Showing ${from}&ndash;${to} of ${totalEvals}${truncatedWarning}</p>
                ${totalEvals > ANALYTICS_EVALS_PAGE_SIZE ? `<div style="display: flex; gap: 0.5rem;">
                    <button type="button" onclick="analyticsEvaluationsPage--; updateEvaluationsTable(window.currentEvaluationsList || []);" class="btn-secondary" style="padding: 0.35rem 0.75rem;" ${analyticsEvaluationsPage <= 0 ? 'disabled' : ''}>Previous</button>
                    <button type="button" onclick="analyticsEvaluationsPage++; updateEvaluationsTable(window.currentEvaluationsList || []);" class="btn-secondary" style="padding: 0.35rem 0.75rem;" ${analyticsEvaluationsPage >= totalPages - 1 ? 'disabled' : ''}>Next</button>
                </div>` : ''}
            </div>
            `;
            var tableCardHtml = html;
            function customEvalCardHtml(w) {
                return '<div class="card" data-widget-id="' + escapeHtml(w.id) + '"><div class="card-header">' + escapeHtml(w.label || 'Custom section') + '</div><div style="padding:1rem;color:var(--text-light);font-size:0.9rem;">Custom section. Use Edit cards to remove or reorder.</div></div>';
            }
            var evalBlocks = { 'card-table': tableCardHtml };
            var evalTabWidgets = (typeof getTabWidgets === 'function' ? getTabWidgets('evaluations') : []).filter(function(w) { return w.visible !== false; }).sort(function(a, b) { return (a.order || 0) - (b.order || 0); });
            if (!evalTabWidgets.length) evalTabWidgets = (DEFAULT_TAB_WIDGETS.evaluations || []).filter(function(w) { return w.visible !== false; }).sort(function(a, b) { return a.order - b.order; });
            container.innerHTML = evalTabWidgets.map(function(w) { return evalBlocks[w.id] || (w.custom || String(w.id).indexOf('custom_') === 0 ? customEvalCardHtml(w) : ''); }).filter(Boolean).join('') || '<p style="color: var(--text-light); padding: 1rem;">No cards visible. Use Customize → Edit cards to show cards.</p>';
            
            // Initialize bulk selection functionality
            if (typeof initializeBulkSelection === 'function') {
            initializeBulkSelection();
            }
            
            if (typeof isSuperAdmin === 'function' && isSuperAdmin()) {
                var llmCard = document.createElement('div');
                llmCard.id = 'llmTrainingExportCard';
                llmCard.className = 'card';
                llmCard.style.marginTop = '1rem';
                llmCard.innerHTML = '<div style="padding: 1rem; border-bottom: 1px solid var(--border); background: var(--bg-alt);"><h3 style="margin: 0 0 0.35rem 0; font-size: 1rem;"><span class="icon-with-text"><i data-lucide="cpu"></i> LLM training data</span> <span class="support-tier-badge" data-tier="super_admin">Super Admin</span></h3><p style="margin: 0; font-size: 0.85rem; color: var(--text-light);">Export for Mistral or Qwen. Go to <strong>Settings → Admin → Data Management</strong> for Export buttons and full instructions.</p></div><div style="padding: 1rem; display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;"><button type="button" id="exportLLMTrainingBtn" onclick="downloadLLMTrainingData()" class="btn" style="background: var(--primary); color: white;"><span class="icon-with-text"><i data-lucide="download"></i> Download for Mistral (exported.json)</span></button><span id="llmExportStatus" style="font-size: 0.85rem; color: var(--text-light);"></span></div>';
                container.appendChild(llmCard);
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: llmCard });
            }
        }
        
        // Bulk selection functionality for evaluations
        function initializeBulkSelection() {
            // Ensure bulk actions bar is hidden initially
            const bulkActionsBar = document.getElementById('bulkActionsBar');
            if (bulkActionsBar) {
                bulkActionsBar.style.display = 'none';
            }
            
            // Update bulk actions bar when checkboxes change
            updateBulkActionsBar();
        }
        
        function updateBulkActionsBar() {
            const checkboxes = document.querySelectorAll('.eval-checkbox:checked');
            const count = checkboxes.length;
            const bulkActionsBar = document.getElementById('bulkActionsBar');
            const bulkSelectionCount = document.getElementById('bulkSelectionCount');
            const selectAllCheckbox = document.getElementById('selectAllEvaluations');
            
            if (bulkActionsBar) {
                if (count > 0) {
                    bulkActionsBar.style.display = 'flex';
                } else {
                    bulkActionsBar.style.display = 'none';
                }
            }
            
            if (bulkSelectionCount) {
                bulkSelectionCount.textContent = count > 0 ? `${count} selected` : '';
            }
            
            // Update "select all" checkbox state
            if (selectAllCheckbox) {
                const allCheckboxes = document.querySelectorAll('.eval-checkbox');
                const allChecked = allCheckboxes.length > 0 && checkboxes.length === allCheckboxes.length;
                selectAllCheckbox.checked = allChecked;
                selectAllCheckbox.indeterminate = count > 0 && count < allCheckboxes.length;
            }
        }
        
        function toggleSelectAllEvaluations(checkbox) {
            const checkboxes = document.querySelectorAll('.eval-checkbox');
            checkboxes.forEach(cb => {
                cb.checked = checkbox.checked;
            });
            updateBulkActionsBar();
        }
        
        function clearBulkSelection() {
            const checkboxes = document.querySelectorAll('.eval-checkbox');
            checkboxes.forEach(cb => {
                cb.checked = false;
            });
            const selectAllCheckbox = document.getElementById('selectAllEvaluations');
            if (selectAllCheckbox) {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
            }
            updateBulkActionsBar();
        }
        
        function getSelectedEvaluationIds() {
            const checkboxes = document.querySelectorAll('.eval-checkbox:checked');
            return Array.from(checkboxes).map(cb => cb.getAttribute('data-eval-id')).filter(id => id);
        }
        
        function bulkDeleteEvaluations() {
            const selectedIds = getSelectedEvaluationIds();
            if (selectedIds.length === 0) {
                if (typeof showNotification === 'function') {
                    showNotification('No evaluations selected', 'error', 3000);
                }
                return;
            }
            
            if (!confirm(`Are you sure you want to delete ${selectedIds.length} evaluation(s)? This action cannot be undone.`)) {
                return;
            }
            
            // Delete each evaluation
            let deleted = 0;
            let failed = 0;
            const deletePromises = selectedIds.map(async (evalId) => {
                try {
                    // Find the student_id from the checkbox
                    const checkbox = document.querySelector(`.eval-checkbox[data-eval-id="${evalId}"]`);
                    const studentId = checkbox ? checkbox.getAttribute('data-student-id') : null;
                    
                    if (typeof deleteEvaluation === 'function') {
                        await deleteEvaluation(evalId, studentId);
                        deleted++;
                    } else {
                        // Fallback: direct Supabase delete
                        if (supabaseClient) {
                            const { error } = await supabaseClient
                                .from('evaluations')
                                .update({ deleted_locally_at: new Date().toISOString() })
                                .eq('id', evalId);
                            if (!error) deleted++;
                            else failed++;
                        } else {
                            failed++;
                        }
                    }
                } catch (error) {
                    console.error('Error deleting evaluation:', evalId, error);
                    failed++;
                }
            });
            
            Promise.all(deletePromises).then(() => {
                clearBulkSelection();
                if (typeof showNotification === 'function') {
                    if (failed > 0) {
                        showNotification(`Deleted ${deleted} evaluation(s). ${failed} failed.`, failed > 0 ? 'error' : 'success', 5000);
                    } else {
                        showNotification(`Successfully deleted ${deleted} evaluation(s)`, 'success', 3000);
                    }
                }
                // Reload evaluations
                if (typeof renderEvaluationsTab === 'function') {
                    renderEvaluationsTab();
                } else if (typeof loadEnhancedAnalytics === 'function') {
                    loadEnhancedAnalytics();
                }
            });
        }
        
        function bulkMoveEvaluations() {
            const selectedIds = getSelectedEvaluationIds();
            if (selectedIds.length === 0) {
                if (typeof showNotification === 'function') {
                    showNotification('No evaluations selected', 'error', 3000);
                }
                return;
            }
            
            // Use the existing move modal for the first selected evaluation
            // In a full implementation, you'd want a bulk move modal
            const firstId = selectedIds[0];
            const checkbox = document.querySelector(`.eval-checkbox[data-eval-id="${firstId}"]`);
            const studentId = checkbox ? checkbox.getAttribute('data-student-id') : null;
            
            if (typeof openMoveEvalModal === 'function') {
                openMoveEvalModal(firstId, '', studentId);
                // Store other IDs for bulk move if needed
                window.bulkMoveRemainingIds = selectedIds.slice(1);
            } else {
                if (typeof showNotification === 'function') {
                    showNotification('Move functionality not available', 'error', 3000);
                }
            }
        }
        
        function bulkExportEvaluations() {
            const selectedIds = getSelectedEvaluationIds();
            if (selectedIds.length === 0) {
                if (typeof showNotification === 'function') {
                    showNotification('No evaluations selected', 'error', 3000);
                }
                return;
            }
            
            // Get selected evaluations from the current list
            const allEvals = window.currentEvaluationsList || analyticsData.filtered || [];
            const selectedEvals = allEvals.filter(e => selectedIds.includes(e.id));
            
            if (selectedEvals.length === 0) {
                if (typeof showNotification === 'function') {
                    showNotification('Selected evaluations not found in current data', 'error', 3000);
                }
                return;
            }
            
            // Export to CSV
            const headers = ['Date', 'Student', 'Course', 'Instructor', 'Score %', 'Rubric'];
            const rows = selectedEvals.map(eval => {
                const studentName = eval.course_students 
                    ? `${eval.course_students.first_name || ''} ${eval.course_students.last_name || ''}`.trim()
                    : 'Unknown';
                const courseName = eval.courses?.name || 'Unknown';
                const date = eval.created_at ? new Date(eval.created_at).toLocaleDateString() : '';
                const instructorName = eval.instructorName || 'Unknown';
                const score = eval.overallScore !== undefined && eval.overallScore !== 'N/A' ? `${eval.overallScore}%` : 'N/A';
                const rubricName = eval.rubric?.name || 'Unknown';
                return [date, studentName, courseName, instructorName, score, rubricName];
            });
            
            // Create CSV
            const csvContent = [
                headers.join(','),
                ...rows.map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(','))
            ].join('\n');
            
            // Download
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', `evaluations_export_${new Date().toISOString().split('T')[0]}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            if (typeof showNotification === 'function') {
                showNotification(`Exported ${selectedEvals.length} evaluation(s)`, 'success', 3000);
            }
            
            clearBulkSelection();
        }
        
        // Evaluations tab: column sort + filter (same as Data Export)
        var evaluationsColumnFilters = { date: [], student: [], course: [], instructor: [], score: [] };
        var evaluationsSortColumn = 'date';
        var evaluationsSortDir = 'desc';
        var evaluationsHeaderFilterPanelOpen = null;
        var EVAL_HEADER_LABELS = { date: 'Date', student: 'Student', course: 'Course', instructor: 'Instructor', score: 'Score %' };
        
        function getEvaluationsDisplayValue(eval, column) {
            switch (column) {
                case 'date': return eval.created_at ? new Date(eval.created_at).toLocaleDateString() : '\u2014';
                case 'student': return eval.course_students ? (eval.course_students.first_name || '') + ' ' + (eval.course_students.last_name || '') : '\u2014';
                case 'course': return eval.courses && eval.courses.name ? eval.courses.name : '\u2014';
                case 'instructor': return (eval.instructorName != null ? eval.instructorName : '\u2014');
                case 'score': return eval.overallScore !== undefined && eval.overallScore !== 'N/A' ? eval.overallScore + '%' : '\u2014';
                default: return '';
            }
        }
        
        function getEvaluationsUniqueValues(column) {
            var list = window.evaluationsFullListWithDetails || [];
            var set = {};
            list.forEach(function(e) {
                var v = getEvaluationsDisplayValue(e, column);
                if (v !== undefined && v !== null) set[v] = true;
            });
            var arr = Object.keys(set);
            arr.sort(function(a, b) { return String(a).localeCompare(String(b), undefined, { numeric: true }); });
            return arr;
        }
        
        function openEvaluationsHeaderFilter(column, button) {
            if (evaluationsHeaderFilterPanelOpen) {
                evaluationsHeaderFilterPanelOpen.remove();
                if (evaluationsHeaderFilterPanelOpen.getAttribute('data-column') === column) {
                    evaluationsHeaderFilterPanelOpen = null;
                    return;
                }
            }
            var unique = getEvaluationsUniqueValues(column);
            var selected = evaluationsColumnFilters[column] || [];
            var panel = document.createElement('div');
            panel.className = 'export-header-filter-panel';
            panel.setAttribute('data-column', column);
            var rect = button.getBoundingClientRect();
            panel.style.left = rect.left + 'px';
            panel.style.top = (rect.bottom + 4) + 'px';
            panel.innerHTML = '<div class="export-filter-toolbar"><a href="#" role="button" data-action="selectall">Select all</a><a href="#" role="button" data-action="clear">Clear</a></div><div class="export-filter-list"></div>';
            var list = panel.querySelector('.export-filter-list');
            unique.forEach(function(value) {
                var checked = selected.length === 0 || selected.indexOf(value) !== -1;
                var item = document.createElement('label');
                item.className = 'export-filter-item';
                item.innerHTML = '<input type="checkbox" ' + (checked ? 'checked' : '') + ' data-value="' + escapeHtml(value) + '"><span>' + escapeHtml(value) + '</span>';
                list.appendChild(item);
            });
            panel.querySelector('.export-filter-toolbar [data-action="selectall"]').addEventListener('click', function(e) { e.preventDefault(); evaluationsColumnFilters[column] = unique.slice(); renderEvaluationsTab(); });
            panel.querySelector('.export-filter-toolbar [data-action="clear"]').addEventListener('click', function(e) { e.preventDefault(); evaluationsColumnFilters[column] = []; renderEvaluationsTab(); });
            list.addEventListener('change', function(e) {
                if (e.target.type !== 'checkbox') return;
                var value = e.target.getAttribute('data-value');
                var arr = evaluationsColumnFilters[column] || [];
                var idx = arr.indexOf(value);
                if (e.target.checked) { if (idx === -1) arr.push(value); } else { if (idx !== -1) arr.splice(idx, 1); }
                evaluationsColumnFilters[column] = arr;
                renderEvaluationsTab();
            });
            document.body.appendChild(panel);
            evaluationsHeaderFilterPanelOpen = panel;
        }
        
        function closeEvaluationsHeaderFilterPanel() {
            if (evaluationsHeaderFilterPanelOpen) { evaluationsHeaderFilterPanelOpen.remove(); evaluationsHeaderFilterPanelOpen = null; }
        }
        
        function sortEvaluationsByColumn(column) {
            if (column === evaluationsSortColumn) evaluationsSortDir = evaluationsSortDir === 'asc' ? 'desc' : 'asc';
            else { evaluationsSortColumn = column; evaluationsSortDir = 'asc'; }
            renderEvaluationsTab();
        }
        
        // Sort evaluations (uses global Sort dropdown when present, else column header sort)
        function sortEvaluations() {
            const sortField = document.getElementById('analyticsGlobalSort')?.value || document.getElementById('evalSortField')?.value || 'date';
            const evals = window.currentEvaluationsList || [];
            
            if (evals.length === 0) return;
            
            switch(sortField) {
                case 'date':
                    evals.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
                    break;
                case 'date-asc':
                    evals.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
                    break;
                case 'student':
                    evals.sort((a, b) => {
                        const nameA = a.course_students ? `${a.course_students.first_name} ${a.course_students.last_name}` : 'Unknown';
                        const nameB = b.course_students ? `${b.course_students.first_name} ${b.course_students.last_name}` : 'Unknown';
                        return nameA.localeCompare(nameB);
                    });
                    break;
                case 'course':
                    evals.sort((a, b) => {
                        const courseA = a.courses?.name || 'Unknown';
                        const courseB = b.courses?.name || 'Unknown';
                        return courseA.localeCompare(courseB);
                    });
                    break;
                case 'instructor':
                    evals.sort((a, b) => a.instructorName.localeCompare(b.instructorName));
                    break;
                case 'score':
                    evals.sort((a, b) => {
                        const scoreA = a.overallScore === 'N/A' ? -1 : parseFloat(a.overallScore);
                        const scoreB = b.overallScore === 'N/A' ? -1 : parseFloat(b.overallScore);
                        return scoreB - scoreA;
                    });
                    break;
                case 'score-asc':
                    evals.sort((a, b) => {
                        const scoreA = a.overallScore === 'N/A' ? 999 : parseFloat(a.overallScore);
                        const scoreB = b.overallScore === 'N/A' ? 999 : parseFloat(b.overallScore);
                        return scoreA - scoreB;
                    });
                    break;
            }
            
            // Re-render table body
            updateEvaluationsTable(evals);
        }
        
        // Apply evaluation filters
        function applyEvalFilters() {
            const scoreFilter = document.getElementById('evalScoreFilter').value;
            let filtered = window.allEvaluationsList || [];
            
            // Apply score filter
            if (scoreFilter !== 'all') {
                filtered = filtered.filter(e => {
                    const score = e.overallScore === 'N/A' ? 0 : parseFloat(e.overallScore);
                    switch(scoreFilter) {
                        case 'high':
                            return score >= 80;
                        case 'medium':
                            return score >= 60 && score < 80;
                        case 'low':
                            return score < 60 && score > 0;
                        default:
                            return true;
                    }
                });
            }
            
            // Update current list and re-apply sort
            window.currentEvaluationsList = filtered;
            analyticsEvaluationsPage = 0;
            sortEvaluations();
        }
        
        // Update evaluations table display (supports pagination)
        function updateEvaluationsTable(evals) {
            const tbody = document.getElementById('evaluationsTableBody');
            if (!tbody) return;
            
            const totalEvals = evals.length;
            const totalPages = Math.max(1, Math.ceil(totalEvals / ANALYTICS_EVALS_PAGE_SIZE));
            if (analyticsEvaluationsPage >= totalPages) analyticsEvaluationsPage = totalPages - 1;
            if (analyticsEvaluationsPage < 0) analyticsEvaluationsPage = 0;
            const start = analyticsEvaluationsPage * ANALYTICS_EVALS_PAGE_SIZE;
            const pageEvals = evals.slice(start, start + ANALYTICS_EVALS_PAGE_SIZE);
            
            let html = '';
            pageEvals.forEach(eval => {
                const studentName = eval.course_students 
                    ? `${eval.course_students.first_name} ${eval.course_students.last_name}`
                    : 'Unknown';
                const courseName = eval.courses?.name || 'Unknown';
                const date = new Date(eval.created_at).toLocaleDateString();
                const evalId = eval.id;
                const scoreColor = eval.overallScore === 'N/A' ? 'var(--text-light)' :
                                  eval.overallScore >= 80 ? 'var(--success)' : 
                                  eval.overallScore >= 60 ? 'var(--warning)' : 'var(--error)';
                const deletedTag = formatDeletedLocallyTag(eval.deleted_locally_at);
                html += `
                    <tr>
                        <td style="color: var(--text-light); font-size: 0.9rem;">${date}</td>
                        <td><strong>${escapeHtml(studentName)}</strong>${deletedTag}</td>
                        <td style="color: var(--text-light); font-size: 0.9rem;">${escapeHtml(courseName)}</td>
                        <td style="color: var(--text-light); font-size: 0.9rem;">${escapeHtml(eval.instructorName)}</td>
                        <td style="text-align: center; font-weight: 600; color: ${scoreColor};">${eval.overallScore === 'N/A' ? 'N/A' : `${eval.overallScore}%`}</td>
                        <td style="text-align: center;">
                            <div class="eval-actions-dropdown" style="position: relative; display: inline-block;">
                                <button type="button" class="btn-secondary eval-actions-btn" id="evalActionsBtn_${evalId}" onclick="toggleEvalActionsDropdown('${evalId}')" style="padding: 0.25rem 0.6rem; font-size: 0.875rem; display: inline-flex; align-items: center; gap: 0.25rem;">
                                    Actions <i data-lucide="chevron-down" style="width:0.75rem;height:0.75rem;"></i>
                                </button>
                                <div class="eval-actions-menu hidden" id="evalActionsMenu_${evalId}" style="position: absolute; top: 100%; left: 0; margin-top: 0.25rem; background: white; border: 1px solid var(--border); border-radius: var(--radius-md); box-shadow: var(--elevation-3); z-index: 1000; min-width: 150px; padding: 0.25rem 0;">
                                    <button type="button" onclick="viewEvaluationDetails('${evalId}'); closeEvalActionsDropdown('${evalId}'); return false;" style="width: 100%; text-align: left; padding: 0.5rem 0.75rem; border: none; background: none; cursor: pointer; font-size: 0.875rem; color: var(--text); display: flex; align-items: center; gap: 0.5rem;">
                                        <i data-lucide="eye" style="width:1rem;height:1rem;"></i> View
                                    </button>
                                    <button type="button" onclick="openMoveEvalModal('${evalId}', '${eval.course_id || ''}', '${eval.student_id || ''}'); closeEvalActionsDropdown('${evalId}'); return false;" style="width: 100%; text-align: left; padding: 0.5rem 0.75rem; border: none; background: none; cursor: pointer; font-size: 0.875rem; color: var(--text); display: flex; align-items: center; gap: 0.5rem; border-top: 1px solid var(--border);">
                                        <i data-lucide="move" style="width:1rem;height:1rem;"></i> Move
                                    </button>
                                    <button type="button" onclick="deleteEvaluation('${evalId}', '${eval.student_id || ''}'); closeEvalActionsDropdown('${evalId}'); return false;" style="width: 100%; text-align: left; padding: 0.5rem 0.75rem; border: none; background: none; cursor: pointer; font-size: 0.875rem; color: var(--error); display: flex; align-items: center; gap: 0.5rem; border-top: 1px solid var(--border);" onmouseover="this.style.background='var(--bg-alt)'" onmouseout="this.style.background='white'">
                                        <i data-lucide="trash-2" style="width:1rem;height:1rem;"></i> Delete
                                    </button>
                                </div>
                            </div>
                        </td>
                    </tr>
                `;
            });
            
            tbody.innerHTML = html;
            
            // Initialize Lucide icons for action buttons
            if (typeof lucide !== 'undefined' && lucide.createIcons && tbody) {
                lucide.createIcons({ root: tbody });
            }
            
            const totalCount = (analyticsData.evaluations || []).length;
            const isFiltered = evals.length !== totalCount;
            const countText = document.querySelector('#analyticsEvaluationsTab .card p');
            if (countText) {
                countText.textContent = isFiltered ? `${evals.length} of ${totalCount} evaluations` : `${evals.length} evaluation${evals.length !== 1 ? 's' : ''}`;
            }
            
            const paginationEl = document.getElementById('analyticsEvaluationsPagination');
            if (paginationEl && totalEvals > ANALYTICS_EVALS_PAGE_SIZE) {
                const from = start + 1;
                const to = Math.min(start + ANALYTICS_EVALS_PAGE_SIZE, totalEvals);
                paginationEl.innerHTML = `
                    <p style="color: var(--text-light); margin: 0; font-size: 0.9rem;">Showing ${from}&ndash;${to} of ${totalEvals}</p>
                    <div style="display: flex; gap: 0.5rem;">
                        <button type="button" onclick="analyticsEvaluationsPage--; updateEvaluationsTable(window.currentEvaluationsList || []);" class="btn-secondary" style="padding: 0.35rem 0.75rem;" ${analyticsEvaluationsPage <= 0 ? 'disabled' : ''}>Previous</button>
                        <button type="button" onclick="analyticsEvaluationsPage++; updateEvaluationsTable(window.currentEvaluationsList || []);" class="btn-secondary" style="padding: 0.35rem 0.75rem;" ${analyticsEvaluationsPage >= totalPages - 1 ? 'disabled' : ''}>Next</button>
                    </div>
                `;
            }
        }
        
        // View evaluation details modal
        async function viewEvaluationDetails(evaluationId) {
            const evaluation = analyticsData.filtered.find(e => e.id === evaluationId);
            if (!evaluation) {
                alert('Evaluation not found');
                return;
            }
            
            console.log('🔍 Viewing evaluation:', evaluation.id);
            
            // Navigate to evaluation using path-based routing
            if (typeof Router !== 'undefined' && Router.navigateToEvaluation) {
                Router.navigateToEvaluation(
                    evaluationId, 
                    evaluation.student_id || null, 
                    evaluation.course_id || null, 
                    false // view mode, not edit
                );
                return; // Router will handle displaying the evaluation
            }
            
            // Fallback: FERPA audit: log access to individual evaluation
            await logAccess('view', 'evaluations', evaluation.id, evaluation.student_id || null, {
                purpose: 'view_evaluation_details',
                course_id: evaluation.course_id
            });
            
            const studentName = evaluation.course_students 
                ? `${evaluation.course_students.first_name} ${evaluation.course_students.last_name}`
                : 'Unknown';
            const courseName = evaluation.courses?.name || 'Unknown';
            const date = new Date(evaluation.created_at).toLocaleString();
            
            let detailsHTML = `
                <div style="margin-bottom: 1.5rem;">
                    <p><strong>Student:</strong> ${studentName}</p>
                    <p><strong>Course:</strong> ${courseName}</p>
                    <p><strong>Date:</strong> ${date}</p>
                </div>
            `;
            
            // Add video/audio player if media URL exists
            const videoUrl = evaluation.video_url || null;
            const audioUrl = evaluation.audio_url || null;
            const mediaUrl = videoUrl || audioUrl;
            
            if (mediaUrl) {
                detailsHTML += `
                    <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 1.5rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                            <h4 style="margin: 0; color: var(--primary);"><span class="icon-with-text"><i data-lucide="${videoUrl ? 'video' : 'headphones'}"></i> ${videoUrl ? 'Video Recording' : 'Audio Recording'}</span></h4>
                        </div>
                        ${videoUrl ? `
                        <video controls style="width: 100%; max-width: 600px; border-radius: 0.5rem; background: #000;">
                            <source src="${escapeHtml(videoUrl)}" type="video/mp4">
                            <source src="${escapeHtml(videoUrl)}" type="video/webm">
                            <source src="${escapeHtml(videoUrl)}" type="video/quicktime">
                            Your browser does not support the video tag.
                        </video>
                        ` : `
                        <audio controls style="width: 100%; max-width: 500px;">
                            <source src="${escapeHtml(audioUrl)}" type="audio/mpeg">
                            <source src="${escapeHtml(audioUrl)}" type="audio/mp3">
                            <source src="${escapeHtml(audioUrl)}" type="audio/wav">
                            Your browser does not support the audio tag.
                        </audio>
                        `}
                        <p style="font-size: 0.85rem; color: var(--text-light); margin-top: 0.75rem;">
                            ${videoUrl ? 'Watch the recorded speech video.' : 'Listen to the recorded speech audio.'}
                        </p>
                    </div>
                `;
            }
            
            // Parse evaluation_data if it's a string
            let evalData = evaluation.evaluation_data;
            if (typeof evalData === 'string') {
                try {
                    evalData = JSON.parse(evalData);
                } catch (e) {
                    console.error('Error parsing evaluation data:', e);
                    evalData = null;
                }
            }
            
            // Show rubric scores if available
            if (evalData && evalData.sections && typeof evalData.sections === 'object') {
                detailsHTML += '<h4 style="margin-bottom: 1rem;">Rubric Scores</h4>';
                
                // sections is an object like { "Content": {...}, "Delivery": {...} }
                Object.entries(evalData.sections).forEach(([sectionName, section]) => {
                    detailsHTML += `<h5 style="margin-top: 1rem; color: var(--primary);">${sectionName}</h5>`;
                    
                    // Show section score
                    if (section.score !== undefined) {
                        const sectionScore = parseFloat(section.score);
                        const scoreColor = sectionScore >= section.maxScore * 0.8 ? 'var(--success)' : 
                                          sectionScore >= section.maxScore * 0.6 ? 'var(--warning)' : 'var(--error)';
                        detailsHTML += `
                            <div style="background: var(--bg-alt); padding: 0.75rem; border-radius: 0.5rem; margin-top: 0.5rem; margin-bottom: 0.5rem;">
                                <strong>Section Score:</strong> 
                                <span style="font-weight: 600; color: ${scoreColor};">${sectionScore}/${section.maxScore || 'N/A'}</span>
                            </div>
                        `;
                    }
                    
                    // Show subcategories/feedback items (subsection scores)
                    const items = section.subcategories || section.feedback || [];
                    if (Array.isArray(items) && items.length > 0) {
                        detailsHTML += '<div style="background: var(--bg-alt); padding: 0.5rem; border-radius: 0.5rem; margin-top: 0.5rem;"><strong style="display: block; margin-bottom: 0.5rem;">Subsections:</strong>';
                        items.forEach(item => {
                            const points = item.points !== undefined ? item.points : 'N/A';
                            const maxPoints = item.maxPoints || 10;
                            const scoreColor = typeof points === 'number' && maxPoints > 0 && points >= maxPoints * 0.8 ? 'var(--success)' : 
                                              typeof points === 'number' && maxPoints > 0 && points >= maxPoints * 0.6 ? 'var(--warning)' : 'var(--error)';
                            const gradeStr = item.grade ? ` (${item.grade})` : '';
                            
                            detailsHTML += `
                                <div style="padding: 0.5rem 0; border-bottom: 1px solid var(--border);">
                                    <div style="display: flex; justify-content: space-between;">
                                        <span><strong>${escapeHtml(item.name || '')}</strong></span>
                                        <span style="font-weight: 600; color: ${scoreColor};">${points}/${maxPoints}${gradeStr}</span>
                                    </div>
                                    ${item.feedback ? `<div style="color: var(--text-light); font-size: 0.9rem; margin-top: 0.25rem;">${escapeHtml(item.feedback)}</div>` : ''}
                                </div>
                            `;
                        });
                        detailsHTML += '</div>';
                    }
                });
            }
            
            // Show in modal
            const modal = `
                <div id="evaluationDetailsModal" style="display:flex;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
                    <div style="background:white;padding:2rem;border-radius:1rem;max-width:700px;width:90%;max-height:90vh;overflow-y:auto;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:1.5rem;">
                            <h3 style="margin:0;color:var(--primary);"><span class="icon-with-text"><i data-lucide="bar-chart-2" style="width:1.25em;height:1.25em;"></i> Evaluation Details</span></h3>
                            <button onclick="closeEvaluationDetailsModal()" style="background:none;border:none;font-size:1.5rem;cursor:pointer;color:var(--text-light);padding:0.25rem;" aria-label="Close"><i data-lucide="x" style="width:1.25em;height:1.25em;"></i></button>
                        </div>
                        ${detailsHTML}
                        <div style="margin-top:2rem;display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:0.75rem;">
                            <div style="display:flex;gap:0.75rem;flex-wrap:wrap;">
                                <button type="button" onclick="openComparePicker('${evaluation.id}')" style="padding:0.75rem 1.25rem;background:var(--bg-alt);color:var(--primary);border:1px solid var(--primary);border-radius:0.5rem;cursor:pointer;font-weight:500;">
                                    <span class="icon-with-text"><i data-lucide="git-compare" style="width:1em;height:1em;"></i> Compare with another speech</span>
                                </button>
                                <button type="button" onclick="closeEvaluationDetailsModal(); openMoveEvalModal('${evaluation.id}', '${evaluation.course_id || ''}', '${evaluation.student_id || ''}');" style="padding:0.75rem 1.25rem;background:var(--bg-alt);color:var(--primary);border:1px solid var(--primary);border-radius:0.5rem;cursor:pointer;font-weight:500;">
                                    <span class="icon-with-text"><i data-lucide="move" style="width:1em;height:1em;"></i> Move</span>
                                </button>
                            </div>
                            <button onclick="closeEvaluationDetailsModal()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;">
                                Close
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            window._evalDetailsPreviousFocus = document.activeElement && document.activeElement.nodeName ? document.activeElement : null;
            document.body.insertAdjacentHTML('beforeend', modal);
            var modalEl = document.getElementById('evaluationDetailsModal');
            if (modalEl && typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: modalEl });
            var closeBtn = modalEl ? modalEl.querySelector('button[onclick*="closeEvaluationDetailsModal"]') : null;
            if (closeBtn) closeBtn.focus();
        }
        
        // Close evaluation details modal
        function closeEvaluationDetailsModal() {
            const modal = document.getElementById('evaluationDetailsModal');
            if (modal) {
                if (window._evalDetailsPreviousFocus && typeof window._evalDetailsPreviousFocus.focus === 'function' && window._evalDetailsPreviousFocus.isConnected) window._evalDetailsPreviousFocus.focus();
                window._evalDetailsPreviousFocus = null;
                modal.remove();
            }
        }
        
        // --- Compare one speech to another (e.g. Persuasive 1 vs Persuasive 2) ---
        function openComparePicker(currentEvaluationId) {
            const evaluation = (window.evaluationsFullListWithDetails || window.allEvaluationsList || analyticsData.filtered || []).find(e => e.id === currentEvaluationId);
            if (!evaluation) {
                alert('Evaluation not found.');
                return;
            }
            window._comparePickerPreviousFocus = document.activeElement && document.activeElement.nodeName ? document.activeElement : null;
            const sameStudentCourse = (window.evaluationsFullListWithDetails || window.allEvaluationsList || analyticsData.filtered || []).filter(
                e => e.student_id === evaluation.student_id && e.course_id === evaluation.course_id && e.id !== evaluation.id
            );
            if (sameStudentCourse.length === 0) {
                alert('No other evaluations found for this student in this course. Add another speech (e.g. Persuasive Speech 2) to compare.');
                return;
            }
            const rubricName = (e) => {
                let d = e.evaluation_data;
                if (typeof d === 'string') try { d = JSON.parse(d); } catch (_) {} return (d && d.rubricUsed) || e.rubric?.name || 'Speech';
            };
            let pickerHTML = `
                <div id="comparePickerModal" style="display:flex;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:10000;align-items:center;justify-content:center;">
                    <div style="background:white;padding:1.5rem;border-radius:1rem;max-width:420px;width:90%;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                        <h4 style="margin:0 0 1rem 0;color:var(--primary);">Compare with which speech?</h4>
                        <p style="color:var(--text-light);font-size:0.9rem;margin-bottom:1rem;">Compare this evaluation to another by the same student to see improvement.</p>
                        <div style="display:flex;flex-direction:column;gap:0.5rem;">
            `;
            sameStudentCourse.forEach(ev => {
                const date = new Date(ev.created_at).toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });
                const label = rubricName(ev) + ' – ' + date;
                pickerHTML += `<button type="button" onclick="showComparisonModal('${evaluation.id}','${ev.id}'); closeComparePickerModal();" style="text-align:left;padding:0.75rem 1rem;background:var(--bg-alt);border:1px solid var(--border);border-radius:0.5rem;cursor:pointer;color:var(--text);">${escapeHtml(label)}</button>`;
            });
            pickerHTML += `
                        </div>
                        <div style="margin-top:1rem;text-align:right;">
                            <button type="button" onclick="closeComparePickerModal()" style="padding:0.5rem 1rem;background:var(--bg-alt);border:none;border-radius:0.5rem;cursor:pointer;">Cancel</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', pickerHTML);
            var pickerEl = document.getElementById('comparePickerModal');
            if (pickerEl && typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: pickerEl });
            var cancelBtn = pickerEl ? pickerEl.querySelector('button[onclick*="closeComparePickerModal"]') : null;
            if (cancelBtn) cancelBtn.focus();
        }
        
        function closeComparePickerModal() {
            const el = document.getElementById('comparePickerModal');
            if (el) {
                if (window._comparePickerPreviousFocus && typeof window._comparePickerPreviousFocus.focus === 'function' && window._comparePickerPreviousFocus.isConnected) window._comparePickerPreviousFocus.focus();
                window._comparePickerPreviousFocus = null;
                el.remove();
            }
        }
        
        function getEvalData(ev) {
            let d = ev.evaluation_data;
            if (typeof d === 'string') try { d = JSON.parse(d); } catch (_) { d = null; }
            return d;
        }
        
        function buildComparisonHTML(evalA, evalB) {
            const dataA = getEvalData(evalA);
            const dataB = getEvalData(evalB);
            const sectionsA = (dataA && dataA.sections && typeof dataA.sections === 'object') ? dataA.sections : {};
            const sectionsB = (dataB && dataB.sections && typeof dataB.sections === 'object') ? dataB.sections : {};
            const rubricName = (d) => (d && d.rubricUsed) || 'Speech';
            const dateStr = (e) => new Date(e.created_at).toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });
            const labelA = rubricName(dataA) + ' (' + dateStr(evalA) + ')';
            const labelB = rubricName(dataB) + ' (' + dateStr(evalB) + ')';
            
            let overallA = 0, maxA = 0, overallB = 0, maxB = 0;
            Object.values(sectionsA).forEach(s => { if (s.score != null && s.maxScore) { overallA += parseFloat(s.score); maxA += parseFloat(s.maxScore); } });
            Object.values(sectionsB).forEach(s => { if (s.score != null && s.maxScore) { overallB += parseFloat(s.score); maxB += parseFloat(s.maxScore); } });
            const pctA = maxA ? ((overallA / maxA) * 100).toFixed(1) : '—';
            const pctB = maxB ? ((overallB / maxB) * 100).toFixed(1) : '—';
            const delta = (maxA && maxB) ? (parseFloat(pctB) - parseFloat(pctA)).toFixed(1) : '—';
            const deltaSign = (delta !== '—' && parseFloat(delta) > 0) ? '+' : '';
            const deltaColor = (delta === '—') ? 'var(--text-light)' : (parseFloat(delta) >= 0 ? 'var(--success)' : 'var(--error)');
            
            const allCategories = new Set([...Object.keys(sectionsA), ...Object.keys(sectionsB)]);
            let rows = '';
            allCategories.forEach(cat => {
                const sA = sectionsA[cat];
                const sB = sectionsB[cat];
                const scoreA = (sA && sA.score != null && sA.maxScore) ? (parseFloat(sA.score) / parseFloat(sA.maxScore) * 100).toFixed(1) : '—';
                const scoreB = (sB && sB.score != null && sB.maxScore) ? (parseFloat(sB.score) / parseFloat(sB.maxScore) * 100).toFixed(1) : '—';
                let diff = '—';
                let diffColor = 'var(--text-light)';
                if (scoreA !== '—' && scoreB !== '—') {
                    const d = (parseFloat(scoreB) - parseFloat(scoreA)).toFixed(1);
                    diff = (parseFloat(d) >= 0 ? '+' : '') + d + '%';
                    diffColor = parseFloat(d) >= 0 ? 'var(--success)' : 'var(--error)';
                }
                rows += `<tr><td style="padding:0.5rem;border-bottom:1px solid var(--border);"><strong>${escapeHtml(cat)}</strong></td><td style="padding:0.5rem;border-bottom:1px solid var(--border);">${scoreA}%</td><td style="padding:0.5rem;border-bottom:1px solid var(--border);">${scoreB}%</td><td style="padding:0.5rem;border-bottom:1px solid var(--border);color:${diffColor};font-weight:600;">${diff}</td></tr>`;
            });
            
            return `
                <div style="margin-bottom:1rem;">
                    <p style="margin:0 0 0.5rem 0;"><strong>Overall</strong></p>
                    <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:0.75rem;margin-bottom:1rem;">
                        <div style="background:var(--bg-alt);padding:0.75rem;border-radius:0.5rem;"><div style="font-size:0.8rem;color:var(--text-light);">First speech</div><div style="font-weight:700;">${overallA}/${maxA} (${pctA}%)</div></div>
                        <div style="background:var(--bg-alt);padding:0.75rem;border-radius:0.5rem;"><div style="font-size:0.8rem;color:var(--text-light);">Second speech</div><div style="font-weight:700;">${overallB}/${maxB} (${pctB}%)</div></div>
                        <div style="background:var(--bg-alt);padding:0.75rem;border-radius:0.5rem;"><div style="font-size:0.8rem;color:var(--text-light);">Change</div><div style="font-weight:700;color:${deltaColor};">${deltaSign}${delta}%</div></div>
                    </div>
                </div>
                <p style="margin:0 0 0.5rem 0;"><strong>By category (percentage)</strong></p>
                <div style="overflow-x:auto;">
                    <table style="width:100%;border-collapse:collapse;">
                        <thead><tr style="background:var(--bg-alt);"><th style="padding:0.5rem;text-align:left;">Category</th><th style="padding:0.5rem;">${escapeHtml(labelA)}</th><th style="padding:0.5rem;">${escapeHtml(labelB)}</th><th style="padding:0.5rem;">Change</th></tr></thead>
                        <tbody>${rows}</tbody>
                    </table>
                </div>
            `;
        }
        
        function showComparisonModal(evalAId, evalBId) {
            window._comparisonModalPreviousFocus = document.activeElement && document.activeElement.nodeName ? document.activeElement : null;
            const list = window.evaluationsFullListWithDetails || window.allEvaluationsList || analyticsData.filtered || [];
            const evalA = list.find(e => e.id === evalAId);
            const evalB = list.find(e => e.id === evalBId);
            if (!evalA || !evalB) {
                alert('One or both evaluations not found.');
                return;
            }
            const studentName = evalA.course_students ? `${evalA.course_students.first_name} ${evalA.course_students.last_name}` : 'Unknown';
            const comparisonHTML = buildComparisonHTML(evalA, evalB);
            const modal = `
                <div id="comparisonModal" style="display:flex;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:10000;align-items:center;justify-content:center;">
                    <div style="background:white;padding:2rem;border-radius:1rem;max-width:720px;width:95%;max-height:90vh;overflow-y:auto;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:1.5rem;">
                            <h3 style="margin:0;color:var(--primary);"><span class="icon-with-text"><i data-lucide="git-compare" style="width:1.25em;height:1.25em;"></i> Speech comparison – ${escapeHtml(studentName)}</span></h3>
                            <button type="button" onclick="closeComparisonModal()" style="background:none;border:none;font-size:1.5rem;cursor:pointer;color:var(--text-light);padding:0.25rem;" aria-label="Close"><i data-lucide="x" style="width:1.25em;height:1.25em;"></i></button>
                        </div>
                        ${comparisonHTML}
                        <div style="margin-top:1.5rem;text-align:right;">
                            <button type="button" onclick="closeComparisonModal()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;">Close</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modal);
            var modalEl = document.getElementById('comparisonModal');
            if (modalEl && typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: modalEl });
            var closeBtn = modalEl ? modalEl.querySelector('button[onclick="closeComparisonModal()"]') : null;
            if (closeBtn) closeBtn.focus();
        }
        
        function closeComparisonModal() {
            const el = document.getElementById('comparisonModal');
            if (el) {
                var returnEl = window._comparisonModalPreviousFocus;
                el.remove();
                if (returnEl && typeof returnEl.focus === 'function' && returnEl.isConnected) returnEl.focus();
            }
        }
        
        // Load department analytics (old function kept for compatibility)
        async function loadDepartmentAnalytics() {
            
            if (!currentUser.department_id) {
                var deptContainer = document.getElementById('departmentAnalyticsContainer');
                deptContainer.innerHTML = '<p style="color: var(--warning);"><span class="icon-with-text"><i data-lucide="alert-triangle" style="width:1.1em;height:1.1em;"></i> You are not assigned to a department.</span></p>';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: deptContainer });
                return;
            }
            
            const container = document.getElementById('departmentAnalyticsContainer');
            container.innerHTML = '<p style="color: var(--text-light);">Loading analytics...</p>';
            
            try {
                // Get date range filters (optional when global filter bar removed)
                const startDate = document.getElementById('analyticsStartDate')?.value || '';
                const endDate = document.getElementById('analyticsEndDate')?.value || '';
                
                // Get all instructors in department
                const { data: instructors, error: instError } = await supabaseClient
                    .from('user_profiles')
                    .select('id, email, full_name')
                    .eq('department_id', currentUser.department_id)
                    .eq('account_tier', 'instructor');
                
                if (instError) throw instError;
                
                if (!instructors || instructors.length === 0) {
                    container.innerHTML = '<p style="color: var(--text-light);">No instructors in department.</p>';
                    return;
                }
                
                // Get all evaluations for department instructors
                let query = supabaseClient
                    .from('evaluations')
                    .select(`
                        id,
                        instructor_id,
                        course_id,
                        student_id,
                        created_at,
                        evaluation_data
                    `)
                    .in('instructor_id', instructors.map(i => i.id));
                
                // Apply date filters if set
                if (startDate) {
                    query = query.gte('created_at', startDate);
                }
                if (endDate) {
                    query = query.lte('created_at', endDate + 'T23:59:59');
                }
                
                const { data: evaluations, error: evalError } = await query;
                
                if (evalError) throw evalError;
                
                // Calculate statistics
                const stats = calculateDepartmentStats(instructors, evaluations || []);
                
                // Display analytics
                displayDepartmentAnalytics(stats);
                
            } catch (error) {
                console.error('Error loading analytics:', error);
                container.innerHTML = '<p style="color: var(--error);">Error loading analytics. Please try again.</p>';
            }
        }
        
        // Calculate department statistics
        function calculateDepartmentStats(instructors, evaluations) {
            const stats = {
                totalInstructors: instructors.length,
                totalEvaluations: evaluations.length,
                instructorStats: [],
                dateRange: {
                    start: document.getElementById('analyticsStartDate')?.value || 'All time',
                    end: document.getElementById('analyticsEndDate')?.value || 'Present'
                }
            };
            
            // Calculate per-instructor stats
            instructors.forEach(instructor => {
                const instructorEvals = evaluations.filter(e => e.instructor_id === instructor.id);
                const uniqueStudents = new Set(instructorEvals.map(e => e.student_id)).size;
                const uniqueCourses = new Set(instructorEvals.map(e => e.course_id)).size;
                
                stats.instructorStats.push({
                    name: instructor.full_name || instructor.email,
                    email: instructor.email,
                    evaluationCount: instructorEvals.length,
                    studentCount: uniqueStudents,
                    courseCount: uniqueCourses
                });
            });
            
            // Sort by evaluation count
            stats.instructorStats.sort((a, b) => b.evaluationCount - a.evaluationCount);
            
            return stats;
        }
        
        // Display department analytics
        function displayDepartmentAnalytics(stats) {
            const container = document.getElementById('departmentAnalyticsContainer');
            
            let html = `
                <!-- Overview Cards -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
                    <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; border-left: 4px solid var(--primary);">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--primary);">${stats.totalInstructors}</div>
                        <div style="color: var(--text-light); margin-top: 0.5rem;">Total Instructors</div>
                    </div>
                    <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; border-left: 4px solid var(--success);">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--success);">${stats.totalEvaluations}</div>
                        <div style="color: var(--text-light); margin-top: 0.5rem;">Total Evaluations</div>
                    </div>
                    <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; border-left: 4px solid var(--secondary);">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--secondary);">${stats.totalEvaluations > 0 ? Math.round(stats.totalEvaluations / stats.totalInstructors) : 0}</div>
                        <div style="color: var(--text-light); margin-top: 0.5rem;">Avg per Instructor</div>
                    </div>
                </div>
                
                <div style="background: var(--bg-alt); padding: 1rem; border-radius: 0.5rem; margin-bottom: 2rem;">
                    <p style="margin: 0; color: var(--text-light); font-size: 0.9rem;">
                        <span class="icon-with-text"><i data-lucide="calendar"></i> Date Range:</span> ${stats.dateRange.start} to ${stats.dateRange.end}
                    </p>
                </div>
                
                <!-- Instructor Breakdown Table -->
                <h4 style="margin-bottom: 1rem;">Instructor Activity</h4>
                <div style="background: var(--bg); border: 1px solid var(--border); border-radius: 0.5rem; overflow: hidden;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead style="background: var(--bg-alt);">
                            <tr>
                                <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Instructor</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Courses</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Students</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Evaluations</th>
                                <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">% of Total</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            stats.instructorStats.forEach(instructor => {
                const percentage = stats.totalEvaluations > 0 
                    ? Math.round((instructor.evaluationCount / stats.totalEvaluations) * 100)
                    : 0;
                
                html += `
                    <tr style="border-bottom: 1px solid var(--border);">
                        <td style="padding: 0.75rem;">
                            <strong>${instructor.name}</strong>
                            <br><small style="color: var(--text-light);">${instructor.email}</small>
                        </td>
                        <td style="padding: 0.75rem; text-align: center;">${instructor.courseCount}</td>
                        <td style="padding: 0.75rem; text-align: center;">${instructor.studentCount}</td>
                        <td style="padding: 0.75rem; text-align: center;"><strong>${instructor.evaluationCount}</strong></td>
                        <td style="padding: 0.75rem; text-align: center;">
                            <div style="background: var(--bg-alt); border-radius: 0.25rem; padding: 0.25rem;">
                                ${percentage}%
                            </div>
                        </td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
            `;
            
            container.innerHTML = html;
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: container });
            console.log('✓ Analytics loaded:', stats);
        }
        
        // Export department data to CSV (for research - SPSS compatible)
        async function exportDepartmentData() {
            if (!supabaseClient || !isAdmin()) return;
            
            if (!currentUser.department_id) {
                alert('You are not assigned to a department.');
                return;
            }
            
            try {
                console.log('💾 Exporting SPSS-compatible department data...');
                
                // Get date range filters (optional when global filter bar removed)
                const startDate = document.getElementById('analyticsStartDate')?.value || '';
                const endDate = document.getElementById('analyticsEndDate')?.value || '';
                
                // Get all instructors in department
                const { data: instructors, error: instError } = await supabaseClient
                    .from('user_profiles')
                    .select('id, email, full_name, is_research_partner')
                    .eq('department_id', currentUser.department_id)
                    .eq('account_tier', 'instructor');
                
                if (instError) throw instError;
                
                // Get all evaluations with full details (explicit FKs: DB has multiple FKs to courses and course_students)
                let query = supabaseClient
                    .from('evaluations')
                    .select(`
                        id,
                        instructor_id,
                        course_id,
                        student_id,
                        rubric_id,
                        created_at,
                        evaluation_data,
                        courses!fk_evaluations_course (id, name, semester, year),
                        course_students!fk_evaluations_student (id, first_name, last_name),
                        rubric:rubrics!fk_evaluations_rubric(id, name)
                    `)
                    .in('instructor_id', instructors.map(i => i.id))
                    .is('deleted_locally_at', null);
                
                // Apply date filters
                if (startDate) query = query.gte('created_at', startDate);
                if (endDate) query = query.lte('created_at', endDate + 'T23:59:59');
                
                const { data: evaluations, error: evalError } = await query;
                
                if (evalError) throw evalError;
                
                if (!evaluations || evaluations.length === 0) {
                    alert('No evaluation data found for the selected date range.');
                    return;
                }
                
                // Phase 3: Only export evaluations for students who have consented (suitable for research/LLM)
                const courseIds = [...new Set(evaluations.map(e => e.course_id))];
                const { data: consentedRows, error: consentErr } = await supabaseClient
                    .from('consent_forms')
                    .select('course_id, student_id')
                    .eq('consent_type', 'data_collection')
                    .eq('consent_given', true)
                    .in('course_id', courseIds);
                if (consentErr) {
                    console.error('Error fetching consent for export:', consentErr);
                    alert('Could not verify student consent. Export cancelled.');
                    return;
                }
                const consentedSet = new Set((consentedRows || []).map(r => r.course_id + '|' + r.student_id));
                const evaluationsConsented = evaluations.filter(e => consentedSet.has(e.course_id + '|' + e.student_id));
                if (evaluationsConsented.length === 0) {
                    alert('No evaluations with student consent in the selected date range.\n\nOnly students who have submitted consent (via the consent link) can be included in research/LLM export.');
                    return;
                }
                if (evaluationsConsented.length < evaluations.length) {
                    console.log('Export: including only consented students:', evaluationsConsented.length, 'of', evaluations.length);
                }
                
                // Create instructor lookup
                const instructorMap = {};
                instructors.forEach(i => {
                    instructorMap[i.id] = i;
                });
                
                // Apply column filters from Export tab (Rubric, Assignment Type, etc.) so CSV matches preview
                const evaluationsToExport = getExportColumnFilteredEvaluations(evaluationsConsented, { instructorMap: instructorMap });
                if (evaluationsToExport.length === 0) {
                    alert('No evaluations match the current column filters. Clear filters (click ▾ on column headers) or adjust your selections to export.');
                    return;
                }
                
                // Audit: log export of evaluation/student data for FERPA
                await logAccess('export', 'evaluations', null, null, { evaluation_count: evaluationsToExport.length, format: 'csv', purpose: 'department_export', consented_only: true });
                
                // Collect all unique rubric categories across filtered evaluations
                const allCategories = new Set();
                evaluationsToExport.forEach(eval => {
                    let evalData = eval.evaluation_data;
                    if (typeof evalData === 'string') {
                        try {
                            evalData = JSON.parse(evalData);
                        } catch (e) {
                            return;
                        }
                    }
                    
                    // sections is an object like { "Content": {...}, "Delivery": {...} }
                    if (evalData?.sections && typeof evalData.sections === 'object') {
                        // Add section names
                        Object.keys(evalData.sections).forEach(sectionName => {
                            allCategories.add(sectionName);
                        });
                        
                        // Add subcategory/feedback item names
                        Object.values(evalData.sections).forEach(section => {
                            const items = section.subcategories || section.feedback || [];
                            if (Array.isArray(items)) {
                                items.forEach(item => {
                                    if (item.name) {
                                        allCategories.add(item.name);
                                    }
                                });
                            }
                        });
                    }
                });
                
                const categoryList = Array.from(allCategories).sort();
                
                // Build SPSS-compatible CSV header
                let csv = 'EvalID,Date,Year,Month,Day,';
                csv += 'InstructorID,InstructorName,InstructorEmail,ResearchPartner,';
                csv += 'CourseID,CourseName,Semester,';
                csv += 'RubricID,RubricName,AssignmentType,';
                csv += 'StudentID,StudentFirstName,StudentLastName,';
                
                // Add columns for each rubric category - BOTH raw and percentage
                categoryList.forEach(cat => {
                    // Convert category name to valid variable name (remove spaces, special chars)
                    const varName = cat.replace(/[^a-zA-Z0-9]/g, '_');
                    csv += `${varName}_Raw,${varName}_Pct,${varName}_Max,`;
                });
                
                csv += 'OverallScore_Pct\n';
                
                // Build data rows (filtered by column filters)
                evaluationsToExport.forEach(eval => {
                    const instructor = instructorMap[eval.instructor_id];
                    const date = new Date(eval.created_at);
                    
                    // Basic info
                    csv += `"${eval.id}",`;
                    csv += `"${date.toISOString().split('T')[0]}",`;
                    csv += `${date.getFullYear()},`;
                    csv += `${date.getMonth() + 1},`;
                    csv += `${date.getDate()},`;
                    
                    // Instructor info
                    csv += `"${instructor?.id || ''}",`;
                    csv += `"${(instructor?.full_name || '').replace(/"/g, '""')}",`;
                    csv += `"${instructor?.email || ''}",`;
                    csv += `${instructor?.is_research_partner ? '1' : '0'},`;
                    
                    // Course info
                    csv += `"${eval.course_id || ''}",`;
                    csv += `"${(eval.courses?.name || '').replace(/"/g, '""')}",`;
                    csv += `"${eval.courses?.semester && eval.courses?.year ? eval.courses.semester + ' ' + eval.courses.year : ''}",`;
                    
                    // Rubric info (handle join as object or array; Supabase may return as rubrics or rubric)
                    const rubric = (eval.rubrics && (Array.isArray(eval.rubrics) ? eval.rubrics[0] : eval.rubrics)) || (eval.rubric && (Array.isArray(eval.rubric) ? eval.rubric[0] : eval.rubric));
                    csv += `"${eval.rubric_id || ''}",`;
                    csv += `"${(rubric?.name || '').replace(/"/g, '""')}",`;
                    
                    // Parse evaluation data (used for assignmentType and scores)
                    let evalData = eval.evaluation_data;
                    if (typeof evalData === 'string') {
                        try {
                            evalData = JSON.parse(evalData);
                        } catch (e) {
                            evalData = null;
                        }
                    }
                    const assignmentTypeVal = ((evalData && evalData.assignmentType) || '').replace(/"/g, '""');
                    csv += `"${assignmentTypeVal}",`;
                    
                    // Student info
                    csv += `"${eval.student_id || ''}",`;
                    csv += `"${(eval.course_students?.first_name || '').replace(/"/g, '""')}",`;
                    csv += `"${(eval.course_students?.last_name || '').replace(/"/g, '""')}",`;
                    
                    // Create score lookup for this evaluation
                    const scores = {};
                    let allPercentages = [];
                    
                    if (evalData?.sections && typeof evalData.sections === 'object') {
                        Object.entries(evalData.sections).forEach(([sectionName, section]) => {
                            // Add section score
                            if (section.score !== undefined && section.score !== null && section.maxScore) {
                                const raw = parseFloat(section.score);
                                const max = parseFloat(section.maxScore);
                                const pct = (raw / max) * 100;
                                
                                scores[sectionName] = {
                                    raw: raw,
                                    pct: pct.toFixed(1),
                                    max: max
                                };
                                allPercentages.push(pct);
                            }
                            
                            // Add subcategory/feedback item scores
                            const items = section.subcategories || section.feedback || [];
                            if (Array.isArray(items)) {
                                items.forEach(item => {
                                    if (item.name && item.points !== undefined && item.points !== null && item.maxPoints) {
                                        const raw = parseFloat(item.points);
                                        const max = parseFloat(item.maxPoints);
                                        const pct = (raw / max) * 100;
                                        
                                        scores[item.name] = {
                                            raw: raw,
                                            pct: pct.toFixed(1),
                                            max: max
                                        };
                                        allPercentages.push(pct);
                                    }
                                });
                            }
                        });
                    }
                    
                    // Add score for each category (or empty if not present) - raw, pct, max
                    categoryList.forEach(cat => {
                        if (scores[cat]) {
                            csv += `${scores[cat].raw},${scores[cat].pct},${scores[cat].max},`;
                        } else {
                            csv += ',,,'; // Empty raw, pct, max
                        }
                    });
                    
                    // Add overall percentage score
                    const overallPct = allPercentages.length > 0 
                        ? (allPercentages.reduce((a, b) => a + b, 0) / allPercentages.length).toFixed(1)
                        : '';
                    csv += `${overallPct}\n`;
                });
                
                // Download CSV
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                
                const departmentName = currentUser.department?.name || 'Department';
                const dateStr = new Date().toISOString().split('T')[0];
                a.download = `${departmentName}_SPSS_Data_${dateStr}.csv`;
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
                console.log('✓ Exported', evaluationsConsented.length, 'evaluations (consented only) to SPSS-compatible CSV');
                console.log('✓ Rubric categories as columns:', categoryList.length);
                alert(`Success. Exported ${evaluationsConsented.length} evaluations (consented students only) to SPSS-compatible CSV!\n\n` +
                      `File: ${a.download}\n\n` +
                      `Format: Each rubric category has 3 columns:\n` +
                      `  - CategoryName_Raw (actual points earned)\n` +
                      `  - CategoryName_Pct (normalized 0-100%)\n` +
                      `  - CategoryName_Max (max possible points)\n\n` +
                      `Normalized percentages allow fair comparison across different rubrics.\n` +
                      `Numeric codes: ResearchPartner (1=Yes, 0=No)\n` +
                      `Date components: Year, Month, Day for time series analysis`);
                
            } catch (error) {
                console.error('Error exporting data:', error);
                alert('Error exporting data. Please try again.');
            }
        }
        
        /** Super Admin only: export consented evaluations for LLM training (exported.json format). */
        async function exportLLMTrainingData() {
            if (!supabaseClient || !currentUser) return null;
            if (typeof isSuperAdmin !== 'function' || !isSuperAdmin()) {
                console.warn('LLM training export is restricted to Super Admin.');
                return null;
            }
            try {
                const statusEl = document.getElementById('llmExportStatus');
                if (statusEl) statusEl.textContent = 'Loading…';
                let query = supabaseClient
                    .from('evaluations')
                    .select('id, transcript, rubric_id, evaluation_data, student_id, course_id, instructor_id')
                    .not('transcript', 'is', null)
                    .is('exported_for_llm_at', null)
                    .is('deleted_locally_at', null);
                const { data: rows, error } = await query;
                if (error) throw error;
                const allEvals = rows || [];
                if (allEvals.length === 0) {
                    if (statusEl) statusEl.textContent = '';
                    return [];
                }
                const courseIds = [...new Set(allEvals.map(e => e.course_id).filter(Boolean))];
                const { data: consentedRows, error: consentErr } = await supabaseClient
                    .from('consent_forms')
                    .select('course_id, student_id')
                    .eq('consent_type', 'data_collection')
                    .eq('consent_given', true)
                    .in('course_id', courseIds);
                if (consentErr) throw consentErr;
                const consentedSet = new Set((consentedRows || []).map(r => r.course_id + '|' + r.student_id));
                let evaluations = allEvals.filter(e => consentedSet.has(e.course_id + '|' + e.student_id));
                // Only include evaluations from instructors who have given LLM training consent and are NOT demo accounts
                const instructorIds = [...new Set(evaluations.map(e => e.instructor_id).filter(Boolean))];
                if (instructorIds.length > 0) {
                    const { data: profiles, error: profileErr } = await supabaseClient
                        .from('user_profiles')
                        .select('id, llm_training_consent_given, account_tier')
                        .in('id', instructorIds);
                    if (!profileErr && profiles) {
                        const consentedInstructors = new Set(profiles.filter(p => p.llm_training_consent_given === true && p.account_tier !== 'demo').map(p => p.id));
                        const demoInstructors = new Set(profiles.filter(p => p.account_tier === 'demo').map(p => p.id));
                        evaluations = evaluations.filter(e => consentedInstructors.has(e.instructor_id) && !demoInstructors.has(e.instructor_id));
                        if (evaluations.length === 0 && consentedInstructors.size < instructorIds.length) {
                            if (statusEl) statusEl.textContent = 'No evaluations from instructors who have given LLM training consent (demo content excluded).';
                            return [];
                        }
                    }
                }
                if (evaluations.length === 0) {
                    if (statusEl) statusEl.textContent = 'No new consented evaluations (all have been exported already, or none with consent).';
                    return [];
                }
                const out = [];
                for (const row of evaluations) {
                    let data = row.evaluation_data;
                    if (typeof data === 'string') {
                        try { data = JSON.parse(data); } catch (_) { data = null; }
                    }
                    if (!data || !data.sections || typeof data.sections !== 'object') continue;
                    const rubricName = data.rubricUsed || row.rubric_id || 'General';
                    const item = {
                        transcript: row.transcript || '',
                        rubric: rubricName,
                        scores: data.sections,
                        video_notes: (data.video_notes && String(data.video_notes).trim()) || undefined,
                        markers: (data.timeline_markers && Array.isArray(data.timeline_markers)) ? data.timeline_markers : undefined,
                        student_hash: row.student_id ? 's_' + row.student_id : undefined,
                        institution_hash: row.instructor_id ? 'i_' + row.instructor_id : undefined,
                        source_evaluation_id: row.id
                    };
                    if (data.rubric_structure && data.rubric_structure.categories) {
                        item.rubric_structure = data.rubric_structure;
                    }
                    out.push(item);
                }
                await logAccess('export', 'evaluations', null, null, { evaluation_count: out.length, format: 'json', purpose: 'llm_training_export', consented_only: true });
                if (statusEl) statusEl.textContent = '';
                return out;
            } catch (err) {
                console.error('exportLLMTrainingData error:', err);
                const statusEl = document.getElementById('llmExportStatus');
                if (statusEl) statusEl.textContent = 'Export failed.';
                return null;
            }
        }
        
        /** Super Admin only: export consented evaluations that have video_url for Qwen (video) model training. Returns array of { video_path, rubric, scores } for JSONL manifest. */
        async function exportLLMQwenTrainingData() {
            if (!supabaseClient || !currentUser) return null;
            if (typeof isSuperAdmin !== 'function' || !isSuperAdmin()) {
                console.warn('Qwen training export is restricted to Super Admin.');
                return null;
            }
            try {
                const statusEl = document.getElementById('llmQwenExportStatus');
                const statusElA = document.getElementById('llmQwenExportStatusAnalytics');
                if (statusEl) statusEl.textContent = 'Loading…';
                if (statusElA) statusElA.textContent = 'Loading…';
                let query = supabaseClient
                    .from('evaluations')
                    .select('id, video_url, rubric_id, evaluation_data, student_id, course_id, instructor_id')
                    .not('video_url', 'is', null)
                    .is('deleted_locally_at', null);
                const { data: rows, error } = await query;
                if (error) throw error;
                const allEvals = rows || [];
                if (allEvals.length === 0) {
                    if (statusEl) statusEl.textContent = '';
                    if (statusElA) statusElA.textContent = '';
                    return [];
                }
                const courseIds = [...new Set(allEvals.map(e => e.course_id).filter(Boolean))];
                const { data: consentedRows, error: consentErr } = await supabaseClient
                    .from('consent_forms')
                    .select('course_id, student_id')
                    .eq('consent_type', 'data_collection')
                    .eq('consent_given', true)
                    .in('course_id', courseIds);
                if (consentErr) throw consentErr;
                const consentedSet = new Set((consentedRows || []).map(r => r.course_id + '|' + r.student_id));
                let evaluations = allEvals.filter(e => consentedSet.has(e.course_id + '|' + e.student_id));
                const instructorIds = [...new Set(evaluations.map(e => e.instructor_id).filter(Boolean))];
                if (instructorIds.length > 0) {
                    const { data: profiles, error: profileErr } = await supabaseClient
                        .from('user_profiles')
                        .select('id, llm_training_consent_given, account_tier')
                        .in('id', instructorIds);
                    if (!profileErr && profiles) {
                        const consentedInstructors = new Set(profiles.filter(p => p.llm_training_consent_given === true && p.account_tier !== 'demo').map(p => p.id));
                        evaluations = evaluations.filter(e => consentedInstructors.has(e.instructor_id));
                    }
                }
                if (evaluations.length === 0) {
                    if (statusEl) statusEl.textContent = 'No consented evaluations with video. Save evaluations with video first.';
                    if (statusElA) statusElA.textContent = 'No consented evaluations with video. Save evaluations with video first.';
                    return [];
                }
                const out = [];
                for (const row of evaluations) {
                    let data = row.evaluation_data;
                    if (typeof data === 'string') {
                        try { data = JSON.parse(data); } catch (_) { data = null; }
                    }
                    if (!data || !data.sections || typeof data.sections !== 'object') continue;
                    const rs = data.rubric_structure;
                    const rubric = {
                        name: data.rubricUsed || row.rubric_id || 'General',
                        totalPoints: (rs && rs.totalPoints) || 100,
                        categories: (rs && rs.categories) || []
                    };
                    out.push({
                        video_path: row.video_url,
                        rubric: rubric,
                        scores: data.sections
                    });
                }
                await logAccess('export', 'evaluations', null, null, { evaluation_count: out.length, format: 'jsonl', purpose: 'qwen_video_training_export', consented_only: true });
                if (statusEl) statusEl.textContent = '';
                if (statusElA) statusElA.textContent = '';
                return out;
            } catch (err) {
                console.error('exportLLMQwenTrainingData error:', err);
                const statusEl = document.getElementById('llmQwenExportStatus');
                const statusElA = document.getElementById('llmQwenExportStatusAnalytics');
                if (statusEl) statusEl.textContent = 'Export failed.';
                if (statusElA) statusElA.textContent = 'Export failed.';
                return null;
            }
        }

        /** Super Admin only: export comparison pairs (same student, same course, two speeches) for Qwen training. Returns array of { video_path_1, video_path_2, rubric, scores_1, scores_2, evaluation_id_1, evaluation_id_2 }. Used to train the model on "improvement" between speeches. */
        async function exportLLMQwenComparisonPairs() {
            if (!supabaseClient || !currentUser) return null;
            if (typeof isSuperAdmin !== 'function' || !isSuperAdmin()) {
                console.warn('Qwen comparison pairs export is restricted to Super Admin.');
                return null;
            }
            try {
                const statusEl = document.getElementById('llmQwenPairsExportStatus');
                const statusElA = document.getElementById('llmQwenPairsExportStatusAnalytics');
                if (statusEl) statusEl.textContent = 'Loading…';
                if (statusElA) statusElA.textContent = 'Loading…';
                let query = supabaseClient
                    .from('evaluations')
                    .select('id, video_url, rubric_id, evaluation_data, student_id, course_id, instructor_id, created_at')
                    .not('video_url', 'is', null)
                    .is('deleted_locally_at', null)
                    .order('created_at', { ascending: true });
                const { data: rows, error } = await query;
                if (error) throw error;
                const allEvals = rows || [];
                const courseIds = [...new Set(allEvals.map(e => e.course_id).filter(Boolean))];
                const { data: consentedRows, error: consentErr } = await supabaseClient
                    .from('consent_forms')
                    .select('course_id, student_id')
                    .eq('consent_type', 'data_collection')
                    .eq('consent_given', true)
                    .in('course_id', courseIds);
                if (consentErr) throw consentErr;
                const consentedSet = new Set((consentedRows || []).map(r => r.course_id + '|' + r.student_id));
                let evaluations = allEvals.filter(e => consentedSet.has(e.course_id + '|' + e.student_id));
                const instructorIds = [...new Set(evaluations.map(e => e.instructor_id).filter(Boolean))];
                if (instructorIds.length > 0) {
                    const { data: profiles, error: profileErr } = await supabaseClient
                        .from('user_profiles')
                        .select('id, llm_training_consent_given, account_tier')
                        .in('id', instructorIds);
                    if (!profileErr && profiles) {
                        const consentedInstructors = new Set(profiles.filter(p => p.llm_training_consent_given === true && p.account_tier !== 'demo').map(p => p.id));
                        evaluations = evaluations.filter(e => consentedInstructors.has(e.instructor_id));
                    }
                }
                var key = function(e) { return (e.course_id || '') + '|' + (e.student_id || ''); };
                var byStudentCourse = {};
                evaluations.forEach(function(ev) {
                    var k = key(ev);
                    if (!byStudentCourse[k]) byStudentCourse[k] = [];
                    byStudentCourse[k].push(ev);
                });
                var out = [];
                Object.values(byStudentCourse).forEach(function(group) {
                    group.sort(function(a, b) { return new Date(a.created_at) - new Date(b.created_at); });
                    for (var i = 0; i < group.length - 1; i++) {
                        var row1 = group[i], row2 = group[i + 1];
                        var data1 = row1.evaluation_data; if (typeof data1 === 'string') try { data1 = JSON.parse(data1); } catch (_) { data1 = null; }
                        var data2 = row2.evaluation_data; if (typeof data2 === 'string') try { data2 = JSON.parse(data2); } catch (_) { data2 = null; }
                        if (!data1 || !data1.sections || typeof data1.sections !== 'object') continue;
                        if (!data2 || !data2.sections || typeof data2.sections !== 'object') continue;
                        var rs = data1.rubric_structure || data2.rubric_structure;
                        var rubric = {
                            name: data1.rubricUsed || data2.rubricUsed || 'General',
                            totalPoints: (rs && rs.totalPoints) || 100,
                            categories: (rs && rs.categories) || []
                        };
                        out.push({
                            video_path_1: row1.video_url,
                            video_path_2: row2.video_url,
                            rubric: rubric,
                            scores_1: data1.sections,
                            scores_2: data2.sections,
                            evaluation_id_1: row1.id,
                            evaluation_id_2: row2.id
                        });
                    }
                });
                await logAccess('export', 'evaluations', null, null, { pair_count: out.length, format: 'jsonl', purpose: 'qwen_comparison_pairs_export', consented_only: true });
                if (statusEl) statusEl.textContent = out.length ? 'Downloaded ' + out.length + ' pair(s).' : 'No pairs (need 2+ videos per student per course).';
                if (statusElA) statusElA.textContent = out.length ? 'Downloaded ' + out.length + ' pair(s).' : 'No pairs (need 2+ videos per student per course).';
                return out;
            } catch (err) {
                console.error('exportLLMQwenComparisonPairs error:', err);
                const statusEl = document.getElementById('llmQwenPairsExportStatus');
                const statusElA = document.getElementById('llmQwenPairsExportStatusAnalytics');
                if (statusEl) statusEl.textContent = 'Export failed.';
                if (statusElA) statusElA.textContent = 'Export failed.';
                return null;
            }
        }

        function downloadQwenComparisonPairs() {
            exportLLMQwenComparisonPairs().then(function(pairs) {
                if (pairs === null) return;
                if (pairs.length === 0) return;
                var jsonl = pairs.map(function(p) { return JSON.stringify(p); }).join('\n');
                var blob = new Blob([jsonl], { type: 'application/x-ndjson' });
                var a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'train_qwen_pairs.jsonl';
                a.click();
                URL.revokeObjectURL(a.href);
            });
        }

        /** Super Admin only: export AI vs instructor correction pairs (evaluations that have model_output_original and video_url). Each line: { video_path, rubric, scores_original, scores_final } so the model can learn from instructor feedback. */
        async function exportLLMQwenCorrectionPairs() {
            if (!supabaseClient || !currentUser) return null;
            if (typeof isSuperAdmin !== 'function' || !isSuperAdmin()) {
                console.warn('Correction pairs export is restricted to Super Admin.');
                return null;
            }
            try {
                const statusEl = document.getElementById('llmQwenCorrectionExportStatus');
                const statusElA = document.getElementById('llmQwenCorrectionExportStatusAnalytics');
                if (statusEl) statusEl.textContent = 'Loading…';
                if (statusElA) statusElA.textContent = 'Loading…';
                let query = supabaseClient
                    .from('evaluations')
                    .select('id, video_url, rubric_id, evaluation_data, course_id, student_id, instructor_id')
                    .not('video_url', 'is', null)
                    .is('deleted_locally_at', null);
                const { data: rows, error } = await query;
                if (error) throw error;
                const allEvals = rows || [];
                const courseIds = [...new Set(allEvals.map(function(e) { return e.course_id; }).filter(Boolean))];
                const { data: consentedRows, error: consentErr } = await supabaseClient
                    .from('consent_forms')
                    .select('course_id, student_id')
                    .eq('consent_type', 'data_collection')
                    .eq('consent_given', true)
                    .in('course_id', courseIds);
                if (consentErr) throw consentErr;
                const consentedSet = new Set((consentedRows || []).map(r => r.course_id + '|' + r.student_id));
                const instructorIds = [...new Set(allEvals.map(e => e.instructor_id).filter(Boolean))];
                let consentedInstructors = new Set();
                if (instructorIds.length > 0) {
                    const { data: profiles, error: profileErr } = await supabaseClient
                        .from('user_profiles')
                        .select('id, llm_training_consent_given, account_tier')
                        .in('id', instructorIds);
                    if (!profileErr && profiles) {
                        consentedInstructors = new Set(profiles.filter(p => p.llm_training_consent_given === true && p.account_tier !== 'demo').map(p => p.id));
                    }
                }
                const out = [];
                for (const row of allEvals) {
                    if (!consentedSet.has((row.course_id || '') + '|' + (row.student_id || ''))) continue;
                    if (consentedInstructors.size && !consentedInstructors.has(row.instructor_id)) continue;
                    let data = row.evaluation_data;
                    if (typeof data === 'string') try { data = JSON.parse(data); } catch (_) { data = null; }
                    if (!data || !data.sections || typeof data.sections !== 'object') continue;
                    const original = data.model_output_original;
                    if (!original || !original.sections || typeof original.sections !== 'object') continue;
                    const rs = data.rubric_structure;
                    const rubric = { name: data.rubricUsed || row.rubric_id || 'General', totalPoints: (rs && rs.totalPoints) || 100, categories: (rs && rs.categories) || [] };
                    out.push({
                        video_path: row.video_url,
                        rubric: rubric,
                        scores_original: original.sections,
                        scores_final: data.sections,
                        evaluation_id: row.id
                    });
                }
                await logAccess('export', 'evaluations', null, null, { correction_pair_count: out.length, format: 'jsonl', purpose: 'qwen_correction_pairs_export', consented_only: true });
                if (statusEl) statusEl.textContent = out.length ? out.length + ' correction pair(s) ready.' : 'No correction pairs (save evals after editing to store AI vs instructor).';
                if (statusElA) statusElA.textContent = out.length ? out.length + ' correction pair(s) ready.' : 'No correction pairs (save evals after editing to store AI vs instructor).';
                return out;
            } catch (err) {
                console.error('exportLLMQwenCorrectionPairs error:', err);
                const statusEl = document.getElementById('llmQwenCorrectionExportStatus');
                const statusElA = document.getElementById('llmQwenCorrectionExportStatusAnalytics');
                if (statusEl) statusEl.textContent = 'Export failed.';
                if (statusElA) statusElA.textContent = 'Export failed.';
                return null;
            }
        }

        function downloadQwenCorrectionPairs() {
            exportLLMQwenCorrectionPairs().then(function(pairs) {
                if (pairs === null) return;
                if (pairs.length === 0) return;
                var jsonl = pairs.map(function(p) { return JSON.stringify(p); }).join('\n');
                var blob = new Blob([jsonl], { type: 'application/x-ndjson' });
                var a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'train_qwen_correction_pairs.jsonl';
                a.click();
                URL.revokeObjectURL(a.href);
            });
        }

        /** Super Admin only: download Qwen (video) training manifest as train_qwen.jsonl. */
        function downloadQwenManifest() {
            if (typeof isSuperAdmin !== 'function' || !isSuperAdmin()) {
                alert('This action is available only to Super Admins.');
                return;
            }
            var statusEl = document.getElementById('llmQwenExportStatus');
            var statusElA = document.getElementById('llmQwenExportStatusAnalytics');
            if (statusEl) statusEl.textContent = 'Loading…';
            if (statusElA) statusElA.textContent = 'Loading…';
            exportLLMQwenTrainingData().then(function(data) {
                if (statusEl) statusEl.textContent = '';
                if (statusElA) statusElA.textContent = '';
                if (data === null) return;
                if (data.length === 0) {
                    alert('No evaluations with video to export. Save evaluations with a video file first, and ensure student and instructor consent are in place.');
                    return;
                }
                var jsonl = data.map(function(p) { return JSON.stringify(p); }).join('\n');
                var blob = new Blob([jsonl], { type: 'application/x-ndjson' });
                var a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'train_qwen.jsonl';
                a.click();
                URL.revokeObjectURL(a.href);
                if (statusEl) statusEl.textContent = 'Downloaded ' + data.length + ' example(s) as train_qwen.jsonl';
                if (statusElA) statusElA.textContent = 'Downloaded ' + data.length + ' example(s) as train_qwen.jsonl';
            });
        }

        /** Mark evaluations as exported for LLM (set exported_for_llm_at). Super Admin only. */
        async function markEvaluationsExportedForLLM(evaluationIds) {
            if (!evaluationIds || evaluationIds.length === 0 || !supabaseClient) return;
            try {
                const { error } = await supabaseClient
                    .from('evaluations')
                    .update({ exported_for_llm_at: new Date().toISOString() })
                    .in('id', evaluationIds);
                if (error) throw error;
                console.log('✓ Marked', evaluationIds.length, 'evaluations as exported for LLM');
            } catch (err) {
                console.error('markEvaluationsExportedForLLM error:', err);
            }
        }

        /** Trigger download of LLM training data as exported.json (Super Admin only). Only includes data not previously exported; marks as exported after user confirms download. */
        async function downloadLLMTrainingData() {
            if (typeof isSuperAdmin !== 'function' || !isSuperAdmin()) {
                alert('This action is available only to Super Admins.');
                return;
            }
            const statusEl = document.getElementById('llmExportStatus');
            if (statusEl) statusEl.textContent = 'Loading…';
            
            const data = await exportLLMTrainingData();
            if (data === null) {
                if (statusEl) statusEl.textContent = '';
                alert('Export failed. Check the console for details. If you see a column error, run ADD_exported_for_llm.sql in Supabase first.');
                return;
            }
            if (data.length === 0) {
                if (statusEl) statusEl.textContent = 'No new evaluations to export.';
                alert('No new evaluations to export.\n\nOnly evaluations that:\n• have not been exported before\n• have student data-use consent (via the consent link)\n• are from instructors who have given LLM training consent\nare included. Run ADD_exported_for_llm.sql in Supabase if you have not yet.');
                return;
            }
            
            // Trigger download
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json;charset=utf-8;' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'exported.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            
            if (statusEl) statusEl.textContent = 'Download started...';
            
            // Ask user to confirm download was successful before marking evaluations as exported
            const confirmed = confirm(
                `Download started for ${data.length} evaluation(s).\n\n` +
                `Did the file save successfully?\n\n` +
                `Click OK to mark these evaluations as exported (they won't appear in future exports).\n` +
                `Click Cancel if the download failed and you want to try again.`
            );
            
            if (confirmed) {
                var ids = data.map(function(d) { return d.source_evaluation_id; }).filter(Boolean);
                if (ids.length) await markEvaluationsExportedForLLM(ids);
                if (statusEl) statusEl.textContent = 'Downloaded ' + data.length + ' evaluation(s). They will not be included in the next export.';
                console.log('✓ Exported', data.length, 'evaluations for LLM training (exported.json); marked as exported');
            } else {
                if (statusEl) statusEl.textContent = 'Download cancelled or failed. Evaluations not marked; try again.';
                console.log('⚠️ User cancelled marking evaluations as exported');
            }
        }

        /** Export LLM training data and submit (same-origin /api/llm-export on Render, or webhook URL for local). Super Admin only. */
        async function submitLLMTrainingToWebhook() {
            if (typeof isSuperAdmin !== 'function' || !isSuperAdmin()) {
                alert('This action is available only to Super Admins.');
                return;
            }
            var webhookInput = document.getElementById('llmExportWebhookUrl');
            var webhookUrl = webhookInput ? (webhookInput.value || '').trim() : '';
            var apiUrl = webhookUrl || (window.location.origin + '/api/llm-export');
            var statusEl = document.getElementById('llmExportStatus');
            var settingsStatusEl = document.getElementById('llmTrainingSettingsStatus');
            function setStatus(msg) {
                if (statusEl) statusEl.textContent = msg;
                if (settingsStatusEl) settingsStatusEl.textContent = msg;
            }
            setStatus('Loading…');
            var data = await exportLLMTrainingData();
            if (data === null) {
                setStatus('');
                alert('Export failed. Check the console for details.');
                return;
            }
            if (data.length === 0) {
                setStatus('');
                alert('No new evaluations to export. Only evaluations with student consent, instructor LLM consent, and not yet exported are included.');
                return;
            }
            var secretEl = document.getElementById('llmExportApiSecret');
            var secret = secretEl ? (secretEl.value || '').trim() : '';
            if (!secret) {
                setStatus('');
                alert('Please enter the API secret in the "API secret (if set on server)" field above.\n\nUse the same value as RENDER_LLM_EXPORT_SECRET in your Render service Environment.');
                return;
            }
            var headers = { 'Content-Type': 'application/json' };
            headers['X-LLM-Export-Secret'] = secret;
            try {
                var res = await fetch(apiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(data)
                });
                var text = await res.text();
                if (!res.ok) {
                    var msg = (res.status === 401 ? 'Invalid or missing API secret. ' : '') + 'Server returned ' + res.status + ': ' + text;
                    if (res.status === 403 && text.indexOf('RENDER_LLM_EXPORT_SECRET') !== -1) {
                        msg = 'Submit to ISAAC requires RENDER_LLM_EXPORT_SECRET on the server.\n\n' +
                            '• Local: Add RENDER_LLM_EXPORT_SECRET=your_secret to your .env file, restart the server (./run_local.sh), then enter the same value in the "API secret" field (Webhook / API secret) and try again.\n\n' +
                            '• Render: Set RENDER_LLM_EXPORT_SECRET in the Render dashboard (Environment), then enter the same value in the "API secret" field.';
                    }
                    if (res.status === 401) {
                        msg += '\n\nTip: In Render dashboard → your service → Logs, search for "llm-export 401" to see header vs secret length (0 = not sent).';
                    }
                    throw new Error(msg);
                }
                var ids = data.map(function(d) { return d.source_evaluation_id; }).filter(Boolean);
                if (ids.length) await markEvaluationsExportedForLLM(ids);
                setStatus('Sent ' + data.length + ' evaluation(s); training submitted to ISAAC.');
                if (typeof localStorage !== 'undefined' && webhookUrl) localStorage.setItem('llm_export_webhook_url', webhookUrl);
                console.log('✓ Exported and submitted', data.length, 'evaluations; marked as exported');
            } catch (err) {
                setStatus('');
                alert('Submit failed: ' + (err.message || err));
                console.error('submitLLMTrainingToWebhook error:', err);
            }
        }

        /** Export Qwen (video) training manifest and submit to ISAAC. Super Admin only. Requires evaluations with video stored (save with video in UI). */
        async function submitQwenTrainingToWebhook() {
            if (typeof isSuperAdmin !== 'function' || !isSuperAdmin()) {
                alert('This action is available only to Super Admins.');
                return;
            }
            var webhookInput = document.getElementById('llmExportWebhookUrl');
            var webhookUrl = webhookInput ? (webhookInput.value || '').trim() : '';
            var apiUrl = webhookUrl ? (webhookUrl.replace(/\/api\/llm-export.*$/, '') + '/api/llm-export-qwen') : (window.location.origin + '/api/llm-export-qwen');
            var statusEl = document.getElementById('llmQwenExportStatus');
            var statusElAnalytics = document.getElementById('llmQwenExportStatusAnalytics');
            var setStatus = function(msg) { if (statusEl) statusEl.textContent = msg; if (statusElAnalytics) statusElAnalytics.textContent = msg; };
            setStatus('Loading…');
            var data = await exportLLMQwenTrainingData();
            if (data === null) {
                setStatus('');
                alert('Export failed. Check the console for details.');
                return;
            }
            if (data.length === 0) {
                setStatus('');
                alert('No evaluations with video to export. Save evaluations with a video file first, and ensure consent is in place.');
                return;
            }
            var secretEl = document.getElementById('llmExportApiSecret');
            var secret = secretEl ? (secretEl.value || '').trim() : '';
            if (!secret) {
                setStatus('');
                alert('Please enter the API secret in the "API secret (if set on server)" field above.\n\nUse the same value as RENDER_LLM_EXPORT_SECRET in your Render service Environment.');
                return;
            }
            var headers = { 'Content-Type': 'application/json' };
            headers['X-LLM-Export-Secret'] = secret;
            try {
                var res = await fetch(apiUrl, { method: 'POST', headers: headers, body: JSON.stringify(data) });
                var text = await res.text();
                if (!res.ok) {
                    var msg = (res.status === 401 ? 'Invalid or missing API secret. ' : '') + 'Server returned ' + res.status + ': ' + text;
                    if (res.status === 403 && text.indexOf('RENDER_LLM_EXPORT_SECRET') !== -1) {
                        msg = 'Submit to ISAAC requires RENDER_LLM_EXPORT_SECRET on the server.\n\n' +
                            '• Local: Add RENDER_LLM_EXPORT_SECRET=your_secret to your .env file, restart the server (./run_local.sh), then enter the same value in the "API secret" field (Webhook / API secret) and try again.\n\n' +
                            '• Render: Set RENDER_LLM_EXPORT_SECRET in the Render dashboard (Environment), then enter the same value in the "API secret" field.';
                    }
                    if (res.status === 401) {
                        msg += '\n\nTip: In Render dashboard → your service → Logs, search for "llm-export 401" to see header vs secret length (0 = not sent).';
                    }
                    throw new Error(msg);
                }
                setStatus('Sent ' + data.length + ' video(s); SpeechGradebook Text + Video Model (Qwen) training submitted to ISAAC.');
                console.log('✓ SpeechGradebook Text + Video Model (Qwen) export submitted', data.length, 'videos');
            } catch (err) {
                setStatus('');
                alert('Submit failed: ' + (err.message || err));
                console.error('submitQwenTrainingToWebhook error:', err);
            }
        }

        // View instructor's courses (for admins)
        async function viewInstructorCourses(instructorId, instructorEmail) {
            console.log('📚 Viewing courses for:', instructorEmail);
            
            if (!supabaseClient) return;
            
            // FERPA audit: log admin access to instructor's courses
            await logAccess('view', 'courses', null, null, {
                purpose: 'admin_view_instructor_courses',
                instructor_id: instructorId
            });
            
            try {
                // Load instructor's courses
                const { data: courses, error } = await supabaseClient
                    .from('courses')
                    .select(`
                        id,
                        name,
                        semester,
                        year,
                        created_at
                    `)
                    .eq('instructor_id', instructorId)
                    .order('created_at', { ascending: false });
                
                if (error) throw error;
                
                // Batch load student and evaluation counts (avoid N+1 queries)
                const courseIds = courses.map(c => c.id);
                
                // Single query for all student counts
                const { data: allStudents } = await supabaseClient
                    .from('course_students')
                    .select('course_id')
                    .in('course_id', courseIds);
                
                // Single query for all evaluation counts
                const { data: allEvaluations } = await supabaseClient
                    .from('evaluations')
                    .select('course_id')
                    .in('course_id', courseIds);
                
                // Aggregate counts by course_id
                const studentCounts = {};
                const evalCounts = {};
                (allStudents || []).forEach(s => {
                    studentCounts[s.course_id] = (studentCounts[s.course_id] || 0) + 1;
                });
                (allEvaluations || []).forEach(e => {
                    evalCounts[e.course_id] = (evalCounts[e.course_id] || 0) + 1;
                });
                
                const coursesWithCounts = courses.map(course => ({
                    ...course,
                    student_count: studentCounts[course.id] || 0,
                    evaluation_count: evalCounts[course.id] || 0
                }));
                
                // Show in modal
                showInstructorCoursesModal(instructorEmail, coursesWithCounts);
                
            } catch (error) {
                console.error('Error loading instructor courses:', error);
                alert('Error loading courses. Please try again.');
            }
        }
        
        // Show instructor courses modal
        function showInstructorCoursesModal(instructorEmail, courses) {
            // Create modal HTML
            let html = `
                <div id="instructorCoursesModal" style="display:flex;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
                    <div style="background:white;padding:2rem;border-radius:1rem;max-width:900px;width:90%;max-height:90vh;overflow-y:auto;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:1.5rem;">
                            <h3 style="margin:0;color:var(--primary);"><span class="icon-with-text"><i data-lucide="book-open" style="width:1.25em;height:1.25em;"></i> Courses - ${instructorEmail}</span></h3>
                            <button onclick="closeInstructorCoursesModal()" style="background:none;border:none;cursor:pointer;color:var(--text-light);padding:0.25rem;" aria-label="Close"><i data-lucide="x" style="width:1.25em;height:1.25em;"></i></button>
                        </div>
            `;
            
            if (!courses || courses.length === 0) {
                html += '<p style="color:var(--text-light);">This instructor has no courses yet.</p>';
            } else {
                html += `
                    <div style="background:var(--bg);border:1px solid var(--border);border-radius:0.5rem;overflow:hidden;">
                        <table style="width:100%;border-collapse:collapse;">
                            <thead style="background:var(--bg-alt);">
                                <tr>
                                    <th style="padding:0.75rem;text-align:left;border-bottom:1px solid var(--border);">Course</th>
                                    <th style="padding:0.75rem;text-align:left;border-bottom:1px solid var(--border);">Semester</th>
                                    <th style="padding:0.75rem;text-align:center;border-bottom:1px solid var(--border);">Students</th>
                                    <th style="padding:0.75rem;text-align:center;border-bottom:1px solid var(--border);">Evaluations</th>
                                    <th style="padding:0.75rem;text-align:left;border-bottom:1px solid var(--border);">Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                courses.forEach(course => {
                    const semester = course.semester && course.year 
                        ? `${course.semester} ${course.year}`
                        : '—';
                    
                    html += `
                        <tr style="border-bottom:1px solid var(--border);">
                            <td style="padding:0.75rem;">
                                <strong>${course.name}</strong>
                            </td>
                            <td style="padding:0.75rem;color:var(--text-light);">${semester}</td>
                            <td style="padding:0.75rem;text-align:center;">${course.student_count}</td>
                            <td style="padding:0.75rem;text-align:center;">${course.evaluation_count}</td>
                            <td style="padding:0.75rem;">
                                <button onclick="viewCourseStudents('${course.id}', '${course.name.replace(/'/g, "\\'")}', '${instructorEmail}')" 
                                        style="padding:0.25rem 0.75rem;font-size:0.875rem;"><span class="icon-with-text"><i data-lucide="users" style="width:1em;height:1em;"></i> View Students</span></button>
                            </td>
                        </tr>
                    `;
                });
                
                html += `
                            </tbody>
                        </table>
                    </div>
                    <p style="margin-top:1rem;color:var(--text-light);font-size:0.875rem;">
                        Total courses: ${courses.length} | 
                        Total students: ${courses.reduce((sum, c) => sum + c.student_count, 0)} | 
                        Total evaluations: ${courses.reduce((sum, c) => sum + c.evaluation_count, 0)}
                    </p>
                `;
            }
            
            html += `
                        <div style="margin-top:1.5rem;text-align:right;">
                            <button onclick="closeInstructorCoursesModal()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;">
                                Close
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            // Add to page
            document.body.insertAdjacentHTML('beforeend', html);
            var modalEl = document.getElementById('instructorCoursesModal');
            if (modalEl && typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: modalEl });
        }
        
        // Close instructor courses modal
        function closeInstructorCoursesModal() {
            const modal = document.getElementById('instructorCoursesModal');
            if (modal) modal.remove();
        }
        
        /** Open class detail for a course (used by Admin/Super Admin "View" and ensures delete options are visible). */
        async function viewCourse(courseId) {
            if (!courseId) return;
            
            // Update URL for deep linking with path-based routing
            if (typeof Router !== 'undefined' && Router.navigateToCourse) {
                Router.navigateToCourse(courseId);
            }
            
            currentClassId = courseId;
            await loadClasses();
            let classes = JSON.parse(getUserItem('classes') || '[]');
            let skipReload = false;
            if (!classes.find(c => c.id === courseId) && ((typeof isAdmin === 'function' && isAdmin()) || (typeof isSuperAdmin === 'function' && isSuperAdmin()))) {
                const single = await loadSingleCourseFromSupabaseForView(courseId);
                if (single) {
                    classes = classes.filter(c => c.id !== courseId).concat([single]);
                    setUserItem('classes', JSON.stringify(classes));
                    skipReload = true; // don't let viewClass call loadClasses() and wipe this list
                }
            }
            if (!classes.find(c => c.id === courseId)) {
                console.warn('Course not in list after load – may be filtered. Trying viewClass anyway.');
            }
            await viewClass(courseId, skipReload);
        }
        
        // View course students (for admins viewing instructor's courses)
        async function viewCourseStudents(courseId, courseName, instructorEmail) {
            console.log('👥 Viewing students for course:', courseName);
            if (!supabaseClient) {
                alert('Not connected to database.');
                return;
            }
            try {
                const { data: students, error } = await supabaseClient
                    .from('course_students')
                    .select('id, first_name, last_name, email, student_id, deleted_locally_at')
                    .eq('course_id', courseId)
                    .order('last_name')
                    .order('first_name');
                if (error) throw error;
                const list = (students || []).map(s => {
                    const name = escapeHtml((s.first_name || '') + ' ' + (s.last_name || '')).trim() || '—';
                    const email = escapeHtml(s.email || '—');
                    const sid = escapeHtml(s.student_id || '');
                    const deletedTag = formatDeletedLocallyTag(s.deleted_locally_at);
                    return `<tr><td>${name}${deletedTag}</td><td>${email}</td><td>${sid}</td></tr>`;
                }).join('');
                const existing = document.getElementById('courseStudentsModal');
                if (existing) existing.remove();
                const modal = document.createElement('div');
                modal.id = 'courseStudentsModal';
                modal.style.cssText = 'display:flex;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;';
                modal.innerHTML = `
                    <div style="background:white;padding:2rem;border-radius:1rem;max-width:560px;width:90%;box-shadow:0 10px 40px rgba(0,0,0,0.3);max-height:80vh;overflow:hidden;display:flex;flex-direction:column;">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:1rem;flex-shrink:0;">
                            <h3 style="margin:0;color:var(--primary);"><span class="icon-with-text"><i data-lucide="users" style="width:1.25em;height:1.25em;"></i> Students — ${escapeHtml(courseName)}</span></h3>
                            <button type="button" onclick="closeCourseStudentsModal()" style="padding:0.35rem 0.75rem;border:1px solid var(--border);border-radius:0.25rem;background:var(--bg);cursor:pointer;">Close</button>
                        </div>
                        <p style="color:var(--text-light);font-size:0.9rem;margin:0 0 1rem 0;">Instructor: ${escapeHtml(instructorEmail || '')}</p>
                        <div style="overflow:auto;flex:1;">
                            ${(students || []).length === 0
                                ? '<p style="color:var(--text-light);">No students in this course.</p>'
                                : '<table class="data-table" style="width:100%;"><thead><tr><th>Name</th><th>Email</th><th>Student ID</th></tr></thead><tbody>' + list + '</tbody></table>'}
                        </div>
                    </div>`;
                modal.onclick = function(e) { if (e.target === modal) closeCourseStudentsModal(); };
                document.body.appendChild(modal);
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: modal });
            } catch (err) {
                console.error('viewCourseStudents:', err);
                alert('Error loading students. Please try again.');
            }
        }
        function closeCourseStudentsModal() {
            const modal = document.getElementById('courseStudentsModal');
            if (modal) modal.remove();
        }
        
        // View instructor details (for admins)
        async function viewInstructorDetails(instructorId, instructorEmail) {
            console.log('👤 Viewing details for:', instructorEmail);
            
            if (!supabaseClient) return;
            
            // FERPA audit: log admin access to instructor details
            await logAccess('view', 'user_profiles', instructorId, null, {
                purpose: 'admin_view_instructor_details'
            });
            
            try {
                // Get instructor info
                const { data: instructor, error: userError } = await supabaseClient
                    .from('user_profiles')
                    .select(`
                        id,
                        email,
                        full_name,
                        account_tier,
                        is_research_partner,
                        research_partner_opt_out_requested,
                        research_partner_opt_out_approved,
                        research_partner_opt_out_reason,
                        created_at,
                        departments (name),
                        institutions (name)
                    `)
                    .eq('id', instructorId)
                    .single();
                
                if (userError) throw userError;
                
                // Get course count
                const { data: courses, error: courseError } = await supabaseClient
                    .from('courses')
                    .select('id')
                    .eq('instructor_id', instructorId);
                
                // Get evaluation count
                const { data: evaluations, error: evalError } = await supabaseClient
                    .from('evaluations')
                    .select('id')
                    .eq('instructor_id', instructorId);
                
                // Show details modal
                showInstructorDetailsModal(instructor, courses?.length || 0, evaluations?.length || 0);
                
            } catch (error) {
                console.error('Error loading instructor details:', error);
                alert('Error loading details. Please try again.');
            }
        }
        
        // Show instructor details modal
        function showInstructorDetailsModal(instructor, courseCount, evaluationCount) {
            const researchStatus = instructor.is_research_partner 
                ? '<span style="color:var(--success);font-weight:600;" class="icon-with-text"><i data-lucide="check-circle" style="width:1em;height:1em;"></i> Active Research Partner</span>'
                : '<span style="color:var(--text-light);">Not a research partner</span>';
            
            let optOutStatus = '';
            if (instructor.research_partner_opt_out_requested && !instructor.research_partner_opt_out_approved) {
                optOutStatus = `
                    <div style="background:#fff3cd;border-left:4px solid var(--warning);padding:1rem;margin-top:1rem;border-radius:0.5rem;">
                        <strong class="icon-with-text"><i data-lucide="alert-triangle" style="width:1em;height:1em;"></i> Pending Opt-Out Request</strong>
                        <p style="margin:0.5rem 0 0 0;color:var(--text);">
                            ${instructor.research_partner_opt_out_reason || 'No reason provided'}
                        </p>
                    </div>
                `;
            }
            
            const html = `
                <div id="instructorDetailsModal" style="display:flex;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;">
                    <div style="background:white;padding:2rem;border-radius:1rem;max-width:600px;width:90%;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:1.5rem;">
                            <h3 style="margin:0;color:var(--primary);"><span class="icon-with-text"><i data-lucide="user" style="width:1.25em;height:1.25em;"></i> Instructor Details</span></h3>
                            <button onclick="closeInstructorDetailsModal()" style="background:none;border:none;cursor:pointer;color:var(--text-light);padding:0.25rem;" aria-label="Close"><i data-lucide="x" style="width:1.25em;height:1.25em;"></i></button>
                        </div>
                        
                        <div style="margin-bottom:1.5rem;">
                            <p><strong>Name:</strong> ${instructor.full_name || 'Not set'}</p>
                            <p><strong>Email:</strong> ${instructor.email}</p>
                            <p><strong>Institution:</strong> ${instructor.institutions?.name || '—'}</p>
                            <p><strong>Department:</strong> ${instructor.departments?.name || '—'}</p>
                            <p><strong>Member since:</strong> ${new Date(instructor.created_at).toLocaleDateString()}</p>
                        </div>
                        
                        <div style="background:var(--bg-alt);padding:1rem;border-radius:0.5rem;margin-bottom:1.5rem;">
                            <h4 style="margin:0 0 0.5rem 0;">Activity Summary</h4>
                            <p style="margin:0.25rem 0;" class="icon-with-text"><i data-lucide="book-open" style="width:1em;height:1em;"></i> Courses: ${courseCount}</p>
                            <p style="margin:0.25rem 0;" class="icon-with-text"><i data-lucide="bar-chart-2" style="width:1em;height:1em;"></i> Evaluations: ${evaluationCount}</p>
                        </div>
                        
                        <div style="margin-bottom:1.5rem;">
                            <h4 style="margin:0 0 0.5rem 0;">Research Partner Status</h4>
                            <p style="margin:0;">${researchStatus}</p>
                            ${optOutStatus}
                        </div>
                        
                        <div style="text-align:right;">
                            <button onclick="closeInstructorDetailsModal()" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;">
                                Close
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', html);
            var modalEl = document.getElementById('instructorDetailsModal');
            if (modalEl && typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: modalEl });
        }
        
        // Close instructor details modal
        function closeInstructorDetailsModal() {
            const modal = document.getElementById('instructorDetailsModal');
            if (modal) modal.remove();
        }
        
        // Admin Functions
        async function loadAllUsers() {
            if (!supabaseClient || !canManageUsers()) return;
            
            try {
                const { data: users, error } = await supabaseClient
                    .from('user_profiles')
                    .select(`
                        id,
                        email,
                        full_name,
                        account_tier,
                        is_admin,
                        is_super_admin,
                        created_at,
                        approval_status,
                        requested_role,
                        institutions (
                            name
                        ),
                        departments (
                            name
                        )
                    `)
                    .order('created_at', { ascending: false });
                
                if (error) throw error;
                
                const container = document.getElementById('usersListContainer');
                
                const pending = (users || []).filter(u => (u.approval_status || '').toLowerCase() === 'pending_approval');
                const approved = (users || []).filter(u => (u.approval_status || '').toLowerCase() !== 'pending_approval');
                
                let html = '';
                
                // Pending approval section (Super Admin only)
                if (isSuperAdmin() && pending.length > 0) {
                    html += `
                        <div style="margin-bottom: 1.5rem;">
                            <h4 style="margin: 0 0 0.75rem 0; font-size: 1rem; color: var(--warning);"><span class="icon-with-text"><i data-lucide="clock"></i> Pending approval (${pending.length})</span></h4>
                            <div style="background: var(--bg); border: 1px solid var(--border); border-radius: 0.5rem; overflow: hidden;">
                                <table style="width: 100%; border-collapse: collapse;">
                                    <thead style="background: var(--bg-alt);">
                                        <tr>
                                            <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Email</th>
                                            <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Name</th>
                                            <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Requested role</th>
                                            <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Actions</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                    `;
                    pending.forEach(user => {
                        const reqRole = (user.requested_role || 'instructor').trim();
                        html += `
                            <tr style="border-bottom: 1px solid var(--border);">
                                <td style="padding: 0.75rem;">${user.email}</td>
                                <td style="padding: 0.75rem; color: var(--text-light);">${user.full_name || '—'}</td>
                                <td style="padding: 0.75rem;">${reqRole}</td>
                                <td style="padding: 0.75rem;">
                                    <button type="button" onclick="approveUserRequest('${user.id}', '${(user.email || '').replace(/'/g, "\\'")}', '${reqRole}')" style="margin-right: 0.5rem; padding: 0.25rem 0.75rem; font-size: 0.875rem;">Approve</button>
                                    <button type="button" onclick="rejectUserRequest('${user.id}', '${(user.email || '').replace(/'/g, "\\'")}')" style="padding: 0.25rem 0.75rem; font-size: 0.875rem;">Reject</button>
                                </td>
                            </tr>
                        `;
                    });
                    html += `
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    `;
                }
                
                if (approved.length === 0 && (!isSuperAdmin() || pending.length === 0)) {
                    container.innerHTML = html + '<p style="color: var(--text-light);">No users found.</p>';
                    if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: container });
                    return;
                }
                
                // Approved users table
                html += `
                    <div style="background: var(--bg); border: 1px solid var(--border); border-radius: 0.5rem; overflow: hidden;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead style="background: var(--bg-alt);">
                                <tr>
                                    <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Email</th>
                                    <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Name</th>
                                    <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Institution</th>
                                    <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Department</th>
                                    <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Tier</th>
                                    <th style="padding: 0.75rem; text-align: center; border-bottom: 1px solid var(--border);">Admin</th>
                                    <th style="padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border);">Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                approved.forEach(user => {
                    // Determine tier badge based on new tier system
                    let tierBadge = '';
                    switch(user.account_tier) {
                        case 'super_admin':
                            tierBadge = '<span style="background: #9333ea; color: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600;">🌐 Super Admin</span>';
                            break;
                        case 'admin':
                            tierBadge = '<span style="background: var(--primary); color: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600;">🏛️ Admin</span>';
                            break;
                        case 'instructor':
                            tierBadge = '<span style="background: var(--success); color: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600;" class="icon-with-text"><i data-lucide="user" style="width:0.9em;height:0.9em;"></i> Instructor</span>';
                            break;
                        case 'demo':
                            tierBadge = '<span style="background: var(--warning); color: black; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600;" class="icon-with-text"><i data-lucide="theater" style="width:0.9em;height:0.9em;"></i> Demo</span>';
                            break;
                        default:
                            tierBadge = '<span style="background: var(--text-light); color: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem;">Unknown</span>';
                    }
                    
                    const adminBadge = user.is_admin || user.is_super_admin
                        ? '<span style="color: var(--success); font-size: 1.25rem;"><i data-lucide="check" style="width:1.25rem;height:1.25rem;"></i></span>'
                        : '<span style="color: var(--text-light);">—</span>';
                    
                    const institutionName = user.institutions?.name || '—';
                    const departmentName = user.departments?.name || '—';
                    
                    html += `
                        <tr style="border-bottom: 1px solid var(--border);">
                            <td style="padding: 0.75rem;">${user.email}</td>
                            <td style="padding: 0.75rem; color: var(--text-light);">${user.full_name || '—'}</td>
                            <td style="padding: 0.75rem; color: var(--text-light);">${institutionName}</td>
                            <td style="padding: 0.75rem; color: var(--text-light);">${departmentName}</td>
                            <td style="padding: 0.75rem;">${tierBadge}</td>
                            <td style="padding: 0.75rem; text-align: center;">${adminBadge}</td>
                            <td style="padding: 0.75rem;">
                                <button onclick="editUserTier('${user.id}', '${user.email}', '${user.account_tier}', ${user.is_admin})" 
                                        style="padding: 0.25rem 0.75rem; font-size: 0.875rem;">
                                    Edit
                                </button>
                            </td>
                        </tr>
                    `;
                });
                
                html += `
                            </tbody>
                        </table>
                    </div>
                    <p style="margin-top: 1rem; color: var(--text-light); font-size: 0.875rem;">
                        ${pending.length > 0 ? 'Pending: ' + pending.length + '. ' : ''}Total users: ${(users || []).length}
                    </p>
                `;
                
                container.innerHTML = html;
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: container });
                
            } catch (error) {
                console.error('Error loading users:', error);
                document.getElementById('usersListContainer').innerHTML = 
                    `<p style="color: var(--danger);">Error loading users: ${error.message}</p>`;
            }
        }
        
        // Edit user tier
        function editUserTier(userId, email, currentTier, isAdmin) {
            const newTier = prompt(
                `Change account tier for ${email}\n\n` +
                `Current tier: ${currentTier}\n` +
                `Current admin: ${isAdmin ? 'Yes' : 'No'}\n\n` +
                `Enter new tier:\n` +
                `- demo (testing only)\n` +
                `- instructor (faculty)\n` +
                `- admin (department head)\n` +
                `- super_admin (system-wide)`,
                currentTier
            );
            
            if (!newTier || newTier === currentTier) return;
            
            const validTiers = ['demo', 'instructor', 'admin', 'super_admin'];
            if (!validTiers.includes(newTier)) {
                alert('Invalid tier. Must be one of: demo, instructor, admin, super_admin');
                return;
            }
            
            // Warn when promoting to super_admin
            if (newTier === 'super_admin') {
                showConfirmModal(
                    'Promote to Super Admin',
                    'Promoting ' + email + ' to Super Admin will give them access to ALL institutions, ability to manage ALL users, and system-wide administration. Are you sure?',
                    function() { updateUserTier(userId, email, newTier, null); },
                    null,
                    'Promote'
                );
                return;
            }
            
            updateUserTier(userId, email, newTier, null);
        }
        
        // Update user tier in database
        async function updateUserTier(userId, email, newTier, toggleAdmin) {
            if (!supabaseClient || !canManageUsers()) return;
            
            try {
                const updates = {
                    account_tier: newTier,
                    updated_at: new Date().toISOString()
                };
                
                // If toggleAdmin is provided, update admin status
                if (toggleAdmin !== null) {
                    updates.is_admin = toggleAdmin;
                }
                
                const { error } = await supabaseClient
                    .from('user_profiles')
                    .update(updates)
                    .eq('id', userId);
                
                if (error) throw error;
                
                alert(`Success. Updated ${email} to ${newTier}${toggleAdmin !== null ? (toggleAdmin ? ' (Admin)' : ' (Not Admin)') : ''}`);
                
                // Reload user list
                loadAllUsers();
                
            } catch (error) {
                console.error('Error updating user:', error);
                alert('Error updating user: ' + error.message);
            }
        }
        
        async function approveUserRequest(userId, email, requestedRole) {
            if (!supabaseClient || !isSuperAdmin()) return;
            try {
                const tier = (requestedRole === 'admin') ? 'admin' : 'instructor';
                const isAdmin = requestedRole === 'admin';
                const { error } = await supabaseClient
                    .from('user_profiles')
                    .update({
                        approval_status: 'approved',
                        account_tier: tier,
                        is_admin: isAdmin,
                        updated_at: new Date().toISOString()
                    })
                    .eq('id', userId);
                if (error) throw error;
                alert('Approved. ' + email + ' can now sign in as ' + tier + (isAdmin ? ' (Admin).' : '.'));
                loadAllUsers();
            } catch (err) {
                console.error('Approve error:', err);
                alert('Error approving user: ' + (err.message || err));
            }
        }
        
        async function rejectUserRequest(userId, email) {
            if (!supabaseClient || !isSuperAdmin()) return;
            showConfirmModal('Reject account request', 'Reject account request for ' + email + '? They will not be able to use the app.', async function() {
                try {
                    const { error } = await supabaseClient
                        .from('user_profiles')
                        .update({
                            approval_status: 'rejected',
                            updated_at: new Date().toISOString()
                        })
                        .eq('id', userId);
                    if (error) throw error;
                    if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Rejected. ' + email + ' will not have access.', 5000);
                    else alert('Rejected. ' + email + ' will not have access.');
                    loadAllUsers();
                } catch (err) {
                    console.error('Reject error:', err);
                    if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Error rejecting user: ' + (err.message || err), 6000);
                    else alert('Error rejecting user: ' + (err.message || err));
                }
            }, null, 'Reject');
        }
        
        function showInviteForm() {
            const card = document.getElementById('inviteFormCard');
            card.classList.remove('hidden');
            card.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        
        function cancelInvite() {
            document.getElementById('inviteFormCard').classList.add('hidden');
            document.getElementById('inviteForm').reset();
        }
        
        async function sendInvite(event) {
            event.preventDefault();
            
            const recipientEmail = document.getElementById('inviteEmail').value;
            const name = document.getElementById('inviteName').value;
            const institution = document.getElementById('inviteInstitution').value;
            const autoApprove = document.getElementById('inviteAutoApprove').checked;
            
            // Get the current deployment URL
            const deploymentUrl = window.location.origin + window.location.pathname;
            const registrationUrl = `${deploymentUrl}#register`;
            
            // Create invitation record in database
            let inviteToken = null;
            if (supabaseClient && autoApprove) {
                try {
                    inviteToken = generateInviteToken();
                    const { error } = await supabaseClient
                        .from('invitations')
                        .insert({
                            email: recipientEmail,
                            name: name,
                            institution: institution,
                            invited_by: currentUser.email,
                            invite_token: inviteToken,
                            account_tier: 'research_partner',
                            expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString()
                        });
                    
                    if (error) {
                        console.error('Could not save invitation:', error);
                    }
                } catch (err) {
                    console.error('Error saving invitation:', err);
                }
            }
            
            // Show sending modal
            showSendingInvitationModal(recipientEmail, name, institution, registrationUrl, autoApprove);
            
            cancelInvite();
        }
        
        // Show modal for sending invitation
        function showSendingInvitationModal(recipientEmail, name, institution, registrationUrl, autoApprove) {
            const modal = document.createElement('div');
            modal.id = 'invitationModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                padding: 2rem;
            `;
            
            const institutionLine = institution ? `<tr><td style="padding: 8px 12px; color: var(--text-light); border-bottom: 1px solid var(--border);">Institution:</td><td style="padding: 8px 12px; border-bottom: 1px solid var(--border);"><strong>${institution}</strong></td></tr>` : '';
            
            modal.innerHTML = `
                <div style="background: var(--bg); border-radius: 12px; max-width: 700px; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3);">
                    <div style="background: var(--primary); padding: 2rem; border-radius: 12px 12px 0 0; color: white;">
                        <h2 style="margin: 0; font-size: 1.5rem; font-weight: 600;"><span class="icon-with-text"><i data-lucide="mail" style="width:1.25em;height:1.25em;"></i> Send Research Partner Invitation</span></h2>
                        <p style="margin: 0.5rem 0 0 0; opacity: 0.9;">Review and send invitation to join SpeechGradebook</p>
                    </div>
                    
                    <div style="padding: 2rem;">
                        <!-- Recipient Info -->
                        <div style="background: var(--bg-alt); border-radius: 8px; padding: 1.5rem; margin-bottom: 1.5rem; border-left: 4px solid var(--primary);">
                            <h3 style="margin: 0 0 1rem 0; font-size: 1rem; color: var(--text);">Invitation Details</h3>
                            <table style="width: 100%; border-collapse: collapse;">
                                <tr>
                                    <td style="padding: 8px 12px; color: var(--text-light); border-bottom: 1px solid var(--border); width: 120px;">To:</td>
                                    <td style="padding: 8px 12px; border-bottom: 1px solid var(--border);"><strong>${recipientEmail}</strong></td>
                                </tr>
                                <tr>
                                    <td style="padding: 8px 12px; color: var(--text-light); border-bottom: 1px solid var(--border);">Name:</td>
                                    <td style="padding: 8px 12px; border-bottom: 1px solid var(--border);"><strong>${name || 'Not provided'}</strong></td>
                                </tr>
                                ${institutionLine}
                                <tr>
                                    <td style="padding: 8px 12px; color: var(--text-light);">Access Level:</td>
                                    <td style="padding: 8px 12px;"><span style="background: var(--success); color: white; padding: 4px 12px; border-radius: 4px; font-size: 0.875rem; font-weight: 600;">Research Partner</span></td>
                                </tr>
                            </table>
                        </div>
                        
                        <!-- Email Preview -->
                        <div style="background: var(--bg); border: 2px solid var(--border); border-radius: 8px; padding: 2rem; margin-bottom: 1.5rem;">
                            <div style="border-bottom: 2px solid var(--primary); padding-bottom: 1rem; margin-bottom: 1.5rem;">
                                <p style="margin: 0; color: var(--text-light); font-size: 0.875rem;">Subject:</p>
                                <p style="margin: 0.25rem 0 0 0; font-size: 1.125rem; font-weight: 600; color: var(--text);">Invitation to SpeechGradebook Research Partnership</p>
                            </div>
                            
                            <div style="line-height: 1.8; color: var(--text); font-size: 0.9375rem;">
                                <p style="margin: 0 0 1.5rem 0;">Dear ${name || 'Colleague'},</p>
                                
                                <p style="margin: 0 0 1.5rem 0;">You're invited to join <strong>SpeechGradebook</strong> as a <strong style="color: var(--primary);">Research Partner</strong>.</p>
                                
                                <div style="background: var(--bg-alt); border-left: 4px solid var(--primary); padding: 1rem 1.5rem; margin: 1.5rem 0; border-radius: 4px;">
                                    <p style="margin: 0 0 0.75rem 0; font-weight: 600; color: var(--primary);">Benefits:</p>
                                    <ul style="margin: 0; padding-left: 1.25rem;">
                                        <li style="margin-bottom: 0.5rem;">Full evaluation storage and correction tracking</li>
                                        <li style="margin-bottom: 0.5rem;">Contribute to AI training research</li>
                                        <li style="margin-bottom: 0.5rem;">Help improve speech education technology</li>
                                    </ul>
                                </div>
                                
                                <div style="background: var(--warning-bg); border-left: 4px solid var(--warning); padding: 1rem 1.5rem; margin: 1.5rem 0; border-radius: 4px;">
                                    <p style="margin: 0 0 0.75rem 0; font-weight: 600; color: var(--warning-dark);">To get started:</p>
                                    <ol style="margin: 0; padding-left: 1.25rem;">
                                        <li style="margin-bottom: 0.5rem;">Register at: <a href="${registrationUrl}" style="color: var(--primary); text-decoration: none; font-weight: 600;">${registrationUrl}</a></li>
                                        <li style="margin-bottom: 0.5rem;">Use this email address (<strong>${recipientEmail}</strong>) during registration</li>
                                        <li style="margin-bottom: 0;">Your account will be automatically upgraded to Research Partner</li>
                                    </ol>
                                </div>
                                
                                ${institution ? `<p style="margin: 1.5rem 0;"><strong>Institution:</strong> ${institution}</p>` : ''}
                                
                                <p style="margin: 1.5rem 0;">Questions? Contact us at <a href="mailto:speechgradebook@proton.me" style="color: var(--primary); text-decoration: none;">speechgradebook@proton.me</a></p>
                                
                                <div style="background: var(--success-bg); border-left: 4px solid var(--success); padding: 1rem 1.5rem; margin: 1.5rem 0; border-radius: 4px;">
                                    <p style="margin: 0 0 0.75rem 0; font-weight: 600; color: var(--success-dark);">After registration, you'll have full access to:</p>
                                    <ul style="margin: 0; padding-left: 1.25rem;">
                                        <li style="margin-bottom: 0.5rem;">Unlimited speech evaluations</li>
                                        <li style="margin-bottom: 0.5rem;">Save and track student progress</li>
                                        <li style="margin-bottom: 0.5rem;">Edit and correct AI evaluations</li>
                                        <li style="margin-bottom: 0;">Contribute to groundbreaking research</li>
                                    </ul>
                                </div>
                                
                                <div style="margin-top: 2rem; padding-top: 1.5rem; border-top: 1px solid var(--border);">
                                    <p style="margin: 0 0 0.25rem 0;">Best regards,</p>
                                    <p style="margin: 0; font-weight: 600;">Anna McClure, Ph.D.</p>
                                    <p style="margin: 0.25rem 0 0 0; color: var(--text-light); font-size: 0.875rem;">SpeechGradebook Research Team</p>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                            <button onclick="closeInvitationModal()" class="btn-secondary" style="padding: 0.75rem 1.5rem;">Cancel</button>
                            <button onclick="copyInvitationForManualSend('${recipientEmail.replace(/'/g, "\\'")}', '${name.replace(/'/g, "\\'")}', '${institution.replace(/'/g, "\\'")}', '${registrationUrl}')" style="padding: 0.75rem 1.5rem;"><span class="icon-with-text"><i data-lucide="clipboard-copy" style="width:1em;height:1em;"></i> Copy Text</span></button>
                            <button onclick="sendInvitationEmail('${recipientEmail.replace(/'/g, "\\'")}', '${name.replace(/'/g, "\\'")}', '${institution.replace(/'/g, "\\'")}', '${registrationUrl}')" style="padding: 0.75rem 2rem;"><span class="icon-with-text"><i data-lucide="send" style="width:1em;height:1em;"></i> Send Invitation</span></button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: modal });
        }
        
        // Send invitation email directly
        async function sendInvitationEmail(recipientEmail, name, institution, registrationUrl) {
            const button = event.target;
            const originalText = button.innerHTML;
            button.innerHTML = '⏳ Sending...';
            button.disabled = true;
            
            try {
                const subject = 'Invitation to SpeechGradebook Research Partnership';
                
                // Create HTML version
                const htmlBody = createHTMLInvitation(recipientEmail, name, institution, registrationUrl);
                
                // For Gmail, use their compose URL with HTML support
                const isGmail = currentUser.email && currentUser.email.includes('@gmail.com');
                
                if (isGmail) {
                    // Open Gmail compose
                    const gmailUrl = `https://mail.google.com/mail/?view=cm&fs=1&to=${encodeURIComponent(recipientEmail)}&su=${encodeURIComponent(subject)}`;
                    window.open(gmailUrl, '_blank');
                    
                    // Copy HTML to clipboard for pasting
                    navigator.clipboard.writeText(htmlBody).then(() => {
                        setTimeout(() => {
                            alert('✅ Gmail opened!\n\nHTML email copied to clipboard.\n\n1. In Gmail, click the three dots (...) at bottom\n2. Select "Rich formatting mode"\n3. Paste (Ctrl+V or Cmd+V)\n4. Send!');
                            closeInvitationModal();
                        }, 500);
                    });
                } else {
                    // For other email clients, use mailto with plain text
                    const plainBody = createPlainTextInvitation(recipientEmail, name, institution, registrationUrl);
                    const mailtoLink = `mailto:${recipientEmail}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(plainBody)}`;
                    window.location.href = mailtoLink;
                    
                    setTimeout(() => {
                        alert('✅ Email client opened!\n\nPlease send the invitation.');
                        closeInvitationModal();
                    }, 1000);
                }
                
            } catch (error) {
                console.error('Error sending invitation:', error);
                alert('❌ Could not send invitation.\n\nPlease use the "Copy Text" button and send manually.');
                button.innerHTML = originalText;
                button.disabled = false;
            }
        }
        
        // Create HTML email version
        function createHTMLInvitation(recipientEmail, name, institution, registrationUrl) {
            return `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body style="margin: 0; padding: 0; font-family: 'Work Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background-color: #f5f5f5;">
    <div style="max-width: 600px; margin: 0 auto; background-color: #ffffff;">
        <!-- Header -->
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 40px 30px; text-align: center;">
            <h1 style="color: #ffffff; margin: 0; font-size: 28px; font-weight: 600; font-family: 'Crimson Pro', serif;">SpeechGradebook</h1>
            <p style="color: rgba(255,255,255,0.9); margin: 10px 0 0 0; font-size: 16px;">Research Partnership Invitation</p>
        </div>
        
        <!-- Content -->
        <div style="padding: 40px 30px; line-height: 1.8; color: #333333;">
            <p style="margin: 0 0 20px 0; font-size: 16px;">Dear ${name || 'Colleague'},</p>
            
            <p style="margin: 0 0 24px 0; font-size: 16px;">You're invited to join <strong>SpeechGradebook</strong> as a <strong style="color: #667eea;">Research Partner</strong>.</p>
            
            <!-- Benefits Box -->
            <div style="background-color: #f0f4ff; border-left: 4px solid #667eea; padding: 20px; margin: 24px 0; border-radius: 4px;">
                <p style="margin: 0 0 12px 0; font-weight: 600; color: #667eea; font-size: 16px;">Benefits:</p>
                <ul style="margin: 0; padding-left: 20px; font-size: 15px;">
                    <li style="margin-bottom: 8px;">Full evaluation storage and correction tracking</li>
                    <li style="margin-bottom: 8px;">Contribute to AI training research</li>
                    <li style="margin-bottom: 0;">Help improve speech education technology</li>
                </ul>
            </div>
            
            <!-- Getting Started Box -->
            <div style="background-color: #fff9e6; border-left: 4px solid #ffc107; padding: 20px; margin: 24px 0; border-radius: 4px;">
                <p style="margin: 0 0 12px 0; font-weight: 600; color: #f57c00; font-size: 16px;">To get started:</p>
                <ol style="margin: 0; padding-left: 20px; font-size: 15px;">
                    <li style="margin-bottom: 8px;">Register at: <a href="${registrationUrl}" style="color: #667eea; text-decoration: none; font-weight: 600;">${registrationUrl}</a></li>
                    <li style="margin-bottom: 8px;">Use this email address (<strong>${recipientEmail}</strong>) during registration</li>
                    <li style="margin-bottom: 0;">Your account will be automatically upgraded to Research Partner</li>
                </ol>
            </div>
            
            ${institution ? `<p style="margin: 24px 0; font-size: 15px;"><strong>Institution:</strong> ${institution}</p>` : ''}
            
            <p style="margin: 24px 0; font-size: 15px;">Questions? Contact us at <a href="mailto:speechgradebook@proton.me" style="color: #667eea; text-decoration: none;">speechgradebook@proton.me</a></p>
            
            <!-- Access Box -->
            <div style="background-color: #e8f5e9; border-left: 4px solid #4caf50; padding: 20px; margin: 24px 0; border-radius: 4px;">
                <p style="margin: 0 0 12px 0; font-weight: 600; color: #2e7d32; font-size: 16px;">After registration, you'll have full access to:</p>
                <ul style="margin: 0; padding-left: 20px; font-size: 15px;">
                    <li style="margin-bottom: 8px;">Unlimited speech evaluations</li>
                    <li style="margin-bottom: 8px;">Save and track student progress</li>
                    <li style="margin-bottom: 8px;">Edit and correct AI evaluations</li>
                    <li style="margin-bottom: 0;">Contribute to groundbreaking research</li>
                </ul>
            </div>
            
            <!-- Signature -->
            <div style="margin-top: 40px; padding-top: 24px; border-top: 1px solid #e0e0e0;">
                <p style="margin: 0 0 4px 0; font-size: 15px;">Best regards,</p>
                <p style="margin: 0; font-weight: 600; font-size: 16px;">Anna McClure, Ph.D.</p>
                <p style="margin: 4px 0 0 0; color: #666666; font-size: 14px;">SpeechGradebook Research Team</p>
            </div>
        </div>
        
        <!-- Footer -->
        <div style="background-color: #f5f5f5; padding: 20px 30px; text-align: center; border-top: 1px solid #e0e0e0;">
            <p style="margin: 0; color: #999999; font-size: 13px;">SpeechGradebook | Instructor-Informed Speech Assessment</p>
        </div>
    </div>
</body>
</html>`;
        }
        
        // Create plain text version for email
        function createPlainTextInvitation(recipientEmail, name, institution, registrationUrl) {
            return `Dear ${name || 'Colleague'},

You're invited to join SpeechGradebook as a Research Partner.

BENEFITS:
• Full evaluation storage and correction tracking
• Contribute to AI training research
• Help improve speech education technology

TO GET STARTED:
1. Register at: ${registrationUrl}
2. Use this email address (${recipientEmail}) during registration
3. Your account will be automatically upgraded to Research Partner

${institution ? `Institution: ${institution}\n\n` : ''}Questions? Contact us at speechgradebook@proton.me

AFTER REGISTRATION, YOU'LL HAVE FULL ACCESS TO:
• Unlimited speech evaluations
• Save and track student progress
• Edit and correct AI evaluations
• Contribute to groundbreaking research

Best regards,
Anna McClure, Ph.D.
SpeechGradebook Research Team`;
        }
        
        // Copy invitation text for manual sending
        function copyInvitationForManualSend(recipientEmail, name, institution, registrationUrl) {
            const text = createPlainTextInvitation(recipientEmail, name, institution, registrationUrl);
            
            navigator.clipboard.writeText(text).then(() => {
                alert(`✅ Invitation text copied to clipboard!\n\nYou can now:\n1. Open your email client\n2. Compose new email to: ${recipientEmail}\n3. Paste the invitation text`);
            }).catch(() => {
                // Fallback
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                alert(`✅ Invitation text copied!\n\nSend to: ${recipientEmail}`);
            });
        }
        
        // Close invitation modal
        function closeInvitationModal() {
            const modal = document.getElementById('invitationModal');
            if (modal) {
                modal.remove();
            }
        }
        
        // Generate a simple invite token
        function generateInviteToken() {
            return Math.random().toString(36).substring(2) + Date.now().toString(36);
        }

        function setActiveSection(sectionId, navId) {
            // Hide all sections using display (not just class)
            document.querySelectorAll('.section').forEach(s => {
                s.classList.remove('active');
                s.style.display = 'none'; // CRITICAL: Actually hide the section
            });
            
            // Hide evaluation saved indicator when navigating away from evaluation section
            if (sectionId !== 'evaluateSection') {
                hideEvaluationSavedIndicator();
            }
            
            // Show selected section
            const selectedSection = document.getElementById(sectionId);
            if (selectedSection) {
                selectedSection.classList.add('active');
                selectedSection.style.display = 'block'; // CRITICAL: Actually show the section
            }
            
            // Update nav (active state and aria-current for accessibility)
            // Make sure nav links are always visible (they're in the header, not a section)
            document.querySelectorAll('.nav-link').forEach(n => {
                n.classList.remove('active');
                n.removeAttribute('aria-current');
                // Ensure nav links are visible
                n.style.display = '';
                n.style.visibility = '';
            });
            const selectedNav = document.getElementById(navId);
            if (selectedNav) {
                selectedNav.classList.add('active');
                selectedNav.setAttribute('aria-current', 'page');
            }
            
            // Ensure header/nav is always visible
            const header = document.querySelector('header, .app-header, .main-header');
            if (header) {
                header.style.display = '';
                header.style.visibility = '';
            }
            
            // Persist section for refresh (main nav sections only; only when main app is visible)
            const mainApp = document.getElementById('mainApp');
            if (mainApp && mainApp.style.display !== 'none' && typeof sessionStorage !== 'undefined') {
                const mainSections = ['evaluateSection', 'dashboardSection', 'settingsSection', 'helpSection'];
                if (mainSections.includes(sectionId)) {
                    sessionStorage.setItem('lastSection', sectionId);
                }
            }
        }

        // ===== DARK MODE MANAGEMENT =====
        const DARK_MODE_KEY = 'speech_dark_mode';
        
        function getDarkModePreference() {
            try {
                const saved = localStorage.getItem(DARK_MODE_KEY);
                if (saved !== null) {
                    return saved === 'true';
                }
                // Check system preference if no saved preference
                if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                    return true;
                }
                return false;
            } catch (e) {
                return false;
            }
        }
        
        function setDarkModePreference(enabled) {
            try {
                localStorage.setItem(DARK_MODE_KEY, enabled ? 'true' : 'false');
            } catch (e) {
                console.warn('Dark mode preference storage failed', e);
            }
        }
        
        function toggleDarkMode(enabled) {
            const root = document.documentElement;
            setDarkModePreference(enabled);
            updateDarkModeToggle(enabled);
            
            if (enabled) {
                // Apply SpeechGradebook Dark Theme
                const darkTheme = DEMO_BRANDING_PACKAGES['speechgradebook-dark'] || DEMO_BRANDING_PACKAGES['option7-dark'];
                root.classList.add('theme-option7-dark');
                root.style.setProperty('--primary', darkTheme.primary);
                root.style.setProperty('--primary-dark', darkTheme.primaryDark);
                root.style.setProperty('--secondary', darkTheme.secondary);
                root.style.setProperty('--accent', darkTheme.accent);
                root.style.setProperty('--text', darkTheme.text);
                root.style.setProperty('--text-light', darkTheme.textLight);
                root.style.setProperty('--bg', darkTheme.bg);
                root.style.setProperty('--bg-alt', darkTheme.bgAlt);
                root.style.setProperty('--card', darkTheme.card);
                root.style.setProperty('--border', darkTheme.border);
                root.style.setProperty('--success', darkTheme.success);
                root.style.setProperty('--warning', darkTheme.warning);
                root.style.setProperty('--error', darkTheme.error);
                
                // Update header
                const header = document.querySelector('header');
                if (header) {
                    header.style.background = darkTheme.primaryDark;
                    header.style.color = 'white';
                    header.querySelectorAll('h1, .subtitle, #logoutLink, .nav-link').forEach(el => {
                        if (el) el.style.color = 'white';
                    });
                }
                console.log('SpeechGradebook Dark Theme enabled');
            } else {
                // Apply SpeechGradebook Light Theme (Option 7)
                const lightTheme = DEMO_BRANDING_PACKAGES['speechgradebook-light'] || DEMO_BRANDING_PACKAGES['option7'];
                root.classList.remove('theme-option7-dark');
                root.style.setProperty('--primary', lightTheme.primary);
                root.style.setProperty('--primary-dark', lightTheme.primaryDark);
                root.style.setProperty('--secondary', lightTheme.secondary);
                root.style.setProperty('--accent', lightTheme.accent);
                root.style.setProperty('--text', lightTheme.text);
                root.style.setProperty('--text-light', lightTheme.textLight);
                root.style.setProperty('--bg', lightTheme.bg);
                root.style.setProperty('--bg-alt', lightTheme.bgAlt);
                root.style.setProperty('--card', lightTheme.card);
                root.style.setProperty('--border', lightTheme.border);
                root.style.setProperty('--success', lightTheme.success);
                root.style.setProperty('--warning', lightTheme.warning);
                root.style.setProperty('--error', lightTheme.error);
                
                // Update header
                const header = document.querySelector('header');
                if (header) {
                    header.style.background = lightTheme.primaryDark;
                    header.style.color = 'white';
                    header.querySelectorAll('h1, .subtitle, #logoutLink, .nav-link').forEach(el => {
                        if (el) el.style.color = '';
                    });
                }
                console.log('SpeechGradebook Light Theme enabled');
            }
            
            // Refresh icons after theme change
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                setTimeout(() => lucide.createIcons(), 100);
            }
        }
        
        
        function updateDarkModeToggle(enabled) {
            const toggle = document.getElementById('darkModeToggle');
            if (toggle) {
                toggle.checked = enabled;
            }
        }
        
        function initDarkMode() {
            // Only apply dark mode if user is logged in (not on login screen)
            const authScreen = document.getElementById('authScreen');
            const isLoggedIn = !authScreen || authScreen.classList.contains('hidden');
            
            if (isLoggedIn) {
                const isDark = getDarkModePreference();
                toggleDarkMode(isDark);
            } else {
                // Login screen always uses light theme
                resetThemeToDefault();
            }
        }
        
        // Listen for system theme changes
        if (window.matchMedia) {
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                // Only auto-switch if user hasn't manually set a preference
                const saved = localStorage.getItem(DARK_MODE_KEY);
                if (saved === null) {
                    toggleDarkMode(e.matches);
                }
            });
        }

        // ===== TENANT/THEME MANAGEMENT =====
        function switchTenant(tenantId) {
            currentTenant = tenantId;
            applyTenant(tenantId);
            localStorage.setItem('current_tenant', tenantId);
        }

        function applyTenant(tenantId) {
            const config = TENANT_CONFIGS[tenantId] || TENANT_CONFIGS['default'];
            
            // Apply colors
            const root = document.documentElement;
            const isDarkMode = root.getAttribute('data-theme') === 'dark';
            
            // Always apply primary colors (they work in both modes)
            root.style.setProperty('--primary', config.colors.primary);
            root.style.setProperty('--primary-dark', config.colors.primaryDark);
            root.style.setProperty('--secondary', config.colors.secondary);
            root.style.setProperty('--accent', config.colors.accent);
            
            // UTK / UTK Torch: dark grey header & footer, favicon, Torch button style
            const header = document.querySelector('header');
            const footer = document.querySelector('footer');
            const faviconEl = document.getElementById('faviconLink');
            const isTorch = tenantId === 'utk' || tenantId === 'utk-torch';
            if (isTorch) {
                root.classList.add('theme-torch');
                if (config.headerBg && header) {
                    header.style.background = config.headerBg;
                    header.style.backgroundImage = 'none';
                    header.style.color = 'white';
                    header.querySelectorAll('h1, .subtitle, #logoutLink, .nav-link').forEach(el => { if (el) el.style.color = 'white'; });
                }
                if (config.footerBg && footer) {
                    footer.style.background = config.footerBg;
                    footer.style.backgroundImage = 'none';
                }
                // Tab favicon always SpeechGradebook (never institution/tenant logo)
                if (faviconEl) {
                    faviconEl.href = 'assets/3d-logo-transparent.png';
                    faviconEl.type = 'image/png';
                }
                // Login screen always shows SpeechGradebook logo (never institution/tenant logo)
                const authLogoImg = document.getElementById('authLogoImg');
                if (authLogoImg) authLogoImg.src = 'assets/3d-logo-transparent.png';
                // UTK Torch Theme: full Torch design tokens from utk-theme-preview.html (both UTK and UTK Torch use this)
                root.classList.add('theme-utk-torch');
                root.style.setProperty('--smokey', '#4B4B4B');
                root.style.setProperty('--link-blue', '#1a73c5');
                // Only set light mode colors if not in dark mode
                if (!isDarkMode) {
                    root.style.setProperty('--text', '#4B4B4B');
                    root.style.setProperty('--text-light', '#6B6B6B');
                    root.style.setProperty('--bg', '#FAFAFA');
                    root.style.setProperty('--bg-alt', '#F0F0F0');
                    root.style.setProperty('--border', '#E0E0E0');
                } else {
                    // Remove light mode overrides so dark mode CSS can take effect
                    root.style.removeProperty('--text');
                    root.style.removeProperty('--text-light');
                    root.style.removeProperty('--bg');
                    root.style.removeProperty('--bg-alt');
                    root.style.removeProperty('--border');
                }
            } else {
                root.classList.remove('theme-torch');
                root.classList.remove('theme-utk-torch');
                root.style.removeProperty('--smokey');
                root.style.removeProperty('--link-blue');
                // Only remove light mode colors if not in dark mode (to let dark mode CSS work)
                if (!isDarkMode) {
                    root.style.removeProperty('--text');
                    root.style.removeProperty('--text-light');
                    root.style.removeProperty('--bg');
                    root.style.removeProperty('--bg-alt');
                    root.style.removeProperty('--border');
                }
                if (header) {
                    header.style.background = '';
                    header.style.backgroundImage = '';
                    header.style.color = '';
                    header.querySelectorAll('h1, .subtitle, #logoutLink, .nav-link').forEach(el => { if (el) el.style.color = ''; });
                }
                if (footer) {
                    footer.style.background = '';
                    footer.style.backgroundImage = '';
                }
                if (faviconEl) {
                    faviconEl.href = 'assets/3d-logo-transparent.png';
                    faviconEl.type = 'image/png';
                }
                const authLogoImg = document.getElementById('authLogoImg');
                if (authLogoImg) authLogoImg.src = 'assets/3d-logo-transparent.png';
            }
            
            // Apply fonts
            root.style.setProperty('--heading-font', config.typography.headingFont);
            root.style.setProperty('--body-font', config.typography.bodyFont);
            root.style.setProperty('--heading-weight', config.typography.headingWeight);
            root.style.setProperty('--body-weight', config.typography.bodyWeight);
            
            // Apply branding (appName, tagline, logo)
            const appNameEl = document.getElementById('appName');
            if (appNameEl) appNameEl.textContent = config.branding.appName;
            const appTaglineEl = document.getElementById('appTagline');
            if (appTaglineEl) appTaglineEl.textContent = config.branding.tagline;
            const appLogoEl = document.getElementById('appLogo');
            if (appLogoEl) {
                if (tenantId === 'default') {
                    appLogoEl.innerHTML = '<img src="assets/3d-logo-transparent.png" alt="SpeechGradebook" style="width: 100%; height: 100%; object-fit: contain; object-position: center; border-radius: 50%; padding: 12%;">';
                    appLogoEl.style.backgroundColor = '#ffffff';
                } else if (config.logoUrl) {
                    appLogoEl.innerHTML = '<img src="' + config.logoUrl + '" alt="' + (config.name || 'Logo') + '" style="width: 100%; height: 100%; object-fit: contain; object-position: center; border-radius: 50%; padding: 12%;">';
                    appLogoEl.style.backgroundColor = '#ffffff';
                } else {
                    appLogoEl.textContent = config.shortName || '';
                    appLogoEl.style.backgroundColor = '#ffffff';
                }
            }
            document.title = 'SpeechGradebook';
            
            // Apply footer
            const footerLinks = document.getElementById('footerLinks');
            footerLinks.innerHTML = config.footer.links.map(link => 
                `<a href="${link.url}">${link.text}</a>`
            ).join('');
            
            document.getElementById('footerCopyright').textContent = config.footer.copyright;
            document.getElementById('footerAdditional').textContent = config.footer.additionalText || '';
            
            // Apply contact (preserve mailto link inside #supportEmail)
            const supportEl = document.getElementById('supportEmail');
            if (supportEl) {
                const email = config.contact.supportEmail || 'speechgradebook@proton.me';
                const link = supportEl.querySelector('a');
                if (link) {
                    link.href = 'mailto:' + email;
                    link.textContent = email;
                } else {
                    const safeHref = 'mailto:' + String(email).replace(/"/g, '&quot;');
                    supportEl.innerHTML = '<a href="' + safeHref + '">' + escapeHtml(email) + '</a>';
                }
            }
            
            // Update tenant selector
            document.getElementById('tenantSelect').value = tenantId;
        }

        // ===== BULK UPLOAD VARIABLES =====
        let bulkUploadMode = 'single'; // 'single' or 'bulk'
        let bulkFiles = []; // Array of {file: File, studentId: string, studentName: string, status: string, evaluationId: string}
        let bulkProcessingQueue = [];
        let bulkProcessingActive = false;
        let bulkProcessingCancelled = false;
        let bulkEvaluationIds = []; // Store evaluation IDs for reassignment

        // ===== BULK UPLOAD FUNCTIONS =====
        function switchUploadMode(mode) {
            bulkUploadMode = mode;
            const singleMode = document.getElementById('singleUploadMode');
            const bulkMode = document.getElementById('bulkUploadMode');
            const singleBtn = document.getElementById('singleUploadModeBtn');
            const bulkBtn = document.getElementById('bulkUploadModeBtn');
            
            if (mode === 'bulk') {
                singleMode.classList.add('hidden');
                bulkMode.classList.remove('hidden');
                singleBtn.className = 'btn-secondary';
                singleBtn.style.background = 'var(--card)';
                bulkBtn.className = 'btn';
                bulkBtn.style.background = 'var(--primary)';
                bulkBtn.style.color = 'white';
                singleBtn.style.color = 'var(--text)';
                
                // Initialize bulk upload
                initializeBulkUpload();
            } else {
                singleMode.classList.remove('hidden');
                bulkMode.classList.add('hidden');
                bulkBtn.className = 'btn-secondary';
                bulkBtn.style.background = 'var(--card)';
                singleBtn.className = 'btn';
                singleBtn.style.background = 'var(--primary)';
                singleBtn.style.color = 'white';
                bulkBtn.style.color = 'var(--text)';
                
                // Clear bulk data
                clearBulkFiles();
            }
        }

        function initializeBulkUpload() {
            const bulkUploadZone = document.getElementById('bulkUploadZone');
            const bulkFileInput = document.getElementById('bulkFileInput');
            
            if (!bulkUploadZone || !bulkFileInput) return;
            
            // Click handler - prefer file input
            bulkUploadZone.addEventListener('click', () => {
                // Check if folder input is supported
                if (bulkFolderInput && 'webkitdirectory' in bulkFolderInput) {
                    // Show option to user
                    const useFolder = confirm('Upload folder structure?\n\nClick OK to select a folder (organized by student)\nClick Cancel to select individual files');
                    if (useFolder) {
                        bulkFolderInput.click();
                    } else {
                        bulkFileInput.click();
                    }
                } else {
                    bulkFileInput.click();
                }
            });
            
            // Drag and drop handlers
            bulkUploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                bulkUploadZone.style.borderColor = 'var(--primary)';
                bulkUploadZone.style.background = 'var(--card)';
            });
            
            bulkUploadZone.addEventListener('dragleave', () => {
                bulkUploadZone.style.borderColor = 'var(--border)';
                bulkUploadZone.style.background = 'var(--bg-alt)';
            });
            
            bulkUploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                bulkUploadZone.style.borderColor = 'var(--border)';
                bulkUploadZone.style.background = 'var(--bg-alt)';
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleBulkFiles(files);
                }
            });
            
            // File input change handler
            bulkFileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleBulkFiles(e.target.files);
                }
            });
            
            // Folder input change handler
            const bulkFolderInput = document.getElementById('bulkFolderInput');
            if (bulkFolderInput) {
                bulkFolderInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        handleBulkFolder(e.target.files);
                    }
                });
            }
            
            // Populate course and rubric selectors
            populateBulkCourseSelector();
            populateBulkRubricSelector().catch(err => console.error('Error populating bulk rubric selector:', err));
        }

        async function populateBulkCourseSelector() {
            const select = document.getElementById('bulkCourseSelect');
            if (!select) return;
            
            select.innerHTML = '<option value="">-- Select Course --</option>';
            
            try {
                if (supabaseClient && currentUser) {
                    const { data: courses, error } = await supabaseClient
                        .from('courses')
                        .select('id, name, semester, year')
                        .eq('instructor_id', currentUser.id)
                        .is('deleted_locally_at', null)
                        .order('year', { ascending: false })
                        .order('semester', { ascending: false })
                        .order('name', { ascending: true });
                    
                    if (!error && courses) {
                        courses.forEach(course => {
                            const opt = document.createElement('option');
                            opt.value = course.id;
                            opt.textContent = `${course.name} - ${course.semester} ${course.year}`;
                            select.appendChild(opt);
                        });
                    }
                } else {
                    // Fallback to localStorage
                    const classes = JSON.parse(getUserItem('classes') || '[]');
                    classes.forEach((cls, idx) => {
                        const opt = document.createElement('option');
                        opt.value = cls.supabaseId || idx;
                        opt.textContent = `${cls.name} - ${cls.semester} ${cls.year}`;
                        select.appendChild(opt);
                    });
                }
            } catch (e) {
                console.error('Error populating bulk course selector:', e);
            }
        }

        async function populateBulkRubricSelector(courseId = null) {
            const select = document.getElementById('bulkRubricSelect');
            if (!select) {
                console.warn('[populateBulkRubricSelector] Select element not found');
                return;
            }
            
            select.innerHTML = '<option value="">-- Select a Rubric --</option>';
            
            try {
                // Use getAllRubrics() to get rubrics from Supabase
                const allRubrics = await getAllRubrics();
                console.log('[populateBulkRubricSelector] Total rubrics loaded:', allRubrics?.length || 0);
                console.log('[populateBulkRubricSelector] Filtering for courseId:', courseId);
                
                if (!allRubrics || allRubrics.length === 0) {
                    console.warn('No rubrics available for bulk upload');
                    return;
                }
                
                // Debug: Log courseIds for all rubrics to diagnose the issue
                console.log('[populateBulkRubricSelector] All rubrics courseIds:', 
                    allRubrics.map(r => ({ 
                        name: r.name, 
                        courseIds: r.courseIds,
                        courseIdsString: JSON.stringify(r.courseIds)
                    })));
                
                // Filter rubrics based on course selection
                let filteredRubrics = allRubrics;
                if (courseId) {
                    const courseIdStr = String(courseId).toLowerCase().trim();
                    console.log('[populateBulkRubricSelector] Filtering for courseId (normalized):', courseIdStr);
                    
                    // Show ONLY rubrics that are assigned to this course (exclude general rubrics)
                    filteredRubrics = allRubrics.filter(rubric => {
                        const courseIds = rubric.courseIds || [];
                        // Convert to strings and normalize for comparison
                        const courseIdsStr = courseIds.map(id => String(id).toLowerCase().trim());
                        
                        // Include ONLY if: course is in the rubric's course_ids array (exclude general rubrics)
                        const isAssigned = courseIds.length > 0 && courseIdsStr.includes(courseIdStr);
                        
                        if (isAssigned) {
                            console.log(`[populateBulkRubricSelector] Including rubric "${rubric.name}": assigned to course, courseIds=[${courseIdsStr.join(', ')}]`);
                        } else {
                            console.log(`[populateBulkRubricSelector] Excluding rubric "${rubric.name}": courseIds=[${courseIdsStr.join(', ')}], looking for=${courseIdStr}`);
                        }
                        return isAssigned;
                    });
                } else {
                    // No course selected - show only general rubrics (no course assignments)
                    filteredRubrics = allRubrics.filter(rubric => {
                        const courseIds = rubric.courseIds || [];
                        return courseIds.length === 0;
                    });
                    console.log('[populateBulkRubricSelector] No course selected - showing only general rubrics');
                }
                
                console.log('[populateBulkRubricSelector] Filtered rubrics count:', filteredRubrics.length);
                
                if (filteredRubrics.length > 0) {
                    filteredRubrics.forEach((rubric) => {
                        const opt = document.createElement('option');
                        // Use supabaseId if available, otherwise use id
                        opt.value = rubric.supabaseId || rubric.id;
                        opt.textContent = rubric.name || 'Unnamed Rubric';
                        select.appendChild(opt);
                    });
                    console.log('[populateBulkRubricSelector] Added', filteredRubrics.length, 'options to dropdown. Dropdown now has', select.options.length, 'options total');
                } else {
                    const opt = document.createElement('option');
                    opt.value = '';
                    opt.textContent = courseId ? 'No rubrics available for this course' : 'No general rubrics available';
                    opt.disabled = true;
                    select.appendChild(opt);
                    console.log('[populateBulkRubricSelector] No rubrics to show - added disabled option');
                }
            } catch (e) {
                console.error('Error populating bulk rubric selector:', e);
            }
        }

        async function handleBulkCourseChange() {
            await loadBulkStudents();
            await updateBulkRubricSelector();
            validateBulkUploadForm();
        }

        async function updateBulkRubricSelector() {
            const courseSelect = document.getElementById('bulkCourseSelect');
            const courseId = courseSelect?.value || null;
            console.log('[updateBulkRubricSelector] Course selected:', courseId);
            await populateBulkRubricSelector(courseId);
        }

        async function loadBulkStudents() {
            const courseSelect = document.getElementById('bulkCourseSelect');
            const courseId = courseSelect?.value;
            
            if (!courseId) return;
            
            // Store students for matching interface
            try {
                let students = [];
                
                if (supabaseClient && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(courseId)) {
                    const { data: courseStudents, error } = await supabaseClient
                        .from('course_students')
                        .select(`
                            id,
                            first_name,
                            last_name,
                            student_id
                        `)
                        .eq('course_id', courseId)
                        .is('deleted_locally_at', null)
                        .order('first_name', { ascending: true });
                    
                    if (!error && courseStudents) {
                        students = courseStudents.map(s => ({
                            id: s.id,
                            firstName: s.first_name,
                            lastName: s.last_name,
                            name: `${s.first_name || ''} ${s.last_name || ''}`.trim() || 'Unnamed Student',
                            studentId: s.student_id
                        }));
                    }
                } else {
                    // Fallback to localStorage
                    const classes = JSON.parse(getUserItem('classes') || '[]');
                    const isUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(courseId);
                    let classData = null;
                    
                    if (isUUID) {
                        classData = classes.find(c => (c.supabaseId || c.id) === courseId);
                    } else {
                        const idx = parseInt(courseId);
                        if (!isNaN(idx) && idx >= 0 && idx < classes.length) {
                            classData = classes[idx];
                        }
                    }
                    
                    if (classData && classData.roster) {
                        students = classData.roster.map(s => ({
                            id: s.supabaseId || s.id,
                            firstName: s.firstName,
                            lastName: s.lastName,
                            name: `${s.firstName || ''} ${s.lastName || ''}`.trim() || 'Unnamed Student',
                            studentId: s.studentId
                        }));
                    }
                }
                
                // Store students for use in matching interface
                window.bulkStudents = students;
                
                // If files are already uploaded, update matching interface
                if (bulkFiles.length > 0) {
                    updateBulkMatchingInterface();
                }
            } catch (e) {
                console.error('Error loading bulk students:', e);
            }
        }

        function handleBulkFiles(files) {
            const fileArray = Array.from(files);
            const allowedVideoFormats = ['.mp4', '.webm', '.mov', '.avi', '.mkv'];
            const allowedAudioFormats = ['.mp3', '.wav', '.m4a', '.webm'];
            
            fileArray.forEach(file => {
                const fileName = (file.name || '').toLowerCase();
                const fileExtension = fileName.substring(fileName.lastIndexOf('.'));
                const isVideo = (file.type || '').startsWith('video/');
                const isAudio = (file.type || '').startsWith('audio/');
                
                if (!isVideo && !isAudio) {
                    const isVideoByExt = allowedVideoFormats.some(ext => fileName.endsWith(ext));
                    const isAudioByExt = allowedAudioFormats.some(ext => fileName.endsWith(ext));
                    if (!isVideoByExt && !isAudioByExt) {
                        alert(`File "${file.name}" is not a supported video or audio format.`);
                        return;
                    }
                }
                
                // Detect assignment type from filename if possible
                let detectedAssignmentType = detectAssignmentTypeFromFilename(file.name);
                
                // Add to bulk files array
                bulkFiles.push({
                    file: file,
                    studentId: '',
                    studentName: '',
                    status: 'pending',
                    evaluationId: null,
                    error: null,
                    folderPath: null, // Track if from folder upload
                    detectedAssignmentType: detectedAssignmentType, // Detected from filename
                    assignmentType: null // Will be set from dropdown or detected
                });
            });
            
            updateBulkFileList();
            updateBulkMatchingInterface();
        }

        function handleBulkFolder(files) {
            // Organize files by folder/student name
            const filesByFolder = {};
            const allowedVideoFormats = ['.mp4', '.webm', '.mov', '.avi', '.mkv'];
            const allowedAudioFormats = ['.mp3', '.wav', '.m4a', '.webm'];
            
            Array.from(files).forEach(file => {
                // Extract folder name from file path
                // File.webkitRelativePath format: "FolderName/video.mp4"
                const relativePath = file.webkitRelativePath || file.name;
                const pathParts = relativePath.split('/');
                
                if (pathParts.length < 2) {
                    // File is in root, treat as individual file
                    const fileName = (file.name || '').toLowerCase();
                    const fileExtension = fileName.substring(fileName.lastIndexOf('.'));
                    const isVideo = (file.type || '').startsWith('video/');
                    const isAudio = (file.type || '').startsWith('audio/');
                    
                    if (!isVideo && !isAudio) {
                        const isVideoByExt = allowedVideoFormats.some(ext => fileName.endsWith(ext));
                        const isAudioByExt = allowedAudioFormats.some(ext => fileName.endsWith(ext));
                        if (!isVideoByExt && !isAudioByExt) {
                            return; // Skip non-media files
                        }
                    }
                    
                    if (!filesByFolder['_root']) {
                        filesByFolder['_root'] = [];
                    }
                    filesByFolder['_root'].push({ file, folderPath: null });
                    return;
                }
                
                // Get folder name (first part of path)
                const folderName = pathParts[0];
                const fileName = (file.name || '').toLowerCase();
                const fileExtension = fileName.substring(fileName.lastIndexOf('.'));
                const isVideo = (file.type || '').startsWith('video/');
                const isAudio = (file.type || '').startsWith('audio/');
                
                // Check if it's a media file
                if (!isVideo && !isAudio) {
                    const isVideoByExt = allowedVideoFormats.some(ext => fileName.endsWith(ext));
                    const isAudioByExt = allowedAudioFormats.some(ext => fileName.endsWith(ext));
                    if (!isVideoByExt && !isAudioByExt) {
                        return; // Skip non-media files
                    }
                }
                
                if (!filesByFolder[folderName]) {
                    filesByFolder[folderName] = [];
                }
                filesByFolder[folderName].push({ file, folderPath: folderName });
            });
            
            // Add all files to bulkFiles array, grouped by folder
            Object.keys(filesByFolder).forEach(folderName => {
                filesByFolder[folderName].forEach(({ file, folderPath }) => {
                    // Detect assignment type from filename
                    let detectedAssignmentType = detectAssignmentTypeFromFilename(file.name);
                    
                    bulkFiles.push({
                        file: file,
                        studentId: '',
                        studentName: '',
                        status: 'pending',
                        evaluationId: null,
                        error: null,
                        folderPath: folderPath,
                        folderName: folderName === '_root' ? null : folderName,
                        detectedAssignmentType: detectedAssignmentType,
                        assignmentType: null
                    });
                });
            });
            
            // Attempt to match folder names to students
            if (window.bulkStudents && window.bulkStudents.length > 0) {
                Object.keys(filesByFolder).forEach(folderName => {
                    if (folderName === '_root') return;
                    
                    // Try to match folder name to student
                    const match = attemptFilenameMatching(folderName, window.bulkStudents);
                    if (match) {
                        // Assign all files in this folder to the matched student
                        bulkFiles.forEach(item => {
                            if (item.folderName === folderName && !item.studentId) {
                                item.studentId = match.id;
                                item.studentName = match.name;
                            }
                        });
                    }
                });
            }
            
            updateBulkFileList();
            updateBulkMatchingInterface();
            
            // Show notification about folder structure
            const folderCount = Object.keys(filesByFolder).filter(k => k !== '_root').length;
            if (folderCount > 0) {
                const totalFiles = bulkFiles.length;
                showNotification(`Uploaded ${totalFiles} video(s) from ${folderCount} folder(s). Review student assignments below.`, 'info', 5000);
            }
        }

        function updateBulkFileList() {
            const fileInfo = document.getElementById('bulkFileInfo');
            const fileCount = document.getElementById('bulkFileCount');
            const fileList = document.getElementById('bulkFileList');
            
            if (!fileInfo || !fileCount || !fileList) return;
            
            if (bulkFiles.length > 0) {
                fileInfo.style.display = 'block';
                fileCount.textContent = bulkFiles.length;
                
                fileList.innerHTML = '';
                bulkFiles.forEach((item, idx) => {
                    const fileSize = formatFileSize(item.file.size);
                    const div = document.createElement('div');
                    div.style.cssText = 'padding: 0.5rem; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center;';
                    div.innerHTML = `
                        <span style="flex: 1; color: var(--text);">${escapeHtml(item.file.name)}</span>
                        <span style="color: var(--text-light); font-size: 0.875rem; margin-right: 1rem;">${fileSize}</span>
                        <button onclick="removeBulkFile(${idx})" class="btn-small btn-danger" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;"><i data-lucide="x"></i></button>
                    `;
                    fileList.appendChild(div);
                });
                
                if (typeof lucide !== 'undefined' && lucide.createIcons) {
                    lucide.createIcons({ root: fileList });
                }
            } else {
                fileInfo.style.display = 'none';
            }
        }

        function removeBulkFile(index) {
            bulkFiles.splice(index, 1);
            updateBulkFileList();
            updateBulkMatchingInterface();
        }

        function clearBulkFiles() {
            bulkFiles = [];
            updateBulkFileList();
            const matchingStep = document.getElementById('bulkMatchingStep');
            if (matchingStep) matchingStep.classList.add('hidden');
        }

        function updateBulkMatchingInterface() {
            const matchingStep = document.getElementById('bulkMatchingStep');
            const tableBody = document.getElementById('bulkMatchingTableBody');
            
            if (!tableBody) return;
            
            if (bulkFiles.length === 0) {
                if (matchingStep) matchingStep.classList.add('hidden');
                return;
            }
            
            // Show matching step
            if (matchingStep) matchingStep.classList.remove('hidden');
            
            // Clear table
            tableBody.innerHTML = '';
            
            // Get students for dropdown
            const students = window.bulkStudents || [];
            
            bulkFiles.forEach((item, idx) => {
                const row = document.createElement('tr');
                row.style.borderBottom = '1px solid var(--border)';
                
                // Attempt filename matching
                let matchedStudentId = '';
                if (students.length > 0 && !item.studentId) {
                    const match = attemptFilenameMatching(item.file.name, students);
                    if (match) {
                        matchedStudentId = match.id;
                        item.studentId = match.id;
                        item.studentName = match.name;
                    }
                } else if (item.studentId) {
                    matchedStudentId = item.studentId;
                }
                
                const fileSize = formatFileSize(item.file.size);
                const assignmentTypeSelect = document.getElementById('bulkAssignmentType');
                const defaultAssignmentType = assignmentTypeSelect ? assignmentTypeSelect.value : 'Speech';
                const itemAssignmentType = item.assignmentType || item.detectedAssignmentType || defaultAssignmentType;
                
                // Show detected assignment type hint
                const assignmentHint = item.detectedAssignmentType && item.detectedAssignmentType !== defaultAssignmentType 
                    ? `<div style="color: var(--info); font-size: 0.75rem; margin-top: 0.25rem;">💡 Detected: ${escapeHtml(item.detectedAssignmentType)}</div>` 
                    : '';
                
                row.innerHTML = `
                    <td style="padding: 0.75rem;">
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <i data-lucide="video" style="width:18px;height:18px;color:var(--primary);"></i>
                            <div>
                                <div style="color: var(--text);">${escapeHtml(item.file.name)}</div>
                                ${item.folderName ? `<div style="color: var(--text-light); font-size: 0.75rem; margin-top: 0.25rem;">📁 ${escapeHtml(item.folderName)}</div>` : ''}
                                ${assignmentHint}
                            </div>
                        </div>
                    </td>
                    <td style="padding: 0.75rem; color: var(--text-light); font-size: 0.875rem;">${fileSize}</td>
                    <td style="padding: 0.75rem;">
                        <select class="bulk-student-select" data-index="${idx}" onchange="updateBulkFileStudent(${idx}, this.value)" style="width: 100%; padding: 0.5rem; border: 2px solid var(--border); border-radius: 0.375rem; font-size: 0.9375rem;">
                            <option value="">-- Select Student --</option>
                            ${students.map(s => `<option value="${s.id}" ${s.id === matchedStudentId ? 'selected' : ''}>${escapeHtml(s.name)}</option>`).join('')}
                        </select>
                    </td>
                    <td style="padding: 0.75rem; text-align: center;">
                        <span class="bulk-status-badge" style="padding: 0.25rem 0.75rem; border-radius: 0.25rem; font-size: 0.875rem; background: var(--bg-alt); color: var(--text-light);">Pending</span>
                    </td>
                    <td style="padding: 0.75rem; text-align: center;">
                        <button onclick="removeBulkFile(${idx})" class="btn-small btn-danger" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;"><i data-lucide="trash-2"></i></button>
                    </td>
                `;
                
                tableBody.appendChild(row);
            });
            
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons({ root: tableBody });
            }
            
            validateBulkUploadForm();
        }

        function detectAssignmentTypeFromFilename(filename) {
            if (!filename) return null;
            
            const lowerFilename = filename.toLowerCase();
            
            // Common assignment type keywords
            const assignmentPatterns = [
                { pattern: /informative|info/i, type: 'Informative Speech' },
                { pattern: /persuasive|persuade/i, type: 'Persuasive Speech' },
                { pattern: /demonstration|demo/i, type: 'Demonstration Speech' },
                { pattern: /special.?occasion/i, type: 'Special Occasion Speech' },
                { pattern: /presentation/i, type: 'Presentation' },
                { pattern: /group/i, type: 'Group Presentation' },
                { pattern: /speech[^0-9]*1|speech.*one|first.*speech/i, type: 'Speech' },
                { pattern: /speech[^0-9]*2|speech.*two|second.*speech/i, type: 'Speech' },
                { pattern: /speech[^0-9]*3|speech.*three|third.*speech/i, type: 'Speech' },
                { pattern: /speech[^0-9]*4|speech.*four|fourth.*speech/i, type: 'Speech' },
                { pattern: /speech[^0-9]*5|speech.*five|fifth.*speech/i, type: 'Speech' }
            ];
            
            for (const { pattern, type } of assignmentPatterns) {
                if (pattern.test(lowerFilename)) {
                    return type;
                }
            }
            
            return null;
        }

        function attemptFilenameMatching(filename, students) {
            if (!filename || !students || students.length === 0) return null;
            
            const lowerFilename = filename.toLowerCase();
            
            // Try matching by student name
            for (const student of students) {
                const fullName = `${student.firstName || ''} ${student.lastName || ''}`.trim().toLowerCase();
                const firstName = (student.firstName || '').toLowerCase();
                const lastName = (student.lastName || '').toLowerCase();
                
                // Check if filename contains full name, first name, or last name
                if (fullName && lowerFilename.includes(fullName)) {
                    return { id: student.id, name: student.name };
                }
                if (firstName && lowerFilename.includes(firstName) && firstName.length > 2) {
                    return { id: student.id, name: student.name };
                }
                if (lastName && lowerFilename.includes(lastName) && lastName.length > 2) {
                    return { id: student.id, name: student.name };
                }
                
                // Try matching by student ID
                if (student.studentId) {
                    const studentIdLower = student.studentId.toLowerCase();
                    if (lowerFilename.includes(studentIdLower)) {
                        return { id: student.id, name: student.name };
                    }
                }
            }
            
            return null;
        }

        function updateBulkFileStudent(index, studentId) {
            if (index < 0 || index >= bulkFiles.length) return;
            
            const students = window.bulkStudents || [];
            const student = students.find(s => s.id === studentId);
            
            bulkFiles[index].studentId = studentId || '';
            bulkFiles[index].studentName = student ? student.name : '';
            
            validateBulkUploadForm();
        }

        function validateBulkUploadForm() {
            const courseSelect = document.getElementById('bulkCourseSelect');
            const rubricSelect = document.getElementById('bulkRubricSelect');
            const startBtn = document.getElementById('startBulkProcessingBtn');
            
            if (!startBtn) return;
            
            const courseValid = courseSelect && courseSelect.value;
            const rubricValid = rubricSelect && rubricSelect.value;
            const allStudentsAssigned = bulkFiles.length > 0 && bulkFiles.every(item => item.studentId);
            
            if (courseValid && rubricValid && allStudentsAssigned && bulkFiles.length > 0) {
                startBtn.disabled = false;
                startBtn.style.opacity = '1';
                startBtn.style.cursor = 'pointer';
            } else {
                startBtn.disabled = true;
                startBtn.style.opacity = '0.6';
                startBtn.style.cursor = 'not-allowed';
            }
        }

        // ===== LOGO FALLBACK =====
        function setupLogoFallback() {
            // Check if transparent logo exists, fallback to existing logos if not
            // This runs immediately to catch images that are already in the DOM
            const logoImages = document.querySelectorAll('img[src*="3d-logo-transparent.png"]');
            logoImages.forEach(img => {
                // Set up error handler
                img.onerror = function() {
                    console.warn('3d-logo-transparent.png not found, using fallback');
                    const currentSrc = img.src || img.getAttribute('src') || '';
                    // Determine which fallback to use based on context
                    if (img.id === 'authLogoImg' || currentSrc.includes('auth')) {
                        // Auth/login page - use light background logo
                        img.src = currentSrc.replace('3d-logo-transparent.png', 'logo-light-bg.png').replace('assets/3d-', 'assets/');
                    } else if (img.closest('#appLogo') || currentSrc.includes('appLogo')) {
                        // Header logo - use dark background logo (for dark header)
                        img.src = currentSrc.replace('3d-logo-transparent.png', 'logo-dark-bg.png').replace('assets/3d-', 'assets/');
                    } else {
                        // Default to light background
                        img.src = currentSrc.replace('3d-logo-transparent.png', 'logo-light-bg.png').replace('assets/3d-', 'assets/');
                    }
                    img.onerror = null; // Prevent infinite loop
                };
                
                // Also trigger a load test
                const testImg = new Image();
                testImg.onerror = function() {
                    // Logo doesn't exist, trigger the fallback
                    img.onerror();
                };
                testImg.src = img.src || img.getAttribute('src') || '';
            });
            
            // Also check favicon
            const favicon = document.getElementById('faviconLink');
            if (favicon) {
                const testImg = new Image();
                testImg.onerror = function() {
                    console.warn('Favicon 3d-logo-transparent.png not found, using fallback');
                    favicon.href = favicon.href.replace('3d-logo-transparent.png', 'logo-light-bg.png').replace('assets/3d-', 'assets/');
                };
                testImg.src = favicon.href;
            }
            
            // Also handle dynamically added logos (e.g., in JavaScript)
            // Use MutationObserver to catch logos added after page load
            if (typeof MutationObserver !== 'undefined') {
                const observer = new MutationObserver(function(mutations) {
                    mutations.forEach(function(mutation) {
                        mutation.addedNodes.forEach(function(node) {
                            if (node.nodeType === 1) { // Element node
                                const imgs = node.querySelectorAll ? node.querySelectorAll('img[src*="3d-logo-transparent.png"]') : [];
                                imgs.forEach(function(img) {
                                    img.onerror = function() {
                                        const currentSrc = img.src || img.getAttribute('src') || '';
                                        if (img.id === 'authLogoImg' || currentSrc.includes('auth')) {
                                            img.src = currentSrc.replace('3d-logo-transparent.png', 'logo-light-bg.png').replace('assets/3d-', 'assets/');
                                        } else if (img.closest('#appLogo') || currentSrc.includes('appLogo')) {
                                            img.src = currentSrc.replace('3d-logo-transparent.png', 'logo-dark-bg.png').replace('assets/3d-', 'assets/');
                                        } else {
                                            img.src = currentSrc.replace('3d-logo-transparent.png', 'logo-light-bg.png').replace('assets/3d-', 'assets/');
                                        }
                                        img.onerror = null;
                                    };
                                });
                            }
                        });
                    });
                });
                observer.observe(document.body, { childList: true, subtree: true });
            }
        }

        // ===== FILE UPLOAD =====
        function initializeFileUpload() {
            const uploadZone = document.getElementById('uploadZone');
            const fileInput = document.getElementById('fileInput');

            uploadZone.addEventListener('click', () => fileInput.click());

            uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadZone.classList.add('drag-over');
            });

            uploadZone.addEventListener('dragleave', () => {
                uploadZone.classList.remove('drag-over');
            });

            uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadZone.classList.remove('drag-over');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });

            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFile(e.target.files[0]);
                }
            });
        }

        const COMPRESS_VIDEO_MAX_BYTES = 50 * 1024 * 1024; // 50 MB (Supabase limit)

        /** Call backend to compress video to under 50 MB; returns a new File or throws. */
        async function compressVideoForUpload(file) {
            const apiBase = window.location.origin + '/api';
            const form = new FormData();
            form.append('file', file);
            const res = await fetch(apiBase + '/compress_video', { method: 'POST', body: form });
            if (!res.ok) {
                const t = await res.text();
                var msg = t || 'Compression failed';
                if (res.status === 502 || res.status >= 500) {
                    msg = 'Server compression is not available on this deployment (e.g. Render without Docker). Compress your video to under 50 MB with a local tool, or continue to evaluate—the video will not be saved for storage or training.';
                }
                throw new Error(msg);
            }
            const blob = await res.blob();
            const name = (file.name || 'video').replace(/\.[a-zA-Z0-9]+$/, '') + '.mp4';
            return new File([blob], name, { type: 'video/mp4' });
        }

        function setFileUI(file) {
            uploadedFile = file;
            const fileNameEl = document.getElementById('fileName');
            if (fileNameEl) {
                const fileSize = formatFileSize(file.size);
                const fileSizeMB = file.size / (1024 * 1024);
                let sizeWarning = '';
                if (fileSizeMB > 40) {
                    sizeWarning = ' <span style="color: var(--warning); font-weight: 600;">(Large file - may take longer)</span>';
                } else if (fileSizeMB > 30) {
                    sizeWarning = ' <span style="color: var(--text-light);">(Moderate size)</span>';
                }
                fileNameEl.innerHTML = `<span class="icon-with-text"><i data-lucide="paperclip"></i> ${escapeHtml(file.name)} <strong>${fileSize}</strong>${sizeWarning}</span>`;
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: fileNameEl });
            }
            const fileInfo = document.getElementById('fileInfo');
            if (fileInfo) fileInfo.classList.remove('hidden');
            const continueBtn = document.getElementById('continueButtonContainer');
            if (continueBtn) continueBtn.style.display = 'block';
            
            // Show class/student selection if user has classes
            const uploadClassStudentContainer = document.getElementById('uploadClassStudentContainer');
            if (uploadClassStudentContainer) {
                try {
                    const classes = JSON.parse(getUserItem('classes') || '[]');
                    if (classes && classes.length > 0) {
                        uploadClassStudentContainer.style.display = 'block';
                        populateUploadClassSelector();
                    }
                } catch (e) {
                    console.warn('Could not load classes for upload assignment:', e);
                }
            }
        }
        
        // Populate class selector in upload step
        function populateUploadClassSelector() {
            try {
                const classes = JSON.parse(getUserItem('classes') || '[]');
                const sel = document.getElementById('uploadClassSel');
                if (!sel) return;
                sel.innerHTML = '<option value="">-- Select Class (Optional) --</option>';
                for (let i = 0; i < classes.length; i++) {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.textContent = classes[i].name + ' - ' + classes[i].semester + ' ' + classes[i].year;
                    sel.appendChild(opt);
                }
            } catch (e) {
                console.error('Error populating upload class selector:', e);
            }
        }
        
        // Load students for selected class in upload step
        function loadUploadStudents() {
            try {
                const classSel = document.getElementById('uploadClassSel');
                if (!classSel) return;
                const idx = classSel.value;
                const studentSel = document.getElementById('uploadStudentSel');
                if (!studentSel) return;
                studentSel.innerHTML = '<option value="">-- Select Student (Optional) --</option>';
                if (!idx) return;
                const classes = JSON.parse(getUserItem('classes') || '[]');
                const classData = classes[idx];
                if (classData && classData.roster) {
                    for (let i = 0; i < classData.roster.length; i++) {
                        const student = classData.roster[i];
                        const opt = document.createElement('option');
                        opt.value = i;
                        opt.textContent = (student.firstName || '') + ' ' + (student.lastName || '');
                        studentSel.appendChild(opt);
                    }
                }
            } catch (e) {
                console.error('Error loading upload students:', e);
            }
        }

        // Error message mapping for user-friendly error messages
        function formatErrorMessage(error, context = {}) {
            const errorStr = String(error).toLowerCase();
            const errorMessage = String(error);
            
            // Video format not supported
            if (errorStr.includes('format') || errorStr.includes('mp4') || errorStr.includes('webm') || errorStr.includes('video')) {
                const fileExtension = context.fileExtension || 'unknown';
                return `Video must be MP4, WebM, MOV, or AVI. Your file is ${fileExtension}. Please convert and try again.`;
            }
            
            // Video too large
            if (errorStr.includes('size') || errorStr.includes('large') || errorStr.includes('50mb') || errorStr.includes('exceed')) {
                const fileSizeMB = context.fileSizeMB || 'unknown';
                return `Video must be under 50MB. Your video is ${fileSizeMB}MB. Please compress and try again.`;
            }
            
            // Qwen service down
            if (errorStr.includes('503') || errorStr.includes('service') || errorStr.includes('unavailable') || errorStr.includes('not ready')) {
                return 'Evaluation service is temporarily unavailable. Please try again in a few minutes.';
            }
            
            // Rate limit exceeded
            if (errorStr.includes('429') || errorStr.includes('rate limit') || errorStr.includes('too many')) {
                const waitTime = context.waitTime || 'a few';
                return `Too many requests. Please wait ${waitTime} seconds before trying again.`;
            }
            
            // Connection errors
            if (errorStr.includes('failed to fetch') || errorStr.includes('network') || errorStr.includes('connection')) {
                return 'Connection error. Please check your internet connection and try again.';
            }
            
            // Timeout errors
            if (errorStr.includes('timeout') || errorStr.includes('504')) {
                return 'The evaluation is taking longer than expected. Please try again with a smaller video file.';
            }
            
            // Out of memory
            if (errorStr.includes('oom') || errorStr.includes('out of memory') || errorStr.includes('cuda')) {
                return 'The video is too large to process. Please compress your video to under 50MB and try again.';
            }
            
            // Model not loaded
            if (errorStr.includes('model') && (errorStr.includes('not loaded') || errorStr.includes('load'))) {
                return 'The evaluation model is not ready. Please try again in a few moments.';
            }
            
            // Return original error if no mapping found
            return errorMessage;
        }

        function handleFile(file) {
            // Check file format first
            const allowedVideoFormats = ['.mp4', '.webm', '.mov', '.avi', '.mkv'];
            const allowedAudioFormats = ['.mp3', '.wav', '.m4a', '.webm'];
            const fileName = (file.name || '').toLowerCase();
            const fileExtension = fileName.substring(fileName.lastIndexOf('.'));
            const isVideo = (file.type || '').startsWith('video/');
            const isAudio = (file.type || '').startsWith('audio/');
            
            if (!isVideo && !isAudio) {
                // Try to determine from extension
                const isVideoByExt = allowedVideoFormats.some(ext => fileName.endsWith(ext));
                const isAudioByExt = allowedAudioFormats.some(ext => fileName.endsWith(ext));
                
                if (!isVideoByExt && !isAudioByExt) {
                    const errorMsg = formatErrorMessage('Video format not supported', { fileExtension: fileExtension || 'unknown' });
                    if (typeof showNotification === 'function') {
                        showNotification(errorMsg, 'error', 6000);
                    } else {
                        alert(errorMsg);
                    }
                    const fileInput = document.getElementById('fileInput');
                    if (fileInput) fileInput.value = '';
                    return;
                }
            }
            
            // Check file size limit (50MB) - reject immediately if over limit
            const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50 MB
            if (file.size > MAX_FILE_SIZE) {
                const sizeMB = (file.size / 1024 / 1024).toFixed(2);
                const errorMsg = formatErrorMessage('Video too large', { fileSizeMB: sizeMB });
                if (typeof showNotification === 'function') {
                    showNotification(errorMsg, 'error', 6000);
                } else {
                    alert(errorMsg);
                }
                // Clear the file input
                const fileInput = document.getElementById('fileInput');
                if (fileInput) fileInput.value = '';
                return;
            }
            
            const overLimit = file.size > COMPRESS_VIDEO_MAX_BYTES;
            if (isVideo && overLimit) {
                const fileNameEl = document.getElementById('fileName');
                if (fileNameEl) {
                    fileNameEl.innerHTML = '<span class="icon-with-text"><i data-lucide="loader-2" class="spin"></i> Compressing video to under 50 MB…</span>';
                    if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: fileNameEl });
                }
                const fileInfo = document.getElementById('fileInfo');
                if (fileInfo) fileInfo.classList.remove('hidden');
                const continueBtn = document.getElementById('continueButtonContainer');
                if (continueBtn) continueBtn.style.display = 'none';
                (async function () {
                    try {
                        const compressed = await compressVideoForUpload(file);
                        setFileUI(compressed);
                        if (continueBtn) continueBtn.style.display = 'block';
                    } catch (e) {
                        console.warn('Video compression failed:', e);
                        if (fileNameEl) {
                            var hint = (e && e.message && e.message.indexOf('not available') !== -1)
                                ? 'Server can\'t compress. Compress to under 50 MB locally, or continue to evaluate (video won\'t be saved).'
                                : 'Too large to store; compress locally to under 50 MB or continue to evaluate (video won\'t be saved).';
                            fileNameEl.innerHTML = `<span class="icon-with-text"><i data-lucide="alert-circle"></i> ${escapeHtml(file.name)} (${formatFileSize(file.size)}) – ${escapeHtml(hint)}</span>`;
                            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: fileNameEl });
                        }
                        uploadedFile = file;
                        if (continueBtn) continueBtn.style.display = 'block';
                    }
                })();
                return;
            }
            setFileUI(file);
            // setFileUI already shows the button, no need to show it again here
        }

        function removeFile() {
            uploadedFile = null;
            const fileInfo = document.getElementById('fileInfo');
            if (fileInfo) fileInfo.classList.add('hidden');
            const fileInput = document.getElementById('fileInput');
            if (fileInput) fileInput.value = '';
            const continueBtn = document.getElementById('continueButtonContainer');
            if (continueBtn) continueBtn.style.display = 'none';
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        // ===== FORM VALIDATION =====
        function validateEvalForm() {
            const rubricSelect = document.getElementById('rubricSelect');
            const submitBtn = document.getElementById('submitEvaluationBtn');
            let isValid = true;
            
            // Validate rubric (required)
            if (rubricSelect) {
                const rubricError = document.getElementById('rubricSelect-error');
                if (!rubricSelect.value || rubricSelect.value === '') {
                    rubricSelect.classList.add('invalid');
                    rubricSelect.classList.remove('valid');
                    if (rubricError) {
                        rubricError.classList.add('show');
                        rubricError.querySelector('span').textContent = 'Please select a rubric to continue.';
                    }
                    isValid = false;
                } else {
                    rubricSelect.classList.remove('invalid');
                    rubricSelect.classList.add('valid');
                    if (rubricError) {
                        rubricError.classList.remove('show');
                    }
                    // Enable preview button
                    updateRubricPreview();
                }
            }
            
            // Validate student if class is selected
            const classSelect = document.getElementById('evalClassSelect');
            const studentSelect = document.getElementById('evalStudentSelect');
            if (classSelect && studentSelect && classSelect.value && classSelect.value !== '' && classSelect.value !== 'other') {
                const studentError = document.getElementById('evalStudentSelect-error');
                if (!studentSelect.value || studentSelect.value === '') {
                    studentSelect.classList.add('invalid');
                    studentSelect.classList.remove('valid');
                    if (studentError) {
                        studentError.classList.add('show');
                        studentError.querySelector('span').textContent = 'Please select a student when a class is selected.';
                    }
                    // Student is optional, so don't block submission, but show warning
                } else {
                    studentSelect.classList.remove('invalid');
                    studentSelect.classList.add('valid');
                    if (studentError) {
                        studentError.classList.remove('show');
                    }
                }
            }
            
            // Enable/disable submit button
            if (submitBtn) {
                submitBtn.disabled = !isValid;
                if (isValid) {
                    submitBtn.style.opacity = '1';
                    submitBtn.style.cursor = 'pointer';
                } else {
                    submitBtn.style.opacity = '0.6';
                    submitBtn.style.cursor = 'not-allowed';
                }
            }
            
            return isValid;
        }
        
        // Initialize form validation on step 2 load
        function initEvalFormValidation() {
            const rubricSelect = document.getElementById('rubricSelect');
            const classSelect = document.getElementById('evalClassSelect');
            const studentSelect = document.getElementById('evalStudentSelect');
            const speechDate = document.getElementById('speechDate');
            const assignmentType = document.getElementById('assignmentType');
            
            // Add validation listeners
            if (rubricSelect) {
                rubricSelect.addEventListener('blur', validateEvalForm);
            }
            if (classSelect) {
                classSelect.addEventListener('blur', validateEvalForm);
            }
            if (studentSelect) {
                studentSelect.addEventListener('blur', validateEvalForm);
            }
            
            // Set default date to today
            if (speechDate && !speechDate.value) {
                const today = new Date().toISOString().split('T')[0];
                speechDate.value = today;
            }
            
            // Apply smart defaults
            applySmartDefaults();
            
            // Initial validation
            validateEvalForm();
        }
        
        // Apply smart defaults based on context
        function applySmartDefaults() {
            try {
                // Remember last used rubric per course
                const classSelect = document.getElementById('evalClassSelect');
                const rubricSelect = document.getElementById('rubricSelect');
                
                if (classSelect && rubricSelect && classSelect.value && classSelect.value !== '' && classSelect.value !== 'other') {
                    const lastRubricKey = `lastRubric_${classSelect.value}`;
                    const lastRubricId = getUserItem(lastRubricKey);
                    
                    if (lastRubricId && rubricSelect.querySelector(`option[value="${lastRubricId}"]`)) {
                        rubricSelect.value = lastRubricId;
                        updateRubricPreview();
                    }
                }
            } catch (e) {
                console.warn('Error applying smart defaults:', e);
            }
        }
        
        // Save last used rubric when rubric is selected
        function saveLastUsedRubric() {
            try {
                const classSelect = document.getElementById('evalClassSelect');
                const rubricSelect = document.getElementById('rubricSelect');
                
                if (classSelect && rubricSelect && classSelect.value && rubricSelect.value) {
                    const lastRubricKey = `lastRubric_${classSelect.value}`;
                    setUserItem(lastRubricKey, rubricSelect.value);
                }
            } catch (e) {
                console.warn('Error saving last used rubric:', e);
            }
        }
        
        // Update rubric preview button state
        function updateRubricPreview() {
            const rubricSelect = document.getElementById('rubricSelect');
            const previewBtn = document.getElementById('previewRubricBtn');
            if (previewBtn && rubricSelect) {
                if (rubricSelect.value && rubricSelect.value !== '') {
                    previewBtn.disabled = false;
                    previewBtn.style.opacity = '1';
                    previewBtn.style.cursor = 'pointer';
                } else {
                    previewBtn.disabled = true;
                    previewBtn.style.opacity = '0.6';
                    previewBtn.style.cursor = 'not-allowed';
                }
            }
        }
        
        // Preview selected rubric
        async function previewSelectedRubric() {
            const rubricSelect = document.getElementById('rubricSelect');
            if (!rubricSelect || !rubricSelect.value) {
                alert('Please select a rubric first.');
                return;
            }
            
            try {
                const rubric = await getRubricById(rubricSelect.value);
                if (!rubric) {
                    alert('Rubric not found.');
                    return;
                }
                
                // Build preview HTML
                let previewHtml = `
                    <div style="max-width: 600px; max-height: 80vh; overflow-y: auto;">
                        <h3 style="margin: 0 0 1rem 0; color: var(--primary);">${escapeHtml(rubric.name || 'Unnamed Rubric')}</h3>
                        ${rubric.description ? `<p style="color: var(--text-light); margin-bottom: 1.5rem;">${escapeHtml(rubric.description)}</p>` : ''}
                        <div style="margin-bottom: 1rem;">
                            <strong>Total Points:</strong> ${rubric.totalPoints || 0}
                        </div>
                `;
                
                if (rubric.categories && rubric.categories.length > 0) {
                    previewHtml += '<div style="margin-top: 1.5rem;"><strong>Categories:</strong><ul style="margin: 0.5rem 0 0 0; padding-left: 1.5rem;">';
                    rubric.categories.forEach(cat => {
                        const catPoints = cat.subcategories ? cat.subcategories.reduce((sum, sub) => sum + (parseFloat(sub.maxPoints) || 0), 0) : 0;
                        previewHtml += `<li style="margin-bottom: 0.75rem;">
                            <strong>${escapeHtml(cat.name || 'Unnamed')}</strong> (${catPoints} points)
                            ${cat.description ? `<br><span style="color: var(--text-light); font-size: 0.9rem;">${escapeHtml(cat.description)}</span>` : ''}
                            ${cat.subcategories && cat.subcategories.length > 0 ? `
                                <ul style="margin: 0.5rem 0 0 1rem; padding-left: 1rem; list-style-type: disc;">
                                    ${cat.subcategories.map(sub => `<li style="margin-bottom: 0.25rem;">${escapeHtml(sub.name || 'Unnamed')} (${sub.maxPoints || 0} pts)</li>`).join('')}
                                </ul>
                            ` : ''}
                        </li>`;
                    });
                    previewHtml += '</ul></div>';
                }
                
                previewHtml += '</div>';
                
                // Create and show modal
                const modalId = 'rubricPreviewModal';
                let modal = document.getElementById(modalId);
                if (!modal) {
                    modal = document.createElement('div');
                    modal.id = modalId;
                    modal.style.cssText = 'display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:9999;align-items:center;justify-content:center;';
                    document.body.appendChild(modal);
                }
                
                modal.innerHTML = `
                    <div style="background:white;padding:2rem;border-radius:1rem;max-width:700px;width:90%;max-height:90vh;overflow-y:auto;box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:1.5rem;">
                            <h3 style="margin:0;color:var(--primary);">Rubric Preview</h3>
                            <button onclick="document.getElementById('${modalId}').style.display='none'" style="background:none;border:none;padding:0.5rem;cursor:pointer;color:var(--text-light);border-radius:0.25rem;" onmouseover="this.style.background='var(--bg-alt)'" onmouseout="this.style.background='none'">
                                <i data-lucide="x" style="width:20px;height:20px;"></i>
                            </button>
                        </div>
                        ${previewHtml}
                        <div style="margin-top:1.5rem;display:flex;justify-content:flex-end;">
                            <button onclick="document.getElementById('${modalId}').style.display='none'" style="padding:0.75rem 1.5rem;background:var(--primary);color:white;border:none;border-radius:0.5rem;cursor:pointer;font-weight:600;">Close</button>
                        </div>
                    </div>
                `;
                
                modal.style.display = 'flex';
                if (typeof lucide !== 'undefined' && lucide.createIcons) {
                    lucide.createIcons({ root: modal });
                }
                
                // Close on background click
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        modal.style.display = 'none';
                    }
                });
            } catch (error) {
                console.error('Error loading rubric:', error);
                alert('Error loading rubric: ' + (error.message || error));
            }
        }
        
        // ===== LOAD CLASSES AND STUDENTS FOR EVALUATION =====
        function loadEvalClasses() {
            const classSelect = document.getElementById('evalClassSelect');
            if (!classSelect) return;
            
            // Clear existing options except None and Other
            classSelect.innerHTML = '<option value="">-- None --</option><option value="other">Other</option>';
            
            try {
                const classes = JSON.parse(getUserItem('classes') || '[]');
                classes.forEach((cls, index) => {
                    const option = document.createElement('option');
                    option.value = cls.id || index;
                    option.textContent = cls.name || `Class ${index + 1}`;
                    classSelect.appendChild(option);
                });
            } catch (e) {
                console.warn('Could not load classes for evaluation:', e);
            }
        }
        
        function loadEvalStudents() {
            const classSelect = document.getElementById('evalClassSelect');
            const studentSelect = document.getElementById('evalStudentSelect');
            if (!classSelect || !studentSelect) return;
            
            const classValue = classSelect.value;
            studentSelect.innerHTML = '<option value="">-- None --</option>';
            
            if (!classValue || classValue === '' || classValue === 'other') {
                return;
            }
            
            try {
                const classes = JSON.parse(getUserItem('classes') || '[]');
                const classData = classes.find(c => (c.id === classValue || c.name === classValue) || 
                    (Array.isArray(classes) && classes[parseInt(classValue)]));
                
                if (classData && classData.roster && Array.isArray(classData.roster)) {
                    classData.roster.forEach((student, index) => {
                        const option = document.createElement('option');
                        option.value = student.id || student.studentId || index;
                        const studentName = (student.firstName || '') + ' ' + (student.lastName || '');
                        option.textContent = studentName.trim() || `Student ${index + 1}`;
                        studentSelect.appendChild(option);
                    });
                }
            } catch (e) {
                console.warn('Could not load students for evaluation:', e);
            }
        }
        
        // Populate evaluation fields from pending values (called when step 2 is shown)
        function populateEvalFieldsFromPending() {
            if (!pendingClassIdForEval || !pendingStudentIdForEval) {
                return;
            }
            
            const classSelect = document.getElementById('evalClassSelect');
            const studentSelect = document.getElementById('evalStudentSelect');
            
            if (!classSelect || !studentSelect) {
                // Retry if elements aren't ready yet
                setTimeout(populateEvalFieldsFromPending, 100);
                return;
            }
            
            try {
                const classes = JSON.parse(getUserItem('classes') || '[]');
                const classData = classes.find(c => c.id === pendingClassIdForEval);
                
                if (!classData) {
                    console.warn('Class data not found for pending class ID:', pendingClassIdForEval);
                    pendingClassIdForEval = null;
                    pendingStudentIdForEval = null;
                    return;
                }
                
                // Find and select the class
                let classFound = false;
                for (let i = 0; i < classSelect.options.length; i++) {
                    const option = classSelect.options[i];
                    if (option.value === String(pendingClassIdForEval) || 
                        option.value === pendingClassIdForEval ||
                        (classData && option.textContent.includes(classData.name))) {
                        classSelect.value = option.value;
                        classFound = true;
                        break;
                    }
                }
                
                if (!classFound) {
                    console.warn('Could not find class option for:', pendingClassIdForEval);
                    pendingClassIdForEval = null;
                    pendingStudentIdForEval = null;
                    return;
                }
                
                // Trigger change to load students
                classSelect.dispatchEvent(new Event('change'));
                
                // Wait for students to load, then select the student
                setTimeout(() => {
                    const student = classData.roster?.find(s => 
                        s.id === pendingStudentIdForEval || 
                        s.supabaseId === pendingStudentIdForEval ||
                        s.studentId === pendingStudentIdForEval
                    );
                    
                    if (!student) {
                        console.warn('Student not found for pending student ID:', pendingStudentIdForEval);
                        pendingClassIdForEval = null;
                        pendingStudentIdForEval = null;
                        return;
                    }
                    
                    const studentName = `${student.firstName || ''} ${student.lastName || ''}`.trim();
                    const studentValue = student.id || student.supabaseId || student.studentId;
                    
                    // Find and select the student
                    for (let i = 0; i < studentSelect.options.length; i++) {
                        const option = studentSelect.options[i];
                        if (option.value === String(studentValue) || 
                            option.value === studentValue ||
                            option.textContent.trim() === studentName) {
                            studentSelect.value = option.value;
                            break;
                        }
                    }
                    
                    // Clear pending values after successful population
                    pendingClassIdForEval = null;
                    pendingStudentIdForEval = null;
                }, 200);
            } catch (e) {
                console.error('Error populating eval fields from pending:', e);
                pendingClassIdForEval = null;
                pendingStudentIdForEval = null;
            }
        }
        
        // ===== STEP NAVIGATION =====
        function moveToStep(step) {
            currentStep = step;
            console.log('=== moveToStep(' + step + ') called ===');
            
            // Hide all steps
            document.getElementById('uploadStep').classList.add('hidden');
            document.getElementById('detailsStep').classList.add('hidden');
            document.getElementById('processingStep').classList.add('hidden');
            document.getElementById('resultsStep').classList.add('hidden');
            
            // Hide evaluation saved indicator when leaving results step
            if (step !== 4) {
                hideEvaluationSavedIndicator();
            }
            
            // Update step indicators
            for (let i = 1; i <= 4; i++) {
                const stepEl = document.getElementById(`step${i}`);
                stepEl.classList.remove('active', 'completed');
                if (i < step) {
                    stepEl.classList.add('completed');
                } else if (i === step) {
                    stepEl.classList.add('active');
                }
            }
            
            // Load classes when showing step 2
            if (step === 2) {
                loadEvalClasses();
                
                // Initialize form validation
                setTimeout(() => {
                    initEvalFormValidation();
                }, 100);
                
                // If we have pending class/student values from addEvaluationForStudent, populate them
                if (pendingClassIdForEval && pendingStudentIdForEval) {
                    setTimeout(() => {
                        populateEvalFieldsFromPending();
                    }, 150);
                }
            }
            
            // Update card header based on step
            const headerEl = document.getElementById('evaluateCardHeader');
            if (step === 4) {
                headerEl.innerHTML = '<span class="icon-with-text"><i data-lucide="bar-chart-2"></i> Speech Evaluation Results</span>';
            } else {
                headerEl.innerHTML = '<span class="icon-with-text"><i data-lucide="mic"></i> Evaluate a Speech</span>';
            }
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: headerEl });
            
            // Add "Change File" button in step 2 if file is uploaded
            if (step === 2 && uploadedFile) {
                const detailsStep = document.getElementById('detailsStep');
                if (detailsStep) {
                    // Check if change file button already exists
                    let changeFileBtn = document.getElementById('changeFileBtn');
                    if (!changeFileBtn) {
                        changeFileBtn = document.createElement('button');
                        changeFileBtn.id = 'changeFileBtn';
                        changeFileBtn.type = 'button';
                        changeFileBtn.className = 'btn-secondary';
                        changeFileBtn.style.cssText = 'margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;';
                        changeFileBtn.innerHTML = '<i data-lucide="file-x"></i> Change File';
                        changeFileBtn.onclick = function() {
                            if (confirm('Changing the file will keep your current form selections. Continue?')) {
                                moveToStep(1);
                            }
                        };
                        const form = detailsStep.querySelector('form');
                        if (form) {
                            form.insertBefore(changeFileBtn, form.firstChild);
                            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                                lucide.createIcons({ root: changeFileBtn });
                            }
                        }
                    }
                }
            } else {
                // Remove change file button if not in step 2
                const changeFileBtn = document.getElementById('changeFileBtn');
                if (changeFileBtn) {
                    changeFileBtn.remove();
                }
            }
            
            // Show current step
            if (step === 1) {
                document.getElementById('uploadStep').classList.remove('hidden');
                // Ensure continue button is only shown if a file is actually uploaded
                const continueBtn = document.getElementById('continueButtonContainer');
                if (continueBtn) {
                    // Only show button if uploadedFile exists and is valid
                    if (uploadedFile && uploadedFile instanceof File && uploadedFile.size > 0) {
                        continueBtn.style.display = 'block';
                    } else {
                        continueBtn.style.display = 'none';
                    }
                }
            } else             if (step === 2) {
                document.getElementById('detailsStep').classList.remove('hidden');
                // Populate rubric selector
                populateRubricSelector();
                if (typeof updateEvalProviderHint === 'function') updateEvalProviderHint();
                // Initialize validation after rubric selector is populated
                setTimeout(() => {
                    validateEvalForm();
                }, 200);
            } else if (step === 3) {
                document.getElementById('processingStep').classList.remove('hidden');
            } else if (step === 4) {
                console.log('Showing results step');
                document.getElementById('resultsStep').classList.remove('hidden');
            }
        }

        async function updateRubricSelectorForClass() {
            // Re-populate rubric selector based on selected class
            await populateRubricSelector();
        }
        
        async function populateRubricSelector() {
            const select = document.getElementById('rubricSelect');
            if (!select) return;
            
            const rubrics = await getAllRubrics();
            const classes = JSON.parse(getUserItem('classes') || '[]');
            
            // Get selected class
            const classSelect = document.getElementById('evalClassSelect');
            const selectedClassId = classSelect?.value;
            const selectedClass = selectedClassId && selectedClassId !== '' && selectedClassId !== 'other' 
                ? classes.find(c => (c.id === selectedClassId || c.name === selectedClassId) || 
                    (Array.isArray(classes) && classes[parseInt(selectedClassId)]))
                : null;
            
            // Clear existing options except the first one
            select.innerHTML = '<option value="">-- Select a Rubric --</option>';
            
            // Separate rubrics by type
            const defaultRubrics = rubrics.filter(r => r.id === 'default');
            
            // Filter rubrics for the selected class
            const classRubrics = [];
            const generalRubrics = [];
            
            rubrics.filter(r => r.id !== 'default').forEach(rubric => {
                // Get courseIds for this rubric (handle both old and new format)
                let courseIds = [];
                if (rubric.courseIds && Array.isArray(rubric.courseIds)) {
                    courseIds = rubric.courseIds;
                } else if (rubric.courseId) {
                    courseIds = [rubric.courseId];
                }
                
                // Check if rubric is assigned to the selected class
                const isForSelectedClass = selectedClass && courseIds.some(courseId => {
                    return courseId === selectedClass.id || 
                           courseId === selectedClass.name ||
                           (Array.isArray(classes) && classes[parseInt(courseId)]?.id === selectedClass.id);
                });
                
                // Check if rubric is unassigned (general)
                const isUnassigned = courseIds.length === 0 || 
                    (!rubric.courseId && (!rubric.courseIds || rubric.courseIds.length === 0));
                
                if (isForSelectedClass) {
                    classRubrics.push(rubric);
                } else if (isUnassigned) {
                    generalRubrics.push(rubric);
                }
            });
            
            // If a class is selected, show class rubrics first, then general rubrics
            if (selectedClass) {
                // Add class-specific rubrics first
                if (classRubrics.length > 0) {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = `${selectedClass.name || 'Class'} Rubrics`;
                    classRubrics.forEach(rubric => {
                        const option = document.createElement('option');
                        option.value = rubric.id;
                        option.textContent = `${rubric.name} (${rubric.totalPoints || 0} pts)`;
                        if (rubric.speechType) {
                            option.textContent += ` - ${rubric.speechType}`;
                        }
                        optgroup.appendChild(option);
                    });
                    select.appendChild(optgroup);
                }
                
                // Add general/unassigned rubrics at the bottom
                if (generalRubrics.length > 0) {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = 'General Rubrics';
                    generalRubrics.forEach(rubric => {
                        const option = document.createElement('option');
                        option.value = rubric.id;
                        option.textContent = `${rubric.name} (${rubric.totalPoints || 0} pts)`;
                        if (rubric.speechType) {
                            option.textContent += ` - ${rubric.speechType}`;
                        }
                        optgroup.appendChild(option);
                    });
                    select.appendChild(optgroup);
                }
                
                // Add default rubric at the very end
                if (defaultRubrics.length > 0) {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = 'System Default';
                    defaultRubrics.forEach(rubric => {
                        const option = document.createElement('option');
                        option.value = rubric.id;
                        option.textContent = `${rubric.name} (${rubric.totalPoints} pts)`;
                        optgroup.appendChild(option);
                    });
                    select.appendChild(optgroup);
                }
            } else {
                // If no class is selected, show all rubrics grouped by course (original behavior)
                // Group rubrics by course NAME (not ID) to consolidate sections
                const rubricsByCourse = {};
                rubrics.filter(r => r.id !== 'default').forEach(rubric => {
                    // Get courseIds for this rubric (handle both old and new format)
                    let courseIds = [];
                    if (rubric.courseIds && Array.isArray(rubric.courseIds)) {
                        courseIds = rubric.courseIds;
                    } else if (rubric.courseId) {
                        courseIds = [rubric.courseId];
                    }
                    
                    // Add rubric to each course it's assigned to
                    courseIds.forEach(courseId => {
                        const course = classes.find(c => c.id === courseId);
                        if (course) {
                            // Use course name + semester + year as key
                            const courseKey = `${course.name}|${course.semester}|${course.year}`;
                            if (!rubricsByCourse[courseKey]) {
                                rubricsByCourse[courseKey] = {
                                    name: course.name,
                                    semester: course.semester,
                                    year: course.year,
                                    rubrics: []
                                };
                            }
                            // Avoid duplicates
                            if (!rubricsByCourse[courseKey].rubrics.find(r => r.id === rubric.id)) {
                                rubricsByCourse[courseKey].rubrics.push(rubric);
                            }
                        }
                    });
                });
                
                // Add course-specific rubrics grouped by course name
                Object.keys(rubricsByCourse).sort().forEach(courseKey => {
                    const courseGroup = rubricsByCourse[courseKey];
                    
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = `${courseGroup.name} - ${courseGroup.semester} ${courseGroup.year}`;
                    
                    courseGroup.rubrics.forEach(rubric => {
                        const option = document.createElement('option');
                        option.value = rubric.id;
                        option.textContent = `${rubric.name} (${rubric.totalPoints} pts)`;
                        if (rubric.speechType) {
                            option.textContent += ` - ${rubric.speechType}`;
                        }
                        optgroup.appendChild(option);
                    });
                    
                    select.appendChild(optgroup);
                });
                
                // Filter unassigned rubrics (no courseId or courseIds)
                const unassignedRubrics = rubrics.filter(r => {
                    if (r.id === 'default') return false;
                    const hasOldCourseId = r.courseId && r.courseId !== '';
                    const hasNewCourseIds = r.courseIds && Array.isArray(r.courseIds) && r.courseIds.length > 0;
                    return !hasOldCourseId && !hasNewCourseIds;
                });
                
                // Add unassigned custom rubrics
                if (unassignedRubrics.length > 0) {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = 'Rubrics (No Course)';
                    unassignedRubrics.forEach(rubric => {
                        const option = document.createElement('option');
                        option.value = rubric.id;
                        option.textContent = `${rubric.name} (${rubric.totalPoints} pts)`;
                        if (rubric.speechType) {
                            option.textContent += ` - ${rubric.speechType}`;
                        }
                        optgroup.appendChild(option);
                    });
                    select.appendChild(optgroup);
                }
                
                // Add default rubric at the end
                if (defaultRubrics.length > 0) {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = 'System Default';
                    defaultRubrics.forEach(rubric => {
                        const option = document.createElement('option');
                        option.value = rubric.id;
                        option.textContent = `${rubric.name} (${rubric.totalPoints} pts)`;
                        optgroup.appendChild(option);
                    });
                    select.appendChild(optgroup);
                }
            }
            
            // Pre-select the Self-Introduction rubric if available
            const selfIntroRubric = rubrics.find(r => r.id === 'self-intro-1');
            if (selfIntroRubric) {
                select.value = selfIntroRubric.id;
            }
        }

        // ===== FORMS =====
        function initializeForms() {
            console.log('initializeForms() called');
            
            // Student form
            const studentForm = document.getElementById('studentForm');
            console.log('studentForm element:', studentForm);
            
            if (!studentForm) {
                console.error('ERROR: studentForm element not found!');
                return;
            }
            
            console.log('Adding submit event listener to studentForm...');
            studentForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                console.log('>>> FORM SUBMITTED <<<');
                
                try {
                    if (!uploadedFile) {
                        console.log('Form validation: No file uploaded');
                        alert('Please upload a speech recording first.');
                        return;
                    }
                    console.log('Form validation: File OK');

                    console.log('Form handler: Calling moveToStep(3)');
                    moveToStep(3);
                    console.log('Form handler: Calling processAndEvaluate()');
                    await processAndEvaluate();
                    console.log('Form handler: processAndEvaluate() completed');
                } catch (error) {
                    console.error('FORM HANDLER ERROR:', error);
                    alert('Form submission error: ' + error.message);
                    moveToStep(2);
                }
            });
            console.log('✓ Submit event listener attached to studentForm');
            
            // Also add click listener to submit button for debugging
            const submitBtn = document.getElementById('submitEvaluationBtn');
            if (submitBtn) {
                submitBtn.addEventListener('click', function(e) {
                    console.log('Submit button clicked!');
                    console.log('Form validity:', studentForm.checkValidity());
                    console.log('Rubric selected:', document.getElementById('rubricSelect').value);
                    const defaultUrl = 'http://localhost:8000/api';
                    console.log('Evaluation server URL:', localStorage.getItem('finetuned_api_url') || defaultUrl);
                    
                    // Check custom validation
                    if (!validateEvalForm()) {
                        console.log('Form is INVALID - showing validation errors');
                        // Scroll to first error
                        const firstError = document.querySelector('.form-group .invalid');
                        if (firstError) {
                            firstError.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            firstError.focus();
                        }
                        return;
                    }
                    
                    // Check browser validation
                    if (!studentForm.checkValidity()) {
                        console.log('Form is INVALID - browser will show validation message');
                        studentForm.reportValidity();
                        return;
                    }
                    
                    console.log('Form is valid, submitting...');
                    // Manually call the submit handler since the form submit event isn't firing
                    e.preventDefault();
                    studentForm.dispatchEvent(new Event('submit'));
                });
                console.log('✓ Click listener attached to submit button');
            }

            // Create class form
            document.getElementById('createClassForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const newClass = {
                    id: Date.now().toString(),
                    name: document.getElementById('className').value,
                    semester: document.getElementById('classSemester').value,
                    section: document.getElementById('classSection').value,
                    year: document.getElementById('classYear').value,
                    notes: document.getElementById('classNotes').value,
                    roster: [],
                    evaluations: [],
                    createdAt: new Date().toISOString()
                };
                
                // Save to localStorage first (immediate)
                const classes = JSON.parse(getUserItem('classes') || '[]');
                classes.push(newClass);
                setUserItem('classes', JSON.stringify(classes));
                console.log('✓ Class saved to localStorage');
                
                // Also save to Supabase (async)
                if (supabaseClient) {
                    saveCourseToSupabase(newClass).then(supabaseCourse => {
                        if (supabaseCourse) {
                            // Update with Supabase ID
                            newClass.supabaseId = supabaseCourse.id;
                            const updated = classes.find(c => c.id === newClass.id);
                            if (updated) {
                                updated.supabaseId = supabaseCourse.id;
                                setUserItem('classes', JSON.stringify(classes));
                            }
                        }
                    }).catch(err => {
                        console.log('Supabase save failed, but localStorage succeeded');
                    });
                }
                
                if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Class created successfully.', 4000);
                document.getElementById('createClassForm').reset();
                cancelCreateClass();
                await loadClasses();
            });

            // Create rubric form
            document.getElementById('createRubricForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                
                try {
                    const rubricData = collectRubricData();
                    
                    // Validation
                    if (!rubricData.name) {
                        alert('Please enter a rubric name');
                        return;
                    }
                    
                    if (rubricData.totalPoints < 1) {
                        alert('Total points must be at least 1');
                        return;
                    }
                    
                    if (rubricData.categories.length === 0) {
                        alert('Please add at least one category with subcategories');
                        return;
                    }
                    
                    // Check that all categories have subcategories
                    const emptyCategories = rubricData.categories.filter(cat => cat.subcategories.length === 0);
                    if (emptyCategories.length > 0) {
                        alert('All categories must have at least one subcategory');
                        return;
                    }
                    
                    const submitBtn = document.getElementById('rubricSubmitBtn');
                    const origBtnText = submitBtn ? submitBtn.textContent : '';
                    if (submitBtn) { submitBtn.disabled = true; submitBtn.textContent = 'Saving…'; }
                    const isEditing = document.getElementById('editingRubricId').value !== '';
                    try {
                        await saveRubric(rubricData);
                        if (typeof showAnalyticsToast === 'function') showAnalyticsToast(isEditing ? 'Rubric updated successfully.' : 'Rubric created successfully.', 4000);
                        document.getElementById('createRubricForm').reset();
                        document.getElementById('editingRubricId').value = '';
                        document.getElementById('editingRubricSupabaseId').value = '';
                        cancelCreateRubric();
                        await loadRubrics();
                    } catch (error) {
                        console.error('Error saving rubric:', error);
                        if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Error saving rubric: ' + (error.message || error), 6000);
                        else alert('Error saving rubric: ' + (error.message || error));
                    } finally {
                        if (submitBtn) { submitBtn.disabled = false; submitBtn.textContent = origBtnText; }
                    }
                } catch (error) {
                    console.error('Error saving rubric:', error);
                    if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Error saving rubric: ' + (error.message || error), 6000);
                    else alert('Error saving rubric: ' + (error.message || error));
                }
            });

            // Add student form
            document.getElementById('addStudentForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const newStudent = {
                    id: Date.now().toString(),
                    firstName: document.getElementById('studentFirstName').value,
                    lastName: document.getElementById('studentLastName').value,
                    email: document.getElementById('studentEmailAdd').value,
                    studentId: document.getElementById('studentIdAdd').value,
                    addedAt: new Date().toISOString()
                };
                
                const classes = JSON.parse(getUserItem('classes') || '[]');
                const classIndex = classes.findIndex(c => c.id === currentClassId);
                
                if (classIndex !== -1) {
                    if (!classes[classIndex].roster) {
                        classes[classIndex].roster = [];
                    }
                    classes[classIndex].roster.push(newStudent);
                    setUserItem('classes', JSON.stringify(classes));
                    console.log('✓ Student saved to localStorage');
                    
                    // Also save to Supabase if course has supabaseId
                    const course = classes[classIndex];
                    if (supabaseClient && course.supabaseId) {
                        await saveStudentsToSupabase(course.supabaseId, [newStudent]);
                    }
                    
                    if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Student added successfully.', 4000);
                    document.getElementById('addStudentForm').reset();
                    cancelAddStudent();
                    await viewClass(currentClassId); // Refresh the view
                }
            });
        }

        function updateEvalProviderHint() {
            // No-op: Only Qwen is used, no localhost hint needed
            var hintEl = document.getElementById('localhostServerHint');
            if (hintEl) {
                hintEl.style.display = 'none';
            }
        }

        // ===== RE-EVALUATE FROM STORED VIDEO/AUDIO URL =====
        async function reEvaluateFromUrl(mediaUrl, isVideo) {
            if (!mediaUrl) {
                alert('No media URL available for re-evaluation.');
                return;
            }
            
            if (!confirm('Re-evaluate this ' + (isVideo ? 'video' : 'audio') + '? This will create a new evaluation.')) {
                return;
            }
            
            try {
                updateProcessingMessage('Downloading ' + (isVideo ? 'video' : 'audio') + ' file');
                showUploadProgress(null);
                updateUploadProgress(10, 'Downloading media file');
                
                // Fetch the media file from URL
                const response = await fetch(mediaUrl);
                if (!response.ok) {
                    throw new Error('Failed to download media file: ' + response.statusText);
                }
                
                updateProcessingStage('transcribe');
                updateUploadProgress(50, 'Processing media file');
                const blob = await response.blob();
                
                // Determine file extension and MIME type
                const urlPath = new URL(mediaUrl).pathname;
                const extension = urlPath.split('.').pop() || (isVideo ? 'mp4' : 'mp3');
                const mimeType = isVideo 
                    ? (extension === 'webm' ? 'video/webm' : extension === 'mov' ? 'video/quicktime' : 'video/mp4')
                    : (extension === 'wav' ? 'audio/wav' : extension === 'm4a' ? 'audio/mp4' : 'audio/mpeg');
                
                // Create File object from blob
                const fileName = 'reevaluation.' + extension;
                const file = new File([blob], fileName, { type: mimeType });
                
                updateProcessingStage('analyze');
                updateUploadProgress(80, 'Preparing for evaluation');
                
                // Get current evaluation settings
                const assignmentType = evaluationResults?.assignmentType || document.getElementById('assignmentType')?.value || 'Speech';
                const rubricId = document.getElementById('rubricSelect')?.value;
                if (!rubricId) {
                    throw new Error('Please select a rubric first.');
                }
                const selectedRubric = await getRubricById(rubricId);
                if (!selectedRubric) {
                    throw new Error('Selected rubric not found');
                }
                
                const apiProvider = 'qwen';
                const apiKey = await getEvaluationApiKey(apiProvider);
                
                // Set the file as uploaded
                uploadedFile = file;
                
                updateProcessingStage('analyze');
                updateUploadProgress(90, 'Starting evaluation');
                // Don't hide progress yet - let it switch to finalizing mode
                
                // Move to processing step
                moveToStep(3);
                
                // Run evaluation
                console.log('Re-evaluating from stored media URL:', mediaUrl);
                const result = await evaluateSpeech(apiKey, file, assignmentType, selectedRubric, apiProvider);
                console.log('✓ Re-evaluation complete');
                
                result.aiProvider = apiProvider;
                // Preserve video/audio URL in results
                if (isVideo) {
                    result.video_url = mediaUrl;
                } else {
                    result.audio_url = mediaUrl;
                }
                evaluationResults = result;
                modelOutputOriginal = (result && result.sections) ? { sections: JSON.parse(JSON.stringify(result.sections)), timeline_markers: Array.isArray(result.timeline_markers) ? result.timeline_markers.slice() : [] } : null;
                
                moveToStep(4);
                displayResults(result);
                // Hide progress now that re-evaluation is complete
                hideUploadProgress();
                
            } catch (error) {
                console.error('Re-evaluation error:', error);
                hideUploadProgress();
                alert('Error re-evaluating: ' + error.message);
            }
        }
        
        // ===== CANCEL EVALUATION =====
        function cancelEvaluation() {
            if (evaluationAbortController) {
                evaluationAbortController.abort();
                evaluationAbortController = null;
                console.log('Evaluation cancelled by user');
                showNotification('Evaluation cancelled', 'info', 3000);
                moveToStep(2); // Return to details step
            }
        }
        
        // ===== SPEECH EVALUATION =====
        async function processAndEvaluate() {
            console.log('=== processAndEvaluate START ===');
            console.log('uploadedFile:', uploadedFile);
            
            // Create new abort controller for this evaluation
            evaluationAbortController = new AbortController();
            
            // Reset correction log for new evaluation
            correctionLog = [];
            
            // Check if file is uploaded
            if (!uploadedFile) {
                console.log('FAILURE: No file uploaded');
                alert('No file uploaded. Please go back to Step 1 and upload a speech recording.');
                moveToStep(1);
                return;
            }
            console.log('✓ File uploaded:', uploadedFile.name);
            
            // Always use Qwen for evaluations
            const apiProvider = 'qwen';
            const apiKey = await getEvaluationApiKey(apiProvider);
            console.log('API Provider: Qwen (only provider)');
            console.log('Qwen Service URL:', apiKey ? 'Present' : 'Missing');
            if (!apiKey) {
                alert('Set the SpeechGradebook Text + Video Model (Qwen) Service URL in Settings → General → Qwen Service URL.');
                return;
            }
            if (uploadedFile.type && !uploadedFile.type.startsWith('video/')) {
                alert('SpeechGradebook Text + Video Model (Qwen) requires a video file. Please upload a video (e.g. MP4, WebM).');
                return;
            }
            
            const selectedRubricId = document.getElementById('rubricSelect').value;
            console.log('Selected rubric ID:', selectedRubricId);
            
            if (!selectedRubricId) {
                console.log('FAILURE: No rubric selected');
                alert('Please select a rubric for evaluation.');
                moveToStep(2);
                return;
            }
            console.log('✓ Rubric selected');

            const assignmentType = document.getElementById('assignmentType').value;
            
            // Get student name from details step if class/student were selected
            let studentName = 'Student';
            let selectedClassId = null;
            let selectedStudentId = null;
            try {
                const evalClassSelect = document.getElementById('evalClassSelect');
                const evalStudentSelect = document.getElementById('evalStudentSelect');
                const classValue = evalClassSelect?.value;
                const studentValue = evalStudentSelect?.value;
                
                if (classValue && classValue !== '' && classValue !== 'other') {
                    selectedClassId = classValue;
                    if (studentValue && studentValue !== '') {
                        selectedStudentId = studentValue;
                        const classes = JSON.parse(getUserItem('classes') || '[]');
                        const classData = classes.find(c => c.id === classValue || c.name === classValue);
                        if (classData && classData.roster) {
                            const student = classData.roster.find(s => (s.id === studentValue || s.studentId === studentValue) || 
                                (Array.isArray(classData.roster) && classData.roster[parseInt(studentValue)]));
                            if (student) {
                                studentName = (student.firstName || '') + ' ' + (student.lastName || '');
                                if (!studentName.trim()) studentName = 'Student';
                            }
                        }
                    }
                }
            } catch (e) {
                console.warn('Could not get student name from details selection:', e);
            }
            
            console.log('Student name:', studentName);
            console.log('Assignment type:', assignmentType);
            console.log('=== All validations passed, starting evaluation ===');
            
            // Get video duration for time estimation
            try {
                videoDuration = await getVideoDuration(uploadedFile);
            } catch (e) {
                console.warn('Could not get video duration:', e);
                videoDuration = null;
            }
            
            // Initialize processing stages
            processingStartTime = Date.now();
            updateProcessingStage('upload');
            
            document.getElementById('processingMessage').textContent = 
                'Analyzing speech content and delivery for ' + studentName + '...';

            try {
                // Get the selected rubric
                const selectedRubric = await getRubricById(selectedRubricId);
                if (!selectedRubric) {
                    console.log('FAILURE: Rubric not found in storage');
                    throw new Error('Selected rubric not found');
                }
                
                console.log('✓ Using rubric:', selectedRubric.name);
                
                // Pass rubric and provider to evaluation function
                console.log('Calling evaluateSpeech...');
                const result = await evaluateSpeech(apiKey, uploadedFile, assignmentType, selectedRubric, apiProvider);
                
                // Check if evaluation was cancelled
                if (evaluationAbortController && evaluationAbortController.signal.aborted) {
                    console.log('Evaluation was cancelled');
                    return;
                }
                
                console.log('✓ Evaluation complete');
                result.aiProvider = apiProvider;
                // Set student name if it was selected during details step
                if (studentName && studentName !== 'Student') {
                    result.studentName = studentName;
                }
                // Store selected class and student IDs for saving
                result.selectedClassId = selectedClassId;
                result.selectedStudentId = selectedStudentId;
                
                // Store course name if class was selected
                if (selectedClassId) {
                    try {
                        const classes = JSON.parse(getUserItem('classes') || '[]');
                        const classData = classes.find(c => c.id === selectedClassId || c.name === selectedClassId);
                        if (classData) {
                            result.courseName = classData.name + (classData.semester ? ' - ' + classData.semester + ' ' + classData.year : '');
                        }
                    } catch (e) {
                        console.warn('Could not store course name:', e);
                    }
                }
                
                // Store speech date and assignment type from form
                const speechDateEl = document.getElementById('speechDate');
                if (speechDateEl && speechDateEl.value) {
                    result.speechDate = speechDateEl.value;
                }
                if (assignmentType) {
                    result.assignmentType = assignmentType;
                }
                
                // Store rubric name if available
                if (selectedRubric && selectedRubric.name) {
                    result.rubricUsed = selectedRubric.name;
                }
                
                evaluationResults = result;
                modelOutputOriginal = (result && result.sections) ? { sections: JSON.parse(JSON.stringify(result.sections)), timeline_markers: Array.isArray(result.timeline_markers) ? result.timeline_markers.slice() : [] } : null;
                
                // Mark final stage as complete
                updateProcessingStage('score');
                setTimeout(() => {
                    moveToStep(4);
                    displayResults(result);
                    processingStartTime = null;
                    currentProcessingStage = null;
                }, 500);
                // Hide progress now that evaluation is complete
                hideUploadProgress();
            } catch (error) {
                // Check if error is from cancellation
                if (error.name === 'AbortError' || (evaluationAbortController && evaluationAbortController.signal.aborted)) {
                    console.log('Evaluation cancelled');
                    hideUploadProgress();
                    return;
                }
                console.error('EVALUATION ERROR:', error);
                hideUploadProgress();
                
                // Format and display user-friendly error message
                const errorMessage = formatErrorMessage(error.message || error, {
                    fileSizeMB: uploadedFile ? (uploadedFile.size / 1024 / 1024).toFixed(2) : null
                });
                
                if (typeof showNotification === 'function') {
                    showNotification(errorMessage, 'error', 8000);
                } else {
                    alert('Evaluation failed: ' + errorMessage);
                }
                moveToStep(2);
            } finally {
                // Clear abort controller after evaluation completes
                evaluationAbortController = null;
            }
        }

        // ===== DEMO MODE EVALUATION =====
        async function generateDemoEvaluation(file, assignmentType, rubric) {
            console.log('>>> Generating demo evaluation');
            updateProcessingMessage('Generating realistic demo feedback');
            
            // Simulate processing delay
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            const metrics = calculateRubricMetrics(rubric);
            const studentName = 'Student'; // Generic name since field was removed
            const speechDate = document.getElementById('speechDate').value || new Date().toISOString().split('T')[0];
            
            // First, decide on an overall performance level (70-95%)
            const overallPercentage = 70 + (Math.random() * 25); // 70-95%
            
            // Generate scores that add up correctly
            const sections = {};
            let totalScore = 0;
            let totalMaxScore = 0;
            
            rubric.categories.forEach((category, catIndex) => {
                const categoryName = typeof category === 'string' ? category : category.name;
                const subcategories = typeof category === 'string' ? 
                    ['Introduction', 'Main Points', 'Conclusion'] : 
                    (category.subcategories || []);
                
                const categoryFeedback = [];
                let categoryScore = 0;
                let categoryMaxScore = 0;
                
                subcategories.forEach((sub, subIndex) => {
                    const subName = typeof sub === 'string' ? sub : sub.name;
                    const subPoints = typeof sub === 'string' ? 10 : (sub.points || 10);
                    
                    // Vary individual scores slightly around the overall percentage (±10%)
                    const variance = (Math.random() * 20) - 10; // -10% to +10%
                    const subPercentage = Math.max(60, Math.min(100, overallPercentage + variance));
                    const score = Math.round(subPoints * (subPercentage / 100));
                    
                    // Generate feedback based on score
                    const percentage = (score / subPoints) * 100;
                    let feedback;
                    let grade;
                    
                    if (percentage >= 90) {
                        feedback = `Excellent ${subName.toLowerCase()}. Demonstrates strong mastery of this area.`;
                        grade = 'A';
                    } else if (percentage >= 80) {
                        feedback = `Good ${subName.toLowerCase()}. Shows solid understanding with room for minor improvements.`;
                        grade = 'B';
                    } else if (percentage >= 70) {
                        feedback = `Adequate ${subName.toLowerCase()}. Meets basic requirements but could be enhanced.`;
                        grade = 'C';
                    } else if (percentage >= 60) {
                        feedback = `${subName} needs improvement. Consider focusing more on this area.`;
                        grade = 'D';
                    } else {
                        feedback = `${subName} needs significant improvement. Consider focusing more on this area.`;
                        grade = 'F';
                    }
                    
                    categoryFeedback.push({
                        name: subName,
                        points: score,
                        maxPoints: subPoints,
                        grade: grade,
                        feedback: feedback
                    });
                    
                    categoryScore += score;
                    categoryMaxScore += subPoints;
                });
                
                // Create overall category feedback string
                const avgPercentage = (categoryScore / categoryMaxScore) * 100;
                let overallFeedback;
                if (avgPercentage >= 90) {
                    overallFeedback = `Excellent performance in ${categoryName}. Strong demonstration of skills across all areas.`;
                } else if (avgPercentage >= 80) {
                    overallFeedback = `Good work in ${categoryName}. Solid performance with minor areas for improvement.`;
                } else if (avgPercentage >= 70) {
                    overallFeedback = `Adequate ${categoryName}. Meets basic requirements but could be strengthened.`;
                } else {
                    overallFeedback = `${categoryName} needs significant improvement. Focus on developing these skills.`;
                }
                
                sections[categoryName] = {
                    feedback: overallFeedback,
                    score: categoryScore,
                    maxScore: categoryMaxScore,
                    subcategories: categoryFeedback
                };
                
                totalScore += categoryScore;
                totalMaxScore += categoryMaxScore;
            });
            
            // Calculate final percentage from actual scores
            const finalPercentage = (totalScore / totalMaxScore) * 100;
            const letterGrade = getLetterGrade(finalPercentage, rubric.gradeScale);
            
            console.log('Demo evaluation:', {
                totalScore,
                totalMaxScore,
                percentage: finalPercentage.toFixed(1),
                letterGrade
            });
            
            // Generate realistic timeline markers
            const speechDuration = 330; // 5:30 minutes in seconds
            const timeline_markers = [];
            
            // Add 3-7 markers spread throughout speech
            const numMarkers = Math.floor(Math.random() * 5) + 3; // 3-7 markers
            const categories = rubric.categories.map(cat => 
                typeof cat === 'string' ? cat : cat.name
            );
            
            // Define realistic issues for each category
            const issueTemplates = {
                'Introduction': {
                    'positive': ['Strong attention-getter', 'Clear thesis statement', 'Excellent preview of main points'],
                    'minor': ['Attention-getter could be stronger', 'Preview slightly unclear', 'Rushed introduction'],
                    'moderate': ['Missing preview of main points', 'Weak attention-getter', 'No clear thesis']
                },
                'Organization': {
                    'positive': ['Clear transition', 'Strong signpost phrase', 'Logical flow between ideas'],
                    'minor': ['Transition could be smoother', 'Signpost needed here', 'Slight organizational gap'],
                    'moderate': ['Abrupt topic change', 'Missing transition', 'Confusing sequence']
                },
                'Content': {
                    'positive': ['Excellent supporting evidence', 'Strong example usage', 'Compelling story'],
                    'minor': ['Example could be more specific', 'Source citation needed', 'Claim needs support'],
                    'moderate': ['Lack of supporting evidence', 'Unsupported claim', 'Weak reasoning']
                },
                'Delivery': {
                    'positive': ['Great vocal variety', 'Strong emphasis here', 'Clear pronunciation'],
                    'minor': ['Vocalized pause ("um")', 'Speaking slightly fast', 'Volume a bit low'],
                    'moderate': ['Multiple filler words', 'Speaking too fast', 'Monotone delivery']
                },
                'Eye Contact': {
                    'positive': ['Great audience engagement', 'Scanning all sections', 'Natural connection with audience'],
                    'minor': ['Brief glance at notes', 'Favoring one side slightly', 'Quick look down'],
                    'moderate': ['Looking down at notes', 'Avoiding audience gaze', 'Reading from slides']
                },
                'Body Language': {
                    'positive': ['Confident posture', 'Effective gestures', 'Good use of space'],
                    'minor': ['Hands in pockets briefly', 'Slight fidgeting', 'Standing too still'],
                    'moderate': ['Distracting movements', 'Poor posture', 'Awkward gestures']
                },
                'Conclusion': {
                    'positive': ['Strong closing statement', 'Clear call to action', 'Memorable ending'],
                    'minor': ['Conclusion slightly rushed', 'Could restate thesis more clearly', 'Ending a bit abrupt'],
                    'moderate': ['No clear conclusion', 'Forgot to summarize', 'Weak ending']
                }
            };
            
            // Generate markers
            for (let i = 0; i < numMarkers; i++) {
                // Spread markers throughout speech
                const seconds = Math.floor((speechDuration / (numMarkers + 1)) * (i + 1));
                const minutes = Math.floor(seconds / 60);
                const secs = seconds % 60;
                const timestamp = `${minutes}:${secs.toString().padStart(2, '0')}`;
                
                // Pick random category from rubric
                const category = categories[Math.floor(Math.random() * categories.length)];
                
                // Determine severity (weighted toward positive/minor)
                const severityRoll = Math.random();
                let severity;
                if (severityRoll < 0.3) severity = 'positive';
                else if (severityRoll < 0.8) severity = 'minor';
                else severity = 'moderate';
                
                // Get appropriate issue template
                const categoryTemplates = issueTemplates[category] || issueTemplates['Delivery'];
                const issueList = categoryTemplates[severity] || categoryTemplates['minor'];
                const issue = issueList[Math.floor(Math.random() * issueList.length)];
                
                // Generate contextual note based on severity
                let note;
                if (severity === 'positive') {
                    const positiveNotes = [
                        'This was a strong moment in your speech. Keep up this excellent technique!',
                        'Very effective here. This really engaged the audience.',
                        'Great job with this element. Consider using this approach more often.',
                        'This demonstrated strong mastery of the technique.'
                    ];
                    note = positiveNotes[Math.floor(Math.random() * positiveNotes.length)];
                } else if (severity === 'minor') {
                    const minorNotes = [
                        'Small issue that\'s easy to fix with practice. Not a major concern.',
                        'Minor point to work on for your next speech. Otherwise looking good.',
                        'This is easily correctable. Just be mindful of it during practice.',
                        'Worth noting, but doesn\'t significantly impact your overall performance.'
                    ];
                    note = minorNotes[Math.floor(Math.random() * minorNotes.length)];
                } else {
                    const moderateNotes = [
                        'This is an area that needs attention before your next speech. Practice this specifically.',
                        'Work on improving this aspect. It impacted the effectiveness of your message.',
                        'This requires focused practice. Consider getting feedback on this element.',
                        'Important area for improvement. This affects audience comprehension.'
                    ];
                    note = moderateNotes[Math.floor(Math.random() * moderateNotes.length)];
                }
                
                timeline_markers.push({
                    timestamp: timestamp,
                    seconds: seconds,
                    category: category,
                    issue: issue,
                    severity: severity,
                    note: note
                });
            }
            
            // Sort by time
            timeline_markers.sort((a, b) => a.seconds - b.seconds);
            
            console.log('Generated timeline markers:', timeline_markers.length);
            
            // Generate overall comments
            const overallComments = finalPercentage >= 90 ? 
                "Outstanding speech overall. Demonstrates strong mastery across all evaluated areas. Continue refining these excellent skills." :
                finalPercentage >= 80 ?
                "Strong performance with solid execution in most areas. Focus on the identified improvement areas to reach the next level." :
                finalPercentage >= 70 ?
                "Adequate performance meeting basic requirements. Review the specific feedback in each category and work on identified weaknesses." :
                "Significant improvement needed. Focus on the fundamental skills highlighted in the feedback and practice consistently.";
            
            return {
                studentName: studentName,
                speechDate: speechDate,
                assignmentType: assignmentType,
                speechTime: '5:30',
                rubricUsed: rubric.name,
                sections: sections,
                totalScore: totalScore,
                maxScore: totalMaxScore,
                percentage: finalPercentage.toFixed(1),
                letterGrade: letterGrade,
                gradeScale: rubric.gradeScale,
                aiProvider: 'demo',
                transcript: '[Demo Mode - No actual transcription performed]',
                timeline_markers: timeline_markers,
                overallComments: overallComments
            };
        }
        
        /** Add minPoints, maxPoints, and pointRange to each letter in gradeScale so stored evals have explicit point values. totalPoints = rubric max (e.g. 50). */
        function enrichGradeScaleWithPointRanges(gradeScale, totalPoints) {
            if (!gradeScale || typeof totalPoints !== 'number' || totalPoints <= 0) return gradeScale;
            var out = {};
            ['A', 'B', 'C', 'D', 'F'].forEach(function(letter) {
                var config = gradeScale[letter];
                if (!config) return;
                out[letter] = Object.assign({}, config);
                var rangeStr = config.range || '';
                var parts = rangeStr.split('-').map(function(p) { return parseFloat(p.trim()); });
                if (parts.length >= 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
                    var highPct = Math.max(parts[0], parts[1]) / 100;
                    var lowPct = Math.min(parts[0], parts[1]) / 100;
                    var maxPoints = Math.round(totalPoints * highPct * 100) / 100;
                    var minPoints = Math.round(totalPoints * lowPct * 100) / 100;
                    out[letter].minPoints = minPoints;
                    out[letter].maxPoints = maxPoints;
                    out[letter].pointRange = maxPoints + '-' + minPoints;
                }
            });
            return out;
        }

        function getLetterGrade(percentage, gradeScale) {
            if (!gradeScale) return 'N/A';
            const pct = typeof percentage === 'string' ? parseFloat(percentage) : percentage;
            if (isNaN(pct)) return 'N/A';
            
            /** Range "100-91" means 91–100%; use the lower number as the minimum threshold. */
            function getMinThreshold(config) {
                if (config.min !== undefined && config.min !== null) return config.min;
                const range = config.range || '';
                const parts = range.split('-').map(s => parseFloat(String(s).trim())).filter(n => !isNaN(n));
                if (parts.length >= 2) return Math.min(parts[0], parts[1]);
                if (parts.length === 1) return parts[0];
                return 0;
            }
            
            const grades = Object.entries(gradeScale).sort((a, b) => {
                const minA = getMinThreshold(a[1]);
                const minB = getMinThreshold(b[1]);
                return minB - minA;  // highest threshold first (A before B before C...)
            });
            
            for (const [grade, config] of grades) {
                const min = getMinThreshold(config);
                if (pct >= min) return grade;
            }
            return 'F';
        }

        // ===== BULK PROCESSING FUNCTIONS =====
        async function startBulkProcessing() {
            if (bulkFiles.length === 0) {
                alert('No files to process.');
                return;
            }
            
            const courseSelect = document.getElementById('bulkCourseSelect');
            const rubricSelect = document.getElementById('bulkRubricSelect');
            const assignmentTypeSelect = document.getElementById('bulkAssignmentType');
            
            if (!courseSelect || !courseSelect.value || !rubricSelect || !rubricSelect.value) {
                alert('Please select a course and rubric.');
                return;
            }
            
            // Validate all files have students assigned
            const unassigned = bulkFiles.filter(item => !item.studentId);
            if (unassigned.length > 0) {
                alert(`Please assign a student to all videos. ${unassigned.length} video(s) still need student assignments.`);
                return;
            }
            
            // Hide matching step, show processing step
            const matchingStep = document.getElementById('bulkMatchingStep');
            const processingStep = document.getElementById('bulkProcessingStep');
            if (matchingStep) matchingStep.classList.add('hidden');
            if (processingStep) processingStep.classList.remove('hidden');
            
            // Initialize processing queue
            // Use detected assignment type if available, otherwise use dropdown value
            bulkProcessingQueue = bulkFiles.map((item, idx) => {
                const detectedType = item.detectedAssignmentType;
                const dropdownType = assignmentTypeSelect ? assignmentTypeSelect.value : 'Speech';
                // Prefer detected type if it's different from dropdown (user might have mixed assignments)
                // Otherwise use dropdown type
                const finalAssignmentType = detectedType && detectedType !== dropdownType ? detectedType : dropdownType;
                
                return {
                    index: idx,
                    file: item.file,
                    studentId: item.studentId,
                    studentName: item.studentName,
                    courseId: courseSelect.value,
                    rubricId: rubricSelect.value,
                    assignmentType: finalAssignmentType,
                    status: 'pending',
                    evaluationId: null,
                    error: null
                };
            });
            
            // Update processing UI
            updateBulkProcessingUI();
            
            // Warm up the Modal service before bulk uploads to prevent cold starts
            // This sends a health check and waits for the service to be fully ready
            const currentVideoMessage = document.getElementById('bulkCurrentVideoMessage');
            try {
                if (currentVideoMessage) currentVideoMessage.textContent = 'Warming up service (this may take 30-90 seconds on cold start)...';
                
                // Wait for service to be ready with exponential backoff
                let serviceReady = false;
                let waitTime = 5000; // Start with 5 seconds
                const maxWaitTime = 90000; // Max 90 seconds total
                let totalWaited = 0;
                
                while (!serviceReady && totalWaited < maxWaitTime) {
                    try {
                        const healthController = new AbortController();
                        const healthTimeout = setTimeout(() => healthController.abort(), 10000);
                        const healthResponse = await fetch('/qwen-api/health', { 
                            method: 'GET', 
                            signal: healthController.signal 
                        });
                        clearTimeout(healthTimeout);
                        
                        if (healthResponse.ok) {
                            const healthData = await healthResponse.json();
                            if (healthData.status === 'ok') {
                                serviceReady = true;
                                if (currentVideoMessage) {
                                    currentVideoMessage.textContent = 'Service is ready. Starting evaluations...';
                                }
                                break;
                            } else if (healthData.status === 'model_not_loaded') {
                                // Model is still loading - wait longer
                                if (currentVideoMessage) {
                                    currentVideoMessage.textContent = `Service is starting (cold start)... Waiting ${Math.min(waitTime/1000, 30)}s... (${Math.round(totalWaited/1000)}s total)`;
                                }
                                await new Promise(resolve => setTimeout(resolve, waitTime));
                                totalWaited += waitTime;
                                waitTime = Math.min(waitTime * 1.5, 30000); // Increase wait time, max 30s per check
                            }
                        } else if (healthResponse.status === 503) {
                            // Service unavailable - wait and retry
                            if (currentVideoMessage) {
                                currentVideoMessage.textContent = `Service unavailable (cold start)... Waiting ${Math.min(waitTime/1000, 30)}s... (${Math.round(totalWaited/1000)}s total)`;
                            }
                            await new Promise(resolve => setTimeout(resolve, waitTime));
                            totalWaited += waitTime;
                            waitTime = Math.min(waitTime * 1.5, 30000);
                        } else {
                            // Other error - break and let retry logic handle it
                            console.warn(`Health check returned ${healthResponse.status} - proceeding with retry logic`);
                            break;
                        }
                    } catch (error) {
                        // Network error - wait and retry
                        if (currentVideoMessage) {
                            currentVideoMessage.textContent = `Connection error... Waiting ${Math.min(waitTime/1000, 30)}s... (${Math.round(totalWaited/1000)}s total)`;
                        }
                        await new Promise(resolve => setTimeout(resolve, waitTime));
                        totalWaited += waitTime;
                        waitTime = Math.min(waitTime * 1.5, 30000);
                    }
                }
                
                if (!serviceReady) {
                    console.warn('Service warm-up timed out after 90s - proceeding with retry logic');
                    if (currentVideoMessage) {
                        currentVideoMessage.textContent = 'Service warm-up incomplete. Will retry with delays if needed...';
                    }
                }
            } catch (error) {
                console.warn('Service warm-up failed, proceeding anyway:', error);
                if (currentVideoMessage) {
                    currentVideoMessage.textContent = 'Service warm-up failed, but proceeding with retry logic...';
                }
            }
            
            // Start processing
            bulkProcessingActive = true;
            bulkProcessingCancelled = false;
            await processBulkEvaluations();
        }

        async function processBulkEvaluations() {
            if (!bulkProcessingActive || bulkProcessingCancelled) return;
            
            const total = bulkProcessingQueue.length;
            let completed = 0;
            let failed = 0;
            
            for (let i = 0; i < bulkProcessingQueue.length; i++) {
                if (bulkProcessingCancelled) {
                    break;
                }
                
                const item = bulkProcessingQueue[i];
                item.status = 'processing';
                updateBulkProcessingUI();
                
                // Show current video status
                const currentStatus = document.getElementById('bulkCurrentVideoStatus');
                const currentVideoName = document.getElementById('bulkCurrentVideoName');
                const currentVideoMessage = document.getElementById('bulkCurrentVideoMessage');
                
                if (currentStatus) currentStatus.style.display = 'block';
                if (currentVideoName) currentVideoName.textContent = `Processing ${i + 1} of ${total}: ${item.file.name}`;
                if (currentVideoMessage) currentVideoMessage.textContent = `Student: ${item.studentName}`;
                
                try {
                    // Get rubric
                    const rubricId = item.rubricId;
                    const selectedRubric = await getRubricById(rubricId);
                    if (!selectedRubric) {
                        throw new Error('Rubric not found');
                    }
                    
                    // Get API key
                    const apiProvider = 'qwen';
                    const apiKey = await getEvaluationApiKey(apiProvider);
                    if (!apiKey) {
                        throw new Error('Qwen service URL not configured');
                    }
                    
                    // Check if video file
                    if (item.file.type && !item.file.type.startsWith('video/')) {
                        throw new Error('Qwen requires a video file');
                    }
                    
                    // Update message
                    if (currentVideoMessage) currentVideoMessage.textContent = 'Uploading video...';
                    
                    // Process evaluation with retry logic for 503 errors (cold start)
                    let result;
                    let lastError;
                    const maxRetries = 5; // Increased retries for cold starts
                    const baseDelay = 10000; // 10 seconds base delay (cold starts need more time)
                    
                    for (let retry = 0; retry <= maxRetries; retry++) {
                        try {
                            result = await evaluateSpeech(apiKey, item.file, item.assignmentType, selectedRubric, apiProvider);
                            break; // Success, exit retry loop
                        } catch (error) {
                            lastError = error;
                            const is503Error = error.message && (
                                error.message.includes('503') || 
                                error.message.includes('Service Unavailable') ||
                                error.message.includes('service is temporarily unavailable') ||
                                error.message.includes('cold start')
                            );
                            
                            if (is503Error && retry < maxRetries) {
                                // Exponential backoff with longer delays: 10s, 20s, 40s, 80s, 160s
                                const delay = baseDelay * Math.pow(2, retry);
                                if (currentVideoMessage) {
                                    currentVideoMessage.textContent = `Service starting (cold start)... Retrying in ${delay/1000}s (attempt ${retry + 2}/${maxRetries + 1})`;
                                }
                                await new Promise(resolve => setTimeout(resolve, delay));
                                continue; // Retry
                            }
                            throw error; // Not a 503 or out of retries, throw immediately
                        }
                    }
                    
                    if (!result) {
                        throw lastError || new Error('Evaluation failed after retries');
                    }
                    
                    if (currentVideoMessage) currentVideoMessage.textContent = 'Saving evaluation...';
                    
                    // Save evaluation
                    const courseId = item.courseId;
                    const studentId = item.studentId;
                    
                    // Prepare evaluation data
                    const evaluation = {
                        sections: result.sections || {},
                        studentName: item.studentName,
                        speechDate: new Date().toISOString().split('T')[0],
                        assignmentType: item.assignmentType,
                        speechTime: result.speechTime || null,
                        rubricUsed: selectedRubric.name || 'Rubric',
                        totalScore: result.totalScore || 0,
                        maxScore: result.maxScore || selectedRubric.totalPoints || 100,
                        percentage: result.percentage || 0,
                        letterGrade: result.letterGrade || 'N/A',
                        overallComments: result.overallComments || '',
                        timeline_markers: result.timeline_markers || [],
                        video_notes: result.video_notes || null,
                        transcript: result.transcript || '',
                        aiProvider: apiProvider
                    };
                    
                    // Save to Supabase
                    const savedEval = await saveEvaluationToSupabase(
                        evaluation,
                        courseId,
                        studentId,
                        rubricId,
                        selectedRubric,
                        item.file
                    );
                    
                    if (savedEval && savedEval.id) {
                        item.evaluationId = savedEval.id;
                        item.status = 'complete';
                        completed++;
                        
                        // Store evaluation ID for reassignment
                        bulkEvaluationIds.push({
                            evaluationId: savedEval.id,
                            fileIndex: i,
                            fileName: item.file.name,
                            studentName: item.studentName,
                            studentId: studentId,
                            courseId: courseId
                        });
                    } else {
                        throw new Error('Failed to save evaluation');
                    }
                    
                } catch (error) {
                    console.error(`Error processing video ${i + 1}:`, error);
                    item.status = 'error';
                    item.error = error.message || 'Unknown error';
                    failed++;
                }
                
                // Update progress
                updateBulkProcessingUI();
                
                // Small delay between requests to avoid overwhelming the service
                // This is especially important for Modal which has max_inputs=1
                if (i < bulkProcessingQueue.length - 1 && !bulkProcessingCancelled) {
                    await new Promise(resolve => setTimeout(resolve, 1000)); // 1 second delay
                }
                
                // Hide current video status after a delay
                setTimeout(() => {
                    if (i === bulkProcessingQueue.length - 1 || bulkProcessingCancelled) {
                        const currentStatus = document.getElementById('bulkCurrentVideoStatus');
                        if (currentStatus) currentStatus.style.display = 'none';
                    }
                }, 1000);
            }
            
            // Processing complete
            bulkProcessingActive = false;
            
            // Show completion summary
            showBulkCompletionSummary(completed, failed, total);
        }

        function updateBulkProcessingUI() {
            const total = bulkProcessingQueue.length;
            const completed = bulkProcessingQueue.filter(item => item.status === 'complete').length;
            const processing = bulkProcessingQueue.filter(item => item.status === 'processing').length;
            const failed = bulkProcessingQueue.filter(item => item.status === 'error').length;
            
            // Update overall progress
            const progressText = document.getElementById('bulkOverallProgress');
            const progressBar = document.getElementById('bulkOverallProgressBar');
            
            if (progressText) {
                progressText.textContent = `${completed} of ${total}`;
            }
            
            if (progressBar) {
                const percent = total > 0 ? (completed / total) * 100 : 0;
                progressBar.style.width = `${percent}%`;
            }
            
            // Update processing table
            const tableBody = document.getElementById('bulkProcessingTableBody');
            if (!tableBody) return;
            
            tableBody.innerHTML = '';
            
            bulkProcessingQueue.forEach((item, idx) => {
                const row = document.createElement('tr');
                row.style.borderBottom = '1px solid var(--border)';
                
                let statusBadge = '';
                let statusColor = '';
                
                if (item.status === 'complete') {
                    statusBadge = '<i data-lucide="check-circle" style="width:18px;height:18px;color:var(--success);"></i> Complete';
                    statusColor = 'var(--success)';
                } else if (item.status === 'processing') {
                    statusBadge = '<div class="spinner" style="width:16px;height:16px;display:inline-block;margin-right:0.5rem;"></div> Processing';
                    statusColor = 'var(--primary)';
                } else if (item.status === 'error') {
                    statusBadge = '<i data-lucide="x-circle" style="width:18px;height:18px;color:var(--error);"></i> Error';
                    statusColor = 'var(--error)';
                } else {
                    statusBadge = '<i data-lucide="clock" style="width:18px;height:18px;color:var(--text-light);"></i> Pending';
                    statusColor = 'var(--text-light)';
                }
                
                row.innerHTML = `
                    <td style="padding: 0.75rem; color: var(--text); font-size: 0.875rem;">${escapeHtml(item.file.name)}</td>
                    <td style="padding: 0.75rem; color: var(--text-secondary); font-size: 0.875rem;">${escapeHtml(item.studentName)}</td>
                    <td style="padding: 0.75rem; text-align: center; color: ${statusColor}; font-size: 0.875rem;">
                        <span class="icon-with-text">${statusBadge}</span>
                    </td>
                `;
                
                if (item.status === 'error' && item.error) {
                    const errorRow = document.createElement('tr');
                    errorRow.style.background = 'var(--error-bg)';
                    errorRow.innerHTML = `
                        <td colspan="3" style="padding: 0.5rem 0.75rem; color: var(--error-text); font-size: 0.8125rem;">
                            ${escapeHtml(item.error)}
                        </td>
                    `;
                    tableBody.appendChild(row);
                    tableBody.appendChild(errorRow);
                } else {
                    tableBody.appendChild(row);
                }
            });
            
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons({ root: tableBody });
            }
        }

        function cancelBulkProcessing() {
            if (confirm('Cancel processing? Videos already processed will be saved, but remaining videos will not be processed.')) {
                bulkProcessingCancelled = true;
                bulkProcessingActive = false;
                
                // Show completion summary with what was completed
                const completed = bulkProcessingQueue.filter(item => item.status === 'complete').length;
                const failed = bulkProcessingQueue.filter(item => item.status === 'error').length;
                const total = bulkProcessingQueue.length;
                
                showBulkCompletionSummary(completed, failed, total);
            }
        }

        function showBulkCompletionSummary(completed, failed, total) {
            const processingStep = document.getElementById('bulkProcessingStep');
            const completionStep = document.getElementById('bulkCompletionStep');
            
            if (processingStep) processingStep.classList.add('hidden');
            if (completionStep) completionStep.classList.remove('hidden');
            
            // Update summary counts
            const successCount = document.getElementById('bulkSuccessCount');
            const errorCount = document.getElementById('bulkErrorCount');
            const totalCount = document.getElementById('bulkTotalCount');
            
            if (successCount) successCount.textContent = completed;
            if (errorCount) errorCount.textContent = failed;
            if (totalCount) totalCount.textContent = total;
            
            // Populate completion table
            const tableBody = document.getElementById('bulkCompletionTableBody');
            if (!tableBody) return;
            
            tableBody.innerHTML = '';
            
            bulkProcessingQueue.forEach((item, idx) => {
                const row = document.createElement('tr');
                row.style.borderBottom = '1px solid var(--border)';
                
                let statusBadge = '';
                let statusColor = '';
                
                if (item.status === 'complete') {
                    statusBadge = '<span class="icon-with-text"><i data-lucide="check-circle" style="width:18px;height:18px;color:var(--success);"></i> Success</span>';
                    statusColor = 'var(--success)';
                } else {
                    statusBadge = `<span class="icon-with-text"><i data-lucide="x-circle" style="width:18px;height:18px;color:var(--error);"></i> Failed</span>`;
                    statusColor = 'var(--error)';
                }
                
                row.innerHTML = `
                    <td style="padding: 0.75rem; text-align: center;">
                        <input type="checkbox" class="bulk-eval-checkbox" data-eval-id="${item.evaluationId || ''}" data-index="${idx}" onchange="updateBulkMoveButton()" ${item.status === 'complete' && item.evaluationId ? '' : 'disabled'}>
                    </td>
                    <td style="padding: 0.75rem; color: var(--text);">${escapeHtml(item.file.name)}</td>
                    <td style="padding: 0.75rem; color: var(--text-secondary);">${escapeHtml(item.studentName)}</td>
                    <td style="padding: 0.75rem; text-align: center; color: ${statusColor};">
                        ${statusBadge}
                    </td>
                    <td style="padding: 0.75rem; text-align: center;">
                        ${item.status === 'complete' && item.evaluationId ? `
                            <button onclick="openMoveEvalModal('${item.evaluationId}', '${item.courseId}', '${item.studentId}')" class="btn-small btn-secondary" style="padding: 0.25rem 0.75rem; font-size: 0.875rem;">
                                <span class="icon-with-text"><i data-lucide="move"></i> Move</span>
                            </button>
                        ` : '<span style="color: var(--text-light); font-size: 0.875rem;">—</span>'}
                    </td>
                `;
                
                tableBody.appendChild(row);
            });
            
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons({ root: tableBody });
            }
            
            // Update move button state
            updateBulkMoveButton();
        }

        function selectAllBulkEvaluations() {
            const checkboxes = document.querySelectorAll('.bulk-eval-checkbox:not(:disabled)');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            
            checkboxes.forEach(cb => {
                cb.checked = !allChecked;
            });
            
            updateBulkMoveButton();
        }

        function toggleAllBulkEvaluations(checked) {
            const checkboxes = document.querySelectorAll('.bulk-eval-checkbox:not(:disabled)');
            checkboxes.forEach(cb => {
                cb.checked = checked;
            });
            
            updateBulkMoveButton();
        }

        function updateBulkMoveButton() {
            const checkboxes = document.querySelectorAll('.bulk-eval-checkbox:checked:not(:disabled)');
            const moveBtn = document.getElementById('bulkMoveSelectedBtn');
            
            if (moveBtn) {
                if (checkboxes.length > 0) {
                    moveBtn.disabled = false;
                    moveBtn.style.opacity = '1';
                    moveBtn.style.cursor = 'pointer';
                } else {
                    moveBtn.disabled = true;
                    moveBtn.style.opacity = '0.6';
                    moveBtn.style.cursor = 'not-allowed';
                }
            }
        }

        function removeFailedBulkEvaluations() {
            if (!confirm('Remove all failed evaluations from the list? This will not delete any successfully saved evaluations.')) {
                return;
            }
            
            // Filter out failed evaluations from the queue
            const originalLength = bulkProcessingQueue.length;
            bulkProcessingQueue = bulkProcessingQueue.filter(item => item.status === 'complete');
            const removedCount = originalLength - bulkProcessingQueue.length;
            
            // Recalculate counts
            const completed = bulkProcessingQueue.filter(item => item.status === 'complete').length;
            const failed = 0; // All failed are removed
            const total = bulkProcessingQueue.length;
            
            // Update the display
            showBulkCompletionSummary(completed, failed, total);
            
            // Show notification
            if (removedCount > 0) {
                if (typeof showNotification === 'function') {
                    showNotification(`Removed ${removedCount} failed evaluation(s) from the list.`, 'success');
                } else {
                    alert(`Removed ${removedCount} failed evaluation(s) from the list.`);
                }
            }
        }

        function openBulkMoveModal() {
            const checkboxes = document.querySelectorAll('.bulk-eval-checkbox:checked:not(:disabled)');
            const evaluationIds = Array.from(checkboxes).map(cb => cb.getAttribute('data-eval-id')).filter(id => id);
            
            if (evaluationIds.length === 0) {
                alert('Please select at least one evaluation to move.');
                return;
            }
            
            // Store selected evaluation IDs
            window.bulkMoveEvaluationIds = evaluationIds;
            
            // Open the existing move modal, but we'll modify it for bulk
            openMoveEvalModal(null, null, null);
            
            // Modify modal title and behavior for bulk move
            const moveModal = document.getElementById('moveEvalModal');
            if (moveModal) {
                const title = moveModal.querySelector('h3');
                if (title) {
                    title.innerHTML = `<span class="icon-with-text"><i data-lucide="move"></i> Move ${evaluationIds.length} Evaluation(s)</span>`;
                }
                
                const description = moveModal.querySelector('p');
                if (description) {
                    description.textContent = `Move ${evaluationIds.length} evaluation(s) to a different class and/or student.`;
                }
            }
        }

        async function bulkMoveEvaluationsFromUpload(evaluationIds, newCourseId, newStudentId) {
            if (!evaluationIds || evaluationIds.length === 0) {
                alert('No evaluations selected to move.');
                return;
            }
            
            if (!newCourseId || !newStudentId) {
                alert('Please select both class and student.');
                return;
            }
            
            // Get course and student names for confirmation
            let courseName = 'the selected class';
            let studentName = 'the selected student';
            
            try {
                if (supabaseClient && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(newCourseId)) {
                    const { data: course } = await supabaseClient
                        .from('courses')
                        .select('name')
                        .eq('id', newCourseId)
                        .single();
                    if (course) courseName = course.name;
                    
                    const { data: student } = await supabaseClient
                        .from('course_students')
                        .select('first_name, last_name')
                        .eq('id', newStudentId)
                        .single();
                    if (student) {
                        studentName = `${student.first_name || ''} ${student.last_name || ''}`.trim() || 'Unnamed Student';
                    }
                }
            } catch (e) {
                console.warn('Could not fetch course/student names:', e);
            }
            
            if (!confirm(`Move ${evaluationIds.length} evaluation(s) to ${studentName} in ${courseName}?`)) {
                return;
            }
            
            // Update all evaluations in Supabase
            if (supabaseClient) {
                try {
                    const { error } = await supabaseClient
                        .from('evaluations')
                        .update({
                            course_id: newCourseId,
                            student_id: newStudentId,
                            updated_at: new Date().toISOString()
                        })
                        .in('id', evaluationIds);
                    
                    if (error) {
                        throw error;
                    }
                    
                    console.log(`✓ Moved ${evaluationIds.length} evaluations in Supabase`);
                    showNotification(`Successfully moved ${evaluationIds.length} evaluation(s) to ${studentName}`, 'success', 5000);
                    
                    // Close modal
                    closeMoveEvalModal();
                    
                    // Refresh completion table to show updated student names
                    const completed = bulkProcessingQueue.filter(item => item.status === 'complete').length;
                    const failed = bulkProcessingQueue.filter(item => item.status === 'error').length;
                    const total = bulkProcessingQueue.length;
                    showBulkCompletionSummary(completed, failed, total);
                    
                } catch (error) {
                    console.error('Error moving evaluations in Supabase:', error);
                    alert('Error moving evaluations: ' + error.message);
                }
            }
        }

        function resetBulkUpload() {
            // Clear all bulk data
            bulkFiles = [];
            bulkProcessingQueue = [];
            bulkEvaluationIds = [];
            bulkProcessingActive = false;
            bulkProcessingCancelled = false;
            
            // Reset UI
            clearBulkFiles();
            const completionStep = document.getElementById('bulkCompletionStep');
            if (completionStep) completionStep.classList.add('hidden');
            
            // Reset form
            const courseSelect = document.getElementById('bulkCourseSelect');
            const rubricSelect = document.getElementById('bulkRubricSelect');
            const assignmentTypeSelect = document.getElementById('bulkAssignmentType');
            if (courseSelect) courseSelect.value = '';
            if (rubricSelect) rubricSelect.value = '';
            if (assignmentTypeSelect) assignmentTypeSelect.value = 'Speech';
            
            // Show upload step
            switchUploadMode('bulk');
        }

        // Store original doMoveEval function for bulk move integration
        // This will be set up after doMoveEval is defined
        let originalDoMoveEvalFunction = null;

        async function evaluateSpeech(apiKey, file, assignmentType, rubric, apiProvider = 'finetuned') {
            // Check if evaluation was cancelled
            if (evaluationAbortController && evaluationAbortController.signal.aborted) {
                throw new DOMException('Evaluation cancelled', 'AbortError');
            }
            
            // Track evaluation start time for energy calculation
            const evaluationStartTime = performance.now();
            
            console.log('>>> evaluateSpeech called');
            console.log('    API Provider:', apiProvider);
            console.log('    API key:', apiKey ? 'Present' : 'Missing');
            console.log('    File:', file ? file.name : 'Missing');
            console.log('    File size:', file ? (file.size / 1024 / 1024).toFixed(2) + ' MB' : 'N/A');
            console.log('    Assignment type:', assignmentType);
            console.log('    Rubric:', rubric ? rubric.name : 'Missing');
            
            // Check file size based on provider
            let maxSizeBytes;
            if (apiProvider === 'finetuned') {
                maxSizeBytes = 100 * 1024 * 1024; // 100MB for SpeechGradebook Text Model (Mistral) (server transcribes)
            } else if (apiProvider === 'qwen') {
                maxSizeBytes = 100 * 1024 * 1024; // 100MB for SpeechGradebook Text + Video Model (Qwen)
            } else if (apiProvider === 'gemini') {
                maxSizeBytes = 100 * 1024 * 1024; // 100MB for Gemini
            } else if (apiProvider === 'gpt4o') {
                maxSizeBytes = 100 * 1024 * 1024; // 100MB for GPT-4o (generous limit)
            } else {
                maxSizeBytes = 25 * 1024 * 1024; // 25MB for Claude (due to base64 encoding)
            }
            
            if (file.size > maxSizeBytes) {
                const sizeMB = (file.size / 1024 / 1024).toFixed(2);
                const limitMB = (maxSizeBytes / 1024 / 1024).toFixed(0);
                const providerName = apiProvider === 'finetuned' ? 'SpeechGradebook Text Model (Mistral)' :
                                    apiProvider === 'qwen' ? 'SpeechGradebook Text + Video Model (Qwen)' :
                                    apiProvider === 'gemini' ? 'Gemini' :
                                    apiProvider === 'gpt4o' ? 'GPT-4o' : 'Claude';
                throw new Error(
                    `File is ${sizeMB} MB, which exceeds the ${limitMB} MB limit for ${providerName}.\n\n` +
                    `Please compress the file or use a different format.`
                );
            }
            
            // Use the passed rubric (or fallback to default if not provided)
            if (!rubric) {
                rubric = getRubricById('default') || DEFAULT_RUBRIC;
            }
            
            const metrics = calculateRubricMetrics(rubric);
            console.log('    Metrics calculated:', metrics);
            
            // Route to demo mode if selected
            let result;
            if (apiProvider === 'demo') {
                console.log('>>> Using Demo Mode - generating mock evaluation');
                result = await generateDemoEvaluation(file, assignmentType, rubric);
            } else if (apiProvider === 'finetuned') {
                result = await evaluateWithFinetuned(apiKey, file, assignmentType, rubric);
            } else if (apiProvider === 'qwen') {
                result = await evaluateWithQwen(apiKey, file, assignmentType, rubric);
            } else if (apiProvider === 'gpt4o') {
                result = await evaluateWithGPT4o(apiKey, file, assignmentType, rubric);
            } else if (apiProvider === 'gemini') {
                result = await evaluateWithGemini(apiKey, file, assignmentType, rubric);
            } else {
                result = await evaluateWithClaude(apiKey, file, assignmentType, rubric);
            }
            
            // Calculate processing time and add to result
            const evaluationEndTime = performance.now();
            const processingTimeSeconds = (evaluationEndTime - evaluationStartTime) / 1000.0;
            result.processingTimeSeconds = processingTimeSeconds;
            
            // Try to get video duration if available
            if (file && file.type && file.type.startsWith('video/')) {
                try {
                    const duration = await getVideoDuration(file);
                    if (duration) {
                        result.videoDurationSeconds = duration;
                    }
                } catch (e) {
                    console.warn('Could not get video duration for energy tracking:', e);
                }
            }
            
            return result;
        }
        
        // ===== FINE-TUNED (SPEECHGRADEBOOK MISTRAL 7B) EVALUATION =====
        async function evaluateWithFinetuned(apiUrl, file, assignmentType, rubric) {
            console.log('>>> Using SpeechGradebook Text Model (Mistral 7B) API');
            try {
                let videoNotes = '';
                const isVideo = file.type && file.type.startsWith('video');
                const qwenUrl = getQwenApiUrl();
                const geminiKey = typeof localStorage !== 'undefined' ? localStorage.getItem('gemini_api_key') || '' : '';
                if (isVideo && (qwenUrl || geminiKey)) {
                    updateProcessingMessage('Getting video notes (body movement, eye contact, etc.)');
                    try {
                        if (qwenUrl) {
                            videoNotes = await getVideoNotesFromQwen(file, qwenUrl);
                        } else if (typeof getVideoNotesFromGemini === 'function') {
                            videoNotes = await getVideoNotesFromGemini(geminiKey, file);
                        }
                    } catch (e) {
                        console.warn('Video notes unavailable, continuing with transcript only:', e.message);
                    }
                }
                updateProcessingMessage('Sending file to SpeechGradebook Text Model (Mistral) server (transcription + evaluation)');
                showUploadProgress(file.size);
                const formData = new FormData();
                formData.append('file', file);
                formData.append('rubric', JSON.stringify(rubric));
                if (videoNotes) formData.append('video_notes', videoNotes);
                let response;
                try {
                    response = await fetchWithProgress(apiUrl + '/evaluate_with_file', {
                        method: 'POST',
                        body: formData
                    }, (percent) => {
                        updateUploadProgress(percent, 'Uploading file');
                    });
                    // Upload complete - switch to finalizing mode (updateUploadProgress handles this)
                    updateUploadProgress(100, 'Finalizing');
                } finally {
                    // Don't hide here - let it stay visible during evaluation
                }
                if (!response.ok) {
                    const errText = await response.text();
                    if (response.status === 501) {
                        throw new Error('SpeechGradebook Text Model (Mistral) server does not support file upload. Install Whisper on the server: pip install openai-whisper');
                    }
                    if (response.status === 503 && (errText || '').includes('Model not loaded')) {
                        throw new Error(
                            'The SpeechGradebook Text Model (Mistral) server is running but no model is loaded. ' +
                            'Train your model first (see llm_training/IMPLEMENTATION_GUIDE.md), then restart the server with: ' +
                            'python serve_model.py --model_path ./mistral7b-speech-lora --port 8000'
                        );
                    }
                    throw new Error(errText || 'SpeechGradebook Text Model (Mistral) server error: ' + response.status);
                }
                const data = await response.json();
                updateProcessingMessage('Calculating final scores');
                const duration = await getVideoDuration(file);
                const result = formatFinetunedResults(data, rubric, duration, videoNotes);
                // Hide progress now that evaluation is complete
                hideUploadProgress();
                return result;
            } catch (error) {
                console.error('SpeechGradebook Text Model (Mistral) evaluation error:', error);
                const isConnectionError = error.message === 'Load failed' || error.message === 'Failed to fetch' || error.name === 'TypeError';
                if (isConnectionError) {
                    var hint = (apiUrl.indexOf('localhost') !== -1)
                        ? ' Start the server on this computer: open a terminal, go to the SpeechGradebook folder, and run ./run_local.sh (or: uvicorn app:app --host 0.0.0.0 --port 8000).'
                        : ' Make sure the server is running and the URL is correct.';
                    throw new Error(
                        'Could not connect to the SpeechGradebook Text Model (Mistral) server at ' + apiUrl + '.' + hint
                    );
                }
                throw new Error('SpeechGradebook Text Model (Mistral) evaluation failed: ' + error.message);
            }
        }
        
        function rubricSubNameToString(sub) {
            if (sub == null) return '';
            if (typeof sub === 'string') return sub;
            if (typeof sub === 'object' && sub && sub.name != null) return String(sub.name);
            return String(sub);
        }
        
        // Normalize rubric for Qwen/API: ensure subcategories are always { name, description } so server never sees raw strings or inconsistent shapes
        function normalizeRubricForApi(rubric) {
            if (!rubric || !rubric.categories) return rubric;
            const out = JSON.parse(JSON.stringify(rubric));
            out.categories = (out.categories || []).map(function(cat) {
                const c = typeof cat === 'object' && cat ? { name: cat.name || '', description: cat.description || '', subcategories: cat.subcategories || [] } : { name: '', description: '', subcategories: [] };
                c.subcategories = (c.subcategories || []).map(function(sub) {
                    const name = rubricSubNameToString(sub);
                    const desc = (typeof sub === 'object' && sub && sub.description != null) ? String(sub.description) : '';
                    return { name: name, description: desc };
                });
                return c;
            });
            return out;
        }
        
        // ===== QWEN (VIDEO) EVALUATION =====
        async function evaluateWithQwen(qwenUrl, file, assignmentType, rubric) {
            console.log('>>> Using SpeechGradebook Text + Video Model (Qwen) – evaluates video and text');
            if (!qwenUrl || !qwenUrl.trim()) {
                throw new Error('SpeechGradebook Text + Video Model (Qwen) Service URL is not set. Set it in Settings → General.');
            }
            const baseUrl = qwenUrl.replace(/\/$/, '');
            if (file.type && !file.type.startsWith('video/')) {
                throw new Error('Qwen (Video) evaluator requires a video file. Please upload a video (e.g. MP4, WebM).');
            }
            try {
                updateProcessingStage('upload');
                updateProcessingMessage('SpeechGradebook Text + Video Model (Qwen) is evaluating the video (content and delivery)');
                showUploadProgress(file.size);
                updateUploadProgress(10, 'Preparing video for evaluation...');
                
                // Use Render proxy endpoint on production, direct Modal URL on localhost
                const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                const apiEndpoint = isLocalhost ? (baseUrl + '/evaluate_video') : '/qwen-api/evaluate_video';
                
                // Retry logic for 503 errors (cold starts)
                let response;
                let lastError;
                const maxRetries = 5;
                // For first retry on cold start, wait longer (90s) since model loading can take time
                // Subsequent retries use exponential backoff: 20s, 40s, 80s, 160s
                const baseDelay = 20000; // 20 seconds base delay (increased from 10s)
                const firstRetryDelay = 90000; // 90 seconds for first retry (cold starts can take this long)
                
                for (let retry = 0; retry <= maxRetries; retry++) {
                    try {
                        // Recreate formData on each retry to ensure file is included
                        const formData = new FormData();
                        formData.append('file', file);
                        formData.append('rubric', JSON.stringify(normalizeRubricForApi(rubric)));
                        
                        response = await fetchWithProgress(apiEndpoint, {
                            method: 'POST',
                            body: formData
                        }, (percent) => {
                            // Progress from 10% to 99% for API call (upload + evaluation)
                            const apiPercent = 10 + (percent * 0.89);
                            updateUploadProgress(apiPercent, retry > 0 ? `Retrying evaluation... (attempt ${retry + 1}/${maxRetries + 1})` : 'Evaluating video...');
                        });
                        updateUploadProgress(99, 'Finalizing');
                        
                        // Check if response is 503 (cold start) and retry
                        if (!response.ok && response.status === 503 && retry < maxRetries) {
                            // For first retry, wait longer for cold starts (90s)
                            // Subsequent retries use exponential backoff: 20s, 40s, 80s, 160s
                            const delay = retry === 0 ? firstRetryDelay : baseDelay * Math.pow(2, retry - 1);
                            updateProcessingMessage(`Service starting (cold start)... Waiting ${delay/1000}s before retry (attempt ${retry + 2}/${maxRetries + 1})`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            continue; // Retry
                        }
                        
                        // If response is ok, break (success)
                        if (response.ok) {
                            break; // Success, exit retry loop
                        }
                        // If response is not ok and not a retryable 503, break and handle error below
                        break;
                    } catch (error) {
                        lastError = error;
                        // Check if it's a 503 error that we should retry
                        const errorMessage = error?.message || String(error) || '';
                        const is503Error = errorMessage.includes('503') || 
                            errorMessage.includes('Service Unavailable') ||
                            errorMessage.includes('service is temporarily unavailable') ||
                            errorMessage.includes('cold start') ||
                            errorMessage.toLowerCase().includes('unavailable');
                        
                        console.log(`[Retry ${retry + 1}/${maxRetries + 1}] Error caught:`, errorMessage, 'is503Error:', is503Error);
                        
                        if (is503Error && retry < maxRetries) {
                            // For first retry, wait longer for cold starts (90s)
                            // Subsequent retries use exponential backoff: 20s, 40s, 80s, 160s
                            const delay = retry === 0 ? firstRetryDelay : baseDelay * Math.pow(2, retry - 1);
                            console.log(`[Retry ${retry + 1}/${maxRetries + 1}] 503 error detected, waiting ${delay/1000}s before retry...`);
                            updateProcessingMessage(`Service starting (cold start)... Waiting ${delay/1000}s before retry (attempt ${retry + 2}/${maxRetries + 1})`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            continue; // Retry
                        }
                        
                        // If we've exhausted retries on a 503, throw with a helpful message
                        if (is503Error && retry >= maxRetries) {
                            throw new Error(`Service unavailable after ${maxRetries + 1} attempts. The Qwen service may be cold starting. Please wait 1-2 minutes and try again.`);
                        }
                        
                        throw error; // Not a 503 or out of retries, throw immediately
                    }
                }
                
                if (!response) {
                    throw lastError || new Error('Evaluation failed after retries');
                }
                
                if (!response.ok) {
                    const errText = await response.text();
                    let errorMsg = '';
                    
                    if (response.status === 503) {
                        errorMsg = formatErrorMessage('Qwen service down', {});
                    } else if (response.status === 429) {
                        errorMsg = formatErrorMessage('Rate limit exceeded', {});
                    } else if (response.status === 303) {
                        errorMsg = 'Redirect (303) received. Often caused by www vs non-www mismatch or wrong QWEN_API_URL. Use the same domain as the app (e.g. https://www.speechgradebook.com). In Render, set QWEN_API_URL to your Qwen tunnel URL (https, no trailing slash).';
                    } else {
                    var msg = errText || ('Evaluation failed: ' + response.status);
                    try {
                        var j = JSON.parse(errText);
                        if (j && typeof j.detail === 'string') msg = j.detail;
                        else if (j && j.detail && Array.isArray(j.detail)) msg = j.detail.map(function(d) { return d.msg || d.loc ? d.loc.join('.') + ': ' + (d.msg || '') : String(d); }).join('; ');
                    } catch (_) {}
                        
                    if (response.status === 500) {
                            errorMsg = formatErrorMessage(msg, {});
                            if (!errorMsg.includes('Qwen evaluation failed')) {
                                errorMsg = 'Server error (500). ' + errorMsg + ' Check the Qwen/Modal server logs for details.';
                            }
                        } else {
                            errorMsg = formatErrorMessage(msg, {});
                        }
                    }
                    throw new Error(errorMsg);
                }
                const data = await response.json();
                console.log('Qwen API raw response:', data);
                updateProcessingMessage('Calculating final scores');
                const duration = await getVideoDuration(file);
                const result = formatFinetunedResults(data, rubric, duration, '');
                // Hide progress now that evaluation is complete
                hideUploadProgress();
                return result;
            } catch (error) {
                console.error('SpeechGradebook Text + Video Model (Qwen) evaluation error:', error);
                const isConnectionError = error.message === 'Load failed' || error.message === 'Failed to fetch' || error.name === 'TypeError';
                if (isConnectionError) {
                    var hint;
                    if (baseUrl.indexOf('localhost') !== -1) {
                        hint = ' Start the SpeechGradebook Text + Video Model (Qwen) service: python llm_training/qwen_serve.py --port 8001';
                    } else {
                        hint = ' Make sure the service is running and the URL is correct.';
                    }
                    const errorMsg = formatErrorMessage('Connection error', {}) + hint;
                    throw new Error(errorMsg);
                }
                // Re-throw with formatted message if not already formatted
                if (error.message && !error.message.includes('Video must be') && !error.message.includes('Evaluation service') && !error.message.includes('Redirect')) {
                    const formattedMsg = formatErrorMessage(error.message, {
                        fileSizeMB: file ? (file.size / 1024 / 1024).toFixed(2) : null
                    });
                    throw new Error(formattedMsg);
                }
                throw error;
            }
        }
        
        function formatFinetunedResults(apiResponse, rubric, duration, video_notes) {
            const sections = {};
            let totalScore = 0;
            const apiSections = apiResponse.sections || {};
            const gradeScale = rubric.gradeScale || {};
            function findSectionKey(catName) {
                if (apiSections[catName]) return catName;
                const lower = (catName || '').trim().toLowerCase();
                for (var k in apiSections) { if ((k || '').trim().toLowerCase() === lower) return k; }
                return null;
            }
            rubric.categories.forEach((category) => {
                var sectionKey = findSectionKey(category.name);
                const apiCat = sectionKey ? apiSections[sectionKey] : null;
                if (!apiCat || !apiCat.subcategories) {
                    sections[category.name] = {
                        score: 0,
                        maxScore: category.subcategories.length * (rubric.totalPoints / (rubric.categories.reduce((n, c) => n + c.subcategories.length, 0))),
                        feedback: 'No feedback provided.',
                        subcategories: category.subcategories.map((sub) => ({
                            name: rubricSubNameToString(sub),
                            grade: 'C',
                            gradeLabel: 'Developing',
                            points: 0,
                            maxPoints: 0
                        }))
                    };
                    return;
                }
                const subcategoryDetails = category.subcategories.map((sub, subIndex) => {
                    const subNameStr = rubricSubNameToString(sub);
                    const subLower = subNameStr.trim().toLowerCase();
                    const apiSub = apiCat.subcategories.find(s => (s && (s.name || '').trim().toLowerCase() === subLower)) || apiCat.subcategories[subIndex];
                    const points = apiSub ? (apiSub.points || 0) : 0;
                    const maxPoints = apiSub ? (apiSub.maxPoints || 0) : 0;
                    const subPct = maxPoints > 0 ? (points / maxPoints) * 100 : 0;
                    const grade = getLetterGrade(subPct, gradeScale);
                    return {
                        name: subNameStr,
                        grade: grade,
                        gradeLabel: gradeScale[grade]?.label || 'Developing',
                        points: parseFloat(Number(points).toFixed(2)),
                        maxPoints: parseFloat(Number(maxPoints).toFixed(2))
                    };
                });
                const score = apiCat.score != null ? apiCat.score : subcategoryDetails.reduce((s, d) => s + d.points, 0);
                const maxScore = apiCat.maxScore != null ? apiCat.maxScore : subcategoryDetails.reduce((s, d) => s + d.maxPoints, 0);
                sections[category.name] = {
                    score: parseFloat(Number(score).toFixed(2)),
                    maxScore: parseFloat(Number(maxScore).toFixed(2)),
                    feedback: apiCat.feedback || 'No feedback provided.',
                    subcategories: subcategoryDetails
                };
                totalScore += sections[category.name].score;
            });
            const percentage = rubric.totalPoints > 0 ? ((totalScore / rubric.totalPoints) * 100).toFixed(1) : '0';
            const letterGrade = getLetterGrade(parseFloat(percentage), gradeScale);
            return {
                studentName: 'Student',
                speechDate: document.getElementById('speechDate').value,
                assignmentType: rubric.speechType || 'General Speech',
                speechTime: duration || '0:00',
                sections: sections,
                totalScore: parseFloat(totalScore.toFixed(2)),
                maxScore: rubric.totalPoints,
                percentage: percentage,
                letterGrade: letterGrade,
                gradeScale: rubric.gradeScale,
                rubricUsed: rubric.name,
                overallComments: apiResponse.overallComments || '',
                transcript: apiResponse.transcript || '',
                video_notes: video_notes || '',
                timeline_markers: apiResponse.timeline_markers || []
            };
        }
        
        // ===== CLAUDE API EVALUATION =====
        async function evaluateWithClaude(apiKey, file, assignmentType, rubric) {
            console.log('>>> Using Claude API (Audio Only)');
            const metrics = calculateRubricMetrics(rubric);
            
            try {
                let audioFile = file;
                
                // If file is video, extract audio automatically
                if (file.type.startsWith('video/')) {
                    console.log('>>> Video detected, extracting audio...');
                    updateProcessingMessage('Extracting audio from video');
                    audioFile = await extractAudioFromVideo(file);
                    console.log('✓ Audio extracted from video');
                }
                
                // Phase 2a: File Processing - Convert audio to base64
                console.log('>>> Phase 2a: Processing audio file...');
                updateProcessingMessage('Processing audio file');
                const { base64Audio, mediaType, duration } = await processAudioFile(audioFile);
                console.log('✓ Audio processed:', mediaType, duration);
                
                // Phase 2b: Speech Transcription
                console.log('>>> Phase 2b: Transcribing speech...');
                updateProcessingMessage('Transcribing speech');
                const transcript = await transcribeSpeech(apiKey, base64Audio, mediaType);
                console.log('✓ Transcription received, length:', transcript.length);
                
                if (!transcript || transcript.trim().length === 0) {
                    throw new Error('Transcription failed or returned empty. Please ensure the audio is clear and try again.');
                }
                
                // Phase 2c: AI Evaluation Against Rubric
                updateProcessingMessage('Analyzing speech against rubric');
                const aiEvaluation = await evaluateWithClaudeAI(apiKey, transcript, rubric);
                
                // Phase 2d: Results Validation & Formatting
                updateProcessingMessage('Calculating final scores');
                const results = formatEvaluationResults(aiEvaluation, rubric, transcript, duration);
                
                return results;
                
            } catch (error) {
                console.error('Claude evaluation error:', error);
                throw new Error(`Claude evaluation failed: ${error.message}`);
            }
        }
        
        // Extract audio from video file using Web Audio API and MediaRecorder
        async function extractAudioFromVideo(videoFile) {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                video.preload = 'metadata';
                video.muted = true;
                
                video.onloadedmetadata = async function() {
                    try {
                        // Create media element source
                        const source = audioContext.createMediaElementSource(video);
                        
                        // Create destination for recording
                        const dest = audioContext.createMediaStreamDestination();
                        source.connect(dest);
                        
                        // Set up MediaRecorder
                        const mediaRecorder = new MediaRecorder(dest.stream);
                        const chunks = [];
                        
                        mediaRecorder.ondataavailable = (e) => {
                            if (e.data.size > 0) {
                                chunks.push(e.data);
                            }
                        };
                        
                        mediaRecorder.onstop = () => {
                            const audioBlob = new Blob(chunks, { type: 'audio/webm' });
                            const audioFile = new File([audioBlob], 'extracted-audio.webm', { type: 'audio/webm' });
                            URL.revokeObjectURL(video.src);
                            resolve(audioFile);
                        };
                        
                        // Start recording and play video
                        mediaRecorder.start();
                        video.play();
                        
                        // Stop when video ends
                        video.onended = () => {
                            mediaRecorder.stop();
                            audioContext.close();
                        };
                        
                    } catch (error) {
                        URL.revokeObjectURL(video.src);
                        reject(new Error('Failed to extract audio: ' + error.message));
                    }
                };
                
                video.onerror = function() {
                    URL.revokeObjectURL(video.src);
                    reject(new Error('Failed to load video for audio extraction'));
                };
                
                video.src = URL.createObjectURL(videoFile);
            });
        }
        
        // ===== GPT-4O-MINI API EVALUATION =====
        async function evaluateWithGPT4o(apiKey, file, assignmentType, rubric) {
            console.log('>>> Using GPT-4o-mini API (Image/Frame Analysis)');
            const metrics = calculateRubricMetrics(rubric);
            
            try {
                let frameBase64;
                
                // Check if file is an image or video
                if (file.type.startsWith('image/')) {
                    // Direct image upload
                    console.log('>>> Phase 1: Processing uploaded image...');
                    updateProcessingMessage('Processing image');
                    frameBase64 = await fileToBase64(file);
                    console.log('✓ Image processed');
                } else {
                    // Extract frame from video
                    console.log('>>> Phase 1: Extracting frame from video...');
                    updateProcessingMessage('Extracting video frame');
                    frameBase64 = await extractVideoFrame(file);
                    console.log('✓ Video frame extracted');
                }
                
                // Phase 2: Send to GPT-4o for analysis
                console.log('>>> Phase 2: Analyzing with GPT-4o...');
                updateProcessingMessage('Analyzing speech delivery');
                const gptEvaluation = await analyzeWithGPT4o(apiKey, frameBase64, rubric);
                console.log('✓ GPT-4o analysis complete');
                
                // Phase 3: Format results
                updateProcessingMessage('Calculating final scores');
                const duration = file.type.startsWith('image/') ? '0:00' : await getVideoDuration(file);
                const results = formatGPTResults(gptEvaluation, rubric, duration);
                
                return results;
                
            } catch (error) {
                console.error('GPT-4o evaluation error:', error);
                throw new Error(`GPT-4o evaluation failed: ${error.message}`);
            }
        }
        
        // Extract a representative frame from video
        async function extractVideoFrame(file) {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                let hasResolved = false;
                
                // Set timeout to prevent hanging
                const timeout = setTimeout(() => {
                    if (!hasResolved) {
                        URL.revokeObjectURL(video.src);
                        reject(new Error('Video loading timed out after 30 seconds. The video format may not be supported by your browser. Try converting to MP4.'));
                    }
                }, 30000);
                
                video.preload = 'metadata';
                video.muted = true;
                video.playsInline = true;
                
                video.onloadedmetadata = function() {
                    console.log('Video metadata loaded. Duration:', video.duration, 'seconds');
                    // Seek to 2 seconds in (or middle if shorter)
                    const seekTime = Math.min(2, video.duration / 2);
                    console.log('Seeking to:', seekTime, 'seconds');
                    video.currentTime = seekTime;
                };
                
                video.onseeked = function() {
                    console.log('Video seeked successfully');
                    
                    if (hasResolved) return;
                    hasResolved = true;
                    clearTimeout(timeout);
                    
                    try {
                        // Set canvas size to video size (limit to reasonable dimensions)
                        const maxWidth = 1280;
                        const maxHeight = 720;
                        let width = video.videoWidth;
                        let height = video.videoHeight;
                        
                        // Scale down if too large
                        if (width > maxWidth) {
                            height = (height * maxWidth) / width;
                            width = maxWidth;
                        }
                        if (height > maxHeight) {
                            width = (width * maxHeight) / height;
                            height = maxHeight;
                        }
                        
                        canvas.width = width;
                        canvas.height = height;
                        
                        console.log('Canvas size:', width, 'x', height);
                        
                        // Draw video frame to canvas
                        ctx.drawImage(video, 0, 0, width, height);
                        
                        // Convert to base64
                        const base64 = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];
                        console.log('Frame extracted, base64 length:', base64.length);
                        
                        // Clean up
                        URL.revokeObjectURL(video.src);
                        
                        resolve(base64);
                    } catch (error) {
                        URL.revokeObjectURL(video.src);
                        reject(new Error('Failed to extract frame: ' + error.message));
                    }
                };
                
                video.onerror = function(e) {
                    if (hasResolved) return;
                    hasResolved = true;
                    clearTimeout(timeout);
                    
                    URL.revokeObjectURL(video.src);
                    
                    let errorMsg = 'Failed to load video.';
                    if (video.error) {
                        switch (video.error.code) {
                            case 1:
                                errorMsg += ' Video loading was aborted.';
                                break;
                            case 2:
                                errorMsg += ' Network error occurred.';
                                break;
                            case 3:
                                errorMsg += ' Video codec not supported by browser. Try converting to MP4.';
                                break;
                            case 4:
                                errorMsg += ' Video format not supported. Try converting to MP4.';
                                break;
                        }
                    }
                    reject(new Error(errorMsg));
                };
                
                // Load the video
                try {
                    const url = URL.createObjectURL(file);
                    console.log('Loading video from blob URL...');
                    video.src = url;
                    video.load();
                } catch (error) {
                    hasResolved = true;
                    clearTimeout(timeout);
                    reject(new Error('Failed to create video URL: ' + error.message));
                }
            });
        }
        
        // Analyze with GPT-4o API
        async function analyzeWithGPT4o(apiKey, frameBase64, rubric) {
            const prompt = buildGPTPrompt(rubric);
            
            log.debug('GPT-4o API Request Details:');
            log.debug('  - API Key length:', apiKey.length);
            log.debug('  - Frame base64 length:', frameBase64.length);
            
            // Validate API key format
            if (!validateApiKeyFormat(apiKey, 'openai')) {
                throw new Error('Invalid OpenAI API key format. Key should start with "sk-". Make sure you\'re using an OpenAI API key from https://platform.openai.com/api-keys');
            }
            
            const requestBody = {
                model: 'gpt-4o-mini',
                messages: [{
                    role: 'user',
                    content: [
                        {
                            type: 'text',
                            text: prompt
                        },
                        {
                            type: 'image_url',
                            image_url: {
                                url: `data:image/jpeg;base64,${frameBase64}`
                            }
                        }
                    ]
                }],
                max_tokens: 4096
            };
            
            console.log('Calling OpenAI API...');
            
            try {
                const response = await fetchWithTimeout('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(requestBody)
                }, 120000);  // 2 minute timeout for video processing
                
                console.log('GPT-4o API Response Status:', response.status);
                console.log('GPT-4o API Response OK:', response.ok);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('GPT-4o API Error Response:', errorText);
                    
                    let errorMessage;
                    try {
                        const errorData = JSON.parse(errorText);
                        errorMessage = errorData.error?.message || errorText;
                    } catch (e) {
                        errorMessage = errorText;
                    }
                    
                    throw new Error(`GPT-4o API error (${response.status}): ${errorMessage}`);
                }
                
                const data = await response.json();
                console.log('GPT-4o API Response received successfully');
                
                const responseText = data.choices?.[0]?.message?.content || '';
                
                if (!responseText) {
                    console.error('GPT-4o response structure:', JSON.stringify(data, null, 2));
                    throw new Error('GPT-4o returned empty response');
                }
                
                return parseGPTEvaluation(responseText);
            } catch (error) {
                console.error('GPT-4o API fetch error:', error);
                throw error;
            }
        }
        
        // Build prompt for GPT-4o
        function buildGPTPrompt(rubric) {
            let prompt = `You are an expert speech instructor evaluating a student's speech presentation. You are viewing a SINGLE FRAME from the middle of their speech video. Analyze this frame for nonverbal delivery cues, and infer verbal content quality based on context clues.

IMPORTANT: You only have ONE FRAME to work with, so focus on:
- What you CAN see: posture, body language, facial expression, eye direction, hand position, professional appearance
- What you can INFER: likely confidence level, engagement, preparation

RUBRIC INFORMATION:
- Assignment Type: ${rubric.speechType || 'General Speech'}
- Total Points: ${rubric.totalPoints}
- Grading Scale:
`;
            
            Object.entries(rubric.gradeScale).forEach(([grade, info]) => {
                prompt += `  ${grade} (${info.label}): ${Math.round(info.percentage * 100)}% of points\n`;
            });
            
            prompt += '\nCATEGORIES TO EVALUATE:\n';
            
            rubric.categories.forEach((category, index) => {
                prompt += `\n${index + 1}. ${category.name}\n`;
                category.subcategories.forEach((sub, subIndex) => {
                    prompt += `   ${String.fromCharCode(97 + subIndex)}. ${sub}\n`;
                });
            });
            
            prompt += `
EVALUATION INSTRUCTIONS:
1. Analyze the single frame carefully
2. For NONVERBAL categories (eye contact, gestures, body language, appearance):
   - Give specific grades based on what you observe
   - Note: "Eye contact appears direct/averted", "Posture is upright/slouched", etc.
3. For VERBAL categories (content, organization, language):
   - Make reasonable inferences based on the speaker's apparent confidence and preparation
   - Grade conservatively (B/C range) since you can't hear the actual content
4. For EACH subcategory, assign a letter grade (A, B, C, D, or F)
5. Be fair but realistic about the limitations of single-frame analysis

CRITICAL: Return your evaluation in this EXACT JSON format (no additional text before or after):
{
  "evaluations": [
    {
      "category": "Category Name",
      "feedback": "Detailed feedback based on visible cues in the frame",
      "subcategories": [
        { "name": "Subcategory Name", "grade": "A" },
        { "name": "Another Subcategory", "grade": "B" }
      ]
    }
  ],
  "overallComments": "Overall assessment noting this is based on a single frame analysis, with observations about visible delivery and inferred content quality",
  "transcript": "Note: Single frame analysis - actual speech content not available"
}

Ensure every subcategory receives a grade. Be honest about limitations while being as helpful as possible.`;

            return prompt;
        }
        
        // Parse GPT evaluation response
        function parseGPTEvaluation(responseText) {
            try {
                let jsonText = responseText.trim();
                
                // Remove markdown code blocks if present
                const codeBlockMatch = jsonText.match(/```(?:json)?\s*([\s\S]*?)```/);
                if (codeBlockMatch) {
                    jsonText = codeBlockMatch[1].trim();
                }
                
                // Try to find JSON object
                const jsonMatch = jsonText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    jsonText = jsonMatch[0];
                }
                
                const evaluation = JSON.parse(jsonText);
                
                // Validate structure
                if (!evaluation.evaluations || !Array.isArray(evaluation.evaluations)) {
                    throw new Error('Invalid evaluation format: missing evaluations array');
                }
                
                if (!evaluation.overallComments) {
                    throw new Error('Invalid evaluation format: missing overallComments');
                }
                
                return evaluation;
                
            } catch (error) {
                console.error('Failed to parse GPT evaluation:', error);
                console.error('Response text:', responseText);
                throw new Error('Failed to parse GPT evaluation response. Please try again.');
            }
        }
        
        // Format GPT results into expected structure
        function formatGPTResults(gptEvaluation, rubric, duration) {
            const metrics = calculateRubricMetrics(rubric);
            const sections = {};
            let totalScore = 0;
            
            rubric.categories.forEach((category, categoryIndex) => {
                const gptCategory = gptEvaluation.evaluations.find(
                    e => e.category === category.name
                );
                
                if (!gptCategory) {
                    console.warn(`No GPT evaluation found for category: ${category.name}`);
                    return;
                }
                
                const grades = category.subcategories.map((sub) => {
                    const nameStr = rubricSubNameToString(sub);
                    const gptSub = gptCategory.subcategories.find(s => s.name === nameStr);
                    return gptSub ? gptSub.grade : 'C';
                });
                
                const categoryScore = calculateCategoryScore(rubric, categoryIndex, grades);
                const pointsPerSub = metrics.pointsPerSubcategory;
                
                const subcategoryDetails = category.subcategories.map((sub, subIndex) => {
                    const grade = grades[subIndex];
                    const gradePercentage = rubric.gradeScale[grade]?.percentage || 0.8;
                    const points = pointsPerSub * gradePercentage;
                    
                    return {
                        name: rubricSubNameToString(sub),
                        grade: grade,
                        gradeLabel: rubric.gradeScale[grade]?.label || 'Developing',
                        points: parseFloat(points.toFixed(2)),
                        maxPoints: parseFloat(pointsPerSub.toFixed(2))
                    };
                });
                
                sections[category.name] = {
                    score: categoryScore.score,
                    maxScore: categoryScore.maxScore,
                    feedback: gptCategory.feedback || 'No feedback provided.',
                    subcategories: subcategoryDetails
                };
                
                totalScore += categoryScore.score;
            });
            
            const percentage = ((totalScore / rubric.totalPoints) * 100).toFixed(1);
            const letterGrade = getLetterGrade(percentage, rubric.gradeScale);
            
            return {
                studentName: 'Student',
                speechDate: document.getElementById('speechDate').value,
                assignmentType: rubric.speechType || 'General Speech',
                speechTime: duration || '0:00',
                sections: sections,
                totalScore: parseFloat(totalScore.toFixed(2)),
                maxScore: rubric.totalPoints,
                percentage: percentage,
                letterGrade: letterGrade,
                gradeScale: rubric.gradeScale,
                rubricUsed: rubric.name,
                overallComments: gptEvaluation.overallComments,
                transcript: gptEvaluation.transcript || ''
            };
        }
        
        // ===== GEMINI API EVALUATION =====
        async function evaluateWithGemini(apiKey, file, assignmentType, rubric) {
            console.log('>>> Using Gemini API (Full Video Analysis)');
            const metrics = calculateRubricMetrics(rubric);
            
            try {
                // Phase 1: Convert file to base64
                console.log('>>> Phase 1: Processing video/audio file...');
                updateProcessingMessage('Processing video file');
                const base64Data = await fileToBase64(file);
                console.log('✓ File converted to base64');
                
                // Phase 2: Send to Gemini for comprehensive analysis
                console.log('>>> Phase 2: Analyzing video with Gemini...');
                updateProcessingMessage('Analyzing speech content and delivery');
                const geminiEvaluation = await analyzeWithGemini(apiKey, base64Data, file.type, rubric);
                console.log('✓ Gemini analysis complete');
                
                // Phase 3: Format results
                updateProcessingMessage('Calculating final scores');
                const duration = await getVideoDuration(file);
                const results = formatGeminiResults(geminiEvaluation, rubric, duration);
                
                return results;
                
            } catch (error) {
                console.error('Gemini evaluation error:', error);
                throw new Error(`Gemini evaluation failed: ${error.message}`);
            }
        }
        
        // Convert file to base64
        async function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const base64 = e.target.result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        // Get video/audio duration
        async function getVideoDuration(file) {
            return new Promise((resolve) => {
                const url = URL.createObjectURL(file);
                const media = document.createElement(file.type.startsWith('video') ? 'video' : 'audio');
                media.onloadedmetadata = function() {
                    const duration = Math.floor(media.duration);
                    const minutes = Math.floor(duration / 60);
                    const seconds = duration % 60;
                    URL.revokeObjectURL(url);
                    resolve(`${minutes}:${seconds.toString().padStart(2, '0')}`);
                };
                media.onerror = function() {
                    URL.revokeObjectURL(url);
                    resolve('0:00');
                };
                media.src = url;
            });
        }
        
        // Analyze with Gemini API
        async function analyzeWithGemini(apiKey, base64Data, mimeType, rubric) {
            const prompt = buildGeminiPrompt(rubric);
            
            log.debug('Gemini API Request Details:');
            log.debug('  - API Key length:', apiKey.length, '(should be around 39 characters)');
            log.debug('  - MIME type:', mimeType);
            log.debug('  - Base64 data length:', base64Data.length);
            log.debug('  - Prompt length:', prompt.length);
            
            // Validate API key format
            if (!validateApiKeyFormat(apiKey, 'gemini')) {
                throw new Error('Invalid Gemini API key format. Key should start with "AIza". Make sure you\'re using a Gemini API key from https://aistudio.google.com/app/apikey');
            }
            
            const requestBody = {
                contents: [{
                    parts: [
                        {
                            inline_data: {
                                mime_type: mimeType,
                                data: base64Data
                            }
                        },
                        {
                            text: prompt
                        }
                    ]
                }]
            };
            
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;
            console.log('Gemini API URL:', url.substring(0, 100) + '...');
            console.log('Request size: ~' + Math.round(JSON.stringify(requestBody).length / 1024 / 1024) + ' MB');
            
            try {
                const response = await fetchWithTimeout(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                }, 180000);  // 3 minute timeout for video processing
                
                console.log('Gemini API Response Status:', response.status);
                console.log('Gemini API Response OK:', response.ok);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Gemini API Error Response:', errorText);
                    
                    let errorMessage;
                    try {
                        const errorData = JSON.parse(errorText);
                        errorMessage = errorData.error?.message || errorText;
                    } catch (e) {
                        errorMessage = errorText;
                    }
                    
                    throw new Error(`Gemini API error (${response.status}): ${errorMessage}`);
                }
                
                const data = await response.json();
                console.log('Gemini API Response received successfully');
                
                const responseText = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                
                if (!responseText) {
                    console.error('Gemini response structure:', JSON.stringify(data, null, 2));
                    throw new Error('Gemini returned empty response');
                }
                
                return parseGeminiEvaluation(responseText);
            } catch (error) {
                console.error('Gemini API fetch error:', error);
                console.error('Error name:', error.name);
                console.error('Error message:', error.message);
                throw error;
            }
        }
        
        // Build prompt for Gemini
        function buildGeminiPrompt(rubric) {
            let prompt = `You are an expert speech instructor evaluating a student's speech presentation. Analyze this video recording for BOTH verbal content AND nonverbal delivery.

RUBRIC INFORMATION:
- Assignment Type: ${rubric.speechType || 'General Speech'}
- Total Points: ${rubric.totalPoints}
- Grading Scale:
`;
            
            Object.entries(rubric.gradeScale).forEach(([grade, info]) => {
                prompt += `  ${grade} (${info.label}): ${Math.round(info.percentage * 100)}% of points\n`;
            });
            
            prompt += '\nCATEGORIES TO EVALUATE:\n';
            
            rubric.categories.forEach((category, index) => {
                prompt += `\n${index + 1}. ${category.name}\n`;
                category.subcategories.forEach((sub, subIndex) => {
                    prompt += `   ${String.fromCharCode(97 + subIndex)}. ${sub}\n`;
                });
            });
            
            prompt += `
EVALUATION INSTRUCTIONS:
1. Watch the ENTIRE video carefully
2. Evaluate BOTH:
   - VERBAL: Speech content, organization, language use, clarity
   - NONVERBAL: Eye contact, gestures, body language, facial expressions, posture, movement
3. For EACH subcategory, assign a letter grade (A, B, C, D, or F)
4. Base your evaluation on evidence from the video
5. Be fair but rigorous in your assessment

For nonverbal categories (eye contact, gestures, body language):
- Observe actual behavior in the video
- Note specific examples (e.g., "maintained eye contact 80% of the time", "used descriptive hand gestures")
- Consider camera angle limitations but evaluate what is visible

CRITICAL: Return your evaluation in this EXACT JSON format (no additional text before or after):
{
  "video_notes": "One paragraph describing visual delivery only: body movement, eye contact, gestures, posture, use of presentation slides if visible, and facial expressions. Be specific and observational.",
  "evaluations": [
    {
      "category": "Category Name",
      "feedback": "Detailed feedback including specific observations from the video (both verbal and visual)",
      "subcategories": [
        { "name": "Subcategory Name", "grade": "A" },
        { "name": "Another Subcategory", "grade": "B" }
      ]
    }
  ],
  "overallComments": "Overall assessment referencing specific moments from the video, both verbal content and physical delivery",
  "transcript": "Brief summary of what was said (2-3 sentences)"
}

Ensure every subcategory receives a grade. Include "video_notes" as a single paragraph of visual-only observations. Be specific in your feedback and reference actual observations from the video.`;

            return prompt;
        }
        
        // Parse Gemini evaluation response
        function parseGeminiEvaluation(responseText) {
            try {
                let jsonText = responseText.trim();
                
                // Remove markdown code blocks if present
                const codeBlockMatch = jsonText.match(/```(?:json)?\s*([\s\S]*?)```/);
                if (codeBlockMatch) {
                    jsonText = codeBlockMatch[1].trim();
                }
                
                // Try to find JSON object
                const jsonMatch = jsonText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    jsonText = jsonMatch[0];
                }
                
                const evaluation = JSON.parse(jsonText);
                
                // Validate structure
                if (!evaluation.evaluations || !Array.isArray(evaluation.evaluations)) {
                    throw new Error('Invalid evaluation format: missing evaluations array');
                }
                
                if (!evaluation.overallComments) {
                    throw new Error('Invalid evaluation format: missing overallComments');
                }
                
                // video_notes is optional; default to empty string for backward compatibility
                if (typeof evaluation.video_notes !== 'string') {
                    evaluation.video_notes = evaluation.video_notes ? String(evaluation.video_notes) : '';
                }
                return evaluation;
                
            } catch (error) {
                console.error('Failed to parse Gemini evaluation:', error);
                console.error('Response text:', responseText);
                throw new Error('Failed to parse Gemini evaluation response. Please try again.');
            }
        }
        
        // Format Gemini results into expected structure
        function formatGeminiResults(geminiEvaluation, rubric, duration) {
            const metrics = calculateRubricMetrics(rubric);
            const sections = {};
            let totalScore = 0;
            
            rubric.categories.forEach((category, categoryIndex) => {
                const geminiCategory = geminiEvaluation.evaluations.find(
                    e => e.category === category.name
                );
                
                if (!geminiCategory) {
                    console.warn(`No Gemini evaluation found for category: ${category.name}`);
                    return;
                }
                
                const grades = category.subcategories.map((sub) => {
                    const nameStr = rubricSubNameToString(sub);
                    const geminiSub = geminiCategory.subcategories.find(s => s.name === nameStr);
                    return geminiSub ? geminiSub.grade : 'C';
                });
                
                const categoryScore = calculateCategoryScore(rubric, categoryIndex, grades);
                const pointsPerSub = metrics.pointsPerSubcategory;
                
                const subcategoryDetails = category.subcategories.map((sub, subIndex) => {
                    const grade = grades[subIndex];
                    const gradePercentage = rubric.gradeScale[grade]?.percentage || 0.8;
                    const points = pointsPerSub * gradePercentage;
                    
                    return {
                        name: rubricSubNameToString(sub),
                        grade: grade,
                        gradeLabel: rubric.gradeScale[grade]?.label || 'Developing',
                        points: parseFloat(points.toFixed(2)),
                        maxPoints: parseFloat(pointsPerSub.toFixed(2))
                    };
                });
                
                sections[category.name] = {
                    score: categoryScore.score,
                    maxScore: categoryScore.maxScore,
                    feedback: geminiCategory.feedback || 'No feedback provided.',
                    subcategories: subcategoryDetails
                };
                
                totalScore += categoryScore.score;
            });
            
            const percentage = ((totalScore / rubric.totalPoints) * 100).toFixed(1);
            const letterGrade = getLetterGrade(percentage, rubric.gradeScale);
            
            return {
                studentName: 'Student',
                speechDate: document.getElementById('speechDate').value,
                assignmentType: rubric.speechType || 'General Speech',
                speechTime: duration || '0:00',
                sections: sections,
                totalScore: parseFloat(totalScore.toFixed(2)),
                maxScore: rubric.totalPoints,
                percentage: percentage,
                letterGrade: letterGrade,
                gradeScale: rubric.gradeScale,
                rubricUsed: rubric.name,
                overallComments: geminiEvaluation.overallComments,
                transcript: geminiEvaluation.transcript || '',
                video_notes: geminiEvaluation.video_notes || ''
            };
        }
        
        async function getVideoNotesFromQwen(file, qwenUrl) {
            const baseUrl = qwenUrl.replace(/\/$/, '');
            const formData = new FormData();
            formData.append('file', file);
            const response = await fetchWithTimeout(baseUrl + '/analyze_video', {
                method: 'POST',
                body: formData
            }, 120000);
            if (!response.ok) {
                const err = await response.text();
                throw new Error('SpeechGradebook Text + Video Model (Qwen) video analysis failed: ' + (err || response.statusText));
            }
            const data = await response.json();
            return (data && data.video_notes) || '';
        }
        
        // Get video-only notes from Gemini (for SpeechGradebook Text Model (Mistral): body movement, eye contact, slides, etc.)
        async function getVideoNotesFromGemini(apiKey, file) {
            const base64Data = await fileToBase64(file);
            const mimeType = file.type || 'video/mp4';
            const prompt = 'Watch this video and write ONE paragraph (3-5 sentences) describing ONLY the visual delivery. Include: body movement, eye contact, gestures, posture, use of presentation slides if visible, and facial expressions. Be specific and observational. Do not summarize what was said. Output only the paragraph, no JSON or labels.';
            const requestBody = {
                contents: [{
                    parts: [
                        { inline_data: { mime_type: mimeType, data: base64Data } },
                        { text: prompt }
                    ]
                }]
            };
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;
            const response = await fetchWithTimeout(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody)
            }, 120000);  // 2 minute timeout for video notes
            if (!response.ok) {
                const err = await response.text();
                throw new Error('Gemini video notes failed: ' + (JSON.parse(err).error?.message || err));
            }
            const data = await response.json();
            const text = (data.candidates?.[0]?.content?.parts?.[0]?.text || '').trim();
            return text || '';
        }
        
        // Helper function to update processing message
        /* Apple HIG: Enhanced processing message updates */
        function updateProcessingMessage(message, submessage = null) {
            const messageElement = document.getElementById('processingMessage');
            const submessageElement = document.getElementById('processingSubmessage');
            
            if (messageElement) {
                messageElement.textContent = message;
                // Add smooth transition
                messageElement.style.opacity = '0';
                setTimeout(() => {
                    messageElement.style.transition = 'opacity var(--motion-fast) var(--motion-ease)';
                    messageElement.style.opacity = '1';
                }, 50);
            }
            
            if (submessageElement) {
                if (submessage) {
                    submessageElement.textContent = submessage;
                    submessageElement.style.display = 'block';
                    submessageElement.style.opacity = '0';
                    setTimeout(() => {
                        submessageElement.style.transition = 'opacity var(--motion-fast) var(--motion-ease)';
                        submessageElement.style.opacity = '1';
                    }, 50);
                } else {
                    submessageElement.style.display = 'none';
                }
            }
        }
        
        // Upload progress tracking variables (declared before functions that use them)
        let finalizingInterval = null;
        let finalizingStartTime = null;
        let estimatedFinalizingTime = 45; // Estimated seconds for evaluation after upload
        let uploadStartTime = null;
        let uploadLastLoaded = 0;
        let uploadTotalSize = 0;
        let uploadSpeedInterval = null;
        
        // Progress stages for evaluation
        const PROGRESS_STAGES = {
            UPLOADING: { text: 'Uploading video...', minPercent: 0, maxPercent: 30 },
            PROCESSING: { text: 'Processing frames...', minPercent: 30, maxPercent: 60 },
            GENERATING: { text: 'Generating evaluation...', minPercent: 60, maxPercent: 90 },
            FINALIZING: { text: 'Finalizing...', minPercent: 90, maxPercent: 100 }
        };
        
        let currentStage = null;
        let videoDuration = null; // Will be set from file if available
        
        // Update processing stage (for bulk upload progress tracking)
        function updateProcessingStage(stage) {
            currentStage = stage;
            // Stage can be: 'upload', 'transcribe', 'analyze', 'score'
            // This function is called to track progress during bulk uploads
            // The stage information can be used for progress updates if needed
        }
        
        // Helper functions for upload progress tracking
        function showUploadProgress(fileSize = null) {
            const container = document.getElementById('uploadProgressContainer');
            if (container) container.style.display = 'block';
            
            // Initialize upload tracking
            uploadStartTime = Date.now();
            uploadLastLoaded = 0;
            uploadTotalSize = fileSize || 0;
            
            // Reset progress details
            const mbEl = document.getElementById('uploadProgressMB');
            const speedEl = document.getElementById('uploadProgressSpeed');
            const etaEl = document.getElementById('uploadProgressETA');
            if (mbEl) mbEl.textContent = '0 MB / ' + (uploadTotalSize > 0 ? (uploadTotalSize / 1024 / 1024).toFixed(1) + ' MB' : '? MB');
            if (speedEl) {
                speedEl.style.display = 'none';
                speedEl.textContent = '';
            }
            if (etaEl) {
                etaEl.style.display = 'none';
                etaEl.textContent = '';
            }
            
            // Start speed calculation interval
            if (uploadSpeedInterval) clearInterval(uploadSpeedInterval);
            uploadSpeedInterval = setInterval(() => {
                if (!uploadStartTime || uploadTotalSize === 0) return;
                
                const elapsed = (Date.now() - uploadStartTime) / 1000; // seconds
                const loaded = uploadLastLoaded;
                const speed = loaded / elapsed; // bytes per second
                const remaining = uploadTotalSize - loaded;
                const eta = remaining / speed; // seconds
                
                const speedEl = document.getElementById('uploadProgressSpeed');
                const etaEl = document.getElementById('uploadProgressETA');
                
                if (speedEl && speed > 0) {
                    const speedMBps = (speed / 1024 / 1024).toFixed(1);
                    speedEl.textContent = speedMBps + ' MB/s';
                    speedEl.style.display = 'inline';
                    speedEl.style.fontSize = 'var(--text-caption-size)';
                    speedEl.style.fontFamily = 'var(--body-font)';
                    speedEl.style.color = 'var(--text-light)';
                }
                
                if (etaEl && eta > 0 && eta < 3600) {
                    const etaSeconds = Math.ceil(eta);
                    if (etaSeconds < 60) {
                        etaEl.textContent = etaSeconds + 's remaining';
                    } else {
                        const etaMinutes = Math.ceil(etaSeconds / 60);
                        etaEl.textContent = etaMinutes + 'm remaining';
                    }
                    etaEl.style.display = 'inline';
                    etaEl.style.fontSize = 'var(--text-caption-size)';
                    etaEl.style.fontFamily = 'var(--body-font)';
                    etaEl.style.color = 'var(--text-light)';
                }
            }, 500); // Update every 500ms
        }
        
        function hideUploadProgress() {
            // Clear upload tracking
            uploadStartTime = null;
            uploadLastLoaded = 0;
            uploadTotalSize = 0;
            if (uploadSpeedInterval) {
                clearInterval(uploadSpeedInterval);
                uploadSpeedInterval = null;
            }
            // Clear any finalizing interval
            if (finalizingInterval) {
                clearInterval(finalizingInterval);
                finalizingInterval = null;
            }
            finalizingStartTime = null;
            const container = document.getElementById('uploadProgressContainer');
            if (container) container.style.display = 'none';
        }
        
        function updateUploadProgress(percent, text) {
            const bar = document.getElementById('uploadProgressBar');
            const percentEl = document.getElementById('uploadProgressPercent');
            const textEl = document.getElementById('uploadProgressText');
            
            // Determine current stage based on percent
            let stage = null;
            if (percent < 30) stage = PROGRESS_STAGES.UPLOADING;
            else if (percent < 60) stage = PROGRESS_STAGES.PROCESSING;
            else if (percent < 90) stage = PROGRESS_STAGES.GENERATING;
            else stage = PROGRESS_STAGES.FINALIZING;
            
            // Update stage text if changed
            if (stage && (!currentStage || currentStage.text !== stage.text)) {
                currentStage = stage;
                if (textEl) {
                    textEl.textContent = stage.text;
                }
            }
            
            // When upload reaches 100%, switch to "Finalizing Evaluation" mode
            if (percent >= 100 && !finalizingInterval) {
                // Start finalizing mode
                finalizingStartTime = Date.now();
                if (bar) bar.style.width = '100%';
                if (percentEl) percentEl.textContent = '';
                
                // Update text to "Finalizing Evaluation"
                if (textEl) {
                    textEl.textContent = 'Finalizing evaluation...';
                }
                
                // Estimate time based on video duration if available
                let estimatedTime = 45; // Default 45 seconds
                if (videoDuration) {
                    // Rough estimate: 10 seconds base + 2 seconds per minute of video
                    estimatedTime = Math.max(30, Math.min(120, 10 + (videoDuration / 60) * 2));
                }
                
                // Start countdown timer
                finalizingInterval = setInterval(() => {
                    if (!finalizingStartTime) return;
                    
                    const elapsed = Math.floor((Date.now() - finalizingStartTime) / 1000);
                    const remaining = Math.max(0, estimatedTime - elapsed);
                    
                    const percentEl = document.getElementById('uploadProgressPercent');
                    if (percentEl) {
                        if (remaining > 0) {
                            percentEl.textContent = `~${remaining}s remaining`;
                        } else {
                            percentEl.textContent = 'Almost done...';
                        }
                    }
                }, 1000); // Update every second
                
                return; // Don't update further in this call
            }
            
            // If already in finalizing mode, don't update
            if (finalizingInterval) {
                return;
            }
            
            // Normal upload progress (before 100%)
            if (bar) bar.style.width = Math.min(100, Math.max(0, percent)) + '%';
            if (percentEl && percent < 100) {
                percentEl.textContent = Math.round(percent) + '%';
                percentEl.style.fontSize = 'var(--text-body-size)';
                percentEl.style.fontWeight = '600';
                percentEl.style.fontFamily = 'var(--body-font)';
            }
            // Use custom text if provided, otherwise use stage text
            if (textEl && text && percent < 100) {
                textEl.textContent = text;
                textEl.style.fontSize = 'var(--text-body-size)';
                textEl.style.fontWeight = '500';
                textEl.style.fontFamily = 'var(--body-font)';
                textEl.style.color = 'var(--text)';
            } else if (textEl && !text && stage) {
                textEl.textContent = stage.text;
                textEl.style.fontSize = 'var(--text-body-size)';
                textEl.style.fontWeight = '500';
                textEl.style.fontFamily = 'var(--body-font)';
                textEl.style.color = 'var(--text)';
            }
            
            // Update MB transferred if we have file size
            if (uploadTotalSize > 0 && percent < 100) {
                const loaded = (uploadTotalSize * percent) / 100;
                uploadLastLoaded = loaded;
                const mbEl = document.getElementById('uploadProgressMB');
                if (mbEl) {
                    const loadedMB = (loaded / 1024 / 1024).toFixed(1);
                    const totalMB = (uploadTotalSize / 1024 / 1024).toFixed(1);
                    mbEl.textContent = loadedMB + ' MB / ' + totalMB + ' MB';
                    mbEl.style.fontSize = 'var(--text-caption-size)';
                    mbEl.style.fontFamily = 'var(--body-font)';
                    mbEl.style.color = 'var(--text-light)';
                }
            }
        }
        
        // Fetch with upload progress tracking (uses XMLHttpRequest for progress events)
        function fetchWithProgress(url, options, onProgress) {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                const formData = options.body;
                
                xhr.upload.addEventListener('progress', (e) => {
                    if (e.lengthComputable && onProgress) {
                        const percent = (e.loaded / e.total) * 100;
                        onProgress(percent, 'Uploading file');
                    }
                });
                
                xhr.addEventListener('load', () => {
                    if (xhr.status >= 200 && xhr.status < 300) {
                        // Try to parse as JSON, fallback to text
                        let response;
                        try {
                            response = JSON.parse(xhr.responseText);
                        } catch {
                            response = xhr.responseText;
                        }
                        resolve({
                            ok: true,
                            status: xhr.status,
                            json: async () => Promise.resolve(response),
                            text: async () => Promise.resolve(xhr.responseText)
                        });
                    } else {
                        reject(new Error(`HTTP ${xhr.status}: ${xhr.statusText}`));
                    }
                });
                
                xhr.addEventListener('error', () => {
                    reject(new Error('Network error'));
                });
                
                xhr.addEventListener('abort', () => {
                    reject(new Error('Request aborted'));
                });
                
                xhr.open(options.method || 'POST', url);
                
                // Set headers if provided
                if (options.headers) {
                    Object.keys(options.headers).forEach(key => {
                        xhr.setRequestHeader(key, options.headers[key]);
                    });
                }
                
                xhr.send(formData);
            });
        }
        
        // Phase 2a: Process audio/video file and convert to base64
        async function processAudioFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const base64Data = e.target.result.split(',')[1];
                    
                    // Determine media type
                    let mediaType = file.type;
                    
                    // Handle common audio formats
                    if (!mediaType || mediaType === '') {
                        const extension = file.name.split('.').pop().toLowerCase();
                        const typeMap = {
                            'mp3': 'audio/mpeg',
                            'wav': 'audio/wav',
                            'webm': 'audio/webm',
                            'mp4': 'audio/mp4',
                            'm4a': 'audio/mp4',
                            'ogg': 'audio/ogg'
                        };
                        mediaType = typeMap[extension] || 'audio/mpeg';
                    }
                    
                    // Estimate duration (not exact, just for display)
                    const estimatedDuration = Math.floor(file.size / 16000); // Rough estimate
                    const minutes = Math.floor(estimatedDuration / 60);
                    const seconds = estimatedDuration % 60;
                    const duration = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    
                    resolve({
                        base64Audio: base64Data,
                        mediaType: mediaType,
                        duration: duration
                    });
                };
                
                reader.onerror = function(error) {
                    reject(new Error('Failed to read audio file: ' + error));
                };
                
                reader.readAsDataURL(file);
            });
        }
        
        // Phase 2b: Transcribe speech using Claude API
        async function transcribeSpeech(apiKey, base64Audio, mediaType) {
            console.log('transcribeSpeech - API key length:', apiKey.length);
            
            // Sanitize API key - remove any non-ASCII characters
            const cleanApiKey = apiKey.replace(/[^\x00-\x7F]/g, '').trim();
            console.log('transcribeSpeech - Cleaned API key length:', cleanApiKey.length);
            
            if (cleanApiKey !== apiKey) {
                console.warn('API key contained non-ASCII characters that were removed');
            }
            
            const response = await fetchWithTimeout('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': cleanApiKey,
                    'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                    model: 'claude-sonnet-4-20250514',
                    max_tokens: 4096,
                    messages: [
                        {
                            role: 'user',
                            content: [
                                {
                                    type: 'document',
                                    source: {
                                        type: 'base64',
                                        media_type: mediaType,
                                        data: base64Audio
                                    }
                                },
                                {
                                    type: 'text',
                                    text: 'Please transcribe this speech audio. Provide only the transcript text without any additional commentary or formatting.'
                                }
                            ]
                        }
                    ]
                })
            }, 120000);  // 2 minute timeout for transcription
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error?.message || `API request failed with status ${response.status}`);
            }
            
            const data = await response.json();
            const transcript = data.content[0]?.text || '';
            
            return transcript.trim();
        }
        
        // Phase 2c: Evaluate transcript against rubric using Claude API
        async function evaluateWithClaudeAI(apiKey, transcript, rubric) {
            // Build the evaluation prompt
            const prompt = buildEvaluationPrompt(transcript, rubric);
            
            // Sanitize API key - remove any non-ASCII characters
            const cleanApiKey = apiKey.replace(/[^\x00-\x7F]/g, '').trim();
            
            const response = await fetchWithTimeout('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': cleanApiKey,
                    'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                    model: 'claude-sonnet-4-20250514',
                    max_tokens: 4096,
                    messages: [
                        {
                            role: 'user',
                            content: prompt
                        }
                    ]
                })
            }, 90000);  // 90 second timeout for evaluation
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error?.message || `API request failed with status ${response.status}`);
            }
            
            const data = await response.json();
            const responseText = data.content[0]?.text || '';
            
            // Parse the JSON response
            return parseAIEvaluation(responseText);
        }
        
        // Build the evaluation prompt for Claude
        function buildEvaluationPrompt(transcript, rubric) {
            let prompt = `You are an expert speech instructor grading a student's speech. Evaluate the following speech transcript against the provided rubric.

SPEECH TRANSCRIPT:
${transcript}

RUBRIC INFORMATION:
- Assignment Type: ${rubric.speechType || 'General Speech'}
- Total Points: ${rubric.totalPoints}
- Grading Scale:
`;
            
            // Add grade scale information
            Object.entries(rubric.gradeScale).forEach(([grade, info]) => {
                prompt += `  ${grade} (${info.label}): ${Math.round(info.percentage * 100)}% of points\n`;
            });
            
            prompt += '\nCATEGORIES AND SUBCATEGORIES TO EVALUATE:\n';
            
            // Add all categories and subcategories
            rubric.categories.forEach((category, index) => {
                prompt += `\n${index + 1}. ${category.name}\n`;
                category.subcategories.forEach((sub, subIndex) => {
                    prompt += `   ${String.fromCharCode(97 + subIndex)}. ${sub}\n`;
                });
            });
            
            prompt += `
TASK:
For EACH subcategory listed above, you must:
1. Assign a letter grade (A, B, C, D, or F) based on how well the speech demonstrates that specific criterion
2. Base your evaluation on evidence from the transcript
3. Be fair but rigorous in your assessment

Additionally, provide:
- Specific feedback for each CATEGORY (not subcategory) explaining the overall performance
- Overall comments on the entire speech with constructive suggestions for improvement

IMPORTANT: Return your evaluation in this EXACT JSON format (no additional text before or after):
{
  "evaluations": [
    {
      "category": "Category Name",
      "feedback": "Detailed feedback for this category based on the transcript",
      "subcategories": [
        { "name": "Subcategory Name", "grade": "A" },
        { "name": "Another Subcategory", "grade": "B" }
      ]
    }
  ],
  "overallComments": "Overall assessment of the speech with specific examples from the transcript and actionable suggestions for improvement"
}

Ensure every subcategory from the rubric receives a grade. Be specific in your feedback and reference actual content from the speech.`;

            return prompt;
        }
        
        // Parse AI evaluation response
        function parseAIEvaluation(responseText) {
            try {
                // Try to extract JSON from the response
                // Handle cases where Claude might wrap it in markdown code blocks
                let jsonText = responseText.trim();
                
                // Remove markdown code blocks if present
                const codeBlockMatch = jsonText.match(/```(?:json)?\s*([\s\S]*?)```/);
                if (codeBlockMatch) {
                    jsonText = codeBlockMatch[1].trim();
                }
                
                // Try to find JSON object
                const jsonMatch = jsonText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    jsonText = jsonMatch[0];
                }
                
                const evaluation = JSON.parse(jsonText);
                
                // Validate the structure
                if (!evaluation.evaluations || !Array.isArray(evaluation.evaluations)) {
                    throw new Error('Invalid evaluation format: missing evaluations array');
                }
                
                if (!evaluation.overallComments) {
                    throw new Error('Invalid evaluation format: missing overallComments');
                }
                
                return evaluation;
                
            } catch (error) {
                console.error('Failed to parse AI evaluation:', error);
                console.error('Response text:', responseText);
                throw new Error('Failed to parse AI evaluation response. Please try again.');
            }
        }
        
        // Phase 2d: Format evaluation results into the expected structure
        function formatEvaluationResults(aiEvaluation, rubric, transcript, duration) {
            const metrics = calculateRubricMetrics(rubric);
            const sections = {};
            let totalScore = 0;
            
            // Process each category from the AI evaluation
            rubric.categories.forEach((category, categoryIndex) => {
                // Find matching evaluation from AI response
                const aiCategory = aiEvaluation.evaluations.find(
                    e => e.category === category.name
                );
                
                if (!aiCategory) {
                    console.warn(`No AI evaluation found for category: ${category.name}`);
                    return;
                }
                
                // Build grade array for this category
                const grades = category.subcategories.map((sub) => {
                    const nameStr = rubricSubNameToString(sub);
                    const aiSub = aiCategory.subcategories.find(s => s.name === nameStr);
                    return aiSub ? aiSub.grade : 'C'; // Default to C if missing
                });
                
                // Calculate category score
                const categoryScore = calculateCategoryScore(rubric, categoryIndex, grades);
                const pointsPerSub = metrics.pointsPerSubcategory;
                
                // Build subcategory details
                const subcategoryDetails = category.subcategories.map((sub, subIndex) => {
                    const grade = grades[subIndex];
                    const gradePercentage = rubric.gradeScale[grade]?.percentage || 0.8;
                    const points = pointsPerSub * gradePercentage;
                    
                    return {
                        name: rubricSubNameToString(sub),
                        grade: grade,
                        gradeLabel: rubric.gradeScale[grade]?.label || 'Developing',
                        points: parseFloat(points.toFixed(2)),
                        maxPoints: parseFloat(pointsPerSub.toFixed(2))
                    };
                });
                
                sections[category.name] = {
                    score: categoryScore.score,
                    maxScore: categoryScore.maxScore,
                    feedback: aiCategory.feedback || 'No feedback provided.',
                    subcategories: subcategoryDetails
                };
                
                totalScore += categoryScore.score;
            });
            
            const percentage = ((totalScore / rubric.totalPoints) * 100).toFixed(1);
            const letterGrade = getLetterGrade(percentage, rubric.gradeScale);
            
            return {
                studentName: 'Student',
                speechDate: document.getElementById('speechDate').value,
                assignmentType: rubric.speechType || 'General Speech',
                speechTime: duration || '0:00',
                sections: sections,
                totalScore: parseFloat(totalScore.toFixed(2)),
                maxScore: rubric.totalPoints,
                percentage: percentage,
                letterGrade: letterGrade,
                gradeScale: rubric.gradeScale,
                rubricUsed: rubric.name,
                overallComments: aiEvaluation.overallComments,
                transcript: transcript // Store transcript for reference
            };
        }

        // Generate feedback based on category and grades
        function generateCategoryFeedback(categoryName, grades) {
            const avgGrade = calculateAverageGrade(grades);
            
            const feedbackMap = {
                'Content - Introduction': {
                    'A': 'Excellent opening with clear attention getter. Introduction effectively established topic relevance and purpose.',
                    'B': 'Strong opening with clear attention getter. Introduction effectively established topic relevance. Good connection to audience.',
                    'C': 'Adequate introduction present. Could improve attention-getting technique and clearer statement of purpose.',
                    'D': 'Introduction present but lacks clear attention getter or purpose statement.',
                    'F': 'Introduction needs significant improvement in capturing attention and establishing purpose.'
                },
                'Content - Organization': {
                    'A': 'Excellent organizational structure with clear pattern. Smooth transitions and perfect time management.',
                    'B': 'Clear organizational pattern evident. Transitions could be smoother. Excellent time management.',
                    'C': 'Basic organizational structure present. Transitions need improvement. Time management adequate.',
                    'D': 'Organization unclear. Transitions weak. Time management needs attention.',
                    'F': 'Lacks clear organizational pattern. Poor transitions and time management.'
                },
                'Content - Conclusion': {
                    'A': 'Excellent conclusion with memorable final thought and effective summary of main points.',
                    'B': 'Strong conclusion with good summary. Final thought could be more memorable.',
                    'C': 'Adequate conclusion present. Could strengthen summary and final thought.',
                    'D': 'Weak conclusion. Lacks clear summary or memorable ending.',
                    'F': 'No clear conclusion or summary provided.'
                },
                'Content - Assignment': {
                    'A': 'Outstanding content that fully addresses all assignment requirements. Personal stories highly engaging and philosophy exceptionally well-articulated.',
                    'B': 'Content clearly addressed assignment requirements. Personal stories were engaging and philosophy was well-articulated.',
                    'C': 'Content addresses most assignment requirements. Could develop ideas more fully.',
                    'D': 'Content partially addresses assignment. Ideas need more development.',
                    'F': 'Content does not adequately address assignment requirements.'
                },
                'Delivery - Nonverbal': {
                    'A': 'Excellent eye contact, natural gestures, and enthusiastic delivery. Highly professional appearance.',
                    'B': 'Good eye contact and gestures. Enthusiastic delivery. Some improvement needed in reducing nervous movements. Professional appearance.',
                    'C': 'Adequate eye contact and gestures. Could improve enthusiasm and reduce distracting movements.',
                    'D': 'Limited eye contact. Gestures need improvement. Lacks enthusiasm.',
                    'F': 'Poor eye contact and minimal effective gestures. Unprofessional delivery.'
                },
                'Delivery - Verbal': {
                    'A': 'Excellent vocal variety, volume, and speaking rate. Perfect use of pauses. Fully extemporaneous with no filler words.',
                    'B': 'Excellent vocal variety and appropriate volume. Good speaking rate. Mostly extemporaneous style with minimal notes. Some filler words present.',
                    'C': 'Adequate vocal delivery. Could improve variety and reduce dependence on notes. Noticeable filler words.',
                    'D': 'Limited vocal variety. Over-reliant on notes. Excessive filler words.',
                    'F': 'Poor vocal delivery. Reading from notes. Excessive filler words interfere with message.'
                }
            };
            
            return feedbackMap[categoryName]?.[avgGrade] || 'Feedback not available.';
        }

        // Calculate average grade from an array of grades
        function calculateAverageGrade(grades) {
            const gradeValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'F': 1 };
            const sum = grades.reduce((total, grade) => total + gradeValues[grade], 0);
            const avg = sum / grades.length;
            
            if (avg >= 4.5) return 'A';
            if (avg >= 3.5) return 'B';
            if (avg >= 2.5) return 'C';
            if (avg >= 1.5) return 'D';
            return 'F';
        }

        // ===== RUBRIC STORAGE & MANAGEMENT =====
        
        // Create a default "General Speech Evaluation" rubric
        const DEFAULT_RUBRIC = {
            id: 'default',
            name: "General Speech Evaluation",
            description: "Simplified evaluation for verbal and nonverbal communication",
            totalPoints: 50,
            courseId: null,
            speechType: "General",
            createdDate: new Date().toISOString(),
            gradeScale: {
                A: { label: "Professional", percentage: 1.00, range: "100-91" },
                B: { label: "Proficient", percentage: 0.90, range: "90-80" },
                C: { label: "Developing", percentage: 0.80, range: "80-71" },
                D: { label: "Unprofessional", percentage: 0.70, range: "70-61" },
                F: { label: "Unacceptable", percentage: 0.60, range: "60-0" }
            },
            categories: [
                {
                    name: "Verbal Delivery",
                    subcategories: [
                        "Vocal Volume and Clarity",
                        "Speaking Rate and Pacing",
                        "Vocal Variety and Expression",
                        "Minimal Filler Words"
                    ]
                },
                {
                    name: "Nonverbal Delivery",
                    subcategories: [
                        "Eye Contact",
                        "Gestures and Body Language",
                        "Confidence and Enthusiasm",
                        "Professional Appearance"
                    ]
                }
            ]
        };

        // Initialize rubrics in localStorage if not exists
        function initializeRubrics() {
            const existingRubrics = localStorage.getItem('speech_rubrics');
            if (!existingRubrics) {
                // Create initial rubrics array with default and self-intro
                const initialRubrics = [
                    DEFAULT_RUBRIC,
                    {
                        id: 'self-intro-1',
                        name: "Self Introduction Speech",
                        description: "Comprehensive rubric for self-introduction speeches",
                        totalPoints: 50,
                        courseId: null,
                        speechType: "Self-Introduction",
                        createdDate: new Date().toISOString(),
                        gradeScale: SELF_INTRO_RUBRIC.gradeScale,
                        categories: SELF_INTRO_RUBRIC.categories
                    }
                ];
                localStorage.setItem('speech_rubrics', JSON.stringify(initialRubrics));
            }
        }

        // Get all rubrics
        // ===== SUPABASE COURSE FUNCTIONS =====
        
        // Save course to Supabase
        async function saveCourseToSupabase(course) {
            if (!supabaseClient) {
                console.log('Supabase not available, using localStorage only');
                return null;
            }
            
            try {
                // Use current authenticated user ID
                let creatorId = currentUser?.id;
                
                if (!creatorId) {
                    console.error('No authenticated user');
                    return null;
                }
                
                const courseData = {
                    instructor_id: creatorId,
                    name: course.name,
                    code: course.section || null,
                    semester: course.semester || null,
                    year: parseInt(course.year) || null
                };
                
                // If course has Supabase ID, update it
                if (course.supabaseId) {
                    const { data, error } = await supabaseClient
                        .from('courses')
                        .update(courseData)
                        .eq('id', course.supabaseId)
                        .select();
                    
                    if (error) {
                        console.error('Failed to update course:', error);
                        return null;
                    }
                    console.log('✓ Course updated in Supabase');
                    return data[0];
                } else {
                    const { data, error } = await supabaseClient
                        .from('courses')
                        .insert([courseData])
                        .select();
                    
                    if (error) {
                        console.error('Failed to save course:', error);
                        return null;
                    }
                    console.log('✓ Course saved to Supabase');
                    
                    // Save students if they exist
                    if (course.roster && course.roster.length > 0) {
                        await saveStudentsToSupabase(data[0].id, course.roster);
                    }
                    
                    return data[0];
                }
            } catch (error) {
                console.error('Supabase error saving course:', error);
                return null;
            }
        }
        
        // Save students to Supabase
        async function saveStudentsToSupabase(courseId, students) {
            if (!supabaseClient || !students || students.length === 0) {
                return null;
            }
            
            try {
                const studentsData = students.map(student => ({
                    course_id: courseId,
                    student_user_id: null,
                    first_name: student.firstName || student.name?.split(' ')[0] || '',
                    last_name: student.lastName || student.name?.split(' ').slice(1).join(' ') || '',
                    email: student.email || null,
                    student_id: student.studentId || null
                }));
                
                const { data, error } = await supabaseClient
                    .from('course_students')
                    .insert(studentsData)
                    .select();
                
                if (error) {
                    console.error('Failed to save students:', error);
                    return null;
                }
                
                console.log(`✓ ${data.length} students saved to Supabase`);
                return data;
            } catch (error) {
                console.error('Supabase error saving students:', error);
                return null;
            }
        }
        
        // Load courses from Supabase
        async function loadCoursesFromSupabase() {
            if (!supabaseClient || !currentUser) {
                console.log('Cannot load courses: No Supabase client or user');
                return null;
            }
            
            console.log('=== LOADING COURSES FROM SUPABASE ===');
            console.log('View mode:', currentViewMode);
            console.log('User tier:', userTier);
            console.log('User ID:', currentUser.id);
            console.log('Institution:', currentUser.institution_id);
            
            try {
                let query = supabaseClient
                    .from('courses')
                    .select(`
                        *,
                        course_students!course_students_course_id_fkey (
                            id,
                            first_name,
                            last_name,
                            email,
                            student_id,
                            deleted_locally_at,
                            deleted_locally_by
                        )
                    `);
                
                // Filter based on view mode and optional scope filters
                if (currentViewMode === 'own' || userTier === 'instructor') {
                    // Own courses only; hide courses deleted locally by this instructor
                    console.log('Filtering: Own courses only (instructor_id =', currentUser.id, ')');
                    query = query.eq('instructor_id', currentUser.id).is('deleted_locally_at', null);
                } else if (currentViewMode === 'institution' && isAdmin()) {
                    // Admin: department (institution) courses, optionally by instructor
                    const institutionId = currentUser.institution_id;
                    if (currentFilterInstructorId) {
                        console.log('Filtering: Department, instructor =', currentFilterInstructorId);
                        query = query.eq('instructor_id', currentFilterInstructorId);
                    } else {
                        const { data: institutionInstructors, error: instError } = await supabaseClient
                            .from('user_profiles')
                            .select('id')
                            .eq('institution_id', institutionId);
                        if (instError) {
                            console.error('Error loading institution instructors:', instError);
                        }
                        if (institutionInstructors && institutionInstructors.length > 0) {
                            const instructorIds = institutionInstructors.map(i => i.id);
                            query = query.in('instructor_id', instructorIds);
                        } else {
                            query = query.eq('instructor_id', '00000000-0000-0000-0000-000000000000'); // no match
                        }
                    }
                } else if (currentViewMode === 'institution' && isSuperAdmin() && currentFilterInstitutionId) {
                    // Super admin: courses for selected institution, optionally by instructor
                    if (currentFilterInstructorId) {
                        console.log('Filtering: Institution', currentFilterInstitutionId, ', instructor =', currentFilterInstructorId);
                        query = query.eq('instructor_id', currentFilterInstructorId);
                    } else {
                        const { data: institutionInstructors, error: instError } = await supabaseClient
                            .from('user_profiles')
                            .select('id')
                            .eq('institution_id', currentFilterInstitutionId);
                        if (instError) {
                            console.error('Error loading institution instructors:', instError);
                        }
                        if (institutionInstructors && institutionInstructors.length > 0) {
                            const instructorIds = institutionInstructors.map(i => i.id);
                            query = query.in('instructor_id', instructorIds);
                        } else {
                            query = query.eq('instructor_id', '00000000-0000-0000-0000-000000000000');
                        }
                    }
                } else if (currentViewMode === 'institution' && isSuperAdmin() && !currentFilterInstitutionId) {
                    // Super admin chose "Institution" but no institution selected yet
                    console.log('Filtering: Select an institution to view courses');
                    return [];
                } else if (currentViewMode === 'all' && isSuperAdmin()) {
                    // Super admin: all courses (no institution filter selected)
                    console.log('Filtering: ALL institutions (no filter - super admin)');
                } else if (currentViewMode === 'demo') {
                    // Demo mode: Don't load from Supabase
                    console.log('Demo mode: Skipping Supabase load');
                    return null;
                } else {
                    console.warn('Unknown view mode or insufficient permissions:', currentViewMode);
                }
                
                // Exclude courses deleted locally by instructors (All Courses dropdown and grid)
                query = query.is('deleted_locally_at', null);
                
                const { data: courses, error } = await query.order('created_at', { ascending: false });
                
                if (error) {
                    console.error('❌ Failed to load courses:', error);
                    return null;
                }
                
                console.log(`✅ Loaded ${courses.length} courses from Supabase (${currentViewMode} view)`);
                
                // Audit: log course and roster (student) data access for FERPA
                const totalStudents = (courses || []).reduce((sum, c) => sum + (c.course_students?.length || 0), 0);
                await logAccess('view', 'courses', null, null, { course_count: courses.length, student_count: totalStudents });
                if (totalStudents > 0) {
                    await logAccess('view', 'course_students', null, null, { course_count: courses.length, student_count: totalStudents });
                }
                
                // Log course details for debugging
                if (courses.length > 0) {
                    console.log('First course:', {
                        name: courses[0].name,
                        instructor_id: courses[0].instructor_id,
                        created_at: courses[0].created_at
                    });
                }
                
                console.log('=== COURSE LOAD COMPLETE ===');
                return courses;
            } catch (error) {
                console.error('❌ Supabase error loading courses:', error);
                return null;
            }
        }
        
        /** Fetch a single course by id (for Admin/Super Admin viewing another instructor's course). Returns app-format course or null. */
        async function loadSingleCourseFromSupabaseForView(courseId) {
            if (!supabaseClient || !currentUser || !courseId) return null;
            try {
                const { data: course, error } = await supabaseClient
                    .from('courses')
                    .select(`
                        *,
                        course_students!course_students_course_id_fkey (
                            id,
                            first_name,
                            last_name,
                            email,
                            student_id,
                            deleted_locally_at,
                            deleted_locally_by
                        )
                    `)
                    .eq('id', courseId)
                    .single();
                if (error || !course) return null;
                const appCourse = {
                    id: course.id,
                    supabaseId: course.id,
                    name: course.name,
                    semester: course.semester || 'Fall',
                    section: course.code || '001',
                    year: course.year?.toString() || '2024',
                    notes: course.notes || '',
                    roster: (course.course_students || []).filter(s => !s.deleted_locally_at && !isDeletedId('deleted_student_ids', course.id + ':' + s.id)).map(s => ({
                        supabaseId: s.id,
                        firstName: s.first_name,
                        lastName: s.last_name,
                        name: `${s.first_name || ''} ${s.last_name || ''}`.trim() || '—',
                        email: s.email || '',
                        studentId: s.student_id || '',
                        evaluations: []
                    })),
                    evaluations: []
                };
                return appCourse;
            } catch (e) {
                console.error('loadSingleCourseFromSupabaseForView:', e);
                return null;
            }
        }
        
        // ===== CONSENT & LOCAL-ONLY EVALUATIONS =====
        // Students who do not consent to research/LLM are still evaluated; their data is stored only in localStorage (classes), not in Supabase.

        /** Returns true if student has consented to cloud storage (single catch-all data_collection consent); false = store locally only. */
        async function getStudentConsentForStorage(courseId, studentId) {
            if (!supabaseClient || !courseId || !studentId) return false;
            try {
                const { data, error } = await supabaseClient
                    .from('consent_forms')
                    .select('consent_given')
                    .eq('course_id', courseId)
                    .eq('student_id', studentId)
                    .eq('consent_type', 'data_collection');
                if (error) return false;
                return (data || []).some(function(r) { return r.consent_given === true; });
            } catch (e) {
                return false;
            }
        }

        // Supabase Storage bucket for evaluation media (video/audio). Create bucket "evaluation-media" in Supabase Dashboard and set RLS if needed.
        const EVALUATION_MEDIA_BUCKET = 'evaluation-media';

        // Save evaluation to Supabase
        // rubricOrNull: optional full rubric object; when provided, stores rubric_structure for LLM training (categories + totalPoints).
        // mediaFile: optional File (video or audio); if provided, uploads to Supabase Storage and sets video_url or audio_url.
        async function saveEvaluationToSupabase(evaluation, courseId, studentId, rubricId, rubricOrNull, mediaFile) {
            if (!supabaseClient || !currentUser) {
                console.log('Cannot save evaluation: no Supabase or user');
                return null;
            }
            
            try {
                const evalDataPayload = {
                        sections: evaluation.sections,
                        studentName: evaluation.studentName,
                        speechDate: evaluation.speechDate,
                        assignmentType: evaluation.assignmentType,
                        speechTime: evaluation.speechTime,
                        rubricUsed: evaluation.rubricUsed,
                        totalScore: evaluation.totalScore,
                        maxScore: evaluation.maxScore,
                        percentage: evaluation.percentage,
                        letterGrade: evaluation.letterGrade,
                        overallComments: evaluation.overallComments,
                        timeline_markers: evaluation.timeline_markers || [],
                        video_notes: evaluation.video_notes || null,
                        corrections: correctionLog || [],  // Include correction log
                        edited: correctionLog && correctionLog.length > 0
                    };
                if (evaluation.gradeScale && typeof evaluation.gradeScale === 'object') {
                    var totalPts = evaluation.maxScore != null ? parseFloat(evaluation.maxScore) : (rubricOrNull && rubricOrNull.totalPoints != null ? parseFloat(rubricOrNull.totalPoints) : 100);
                    evalDataPayload.gradeScale = enrichGradeScaleWithPointRanges(evaluation.gradeScale, totalPts);
                }
                if (modelOutputOriginal) {
                    evalDataPayload.model_output_original = modelOutputOriginal;
                    modelOutputOriginal = null;
                }
                // Snapshot rubric structure for LLM training so export has exact categories/subcategories used at evaluation time.
                if (rubricOrNull && rubricOrNull.categories && Array.isArray(rubricOrNull.categories)) {
                    evalDataPayload.rubric_structure = {
                        categories: rubricOrNull.categories,
                        totalPoints: rubricOrNull.totalPoints
                    };
                }
                const evaluationData = {
                    instructor_id: currentUser.id,
                    student_id: studentId, // course_students table ID
                    course_id: courseId,
                    rubric_id: rubricId,
                    video_url: null,
                    audio_url: null,
                    transcript: evaluation.transcript || null,
                    ai_provider: evaluation.aiProvider || 'unknown',
                    evaluation_data: evalDataPayload,
                    total_score: evaluation.totalScore || 0,
                    letter_grade: evaluation.letterGrade || 'N/A',
                    status: 'completed'
                };
                
                const { data, error } = await supabaseClient
                    .from('evaluations')
                    .insert([evaluationData])
                    .select();
                
                if (error) {
                    console.error('Failed to save evaluation to Supabase:', error);
                    return null;
                }
                
                const inserted = data && data[0];
                if (!inserted) return null;
                
                // Log creation for FERPA compliance
                await logAccess('create', 'evaluations', inserted.id, studentId, {
                    course_id: courseId,
                    rubric_id: rubricId,
                    total_score: evaluation.totalScore
                });
                
                // Upload video/audio to Storage if provided (for Qwen training and replay)
                if (mediaFile && mediaFile.size > 0) {
                    const isVideo = (mediaFile.type || '').startsWith('video/');
                    const safeName = (mediaFile.name || 'media').replace(/[^a-zA-Z0-9._-]/g, '_');
                    const storagePath = `${currentUser.id}/${inserted.id}/${safeName}`;
                    try {
                        const { error: uploadErr } = await supabaseClient.storage
                            .from(EVALUATION_MEDIA_BUCKET)
                            .upload(storagePath, mediaFile, { contentType: mediaFile.type || (isVideo ? 'video/mp4' : 'audio/mpeg'), upsert: false });
                        if (uploadErr) {
                            console.warn('Storage upload failed (evaluation saved without media URL):', uploadErr);
                        } else {
                            const { data: urlData } = supabaseClient.storage.from(EVALUATION_MEDIA_BUCKET).getPublicUrl(storagePath);
                            const mediaUrl = urlData.publicUrl;
                            const updatePayload = isVideo ? { video_url: mediaUrl } : { audio_url: mediaUrl };
                            const { error: updateErr } = await supabaseClient
                                .from('evaluations')
                                .update(updatePayload)
                                .eq('id', inserted.id);
                            if (updateErr) console.warn('Failed to set media URL on evaluation:', updateErr);
                            else {
                                if (isVideo) inserted.video_url = mediaUrl; else inserted.audio_url = mediaUrl;
                            }
                            console.log('✓ Evaluation media saved to Storage:', isVideo ? 'video' : 'audio');
                        }
                    } catch (e) {
                        console.warn('Storage upload error (evaluation saved without media URL):', e);
                    }
                }
                
                // Track energy usage for this evaluation
                try {
                    await trackEvaluationEnergyUsage(inserted.id, evaluation, mediaFile, currentUser.id);
                } catch (energyError) {
                    console.warn('Failed to track energy usage (evaluation still saved):', energyError);
                    // Don't fail the save if energy tracking fails
                }
                
                console.log('✓ Evaluation saved to Supabase');
                return inserted;
            } catch (error) {
                console.error('Supabase error saving evaluation:', error);
                return null;
            }
        }
        
        // Track energy usage for an evaluation
        async function trackEvaluationEnergyUsage(evaluationId, evaluation, mediaFile, instructorId) {
            if (!supabaseClient || !evaluationId || !evaluation) {
                return;
            }
            
            const aiProvider = evaluation.aiProvider || 'unknown';
            const fileSizeBytes = mediaFile ? mediaFile.size : null;
            const processingTimeSeconds = evaluation.processingTimeSeconds || null;
            const videoDurationSeconds = evaluation.videoDurationSeconds || null;
            
            // Get provider metadata if available
            const providerMetadata = {
                model: evaluation.modelVersion || null,
                tokens: evaluation.tokenCount || null,
                region: evaluation.region || null
            };
            
            // Get institution_id from user profile
            let institutionId = null;
            try {
                const { data: profile } = await supabaseClient
                    .from('user_profiles')
                    .select('institution_id')
                    .eq('id', instructorId)
                    .single();
                if (profile) {
                    institutionId = profile.institution_id;
                }
            } catch (e) {
                console.warn('Could not fetch institution_id for energy tracking:', e);
            }
            
            // Call database function to calculate energy, or use defaults
            let energy;
            try {
                const { data: energyData, error: calcError } = await supabaseClient.rpc('calculate_evaluation_energy', {
                    p_evaluation_id: evaluationId,
                    p_ai_provider: aiProvider,
                    p_file_size_bytes: fileSizeBytes,
                    p_processing_time_seconds: processingTimeSeconds,
                    p_video_duration_seconds: videoDurationSeconds,
                    p_provider_metadata: providerMetadata
                });
                
                if (calcError || !energyData || energyData.length === 0) {
                    console.warn('Energy calculation failed, using defaults:', calcError);
                    // Use default conservative estimates
                    energy = calculateEnergyDefaults(aiProvider, fileSizeBytes, processingTimeSeconds);
                } else {
                    energy = energyData[0];
                }
            } catch (rpcError) {
                console.warn('RPC function not available, using defaults:', rpcError);
                // Use default conservative estimates
                energy = calculateEnergyDefaults(aiProvider, fileSizeBytes, processingTimeSeconds);
            }
            
            // Insert energy usage record
            const { error: insertError } = await supabaseClient
                .from('energy_usage')
                .insert([{
                    evaluation_id: evaluationId,
                    instructor_id: instructorId,
                    institution_id: institutionId,
                    ai_provider: aiProvider,
                    energy_kwh: energy.energy_kwh,
                    co2_kg: energy.co2_kg,
                    scope: energy.scope,
                    scope_category: energy.scope_category,
                    provider_metadata: providerMetadata,
                    file_size_bytes: fileSizeBytes,
                    processing_time_seconds: processingTimeSeconds,
                    video_duration_seconds: videoDurationSeconds
                }]);
            
            if (insertError) {
                console.error('Failed to insert energy usage:', insertError);
                throw insertError;
            }
            
            console.log('✓ Energy usage tracked:', {
                evaluationId,
                provider: aiProvider,
                energy_kwh: energy.energy_kwh,
                co2_kg: energy.co2_kg
            });
        }
        
        // Calculate default energy values if database function is unavailable
        function calculateEnergyDefaults(aiProvider, fileSizeBytes, processingTimeSeconds) {
            let energy_kwh = 0;
            let co2_kg = 0;
            let scope = 'scope_3';
            let scope_category = 'api_call';
            
            const defaultProcessingTime = processingTimeSeconds || 30;
            
            switch (aiProvider) {
                case 'qwen':
                    // GPU-based, ~0.5 kW average
                    energy_kwh = (defaultProcessingTime / 3600.0) * 0.5;
                    co2_kg = energy_kwh * 0.5; // 0.5 kg CO2/kWh
                    scope = 'scope_2';
                    scope_category = 'cloud_compute';
                    break;
                case 'gpt4o':
                case 'gemini':
                case 'claude':
                    // API calls, ~0.002-0.003 kWh per evaluation
                    energy_kwh = 0.002;
                    co2_kg = energy_kwh * 0.4;
                    scope = 'scope_3';
                    scope_category = 'api_call';
                    break;
                case 'finetuned':
                    // Local/cloud server, ~0.3 kW average
                    energy_kwh = (defaultProcessingTime / 3600.0) * 0.3;
                    co2_kg = energy_kwh * 0.5;
                    scope = 'scope_2';
                    scope_category = 'cloud_compute';
                    break;
                case 'demo':
                    energy_kwh = 0;
                    co2_kg = 0;
                    scope = 'scope_3';
                    scope_category = 'local_compute';
                    break;
                default:
                    energy_kwh = 0.002;
                    co2_kg = energy_kwh * 0.5;
                    scope = 'scope_3';
                    scope_category = 'api_call';
            }
            
            return { energy_kwh, co2_kg, scope, scope_category };
        }
        
        // Load evaluations from Supabase
        async function loadEvaluationsFromSupabase(courseId = null, studentId = null) {
            if (!supabaseClient || !currentUser) {
                return null;
            }
            
            try {
                let query = supabaseClient
                    .from('evaluations')
                    .select(`
                        *,
                        course:courses!evaluations_course_id_fkey(id, name, code, semester, year),
                        student:course_students!evaluations_student_id_fkey(id, first_name, last_name, email),
                        rubric:rubrics!fk_evaluations_rubric(id, name)
                    `);
                
                // Only filter by instructor for instructors; hide evaluations deleted locally by this instructor
                if (userTier === 'instructor') {
                    query = query.eq('instructor_id', currentUser.id).is('deleted_locally_at', null);
                }
                query = query.order('created_at', { ascending: false });
                
                if (courseId) {
                    query = query.eq('course_id', courseId);
                }
                
                if (studentId) {
                    query = query.eq('student_id', studentId);
                }
                
                const { data, error } = await query;
                
                if (error) {
                    console.error('Failed to load evaluations from Supabase:', error);
                    return null;
                }
                
                // Log access for FERPA compliance
                if (data && data.length > 0) {
                    const uniqueStudentIds = [...new Set(data.map(e => e.student_id))];
                    for (const sid of uniqueStudentIds) {
                        await logAccess('view', 'evaluations', null, sid, {
                            course_id: courseId,
                            evaluation_count: data.filter(e => e.student_id === sid).length
                        });
                    }
                }
                
                console.log(`✓ Loaded ${data.length} evaluations from Supabase`);
                return data;
            } catch (error) {
                console.error('Supabase error loading evaluations:', error);
                return null;
            }
        }
        
        // ===== SUPABASE RUBRIC FUNCTIONS =====
        
        // Save rubric to Supabase
        async function saveRubricToSupabase(rubric) {
            if (!supabaseClient) {
                console.log('Supabase not available, using localStorage only');
                return null;
            }
            
            try {
                // Use current authenticated user ID
                let creatorId = currentUser?.id;
                
                if (!creatorId) {
                    console.error('No authenticated user');
                    return null;
                }
                
                // Validate UUID format
                const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
                if (!uuidRegex.test(creatorId)) {
                    console.error('Invalid UUID format for creator_id:', creatorId);
                    return null;
                }
                
                const rubricData = {
                    creator_id: creatorId, // Using authenticated user
                    name: rubric.name,
                    description: (rubric.description != null && rubric.description !== '') ? rubric.description : null,
                    speech_type: rubric.speechType || null,
                    total_points: rubric.totalPoints || 0,
                    grade_scale: rubric.gradeScale,
                    categories: rubric.categories,
                    example_videos: rubric.exampleVideos || rubric.example_videos || [],
                    textbook_id: rubric.textbookId || rubric.textbook_id || null,
                    is_template: rubric.isTemplate || false,
                    course_ids: Array.isArray(rubric.courseIds) ? rubric.courseIds : (rubric.course_ids || [])
                };
                // When an admin uploads/creates a rubric, share it with their institution so instructors can use it
                if (currentUser?.is_admin && currentUser?.institution_id) {
                    rubricData.institution_id = currentUser.institution_id;
                }
                
                // If rubric has a Supabase ID (or id is a UUID from edit), update it
                const idToUpdate = rubric.supabaseId || (uuidRegex.test(rubric.id) ? rubric.id : null);
                if (idToUpdate) {
                    const { data, error } = await supabaseClient
                        .from('rubrics')
                        .update(rubricData)
                        .eq('id', idToUpdate)
                        .select();
                    
                    if (error) {
                        console.error('Failed to update rubric in Supabase:', error);
                        return null;
                    }
                    console.log('✓ Rubric updated in Supabase');
                    return data[0];
                } else {
                    // Insert new rubric
                    const { data, error } = await supabaseClient
                        .from('rubrics')
                        .insert([rubricData])
                        .select();
                    
                    if (error) {
                        console.error('Failed to save rubric to Supabase:', error);
                        return null;
                    }
                    console.log('✓ Rubric saved to Supabase');
                    return data[0];
                }
            } catch (error) {
                console.error('Supabase error saving rubric:', error);
                return null;
            }
        }
        
        // Load rubrics from Supabase
        async function loadRubricsFromSupabase() {
            if (!supabaseClient) {
                return null;
            }
            
            try {
                const { data, error } = await supabaseClient
                    .from('rubrics')
                    .select('*')
                    .order('created_at', { ascending: false });
                
                if (error) {
                    console.error('Failed to load rubrics from Supabase:', error);
                    return null;
                }
                
                console.log(`✓ Loaded ${data.length} rubrics from Supabase`);
                return data;
            } catch (error) {
                console.error('Supabase error loading rubrics:', error);
                return null;
            }
        }
        
        // Hybrid function: Get all rubrics (Supabase + localStorage)
        async function getAllRubrics() {
            // Try Supabase first
            const supabaseRubrics = await loadRubricsFromSupabase();
            
            if (supabaseRubrics && supabaseRubrics.length > 0) {
                // Convert Supabase format to app format; hide locally-deleted rubrics
                const list = supabaseRubrics.map(sr => ({
                    id: sr.id,
                    supabaseId: sr.id,
                    name: sr.name,
                    description: sr.description ?? '',
                    speechType: sr.speech_type,
                    totalPoints: sr.total_points,
                    gradeScale: sr.grade_scale,
                    categories: sr.categories,
                    exampleVideos: sr.example_videos || [],
                    textbookId: sr.textbook_id || null,
                    courseIds: Array.isArray(sr.course_ids) ? sr.course_ids : (sr.course_ids ? [sr.course_ids] : []),
                    isTemplate: sr.is_template,
                    createdDate: sr.created_at,
                    modifiedDate: sr.updated_at
                }));
                return list.filter(r => !isDeletedId('deleted_rubric_ids', r.id));
            }
            
            // Fallback to localStorage; hide locally-deleted rubrics
            const rubrics = localStorage.getItem('speech_rubrics');
            const local = rubrics ? JSON.parse(rubrics) : [];
            return local.filter(r => !isDeletedId('deleted_rubric_ids', r.id));
        }

        // Get rubrics by course
        async function getRubricsByCourse(courseId) {
            const rubrics = await getAllRubrics();
            return rubrics.filter(r => r.courseId === courseId);
        }

        // Get rubric by ID
        async function getRubricById(rubricId) {
            const rubrics = await getAllRubrics();
            return rubrics.find(r => r.id === rubricId);
        }

        // Save/update rubric (hybrid: Supabase + localStorage)
        async function saveRubric(rubric) {
            // Save to localStorage first (immediate, synchronous)
            const rubrics = localStorage.getItem('speech_rubrics');
            const localRubrics = rubrics ? JSON.parse(rubrics) : [];
            const existingIndex = localRubrics.findIndex(r => r.id === rubric.id);
            
            if (existingIndex >= 0) {
                // Update existing
                rubric.modifiedDate = new Date().toISOString();
                localRubrics[existingIndex] = rubric;
            } else {
                // Add new
                if (!rubric.id) {
                    rubric.id = 'rubric-' + Date.now();
                }
                rubric.createdDate = new Date().toISOString();
                localRubrics.push(rubric);
            }
            
            localStorage.setItem('speech_rubrics', JSON.stringify(localRubrics));
            console.log('✓ Rubric saved to localStorage');
            
            // Save to Supabase and wait so we can surface errors
            if (supabaseClient) {
                const supabaseRubric = await saveRubricToSupabase(rubric);
                if (supabaseRubric) {
                    rubric.supabaseId = supabaseRubric.id;
                    const updated = localRubrics.find(r => r.id === rubric.id);
                    if (updated) {
                        updated.supabaseId = supabaseRubric.id;
                        localStorage.setItem('speech_rubrics', JSON.stringify(localRubrics));
                    }
                } else {
                    throw new Error('Failed to save rubric to database. Check the console for details, and ensure you have run the ADD_RUBRIC_DESCRIPTION_AND_COURSE_IDS.sql migration in Supabase if needed.');
                }
            }
            
            return rubric;
        }

        // Duplicate rubric
        async function duplicateRubric(rubricId) {
            const original = await getRubricById(rubricId);
            if (!original) return null;
            
            const duplicate = {
                ...JSON.parse(JSON.stringify(original)), // Deep copy
                id: 'rubric-' + Date.now(),
                supabaseId: undefined, // Remove supabaseId so it creates new in database
                name: original.name + " (Copy)",
                createdDate: new Date().toISOString(),
                modifiedDate: null
            };
            
            return await saveRubric(duplicate);
        }

        // Delete rubric. Admin/Instructor: local only (and mark in Supabase so Admin/Super Admin see tag). Super Admin: scope from Settings.
        async function deleteRubric(rubricId) {
            if (rubricId === 'default') {
                alert('Cannot delete the default rubric.');
                return false;
            }
            const rubrics = await getAllRubrics();
            const rubricToDelete = rubrics.find(r => r.id === rubricId);
            const scope = typeof getDeletionScope === 'function' ? getDeletionScope('rubrics') : 'local';
            if (scope === 'local' || scope === 'both') {
                const filtered = rubrics.filter(r => r.id !== rubricId);
                localStorage.setItem('speech_rubrics', JSON.stringify(filtered));
                addDeletedId('deleted_rubric_ids', rubricId);
            }
            if ((scope === 'supabase' || scope === 'both') && supabaseClient && rubricToDelete && rubricToDelete.supabaseId) {
                await supabaseClient.from('rubrics').delete().eq('id', rubricToDelete.supabaseId);
            } else if ((scope === 'local' || scope === 'both') && supabaseClient && rubricToDelete && rubricToDelete.supabaseId && currentUser) {
                await supabaseClient.from('rubrics').update({
                    deleted_locally_at: new Date().toISOString(),
                    deleted_locally_by: currentUser.id
                }).eq('id', rubricToDelete.supabaseId);
            }
            return true;
        }

        // Get rubrics grouped by course
        function getRubricsGroupedByCourse() {
            const rubrics = getAllRubrics();
            const grouped = {
                'unassigned': []
            };
            
            rubrics.forEach(rubric => {
                if (!rubric.courseId) {
                    grouped['unassigned'].push(rubric);
                } else {
                    if (!grouped[rubric.courseId]) {
                        grouped[rubric.courseId] = [];
                    }
                    grouped[rubric.courseId].push(rubric);
                }
            });
            
            return grouped;
        }

        // Populate course selector in rubric form with checkboxes
        function populateCourseSelector(selectedCourseIds = []) {
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const container = document.getElementById('rubricCoursesContainer');
            
            if (!container) return;
            
            // Clear container
            container.innerHTML = '';
            
            if (classes.length === 0) {
                container.innerHTML = '<p style="color: var(--text-light); text-align: center;">No courses available. Create courses in "My Classes" first.</p>';
                return;
            }
            
            // Group courses by course name for better organization
            const courseGroups = {};
            classes.forEach(cls => {
                if (!courseGroups[cls.name]) {
                    courseGroups[cls.name] = [];
                }
                courseGroups[cls.name].push(cls);
            });
            
            // Create checkboxes grouped by course name
            Object.keys(courseGroups).sort().forEach(courseName => {
                const sections = courseGroups[courseName];
                
                // Add course name header if multiple sections exist
                if (sections.length > 1) {
                    const header = document.createElement('div');
                    header.style.cssText = 'font-weight: 600; color: var(--primary); margin-top: 0.5rem; margin-bottom: 0.25rem; font-size: 0.9rem;';
                    header.textContent = courseName;
                    container.appendChild(header);
                }
                
                // Add checkbox for each section
                sections.forEach(cls => {
                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.style.cssText = 'padding: 0.4rem; display: flex; align-items: center;';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `course_${cls.id}`;
                    checkbox.value = cls.id;
                    checkbox.className = 'course-checkbox';
                    checkbox.style.cssText = 'margin-right: 0.5rem; cursor: pointer;';
                    
                    // Check if this course is in the selected list
                    if (selectedCourseIds.includes(cls.id)) {
                        checkbox.checked = true;
                    }
                    
                    const label = document.createElement('label');
                    label.htmlFor = `course_${cls.id}`;
                    label.style.cssText = 'cursor: pointer; user-select: none;';
                    label.textContent = `${cls.name} - ${cls.semester} ${cls.year} (Section ${cls.section})`;
                    
                    checkboxDiv.appendChild(checkbox);
                    checkboxDiv.appendChild(label);
                    container.appendChild(checkboxDiv);
                });
            });
        }

        // Populate textbook dropdown in rubric form (from Supabase textbooks table)
        async function loadTextbooksForRubricForm() {
            const sel = document.getElementById('rubricTextbook');
            if (!sel) return;
            const currentVal = sel.value;
            sel.innerHTML = '<option value="">None</option>';
            if (!supabaseClient) return;
            try {
                const { data, error } = await supabaseClient.from('textbooks').select('id, name').order('name');
                if (error || !data) return;
                data.forEach(t => {
                    const opt = document.createElement('option');
                    opt.value = t.id;
                    opt.textContent = t.name || 'Unnamed';
                    sel.appendChild(opt);
                });
                if (currentVal) sel.value = currentVal;
            } catch (e) {
                console.warn('Could not load textbooks:', e);
            }
        }

        // Populate course filter dropdown in Rubrics section
        function populateCourseFilter() {
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const filter = document.getElementById('courseFilter');
            
            if (!filter) return;
            
            // Clear existing options except "All Courses"
            filter.innerHTML = '<option value="">All Courses</option>';
            
            // Add "Unassigned" option
            filter.innerHTML += '<option value="unassigned">Unassigned (No Course)</option>';
            
            // Group classes by course name + semester + year
            const courseGroups = {};
            classes.forEach(cls => {
                const courseKey = `${cls.name}|${cls.semester}|${cls.year}`;
                if (!courseGroups[courseKey]) {
                    courseGroups[courseKey] = {
                        name: cls.name,
                        semester: cls.semester,
                        year: cls.year,
                        ids: []
                    };
                }
                courseGroups[courseKey].ids.push(cls.id);
            });
            
            // Add grouped courses to filter
            Object.keys(courseGroups).sort().forEach(courseKey => {
                const group = courseGroups[courseKey];
                const option = document.createElement('option');
                option.value = group.ids.join(','); // Store all section IDs as comma-separated
                option.textContent = `${group.name} - ${group.semester} ${group.year}`;
                filter.appendChild(option);
            });
        }

        // Filter rubrics display based on selected course
        async function filterRubricsByCourse() {
            const filterValue = document.getElementById('courseFilter').value;
            
            // Initialize rubrics storage if needed
            initializeRubrics();
            
            // Get all rubrics (getAllRubrics is async) and classes
            let allRubrics = await getAllRubrics();
            if (!Array.isArray(allRubrics)) allRubrics = [];
            const classes = JSON.parse(getUserItem('classes') || '[]');
            
            // Filter rubrics based on selection
            let filteredRubrics = allRubrics;
            
            if (filterValue === 'unassigned') {
                // Show only rubrics with no courses assigned
                filteredRubrics = allRubrics.filter(r => {
                    const hasOldCourseId = r.courseId && r.courseId !== '';
                    const hasNewCourseIds = r.courseIds && Array.isArray(r.courseIds) && r.courseIds.length > 0;
                    return !hasOldCourseId && !hasNewCourseIds;
                });
            } else if (filterValue !== '') {
                // Filter by course - filterValue contains comma-separated IDs for all sections of a course
                const courseIdsToMatch = filterValue.split(',');
                
                filteredRubrics = allRubrics.filter(rubric => {
                    // Get rubric's course IDs (handle both old and new format)
                    let rubricCourseIds = [];
                    if (rubric.courseIds && Array.isArray(rubric.courseIds)) {
                        rubricCourseIds = rubric.courseIds;
                    } else if (rubric.courseId) {
                        rubricCourseIds = [rubric.courseId];
                    }
                    
                    // Check if rubric is assigned to any of the course sections
                    return rubricCourseIds.some(id => courseIdsToMatch.includes(id));
                });
            }
            
            // Display filtered rubrics
            const list = document.getElementById('rubricsList');
            if (!list) return;
            
            if (filteredRubrics.length === 0) {
                list.innerHTML = '<p style="color: var(--text-light); text-align: center; padding: 2rem;">No rubrics found for this filter.</p>';
                return;
            }
            
            list.innerHTML = filteredRubrics.map(rubric => {
                // Get course info - handle both courseIds array and old courseId
                let courseInfo = '';
                let courseIdsToDisplay = [];
                
                if (rubric.courseIds && Array.isArray(rubric.courseIds) && rubric.courseIds.length > 0) {
                    courseIdsToDisplay = rubric.courseIds;
                } else if (rubric.courseId) {
                    courseIdsToDisplay = [rubric.courseId];
                }
                
                if (courseIdsToDisplay.length > 0) {
                    const courses = courseIdsToDisplay
                        .map(id => classes.find(c => c.id === id))
                        .filter(c => c);
                    
                    if (courses.length > 0) {
                        // Group by course name
                        const courseGroups = {};
                        courses.forEach(course => {
                            if (!courseGroups[course.name]) {
                                courseGroups[course.name] = [];
                            }
                            courseGroups[course.name].push(course);
                        });
                        
                        // Format display
                        const courseDisplays = Object.keys(courseGroups).map(courseName => {
                            const sections = courseGroups[courseName];
                            const firstCourse = sections[0];
                            const sectionNums = sections.map(s => s.section).join(', ');
                            const sectionText = sections.length > 1 ? `Sections ${sectionNums}` : `Section ${sectionNums}`;
                            return `${courseName} (${firstCourse.semester} ${firstCourse.year}) - ${sectionText}`;
                        });
                        
                        courseInfo = ` • <span style="color: var(--primary); font-weight: 500;">${courseDisplays.join(' • ')}</span>`;
                    } else if (courseIdsToDisplay.length > 0) {
                        courseInfo = ' • <span style="color: #999;">Course(s) not found</span>';
                    }
                }
                
                return `
                <div class="rubric-item">
                    <div class="rubric-info">
                        <h4>${rubric.name}</h4>
                        <p>${rubric.description || 'No description'} • ${rubric.totalPoints} points${rubric.speechType ? ' • ' + rubric.speechType : ''}${courseInfo}</p>
                    </div>
                    <div class="rubric-actions">
                        <button class="btn-small btn-view" data-rubric-id="${rubric.id}">View</button>
                        <button class="btn-small btn-edit" data-rubric-id="${rubric.id}">Edit</button>
                        <button class="btn-small btn-duplicate" data-rubric-id="${rubric.id}">Duplicate</button>
                        ${rubric.id !== 'default' ? `
                            <button type="button" class="btn-small btn-danger btn-delete" data-rubric-id="${rubric.id}" aria-label="Delete rubric" title="Delete rubric"><i data-lucide="trash-2" style="width:1.1em;height:1.1em;"></i></button>
                        ` : ''}
                    </div>
                </div>
            `;
            }).join('');
            
            // Re-attach event listeners to all buttons
            document.querySelectorAll('.btn-view').forEach(btn => {
                btn.addEventListener('click', () => viewRubric(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-edit').forEach(btn => {
                btn.addEventListener('click', () => editRubric(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-duplicate').forEach(btn => {
                btn.addEventListener('click', () => duplicateRubricUI(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-delete').forEach(btn => {
                btn.addEventListener('click', () => deleteRubricUI(btn.dataset.rubricId));
            });
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: list });
        }


        function displayResults(results) {
            console.log('=== displayResults called ===');
            console.log('  editingEvaluationId:', editingEvaluationId);
            console.log('  editingEvaluationId type:', typeof editingEvaluationId);
            console.log('  editingEvaluationId value:', String(editingEvaluationId));
            console.log('  results:', results);
            console.log('  results.timeline_markers:', results?.timeline_markers);
            console.log('  results.timeline_markers length:', results?.timeline_markers?.length);
            
            // CRITICAL: If results and evaluationResults are the same object, don't overwrite
            // Otherwise, sync markers from results to evaluationResults
            if (results && evaluationResults && results !== evaluationResults) {
                if (results.timeline_markers && Array.isArray(results.timeline_markers)) {
                    evaluationResults.timeline_markers = results.timeline_markers;
                    console.log('Synced evaluationResults.timeline_markers from results:', evaluationResults.timeline_markers.length, 'markers');
                } else if (!evaluationResults.timeline_markers) {
                    evaluationResults.timeline_markers = [];
                }
            } else if (results === evaluationResults) {
                console.log('results and evaluationResults are the same object - markers should be preserved');
            }
            
            // Define isEditing at the top of the function for use in all template strings
            const isEditing = editingEvaluationId !== null && editingEvaluationId !== undefined && editingEvaluationId !== '';
            
            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/2d493fae-3749-4b25-960d-04d6e5f42b38',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:21042',message:'displayResults isEditing check',data:{isEditing,editingEvaluationId,editingEvaluationIdType:typeof editingEvaluationId},timestamp:Date.now(),runId:'run8',hypothesisId:'K'})}).catch(()=>{});
            // #endregion
            console.log('  isEditing:', isEditing);
            console.log('  isEditing will be used in template strings to show/hide edit buttons');
            
            if (!isEditing) {
                console.warn('⚠️ isEditing is FALSE - edit buttons will NOT appear!');
                console.warn('  Make sure editingEvaluationId is set before calling displayResults');
            }
            let html = '';
            // Ensure timeline_markers exists and is an array
            if (!results.timeline_markers) {
                results.timeline_markers = [];
            }
            if (results.timeline_markers && results.timeline_markers.length > 0) {
                normalizeMarkerBehaviors(results.timeline_markers);
                ensureMarkerIds(results.timeline_markers);
                console.log('Normalized markers:', results.timeline_markers.length);
            } else {
                console.log('No timeline markers to normalize');
            }

            // Show editing mode banner if editing
            // Show move button if editing a saved evaluation
            const moveBtn = document.getElementById('moveEvalBtn');
            if (moveBtn) {
                moveBtn.style.display = editingEvaluationId ? 'inline-flex' : 'none';
            }
            
            // Add editing mode banner following Apple HIG guidelines
            if (isEditing) {
                html += `
                <div id="editingModeBanner" style="background: rgba(0, 122, 255, 0.1); border: 1px solid rgba(0, 122, 255, 0.3); border-radius: 12px; padding: 12px 16px; margin-bottom: 1.5rem; display: flex; align-items: center; justify-content: space-between; gap: 12px; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', sans-serif;">
                    <div style="display: flex; align-items: center; gap: 10px; flex: 1; min-width: 0;">
                        <i data-lucide="edit-2" style="width: 18px; height: 18px; color: #007AFF; flex-shrink: 0;"></i>
                        <span style="font-size: 15px; font-weight: 500; color: #1d1d1f; line-height: 1.4;">You are editing this evaluation. Make your changes and save when finished.</span>
                    </div>
                    <button onclick="document.getElementById('editingModeBanner')?.remove()" style="background: transparent; border: none; padding: 0; width: 44px; height: 44px; min-width: 44px; min-height: 44px; display: flex; align-items: center; justify-content: center; cursor: pointer; border-radius: 8px; transition: background-color 0.2s; flex-shrink: 0;" onmouseover="this.style.backgroundColor='rgba(0,0,0,0.1)'" onmouseout="this.style.backgroundColor='transparent'" aria-label="Dismiss banner" title="Dismiss">
                        <i data-lucide="x" style="width: 18px; height: 18px; color: #1d1d1f;"></i>
                    </button>
                </div>
                `;
            }
            
            // Check for video/audio URL (from editingEvaluationVideoUrl or results object)
            // Also check if uploadedFile exists (for newly evaluated files)
            let videoUrl = editingEvaluationVideoUrl || results.video_url || null;
            let audioUrl = results.audio_url || null;
            let localMediaUrl = null;
            
            // If no URL but uploadedFile exists, create object URL for display
            if (!videoUrl && !audioUrl && typeof uploadedFile !== 'undefined' && uploadedFile) {
                localMediaUrl = URL.createObjectURL(uploadedFile);
                if (uploadedFile.type && uploadedFile.type.startsWith('video/')) {
                    videoUrl = localMediaUrl;
                } else if (uploadedFile.type && uploadedFile.type.startsWith('audio/')) {
                    audioUrl = localMediaUrl;
                }
            }
            
            const mediaUrl = videoUrl || audioUrl;
            const hasVideo = !!videoUrl;
            
            // Build list of sections for navigation menu
            const sectionNames = Object.keys(results.sections || {});
            const hasMedia = !!mediaUrl;
            const hasMarkers = results.timeline_markers && results.timeline_markers.length > 0;
            const hasTranscript = results.transcript && results.transcript.trim().length > 0;
            
            // Determine if we should use split-screen layout (only for video, not audio)
            const useSplitScreen = hasVideo;
            
            // Add sticky navigation menu for quick section jumping (only if not using split-screen)
            if (!useSplitScreen && (sectionNames.length > 0 || hasMedia || hasMarkers || hasTranscript)) {
                html += `
                <nav id="evalNavigationMenu" style="position: sticky; top: 0; background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(20px); border: 1px solid #e5e5e7; border-radius: 12px; padding: 12px 16px; margin-bottom: 24px; z-index: 100; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08); font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', sans-serif;" role="navigation" aria-label="Evaluation sections navigation">
                    <div style="display: flex; flex-wrap: wrap; gap: 8px; align-items: center;">
                        <span style="font-size: 13px; font-weight: 600; color: #6e6e73; text-transform: uppercase; letter-spacing: 0.5px; margin-right: 4px;">Jump to:</span>
                        ${hasMedia ? `<a href="#eval-media-section" onclick="document.getElementById('eval-media-section')?.scrollIntoView({behavior: 'smooth', block: 'start'}); return false;" style="display: inline-flex; align-items: center; gap: 6px; padding: 8px 12px; background: #f5f5f7; color: #007AFF; border-radius: 8px; font-size: 14px; font-weight: 500; text-decoration: none; transition: all 0.2s ease; min-height: 32px;" onmouseover="this.style.background='rgba(0, 122, 255, 0.1)'" onmouseout="this.style.background='#f5f5f7'"><i data-lucide="${videoUrl ? 'video' : 'headphones'}" style="width:14px;height:14px;"></i> ${videoUrl ? 'Video' : 'Audio'}</a>` : ''}
                        ${hasMarkers ? `<a href="#eval-timeline-section" onclick="document.getElementById('eval-timeline-section')?.scrollIntoView({behavior: 'smooth', block: 'start'}); return false;" style="display: inline-flex; align-items: center; gap: 6px; padding: 8px 12px; background: #f5f5f7; color: #007AFF; border-radius: 8px; font-size: 14px; font-weight: 500; text-decoration: none; transition: all 0.2s ease; min-height: 32px;" onmouseover="this.style.background='rgba(0, 122, 255, 0.1)'" onmouseout="this.style.background='#f5f5f7'"><i data-lucide="clock" style="width:14px;height:14px;"></i> Timeline</a>` : ''}
                        <a href="#eval-score-section" onclick="document.getElementById('eval-score-section')?.scrollIntoView({behavior: 'smooth', block: 'start'}); return false;" style="display: inline-flex; align-items: center; gap: 6px; padding: 8px 12px; background: #f5f5f7; color: #007AFF; border-radius: 8px; font-size: 14px; font-weight: 500; text-decoration: none; transition: all 0.2s ease; min-height: 32px;" onmouseover="this.style.background='rgba(0, 122, 255, 0.1)'" onmouseout="this.style.background='#f5f5f7'"><i data-lucide="award" style="width:14px;height:14px;"></i> Score</a>
                        <a href="#eval-categories-section" onclick="document.getElementById('eval-categories-section')?.scrollIntoView({behavior: 'smooth', block: 'start'}); return false;" style="display: inline-flex; align-items: center; gap: 6px; padding: 8px 12px; background: #f5f5f7; color: #007AFF; border-radius: 8px; font-size: 14px; font-weight: 500; text-decoration: none; transition: all 0.2s ease; min-height: 32px;" onmouseover="this.style.background='rgba(0, 122, 255, 0.1)'" onmouseout="this.style.background='#f5f5f7'"><i data-lucide="list" style="width:14px;height:14px;"></i> Categories</a>
                        <a href="#eval-comments-section" onclick="document.getElementById('eval-comments-section')?.scrollIntoView({behavior: 'smooth', block: 'start'}); return false;" style="display: inline-flex; align-items: center; gap: 6px; padding: 8px 12px; background: #f5f5f7; color: #007AFF; border-radius: 8px; font-size: 14px; font-weight: 500; text-decoration: none; transition: all 0.2s ease; min-height: 32px;" onmouseover="this.style.background='rgba(0, 122, 255, 0.1)'" onmouseout="this.style.background='#f5f5f7'"><i data-lucide="message-square" style="width:14px;height:14px;"></i> Comments</a>
                        ${hasTranscript ? `<a href="#eval-transcript-section" onclick="document.getElementById('eval-transcript-section')?.scrollIntoView({behavior: 'smooth', block: 'start'}); return false;" style="display: inline-flex; align-items: center; gap: 6px; padding: 8px 12px; background: #f5f5f7; color: #007AFF; border-radius: 8px; font-size: 14px; font-weight: 500; text-decoration: none; transition: all 0.2s ease; min-height: 32px;" onmouseover="this.style.background='rgba(0, 122, 255, 0.1)'" onmouseout="this.style.background='#f5f5f7'"><i data-lucide="file-text" style="width:14px;height:14px;"></i> Transcript</a>` : ''}
                    </div>
                </nav>
                `;
            }
            
            // Get course name if available
            let courseName = results.courseName || '';
            let studentName = results.studentName || '';
            
            // If course name or student name is missing, try to retrieve from selected class/student
            if ((!courseName || !studentName) && (results.selectedClassId || results.selectedStudentId)) {
                try {
                    const classes = JSON.parse(getUserItem('classes') || '[]');
                    
                    // Get course name if missing
                    if (!courseName && results.selectedClassId) {
                        const classData = classes.find(c => c.id === results.selectedClassId || c.name === results.selectedClassId);
                        if (classData) {
                            courseName = classData.name + (classData.semester ? ' - ' + classData.semester + ' ' + classData.year : '');
                        }
                    }
                    
                    // Get student name if missing
                    if (!studentName && results.selectedClassId && results.selectedStudentId) {
                        const classData = classes.find(c => c.id === results.selectedClassId || c.name === results.selectedClassId);
                        if (classData && classData.roster) {
                            const student = classData.roster.find(s => 
                                (s.id === results.selectedStudentId || s.studentId === results.selectedStudentId) ||
                                (s.supabaseId === results.selectedStudentId) ||
                                (Array.isArray(classData.roster) && classData.roster[parseInt(results.selectedStudentId)])
                            );
                            if (student) {
                                studentName = `${student.firstName || ''} ${student.lastName || ''}`.trim();
                            }
                        }
                    }
                } catch (e) {
                    console.warn('Could not get course/student name:', e);
                }
            }
            
            // Also check current form selections if still missing (for newly evaluated speeches)
            if (!studentName || !courseName) {
                try {
                    const evalClassSelect = document.getElementById('evalClassSelect');
                    const evalStudentSelect = document.getElementById('evalStudentSelect');
                    
                    if (evalClassSelect && evalClassSelect.value && evalClassSelect.value !== '' && evalClassSelect.value !== 'other') {
                        const classes = JSON.parse(getUserItem('classes') || '[]');
                        const classData = classes.find(c => c.id === evalClassSelect.value || c.name === evalClassSelect.value);
                        
                        if (classData) {
                            // Get course name if missing
                            if (!courseName) {
                                courseName = classData.name + (classData.semester ? ' - ' + classData.semester + ' ' + classData.year : '');
                            }
                            
                            // Get student name if missing
                            if (!studentName && evalStudentSelect && evalStudentSelect.value && evalStudentSelect.value !== '' && evalStudentSelect.value !== 'none') {
                                if (classData.roster) {
                                    const student = classData.roster.find(s => 
                                        (s.id === evalStudentSelect.value || s.studentId === evalStudentSelect.value) ||
                                        (s.supabaseId === evalStudentSelect.value) ||
                                        (Array.isArray(classData.roster) && classData.roster[parseInt(evalStudentSelect.value)])
                                    );
                                    if (student) {
                                        studentName = `${student.firstName || ''} ${student.lastName || ''}`.trim();
                                    }
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.warn('Could not get course/student name from form:', e);
                }
            }
            
            // Get rubric name if available
            let rubricName = results.rubricUsed || '';
            
            // Calculate overall score for summary
            const totalScore = results.totalScore || 0;
            const maxScore = results.maxScore || 50;
            const percentage = maxScore > 0 ? ((totalScore / maxScore) * 100).toFixed(0) : 0;
            const letterGrade = results.letterGrade || 'N/A';
            let scoreColor = 'var(--success)';
            if (percentage < 70) scoreColor = 'var(--error)';
            else if (percentage < 80) scoreColor = 'var(--warning)';
            
            // Build summary card
            const summaryCardHtml = `
                <div id="eval-summary-card" style="background: linear-gradient(135deg, rgba(30, 58, 95, 0.05) 0%, rgba(30, 58, 95, 0.02) 100%); border: 1px solid var(--border); border-radius: 16px; padding: 20px; margin-bottom: 24px; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', sans-serif;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 16px;">
                        ${courseName ? `<div><div style="font-size: 13px; font-weight: 600; color: var(--text-light); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">Course</div><div style="font-size: 15px; color: var(--text); font-weight: 500;">${escapeHtml(courseName)}</div></div>` : ''}
                        ${studentName ? `<div><div style="font-size: 13px; font-weight: 600; color: var(--text-light); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">Student</div><div style="font-size: 15px; color: var(--text); font-weight: 500;">${escapeHtml(studentName)}</div></div>` : ''}
                        ${rubricName ? `<div><div style="font-size: 13px; font-weight: 600; color: var(--text-light); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">Rubric</div><div style="font-size: 15px; color: var(--text); font-weight: 500;">${escapeHtml(rubricName)}</div></div>` : ''}
                        <div><div style="font-size: 13px; font-weight: 600; color: var(--text-light); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">Date</div><div style="font-size: 15px; color: var(--text); font-weight: 500;">${escapeHtml(results.speechDate || 'Not set')}</div></div>
                        ${results.assignmentType ? `<div><div style="font-size: 13px; font-weight: 600; color: var(--text-light); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">Assignment</div><div style="font-size: 15px; color: var(--text); font-weight: 500;">${escapeHtml(results.assignmentType)}</div></div>` : ''}
                    </div>
                    <div style="display: flex; align-items: center; gap: 24px; padding-top: 16px; border-top: 1px solid var(--border);">
                        <div style="flex: 1;">
                            <div style="font-size: 13px; font-weight: 600; color: var(--text-light); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">Score</div>
                            <div style="display: flex; align-items: baseline; gap: 8px;">
                                <span style="font-size: 32px; font-weight: 700; color: ${scoreColor}; line-height: 1;">${totalScore}</span>
                                <span style="font-size: 20px; font-weight: 500; color: var(--text-light);">/ ${maxScore}</span>
                                <span style="font-size: 18px; font-weight: 600; color: ${scoreColor}; margin-left: 8px;">(${percentage}%)</span>
                                <span style="font-size: 16px; font-weight: 600; color: ${scoreColor}; margin-left: 4px;">${letterGrade}</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Build metadata section (simplified, since summary card has main info)
            const metadataHtml = `
                <div style="background: #f5f5f7; padding: 16px; border-radius: 12px; margin-bottom: 24px; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', sans-serif; display: none;">
                    <div style="display: grid; gap: 12px;">
                        ${results.speechTime ? `<div style="display: flex; gap: 8px;"><span style="font-size: 15px; font-weight: 600; color: #1d1d1f; min-width: 80px;">Speech Time:</span><span style="font-size: 15px; color: #1d1d1f; line-height: 1.47;">${escapeHtml(results.speechTime)}</span></div>` : ''}
                    </div>
                </div>
            `;
            
            // Build video section HTML separately (for split-screen layout)
            let videoSectionHtml = '';
            
            // Add video/audio player if media URL exists
            if (mediaUrl) {
                const videoSectionContent = `
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; gap: 12px; flex-wrap: wrap;">
                            <h3 style="margin: 0; font-size: 17px; font-weight: 600; color: #1d1d1f; display: flex; align-items: center; gap: 8px;"><i data-lucide="${videoUrl ? 'video' : 'headphones'}" style="width: 20px; height: 20px; color: #007AFF;"></i> ${videoUrl ? 'Video Recording' : 'Audio Recording'}</h3>
                            ${editingEvaluationId ? '' : '<button onclick="reEvaluateFromUrl(\'' + escapeHtml(mediaUrl) + '\', ' + (videoUrl ? 'true' : 'false') + ')" style="background: transparent; color: #007AFF; border: 1px solid #007AFF; padding: 8px 16px; border-radius: 10px; cursor: pointer; font-weight: 500; font-size: 15px; min-width: 44px; min-height: 44px; display: inline-flex; align-items: center; gap: 6px; transition: all 0.2s ease; font-family: -apple-system, BlinkMacSystemFont, \'SF Pro Text\', sans-serif;" onmouseover="this.style.backgroundColor=\'rgba(0, 122, 255, 0.1)\'" onmouseout="this.style.backgroundColor=\'transparent\'"><i data-lucide="refresh-cw" style="width:16px;height:16px;"></i> Re-evaluate</button>'}
                        </div>
                        <div style="position: relative;">
                            ${videoUrl ? `
                        <div style="position: relative; width: 100%; ${useSplitScreen ? '' : 'max-width: 800px;'} border-radius: 10px; overflow: hidden; background: #000;">
                                <video id="evaluationVideoPlayer" controls style="width: 100%; border-radius: 10px; background: #000; ${isEditing ? 'cursor: crosshair;' : ''}">
                                <source src="${escapeHtml(videoUrl)}" type="video/mp4">
                                <source src="${escapeHtml(videoUrl)}" type="video/webm">
                                <source src="${escapeHtml(videoUrl)}" type="video/quicktime">
                                Your browser does not support the video tag.
                            </video>
                                <div id="videoLoadingIndicator" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: none; flex-direction: column; align-items: center; gap: 12px; z-index: 5; pointer-events: none;">
                                    <div style="width: 40px; height: 40px; border: 3px solid rgba(255,255,255,0.3); border-top-color: #ffffff; border-radius: 50%; animation: videoSpin 1s linear infinite;"></div>
                                    <span style="color: white; font-size: 15px; font-weight: 500; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;">Loading video...</span>
                                </div>
                                <div id="videoErrorIndicator" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: none; flex-direction: column; align-items: center; gap: 12px; z-index: 5; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px; max-width: 90%;">
                                    <i data-lucide="alert-circle" style="width: 32px; height: 32px; color: #FF3B30;"></i>
                                    <span style="color: white; font-size: 15px; font-weight: 500; text-align: center; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;">Unable to load video. Please check your connection.</span>
                                </div>
                            ${isEditing ? `
                                <div style="position: absolute; top: 12px; right: 12px; background: rgba(255,255,255,0.95); backdrop-filter: blur(20px); color: #1d1d1f; padding: 8px 12px; border-radius: 8px; font-size: 13px; font-weight: 500; pointer-events: none; box-shadow: 0 4px 12px rgba(0,0,0,0.15); border: 0.5px solid rgba(0,0,0,0.1); z-index: 10; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;">
                                    <i data-lucide="mouse-pointer-click" style="width:14px;height:14px;display:inline-block;vertical-align:middle;margin-right:6px;color:#007AFF;"></i> Double-click video to add marker
                            </div>
                            ` : ''}
                            </div>
                            ` : `
                            <audio id="evaluationAudioPlayer" controls style="width: 100%; max-width: 600px;">
                                <source src="${escapeHtml(audioUrl)}" type="audio/mpeg">
                                <source src="${escapeHtml(audioUrl)}" type="audio/mp3">
                                <source src="${escapeHtml(audioUrl)}" type="audio/wav">
                                Your browser does not support the audio tag.
                            </audio>
                            `}
                        </div>
                        <p style="font-size: 13px; color: #6e6e73; margin-top: 12px; line-height: 1.38; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;">
                            ${videoUrl ? (isEditing ? 'Double-click anywhere on the video to add a marker at that time, or use "Add at Current Time" to mark the current playback position.' : 'Click timeline markers to jump to specific moments.') : 'Listen to the recorded speech audio.'}
                        </p>
                `;
                
                // Build video section with appropriate styling based on layout
                if (useSplitScreen) {
                    // Split-screen: video on left, sticky
                    videoSectionHtml = `
                        <div id="eval-video-sidebar" style="position: sticky; top: 20px; align-self: flex-start; width: 100%; max-width: 480px; flex-shrink: 0; margin-right: 24px;">
                            <div id="eval-media-section" style="background: #ffffff; padding: 16px; border-radius: 12px; border: 1px solid #e5e5e7; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', sans-serif;">
                                ${videoSectionContent}
                            </div>
                        </div>
                    `;
                } else {
                    // Vertical layout: video in normal flow
                    videoSectionHtml = `
                        <div id="eval-media-section" style="background: #ffffff; padding: 16px; border-radius: 12px; margin-bottom: 24px; border: 1px solid #e5e5e7; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', sans-serif; scroll-margin-top: 80px;">
                            ${videoSectionContent}
                    </div>
                `;
                }
            }
            
            // Add timeline markers section right after video (at the top)
                // Always show markers section when editing, even if empty
                // CRITICAL: Ensure timeline_markers exists and is an array
                // Use the markers from the results object that was passed in
                let markersToRender = results.timeline_markers;
                
                // If results and evaluationResults are the same object, use evaluationResults.timeline_markers directly
                if (results === evaluationResults && evaluationResults.timeline_markers) {
                    markersToRender = evaluationResults.timeline_markers;
                    console.log('Using evaluationResults.timeline_markers directly (same object)');
                }
                
                if (!markersToRender) {
                    markersToRender = [];
                    results.timeline_markers = [];
                }
                if (!Array.isArray(markersToRender)) {
                    console.warn('timeline_markers is not an array, converting:', markersToRender);
                    markersToRender = [];
                    results.timeline_markers = [];
                }
                
                // Ensure results.timeline_markers points to the same array we're using
                results.timeline_markers = markersToRender;
                
                const shouldShowMarkersSection = isEditing || (markersToRender && markersToRender.length > 0);
                console.log('=== TIMELINE MARKERS CHECK ===');
                console.log('Checking timeline markers:', { 
                    hasMarkers: !!(markersToRender), 
                    markersLength: markersToRender ? markersToRender.length : 0,
                    isArray: Array.isArray(markersToRender),
                    isEditing: isEditing,
                    shouldShowMarkersSection: shouldShowMarkersSection,
                    editingEvaluationId: editingEvaluationId,
                    resultsIsEvaluationResults: results === evaluationResults
                });
                // Debug: log each marker
                if (markersToRender && Array.isArray(markersToRender) && markersToRender.length > 0) {
                    console.log('Markers found:');
                    markersToRender.forEach((m, idx) => {
                        console.log(`  Marker ${idx}:`, { id: m.id, timestamp: m.timestamp, issue: m.issue, category: m.category, behavior: m.behavior });
                    });
                } else {
                    console.log('No markers in array or array is empty');
                }
                
                if (shouldShowMarkersSection) {
                    let timelineMarkersHTML = '';
                    
                    if (markersToRender.length > 0) {
                        console.log('Rendering', markersToRender.length, 'markers in timeline section');
                        console.log('Rendering timeline markers section with', markersToRender.length, 'markers');
                        const markersByCategory = {};
                        markersToRender.forEach(marker => {
                        if (!markersByCategory[marker.category]) markersByCategory[marker.category] = [];
                        markersByCategory[marker.category].push(marker);
                    });
                    
                    const severityColors = { 'positive': '#10b981', 'minor': '#f59e0b', 'moderate': '#f59e0b', 'major': '#ef4444' };
                    const severityIcons = { 'positive': '✓', 'minor': '⚠', 'moderate': '⚠', 'major': '✕' };
                
                    timelineMarkersHTML = '<div id="timeline-markers-content" style="max-height: 400px; overflow-y: auto;">';
                    
                    Object.keys(markersByCategory).forEach(category => {
                        const categoryMarkers = markersByCategory[category];
                        const byRecurrence = {};
                        categoryMarkers.forEach(m => {
                            var key = markerRecurrenceKey(m);
                            if (!byRecurrence[key]) byRecurrence[key] = [];
                            byRecurrence[key].push(m);
                        });
                        
                        timelineMarkersHTML += `<div style="margin-bottom: 20px;"><h4 style="margin: 0 0 12px 0; color: #1d1d1f; font-size: 13px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;">${escapeHtml(category)}</h4><div style="display: grid; gap: 12px;">`;
                        
                        Object.keys(byRecurrence).forEach(recurrenceKey => {
                            const group = byRecurrence[recurrenceKey];
                            const first = group[0];
                            const countLabel = group.length > 1 ? ' <span style="color: var(--text-light); font-weight: normal; font-size: 0.9rem;">(' + group.length + ' times)</span>' : '';
                            
                            group.forEach((marker, idx) => {
                                const color = severityColors[marker.severity] || '#f59e0b';
                                const icon = severityIcons[marker.severity] || '⚠';
                                const showCount = idx === 0 && group.length > 1;
                                // Parse timestamp to seconds for jump functionality
                                const timestampSeconds = parseTimestampToSeconds(marker.timestamp || '0:00');
                            const videoUrl = mediaUrl && (mediaUrl.includes('.mp4') || mediaUrl.includes('.webm') || mediaUrl.includes('.mov') || mediaUrl.includes('video'));
                                const onClickAttr = videoUrl ? `onclick="jumpToTimestamp(${timestampSeconds})"` : '';
                            const markerId = `marker-${marker.id || idx}-${recurrenceKey}`;
                            // Use the marker's actual ID - this is critical for deletion to work
                            const uniqueMarkerId = marker.id || `temp-${Date.now()}-${idx}-${Math.random().toString(36).substr(2, 9)}`;
                            console.log('Rendering marker with ID:', marker.id, 'uniqueMarkerId:', uniqueMarkerId);
                                timelineMarkersHTML += `
                            <div style="background: #ffffff; border: 1px solid #e5e5e7; border-radius: 12px; padding: 16px; display: flex; gap: 12px; align-items: start; transition: all 0.2s ease; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', sans-serif;" data-marker-id="${uniqueMarkerId}" data-marker-index="${idx}" data-marker-category="${escapeHtml(category)}" onmouseover="this.style.borderColor='#007AFF'; this.style.boxShadow='0 2px 8px rgba(0, 122, 255, 0.1)'" onmouseout="this.style.borderColor='#e5e5e7'; this.style.boxShadow='none'">
                                ${isEditing ? `
                                <div style="display: flex; flex-direction: column; align-items: center; gap: 8px; flex-shrink: 0;">
                                    <input type="text" id="marker-timestamp-${markerId}" value="${escapeHtml(marker.timestamp || '')}" style="background: ${color}; color: white; width: 64px; height: 64px; border-radius: 10px; border: none; text-align: center; padding: 0; font-size: 15px; font-weight: 600; cursor: text; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif; letter-spacing: -0.24px;" placeholder="0:00">
                                    ${videoUrl ? `
                                    <button onclick="jumpToTimestamp(${timestampSeconds})" style="background: transparent; color: #6e6e73; border: none; padding: 8px; cursor: pointer; min-width: 44px; min-height: 44px; display: flex; align-items: center; justify-content: center; border-radius: 8px; transition: all 0.2s;" onmouseover="this.style.background='#f5f5f7'; this.style.color='#007AFF'" onmouseout="this.style.background='transparent'; this.style.color='#6e6e73'" title="Jump to time" aria-label="Jump to time">
                                        <i data-lucide="play" style="width:18px;height:18px;"></i>
                                    </button>
                                    ` : ''}
                                </div>
                                ` : `
                                <div style="display: flex; flex-direction: column; align-items: center; gap: 8px; flex-shrink: 0;">
                                    <div style="background: ${color}; color: white; width: 64px; height: 64px; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 15px; font-weight: 600; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif; letter-spacing: -0.24px;">${escapeHtml(marker.timestamp || '')}</div>
                                    ${videoUrl ? `
                                    <button onclick="jumpToTimestamp(${timestampSeconds})" style="background: transparent; color: #6e6e73; border: none; padding: 8px; cursor: pointer; min-width: 44px; min-height: 44px; display: flex; align-items: center; justify-content: center; border-radius: 8px; transition: all 0.2s;" onmouseover="this.style.background='#f5f5f7'; this.style.color='#007AFF'" onmouseout="this.style.background='transparent'; this.style.color='#6e6e73'" title="Jump to time" aria-label="Jump to time">
                                        <i data-lucide="play" style="width:18px;height:18px;"></i>
                                    </button>
                                    ` : ''}
                                </div>
                                `}
                                <div style="flex: 1; min-width: 0;">
                                    <div style="display: flex; align-items: flex-start; gap: 12px; margin-bottom: 12px;">
                                        <span style="font-size: 20px; flex-shrink: 0; margin-top: 2px;">${icon}</span>
                                        <div style="flex: 1; min-width: 0;">
                                            ${isEditing ? `
                                            <input type="text" id="marker-issue-${markerId}" value="${escapeHtml(marker.issue || '')}" style="width: 100%; padding: 12px; border: 1px solid #d2d2d7; border-radius: 10px; font-size: 17px; font-weight: 500; color: #1d1d1f; background: #ffffff; transition: all 0.2s; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif; letter-spacing: -0.34px; box-sizing: border-box; min-height: 44px;" placeholder="Issue description" onfocus="this.style.borderColor='#007AFF'; this.style.outline='none'; this.style.boxShadow='0 0 0 4px rgba(0, 122, 255, 0.1)'" onblur="this.style.borderColor='#d2d2d7'; this.style.boxShadow='none'">
                                            ` : `
                                            <strong style="color: #1d1d1f; font-size: 17px; font-weight: 600; display: block; line-height: 1.47; letter-spacing: -0.34px;">${escapeHtml(marker.issue || '')}</strong>${showCount ? countLabel : ''}
                                            `}
                                            ${marker.behavior ? '<span style="display: inline-block; background: rgba(0, 122, 255, 0.1); color: #007AFF; font-size: 13px; padding: 4px 12px; border-radius: 12px; font-weight: 500; margin-top: 8px; letter-spacing: -0.08px;">' + escapeHtml(marker.behavior) + '</span>' : ''}
                                        </div>
                                        ${isEditing ? `
                                        <button onclick="if(typeof window.deleteTimelineMarker === 'function') { window.deleteTimelineMarker('${uniqueMarkerId}'); } else { console.error('deleteTimelineMarker not available'); alert('Delete marker function not available. Please refresh the page.'); }" style="background: transparent; color: #6e6e73; border: none; padding: 10px; border-radius: 8px; cursor: pointer; min-width: 44px; min-height: 44px; display: inline-flex; align-items: center; justify-content: center; transition: all 0.2s ease; flex-shrink: 0;" onmouseover="this.style.background='rgba(255, 59, 48, 0.1)'; this.style.color='#FF3B30'" onmouseout="this.style.background='transparent'; this.style.color='#6e6e73'" title="Delete marker" aria-label="Delete marker">
                                            <i data-lucide="trash-2" style="width:18px;height:18px;"></i>
                                        </button>
                                        ` : ''}
                                    </div>
                                    ${isEditing ? `
                                    <textarea id="marker-note-${markerId}" style="width: 100%; min-height: 88px; padding: 12px; border: 1px solid #d2d2d7; border-radius: 10px; font-size: 17px; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif; resize: vertical; background: #ffffff; transition: all 0.2s; line-height: 1.47; color: #1d1d1f; box-sizing: border-box; letter-spacing: -0.34px;" placeholder="Add a note..." onfocus="this.style.borderColor='#007AFF'; this.style.outline='none'; this.style.boxShadow='0 0 0 4px rgba(0, 122, 255, 0.1)'" onblur="this.style.borderColor='#d2d2d7'; this.style.boxShadow='none'">${escapeHtml(marker.note || '')}</textarea>
                                    ` : `
                                    <p style="margin: 0; color: #6e6e73; font-size: 15px; line-height: 1.47;">${escapeHtml(marker.note || '')}</p>
                                    `}
                                </div>
                            </div>`;
                            });
                        });
                        
                        timelineMarkersHTML += `</div></div>`;
                    });
                    
                    timelineMarkersHTML += '</div>';
                    } else {
                        // No markers yet, but show empty section in editing mode
                        timelineMarkersHTML = '<div id="timeline-markers-content" style="max-height: 400px; overflow-y: auto;"><div class="empty-state" style="text-align: center; padding: 32px; color: #6e6e73; font-family: -apple-system, BlinkMacSystemFont, \'SF Pro Text\', sans-serif;"><p style="font-size: 15px; line-height: 1.47; margin: 0;">No timeline markers yet. Add markers to note specific moments in the video.</p></div></div>';
                    }
                
                html += `
                    <div id="eval-timeline-section" style="margin-bottom: 24px; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', sans-serif; scroll-margin-top: 80px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; gap: 12px; flex-wrap: wrap;">
                            <h3 style="margin: 0; font-size: 17px; font-weight: 600; color: #1d1d1f; display: flex; align-items: center; gap: 8px;">
                                <i data-lucide="clock" style="width: 20px; height: 20px; color: #007AFF;"></i> Timeline Markers
                                ${markersToRender && markersToRender.length > 0 ? `<span style="font-weight: 400; color: #6e6e73; font-size: 15px; margin-left: 4px;">(${markersToRender.length})</span>` : ''}
                            </h3>
                            ${isEditing && videoUrl ? `
                            <button onclick="if(typeof window.addTimelineMarkerFromVideo === 'function') { window.addTimelineMarkerFromVideo(); } else { console.error('addTimelineMarkerFromVideo not available'); alert('Add marker function not available. Please refresh the page.'); }" style="background: transparent; color: #007AFF; border: 1px solid #007AFF; padding: 8px 16px; border-radius: 10px; cursor: pointer; font-weight: 500; font-size: 15px; min-width: 44px; min-height: 44px; display: inline-flex; align-items: center; gap: 6px; transition: all 0.2s ease;" onmouseover="this.style.backgroundColor='rgba(0, 122, 255, 0.1)'" onmouseout="this.style.backgroundColor='transparent'">
                                <i data-lucide="plus" style="width:16px;height:16px;"></i> Add at Current Time
                            </button>
                            ` : ''}
                        </div>
                        <div style="display: grid; gap: 12px;">
                            ${timelineMarkersHTML}
                        </div>
                        ${isEditing ? `
                        <button onclick="if(typeof window.addTimelineMarkerWithSelector === 'function') { window.addTimelineMarkerWithSelector(); } else if(typeof window.addTimelineMarker === 'function') { window.addTimelineMarker(); } else { console.error('addTimelineMarker not available'); alert('Add marker function not available. Please refresh the page.'); }" style="background: transparent; color: #1d1d1f; border: 1px dashed #d2d2d7; padding: 12px 16px; border-radius: 10px; cursor: pointer; font-weight: 500; font-size: 15px; min-width: 44px; min-height: 44px; display: flex; align-items: center; justify-content: center; gap: 6px; transition: all 0.2s ease; margin-top: 12px; width: 100%; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;" onmouseover="this.style.borderColor='#007AFF'; this.style.color='#007AFF'; this.style.backgroundColor='rgba(0, 122, 255, 0.05)'" onmouseout="this.style.borderColor='#d2d2d7'; this.style.color='#1d1d1f'; this.style.backgroundColor='transparent'">
                            <i data-lucide="plus" style="width:16px;height:16px;"></i> Add Marker
                        </button>
                        ` : ''}
                    </div>
                `;
                console.log('✓ Timeline markers section HTML added. Total HTML length so far:', html.length);
                console.log('Markers section contains', markersToRender.length, 'markers');
            } else {
                console.warn('⚠️ NOT adding timeline markers section - shouldShowMarkersSection =', shouldShowMarkersSection);
            }
            
            html += `
                <div id="eval-score-section" style="background: linear-gradient(135deg, #007AFF 0%, #0051D5 100%); color: white; padding: 24px; border-radius: 12px; text-align: center; margin-bottom: 24px; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', sans-serif; box-shadow: 0 4px 12px rgba(0, 122, 255, 0.2); scroll-margin-top: 80px;">
                    <h2 style="color: white; margin: 0 0 12px 0; font-size: 15px; font-weight: 600; letter-spacing: -0.24px;">Final Score</h2>
                    <div style="font-size: 48px; font-weight: 700; line-height: 1; margin-bottom: 8px; letter-spacing: -0.96px;">${escapeHtml(String(results.totalScore || 0))} / ${escapeHtml(String(results.maxScore || 0))}</div>
                    <div style="font-size: 20px; font-weight: 500; opacity: 0.9; letter-spacing: -0.4px;">${results.maxScore > 0 ? escapeHtml(((results.totalScore / results.maxScore) * 100).toFixed(1)) : '0'}%</div>
                </div>
                
                <div id="eval-categories-section" style="scroll-margin-top: 80px;">
                    <h3 style="margin-bottom: 16px; font-size: 20px; font-weight: 600; color: #1d1d1f; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif; letter-spacing: -0.4px;">Detailed Scores by Category</h3>
                    <div style="display: grid; gap: 16px; margin-bottom: 24px;">
            `;
            
            for (const [section, data] of Object.entries(results.sections)) {
                const sectionId = section.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                console.log('Rendering section:', section, 'isEditing:', isEditing, 'editingEvaluationId:', editingEvaluationId);
                
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/2d493fae-3749-4b25-960d-04d6e5f42b38',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:21233',message:'Rendering section in template',data:{section,isEditing,editingEvaluationId,willIncludeButton:isEditing},timestamp:Date.now(),runId:'run1',hypothesisId:'A'})}).catch(()=>{});
                // #endregion
                
                // No individual edit buttons - sections are automatically editable when isEditing is true
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/2d493fae-3749-4b25-960d-04d6e5f42b38',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:21245',message:'Rendering section',data:{section,isEditing},timestamp:Date.now(),runId:'run1',hypothesisId:'A'})}).catch(()=>{});
                // #endregion
                
                html += `
                    <div style="background: #ffffff; padding: 16px; border-radius: 12px; border-left: 3px solid #007AFF; border: 1px solid #e5e5e7; margin-bottom: 16px; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', sans-serif;" ${isEditing ? 'data-editable-section="' + escapeHtml(section) + '"' : ''}>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; gap: 12px;">
                            <strong style="text-transform: capitalize; flex: 1; min-width: 0; font-size: 17px; font-weight: 600; color: #1d1d1f; letter-spacing: -0.34px;">${section}</strong>
                            <div style="display: flex; align-items: center; gap: 8px; flex-shrink: 0;">
                                <strong style="color: #007AFF; flex-shrink: 0; white-space: nowrap; font-size: 17px; font-weight: 600; letter-spacing: -0.34px;">${data.score} / ${data.maxScore}</strong>
                            </div>
                        </div>
                        <div style="background: #f5f5f7; padding: 12px; border-radius: 10px; margin-bottom: 12px;">
                            <div style="font-size: 13px; font-weight: 600; color: #007AFF; margin-bottom: 8px; letter-spacing: -0.08px;">AI explanation</div>
                            ${isEditing ? `<textarea id="feedback-${sectionId}" style="width: 100%; min-height: 88px; padding: 12px; border: 1px solid #d2d2d7; border-radius: 10px; font-size: 17px; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif; resize: vertical; background: #ffffff; color: #1d1d1f; line-height: 1.47; transition: all 0.2s ease; box-sizing: border-box;" placeholder="Enter feedback..." onfocus="this.style.borderColor='#007AFF'; this.style.outline='none'; this.style.boxShadow='0 0 0 4px rgba(0, 122, 255, 0.1)'" onblur="this.style.borderColor='#d2d2d7'; this.style.boxShadow='none'">${escapeHtml(data.feedback || 'No feedback provided.')}</textarea>` : `<p style="color: #6e6e73; font-size: 15px; margin: 0; line-height: 1.47;" id="feedback-${sectionId}">${data.feedback || 'No feedback provided.'}</p>`}
                        </div>
                `;
                
                // Show subcategory breakdown if available
                if (data.subcategories && data.subcategories.length > 0) {
                    html += `<div style="background: #f5f5f7; padding: 12px; border-radius: 10px; margin-top: 12px;">
                        <div style="font-size: 15px; font-weight: 600; margin-bottom: 12px; color: #1d1d1f; letter-spacing: -0.24px;">Subcategory Breakdown:</div>
                    `;
                    
                    data.subcategories.forEach((sub, subIdx) => {
                        const gradeColor = sub.grade === 'A' ? '#34C759' : 
                                          sub.grade === 'B' ? '#30D158' :
                                          sub.grade === 'C' ? '#FF9500' :
                                          sub.grade === 'D' ? '#FF3B30' : '#FF2D55';
                        const subId = sectionId + '_sub_' + subIdx;
                        
                        html += `
                            <div style="padding: 12px 0; border-bottom: 0.5px solid #d2d2d7;" ${isEditing ? 'data-editable-subcategory="' + escapeHtml(section) + '" data-subcategory-index="' + subIdx + '"' : ''}>
                                <div style="display: flex; justify-content: space-between; align-items: center; gap: 12px; flex-wrap: wrap;">
                                    <span style="font-size: 15px; color: #1d1d1f; flex: 1; min-width: 0; line-height: 1.47;">${sub.name}</span>
                                    <div style="display: flex; align-items: center; gap: 8px; flex-shrink: 0;">
                                        ${isEditing ? `
                                        <select id="subcategory-${sectionId}-${subIdx}-grade" onchange="updateSubcategoryFromGrade('${section.replace(/'/g, "\\'")}', ${subIdx})" style="background: ${gradeColor}; color: white; border: none; padding: 4px 8px; border-radius: 8px; font-size: 13px; font-weight: 600; cursor: pointer; min-height: 32px; width: 48px; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif; appearance: none; -webkit-appearance: none; -moz-appearance: none; text-align: center;">
                                            <option value="A" ${sub.grade === 'A' ? 'selected' : ''}>A</option>
                                            <option value="B" ${sub.grade === 'B' ? 'selected' : ''}>B</option>
                                            <option value="C" ${sub.grade === 'C' ? 'selected' : ''}>C</option>
                                            <option value="D" ${sub.grade === 'D' ? 'selected' : ''}>D</option>
                                            <option value="F" ${sub.grade === 'F' ? 'selected' : ''}>F</option>
                                        </select>
                                        <input type="number" id="subcategory-${sectionId}-${subIdx}-points" value="${sub.points}" min="0" max="${sub.maxPoints}" step="0.1" onchange="updateSubcategoryGrade('${section.replace(/'/g, "\\'")}', ${subIdx})" style="width: 96px; padding: 10px 12px; border: 1px solid #d2d2d7; border-radius: 10px; font-size: 17px; text-align: center; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif; min-height: 44px; box-sizing: border-box; transition: all 0.2s ease;" onfocus="this.style.borderColor='#007AFF'; this.style.outline='none'; this.style.boxShadow='0 0 0 4px rgba(0, 122, 255, 0.1)'" onblur="this.style.borderColor='#d2d2d7'; this.style.boxShadow='none'">
                                        <span style="font-size: 15px; color: #6e6e73; line-height: 1.47;">/ ${sub.maxPoints} pts</span>
                                        ` : `
                                        <span style="background: ${gradeColor}; color: white; padding: 4px 8px; border-radius: 8px; font-size: 13px; font-weight: 600; min-height: 32px; width: 32px; display: inline-flex; align-items: center; justify-content: center;">${sub.grade || ''}</span>
                                        <span style="font-size: 15px; color: #6e6e73; line-height: 1.47;">${sub.points} / ${sub.maxPoints} pts</span>
                                        `}
                                    </div>
                                </div>
                                ${isEditing ? `
                                <textarea id="subfeedback-${subId}" style="width: 100%; min-height: 88px; padding: 12px; border: 1px solid #d2d2d7; border-radius: 10px; font-size: 17px; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif; resize: vertical; margin-top: 12px; background: #ffffff; color: #1d1d1f; line-height: 1.47; box-sizing: border-box; transition: all 0.2s ease;" placeholder="Enter feedback..." onfocus="this.style.borderColor='#007AFF'; this.style.outline='none'; this.style.boxShadow='0 0 0 4px rgba(0, 122, 255, 0.1)'" onblur="this.style.borderColor='#d2d2d7'; this.style.boxShadow='none'">${escapeHtml(sub.feedback || '')}</textarea>
                                ` : (sub.feedback ? `<p style="font-size: 15px; color: #6e6e73; margin: 8px 0 0 0; line-height: 1.47;">${escapeHtml(sub.feedback)}</p>` : '')}
                            </div>
                        `;
                    });
                    
                    html += `</div>`;
                }
                
                html += `</div>`;
            }
            
            html += `
                </div>
                </div>
                
                <div id="eval-comments-section" style="background: #ffffff; border: 1px solid #e5e5e7; padding: 16px; border-radius: 12px; margin-bottom: 16px; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', sans-serif; scroll-margin-top: 80px;">
                    <div style="margin-bottom: 12px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <h3 style="color: #1d1d1f; margin: 0; font-size: 20px; font-weight: 600; letter-spacing: -0.4px;">Overall Comments</h3>
                            ${isEditing && videoUrl ? `
                            <button onclick="insertTimestampIntoComments()" style="background: transparent; color: #007AFF; border: 1px solid #007AFF; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 14px; min-width: 44px; min-height: 32px; display: inline-flex; align-items: center; gap: 6px; transition: all 0.2s ease; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;" onmouseover="this.style.backgroundColor='rgba(0, 122, 255, 0.1)'" onmouseout="this.style.backgroundColor='transparent'" title="Insert current video timestamp">
                                <i data-lucide="clock" style="width:14px;height:14px;"></i> Insert Timestamp
                            </button>
                            ` : ''}
                        </div>
                        ${isEditing ? `
                        <textarea id="overall-comments-text" style="width: 100%; min-height: 132px; padding: 12px; border: 1px solid #d2d2d7; border-radius: 10px; font-size: 17px; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif; resize: vertical; background: #ffffff; color: #1d1d1f; line-height: 1.47; box-sizing: border-box; transition: all 0.2s ease;" placeholder="Enter overall comments..." onfocus="this.style.borderColor='#007AFF'; this.style.outline='none'; this.style.boxShadow='0 0 0 4px rgba(0, 122, 255, 0.1)'" onblur="this.style.borderColor='#d2d2d7'; this.style.boxShadow='none'">${escapeHtml(results.overallComments || '')}</textarea>
                        ` : `
                        <p id="overall-comments-text" style="margin: 0; color: #1d1d1f; line-height: 1.47; font-size: 15px;">${escapeHtml(results.overallComments || 'No comments')}</p>
                        `}
                    </div>
                </div>
                ${isEditing ? `
                <div style="display: flex; justify-content: flex-end; gap: 12px; margin-top: 24px; padding: 16px; background: #f5f5f7; border-radius: 12px; margin-bottom: 16px; border: 1px solid #e5e5e7;">
                    <button onclick="cancelEdit()" style="background: #ffffff; color: #1d1d1f; border: 1px solid #d2d2d7; padding: 12px 24px; border-radius: 10px; cursor: pointer; font-weight: 600; font-size: 17px; min-width: 88px; min-height: 44px; display: inline-flex; align-items: center; justify-content: center; gap: 6px; transition: all 0.2s ease; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif; letter-spacing: -0.34px;" onmouseover="this.style.backgroundColor='#f5f5f7'; this.style.borderColor='#007AFF'" onmouseout="this.style.backgroundColor='#ffffff'; this.style.borderColor='#d2d2d7'"><i data-lucide="x" style="width:18px;height:18px;"></i> Cancel</button>
                    <button onclick="saveEditedEvaluation()" style="background: #007AFF; color: white; border: none; padding: 12px 24px; border-radius: 10px; cursor: pointer; font-weight: 600; font-size: 17px; min-width: 88px; min-height: 44px; display: inline-flex; align-items: center; justify-content: center; gap: 6px; transition: all 0.2s ease; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif; letter-spacing: -0.34px; box-shadow: 0 2px 8px rgba(0, 122, 255, 0.3);" onmouseover="this.style.backgroundColor='#0051D5'; this.style.boxShadow='0 4px 12px rgba(0, 122, 255, 0.4)'" onmouseout="this.style.backgroundColor='#007AFF'; this.style.boxShadow='0 2px 8px rgba(0, 122, 255, 0.3)'"><i data-lucide="save" style="width:18px;height:18px;"></i> Save</button>
                </div>
                ` : ''}
            `;
            
            // Add transcript section if available
            if (results.transcript && results.transcript.trim().length > 0) {
                html += `
                    <details id="eval-transcript-section" style="background: #f5f5f7; padding: 16px; border-radius: 12px; margin-top: 16px; border: 1px solid #e5e5e7; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', sans-serif; scroll-margin-top: 80px;">
                        <summary style="cursor: pointer; font-weight: 600; color: #007AFF; padding: 8px; font-size: 17px; letter-spacing: -0.34px; user-select: none;">
                            📝 View Speech Transcript
                        </summary>
                        <div style="margin-top: 12px; padding: 16px; background: #ffffff; border-radius: 10px; max-height: 400px; overflow-y: auto; font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace; font-size: 13px; line-height: 1.47; color: #1d1d1f; border: 1px solid #e5e5e7;">
                            ${escapeHtml(results.transcript).replace(/\n/g, '<br>')}
                        </div>
                    </details>
                `;
            }
            
            // Timeline markers are now displayed with the video (above)
            
            // Combine all HTML sections based on layout type
            let finalHtml = '';
            
            // Extract banner and navigation from html (they stay at top)
            const bannerMatch = html.match(/<div id="editingModeBanner"[^>]*>[\s\S]*?<\/div>/);
            const bannerHtml = bannerMatch ? bannerMatch[0] : '';
            const navMatch = html.match(/<nav id="evalNavigationMenu"[^>]*>[\s\S]*?<\/nav>/);
            const navHtml = navMatch ? navMatch[0] : '';
            
            // Remove banner and nav from html to get the rest of the content
            let contentHtml = html
                .replace(/<div id="editingModeBanner"[^>]*>[\s\S]*?<\/div>/, '')
                .replace(/<nav id="evalNavigationMenu"[^>]*>[\s\S]*?<\/nav>/, '');
            
            if (useSplitScreen && videoSectionHtml) {
                // Split-screen layout: video on left (sticky), evaluation content on right
                finalHtml = `
                    ${bannerHtml}
                    ${navHtml}
                    <div id="eval-split-screen-container" style="display: flex; gap: 24px; align-items: flex-start; margin-top: ${bannerHtml || navHtml ? '24px' : '0'};">
                        ${videoSectionHtml}
                        <div style="flex: 1; min-width: 0;">
                            ${metadataHtml}
                            ${contentHtml}
                        </div>
                    </div>
                    <style>
                        @media (max-width: 1024px) {
                            #eval-split-screen-container {
                                flex-direction: column !important;
                            }
                            #eval-video-sidebar {
                                position: static !important;
                                max-width: 100% !important;
                                margin-right: 0 !important;
                                margin-bottom: 24px !important;
                            }
                        }
                    </style>
                `;
            } else {
                // Vertical layout: normal flow
                finalHtml = bannerHtml + navHtml + metadataHtml + (videoSectionHtml || '') + contentHtml;
            }
            
            const resultsContentEl = document.getElementById('resultsContent');
            if (resultsContentEl) {
                console.log('Setting innerHTML, isEditing:', isEditing);
                const htmlHasEditButtons = finalHtml.includes('editSection') || finalHtml.includes('editOverallComments') || finalHtml.includes('editTimelineMarkers');
                console.log('HTML contains edit buttons:', htmlHasEditButtons);
                console.log('Using split-screen layout:', useSplitScreen);
                
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/2d493fae-3749-4b25-960d-04d6e5f42b38',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:21311',message:'Before innerHTML assignment',data:{isEditing,htmlLength:finalHtml.length,htmlHasEditButtons,resultsContentElExists:!!resultsContentEl,useSplitScreen},timestamp:Date.now(),runId:'run1',hypothesisId:'A'})}).catch(()=>{});
                // #endregion
                
                resultsContentEl.innerHTML = finalHtml;
                
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/2d493fae-3749-4b25-960d-04d6e5f42b38',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:21318',message:'After innerHTML assignment',data:{innerHTMLLength:resultsContentEl.innerHTML.length},timestamp:Date.now(),runId:'run1',hypothesisId:'A'})}).catch(()=>{});
                // #endregion
                
                // #region agent log - Check editable fields DOM structure after render
                setTimeout(() => {
                    const editableFields = resultsContentEl.querySelectorAll('textarea, input[type="number"], select');
                    editableFields.forEach((field, idx) => {
                        const parent = field.parentElement;
                        const grandparent = parent ? parent.parentElement : null;
                        const computed = window.getComputedStyle(field);
                        const parentComputed = parent ? window.getComputedStyle(parent) : null;
                        const grandparentComputed = grandparent ? window.getComputedStyle(grandparent) : null;
                        
                        fetch('http://127.0.0.1:7242/ingest/2d493fae-3749-4b25-960d-04d6e5f42b38',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:21352',message:'Editable field DOM structure after render',data:{fieldIndex:idx,fieldType:field.tagName,fieldWidth:field.offsetWidth,fieldHeight:field.offsetHeight,fieldDisplay:computed.display,parentTag:parent?parent.tagName:'none',parentWidth:parent?parent.offsetWidth:0,parentHeight:parent?parent.offsetHeight:0,parentDisplay:parentComputed?parentComputed.display:'none',grandparentTag:grandparent?grandparent.tagName:'none',grandparentWidth:grandparent?grandparent.offsetWidth:0,grandparentHeight:grandparent?grandparent.offsetHeight:0,grandparentDisplay:grandparentComputed?grandparentComputed.display:'none'},timestamp:Date.now(),runId:'run8',hypothesisId:'K'})}).catch(()=>{});
                    });
                }, 100);
                // #endregion
                
                // When editing, check for editable fields (textareas, inputs, selects) instead of buttons
                if (isEditing) {
                    // Check for editable fields (textareas, inputs, selects)
                    let editableFields = resultsContentEl.querySelectorAll('textarea, input[type="number"], select');
                    console.log('🔍 IMMEDIATE: Found', editableFields.length, 'editable fields');
                    
                    if (editableFields.length === 0) {
                        // Try again after a tiny delay
                        setTimeout(() => {
                            editableFields = resultsContentEl.querySelectorAll('textarea, input[type="number"], select');
                            console.log('🔍 AFTER DELAY: Found', editableFields.length, 'editable fields');
                        }, 50);
                    }
                    
                    // Force visibility with multiple attempts
                    const forceVisibility = () => {
                        editableFields = resultsContentEl.querySelectorAll('textarea, input[type="number"], select');
                        console.log('🔧 Forcing visibility for', editableFields.length, 'editable fields');
                        
                        // #region agent log
                        fetch('http://127.0.0.1:7242/ingest/2d493fae-3749-4b25-960d-04d6e5f42b38',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:21330',message:'forceVisibility called',data:{fieldCount:editableFields.length},timestamp:Date.now(),runId:'run1',hypothesisId:'B'})}).catch(()=>{});
                        // #endregion
                        
                        if (editableFields.length > 0) {
                            // Editable fields should be visible by default, but ensure they're not hidden
                            editableFields.forEach((field, idx) => {
                                // Remove any classes that might hide it
                                field.classList.remove('hidden');
                                field.removeAttribute('hidden');
                                
                                // Ensure visibility
                                field.style.setProperty('display', field.tagName === 'TEXTAREA' ? 'block' : 'inline-block', 'important');
                                field.style.setProperty('visibility', 'visible', 'important');
                                field.style.setProperty('opacity', '1', 'important');
                                
                                // For textareas, ensure they have minimum height
                                if (field.tagName === 'TEXTAREA') {
                                    if (!field.style.minHeight || field.style.minHeight === '0px') {
                                        field.style.setProperty('min-height', '60px', 'important');
                                    }
                                }
                                
                                // For inputs and selects, ensure they're visible
                                if (field.tagName === 'INPUT' || field.tagName === 'SELECT') {
                                    field.style.setProperty('min-width', '60px', 'important');
                                }
                            });
                            
                            console.log('✓ Editable fields are visible:', editableFields.length);
                            
                            // Initialize Lucide icons for any icons in the content
                            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                                lucide.createIcons({ root: resultsContentEl });
                                console.log('✓ Lucide icons initialized');
                            }
                        } else {
                            // Check if editable fields exist instead
                            const editableFieldsInHTML = html.includes('<textarea') || html.includes('<input') || html.includes('<select');
                            console.log('Searching in HTML string...');
                            console.log('HTML contains textareas:', html.includes('<textarea'));
                            console.log('HTML contains inputs:', html.includes('<input'));
                            console.log('HTML contains selects:', html.includes('<select'));
                            
                            if (editableFieldsInHTML) {
                                console.log('⚠️ Editable fields are in HTML but not in DOM - possible issue with innerHTML assignment or timing');
                            } else {
                                console.error('❌ NO EDITABLE FIELDS FOUND IN HTML OR DOM!');
                            }
                        }
                    };
                    
                    // Try multiple times
                    forceVisibility();
                    setTimeout(forceVisibility, 50);
                    setTimeout(forceVisibility, 200);
                    setTimeout(forceVisibility, 500);
                } else {
                    console.warn('⚠️ isEditing is FALSE - edit buttons will not be shown');
                }
            }
            
            // Re-initialize Lucide icons for new content
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons({ root: document.getElementById('resultsContent') });
            }
            
            // Render action buttons dynamically
            renderResultsActionButtons(isEditing);
            
            // Set up video loading indicator and error handling
            const videoPlayer = document.getElementById('evaluationVideoPlayer');
            if (videoPlayer) {
                const loadingIndicator = document.getElementById('videoLoadingIndicator');
                const errorIndicator = document.getElementById('videoErrorIndicator');
                
                if (loadingIndicator && errorIndicator) {
                    // Add CSS animation for spinner
                    if (!document.getElementById('videoSpinStyle')) {
                        const style = document.createElement('style');
                        style.id = 'videoSpinStyle';
                        style.textContent = '@keyframes videoSpin { to { transform: rotate(360deg); } }';
                        document.head.appendChild(style);
                    }
                    
                    // Start with indicators hidden
                    loadingIndicator.style.display = 'none';
                    errorIndicator.style.display = 'none';
                    
                    // Function to hide loading indicator
                    const hideLoading = () => {
                        if (loadingIndicator) loadingIndicator.style.display = 'none';
                        if (errorIndicator) errorIndicator.style.display = 'none';
                    };
                    
                    // Function to show loading indicator
                    const showLoading = () => {
                        if (loadingIndicator && errorIndicator.style.display !== 'flex') {
                            loadingIndicator.style.display = 'flex';
                        }
                    };
                    
                    // Check video state after a brief delay to allow video to initialize
                    setTimeout(() => {
                        // Check if video is already loaded and ready to play
                        // readyState values: 0=HAVE_NOTHING, 1=HAVE_METADATA, 2=HAVE_CURRENT_DATA, 3=HAVE_FUTURE_DATA, 4=HAVE_ENOUGH_DATA
                        const readyState = videoPlayer.readyState;
                        const networkState = videoPlayer.networkState; // 0=EMPTY, 1=IDLE, 2=LOADING, 3=NO_SOURCE
                        
                        // If video has enough data to play, don't show loading
                        if (readyState >= 4) {
                            hideLoading();
                            return;
                        }
                        
                        // If video has future data and is not actively loading, don't show loading
                        if (readyState >= 3 && networkState !== 2) {
                            hideLoading();
                            return;
                        }
                        
                        // If video is actively loading (networkState === 2) or has no data yet, show loading
                        if (networkState === 2 || readyState < 2) {
                            showLoading();
                        }
                    }, 100);
                    
                    // Hide loading when video has enough data to play
                    videoPlayer.addEventListener('canplay', hideLoading, { once: true });
                    videoPlayer.addEventListener('canplaythrough', hideLoading, { once: true });
                    videoPlayer.addEventListener('playing', hideLoading, { once: true });
                    
                    // Show loading when video starts loading
                    videoPlayer.addEventListener('loadstart', showLoading);
                    videoPlayer.addEventListener('waiting', showLoading);
                    
                    // Show error if video fails to load
                    videoPlayer.addEventListener('error', (e) => {
                        hideLoading();
                        if (errorIndicator) {
                            errorIndicator.style.display = 'flex';
                            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                                lucide.createIcons({ root: errorIndicator });
                            }
                        }
                        console.error('Video loading error:', e);
                    }, { once: true });
                    
                    // Timeout after 30 seconds if still loading
                    setTimeout(() => {
                        if (videoPlayer.readyState < 4 && loadingIndicator && loadingIndicator.style.display === 'flex') {
                            loadingIndicator.style.display = 'none';
                            if (errorIndicator) {
                                errorIndicator.style.display = 'flex';
                                if (typeof lucide !== 'undefined' && lucide.createIcons) {
                                    lucide.createIcons({ root: errorIndicator });
                                }
                            }
                        }
                    }, 30000);
                }
            }
            
            // Set up video marker listener if video exists and we're editing
            if (isEditing && videoUrl) {
                // Wait for video to be ready
                setTimeout(() => {
                    if (typeof setupVideoMarkerListener === 'function') {
                        setupVideoMarkerListener();
                    }
                }, 100);
                
                // Also set up when video is loaded
                if (videoPlayer) {
                    const setupListener = () => {
                        if (typeof setupVideoMarkerListener === 'function') {
                            setupVideoMarkerListener();
                        }
                    };
                    videoPlayer.addEventListener('loadedmetadata', setupListener, { once: true });
                    if (videoPlayer.readyState >= 1) {
                        // Video already has metadata
                        setTimeout(setupListener, 50);
                    }
                }
            }
            
            // Update correction count badge if corrections exist
            if (typeof updateCorrectionCount === 'function') {
                updateCorrectionCount();
            }
        }

        // ===== EDIT FUNCTIONALITY =====
        
        let currentEditingSection = null;
        let correctionLog = [];
        
        // Edit Section Score and Feedback
        function editSection(sectionName) {
            console.log('editSection called with:', sectionName);
            if (!evaluationResults) {
                console.error('No evaluationResults available');
                return;
            }
            
            currentEditingSection = sectionName;
            const section = evaluationResults.sections[sectionName];
            
            if (!section) {
                console.error('Section not found:', sectionName);
                console.log('Available sections:', Object.keys(evaluationResults.sections));
                alert('Error: Could not find section "' + sectionName + '"');
                return;
            }
            
            console.log('Editing section:', section);
            
            document.getElementById('editSectionName').textContent = sectionName.charAt(0).toUpperCase() + sectionName.slice(1);
            document.getElementById('editSectionScore').value = section.score;
            document.getElementById('editSectionMaxScore').textContent = section.maxScore;
            document.getElementById('editSectionAIFeedback').textContent = section.feedback;
            document.getElementById('editSectionFeedback').value = section.feedback;
            document.getElementById('editSectionReason').value = '';
            document.getElementById('editSectionReason').placeholder = 'Required: Explain why you\'re making changes (helps improve AI)';
            
            // Populate subcategories if they exist
            const subcategoriesContainer = document.getElementById('editSubcategoriesContainer');
            if (section.subcategories && section.subcategories.length > 0) {
                let subHTML = '<h4 style="margin-bottom:1rem;font-size:1rem;color:var(--text-dark);">Edit Subcategories:</h4>';
                
                section.subcategories.forEach((sub, index) => {
                    const gradeColor = sub.grade === 'A' ? '#28a745' : 
                                      sub.grade === 'B' ? '#5cb85c' :
                                      sub.grade === 'C' ? '#f0ad4e' :
                                      sub.grade === 'D' ? '#d9534f' : '#c9302c';
                    
                    // Create safe IDs
                    const sectionId = sectionName.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                    
                    subHTML += `
                        <div style="background:var(--bg-alt);padding:1rem;border-radius:0.5rem;margin-bottom:1rem;border-left:4px solid ${gradeColor};">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.75rem;">
                                <strong style="font-size:0.95rem;color:var(--text-dark);">${sub.name}</strong>
                                <span style="background:${gradeColor};color:white;padding:0.25rem 0.5rem;border-radius:0.25rem;font-size:0.85rem;font-weight:600;">${sub.grade}</span>
                            </div>
                            <div style="display:flex;gap:1rem;align-items:flex-start;">
                                <div style="flex:1;">
                                    <label style="display:block;font-size:0.85rem;font-weight:600;margin-bottom:0.25rem;">Grade:</label>
                                    <select id="subcategory-${sectionId}-${index}-grade" 
                                            onchange="updateSubcategoryFromGrade(\`${sectionName.replace(/`/g, '\\`')}\`, ${index})"
                                            style="width:100%;padding:0.5rem;border:2px solid #ddd;border-radius:0.25rem;font-size:0.9rem;margin-bottom:0.5rem;">
                                        <option value="A" ${sub.grade === 'A' ? 'selected' : ''}>A (90-100%)</option>
                                        <option value="B" ${sub.grade === 'B' ? 'selected' : ''}>B (80-89%)</option>
                                        <option value="C" ${sub.grade === 'C' ? 'selected' : ''}>C (70-79%)</option>
                                        <option value="D" ${sub.grade === 'D' ? 'selected' : ''}>D (60-69%)</option>
                                        <option value="F" ${sub.grade === 'F' ? 'selected' : ''}>F (0-59%)</option>
                                    </select>
                                </div>
                                <div style="flex:1;">
                                    <label style="display:block;font-size:0.85rem;font-weight:600;margin-bottom:0.25rem;">Points (or edit directly):</label>
                                    <div style="display:flex;gap:0.5rem;align-items:center;">
                                        <input type="number" 
                                               id="subcategory-${sectionId}-${index}-points" 
                                               value="${sub.points}" 
                                               min="0" 
                                               max="${sub.maxPoints}"
                                               onchange="updateSubcategoryGrade(\`${sectionName.replace(/`/g, '\\`')}\`, ${index})"
                                               style="width:70px;padding:0.5rem;border:2px solid #ddd;border-radius:0.25rem;font-size:0.9rem;">
                                        <span style="font-size:0.9rem;color:var(--text-light);">/ ${sub.maxPoints}</span>
                                    </div>
                                </div>
                                <div style="flex:2;">
                                    <label style="display:block;font-size:0.85rem;font-weight:600;margin-bottom:0.25rem;">Feedback (optional):</label>
                                    <textarea id="subcategory-${sectionId}-${index}-feedback" 
                                              rows="2" 
                                              style="width:100%;padding:0.5rem;border:2px solid #ddd;border-radius:0.25rem;resize:vertical;font-size:0.85rem;"
                                              placeholder="Optional subcategory feedback">${sub.feedback || ''}</textarea>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                subcategoriesContainer.innerHTML = subHTML;
                subcategoriesContainer.style.display = 'block';
            } else {
                subcategoriesContainer.style.display = 'none';
            }
            
            document.getElementById('editSectionModal').style.display = 'flex';
            console.log('Edit modal displayed');
        }
        
        // Update subcategory grade when points change
        function updateSubcategoryGrade(sectionName, index) {
            try {
                console.log('updateSubcategoryGrade called:', sectionName, index);
                const sectionId = sectionName.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                const pointsInput = document.getElementById(`subcategory-${sectionId}-${index}-points`);
                const gradeSelect = document.getElementById(`subcategory-${sectionId}-${index}-grade`);
                
                if (!pointsInput || !gradeSelect) {
                    console.error('Input elements not found:', `subcategory-${sectionId}-${index}-points`, `subcategory-${sectionId}-${index}-grade`);
                    return;
                }
                
                if (!evaluationResults || !evaluationResults.sections || !evaluationResults.sections[sectionName]) {
                    console.error('evaluationResults or section not found:', sectionName);
                    return;
                }
                
                const section = evaluationResults.sections[sectionName];
                if (!section.subcategories || !section.subcategories[index]) {
                    console.error('Subcategory not found:', index);
                    return;
                }
                
                const sub = section.subcategories[index];
                const maxPoints = sub.maxPoints || 0;
                
                // Get points value (handle both string and number)
                const points = parseFloat(pointsInput.value) || 0;
                
                // Clamp points to valid range
                const clampedPoints = Math.max(0, Math.min(points, maxPoints));
                if (points !== clampedPoints) {
                    pointsInput.value = clampedPoints;
                }
                
                // Calculate percentage and letter grade
                const percentage = maxPoints > 0 ? (clampedPoints / maxPoints) * 100 : 0;
                let grade = 'F';
                if (percentage >= 90) grade = 'A';
                else if (percentage >= 80) grade = 'B';
                else if (percentage >= 70) grade = 'C';
                else if (percentage >= 60) grade = 'D';
                
                // Update grade select dropdown
                const gradeColors = {
                    'A': '#28a745',
                    'B': '#5cb85c',
                    'C': '#f0ad4e',
                    'D': '#d9534f',
                    'F': '#c9302c'
                };
                
                gradeSelect.value = grade;
                gradeSelect.style.background = gradeColors[grade] || '#c9302c';
                
                // Update the displayed grade badge color
                const parentDiv = pointsInput.closest('div[style*="border-left"]');
                const gradeBadge = parentDiv ? parentDiv.querySelector('span[style*="background"]') : null;
                
                if (gradeBadge) {
                    const color = gradeColors[grade] || '#c9302c';
                    gradeBadge.style.background = color;
                    gradeBadge.textContent = grade;
                    if (parentDiv) parentDiv.style.borderLeftColor = color;
                }
                
                // Update subcategory data
                sub.points = clampedPoints;
                sub.grade = grade;
                
                // Recalculate total section score
                if (typeof recalculateSectionScore === 'function') {
                    recalculateSectionScore(sectionName);
                }
            } catch (error) {
                console.error('Error in updateSubcategoryGrade:', error);
            }
        }
        
        // Update subcategory points when grade changes
        function updateSubcategoryFromGrade(sectionName, index) {
            try {
                console.log('updateSubcategoryFromGrade called:', sectionName, index);
                const sectionId = sectionName.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                const gradeSelect = document.getElementById(`subcategory-${sectionId}-${index}-grade`);
                const pointsInput = document.getElementById(`subcategory-${sectionId}-${index}-points`);
                
                if (!gradeSelect || !pointsInput) {
                    console.error('Input elements not found:', `subcategory-${sectionId}-${index}-grade`, `subcategory-${sectionId}-${index}-points`);
                    return;
                }
                
                if (!evaluationResults || !evaluationResults.sections || !evaluationResults.sections[sectionName]) {
                    console.error('evaluationResults or section not found:', sectionName);
                    return;
                }
                
                const section = evaluationResults.sections[sectionName];
                if (!section.subcategories || !section.subcategories[index]) {
                    console.error('Subcategory not found:', index);
                    return;
                }
                
                const sub = section.subcategories[index];
                const maxPoints = sub.maxPoints || 0;
                
                const grade = gradeSelect.value;
                let percentage = 0;
                if (grade === 'A') percentage = 95; // Midpoint of A range
                else if (grade === 'B') percentage = 85;
                else if (grade === 'C') percentage = 75;
                else if (grade === 'D') percentage = 65;
                else percentage = 30; // F range
                
                const points = Math.round((percentage / 100) * maxPoints);
                pointsInput.value = points;
                
                // Update grade select background color
                const gradeColors = {
                    'A': '#28a745',
                    'B': '#5cb85c',
                    'C': '#f0ad4e',
                    'D': '#d9534f',
                    'F': '#c9302c'
                };
                gradeSelect.style.background = gradeColors[grade] || '#c9302c';
                
                // Update visual badge
                const parentDiv = pointsInput.closest('div[style*="border-left"]');
                const gradeBadge = parentDiv ? parentDiv.querySelector('span[style*="background"]') : null;
                if (gradeBadge) {
                    const color = gradeColors[grade] || '#c9302c';
                    gradeBadge.style.background = color;
                    gradeBadge.textContent = grade;
                    if (parentDiv) parentDiv.style.borderLeftColor = color;
                }
                
                // Update subcategory data
                sub.points = points;
                sub.grade = grade;
                
                // Recalculate total section score
                if (typeof recalculateSectionScore === 'function') {
                    recalculateSectionScore(sectionName);
                }
            } catch (error) {
                console.error('Error in updateSubcategoryFromGrade:', error);
            }
        }
        
        // Make subcategory update functions globally available
        window.updateSubcategoryGrade = updateSubcategoryGrade;
        window.updateSubcategoryFromGrade = updateSubcategoryFromGrade;
        
        // Recalculate section score from subcategories
        function recalculateSectionScore(sectionName) {
            const section = evaluationResults.sections[sectionName];
            if (!section || !section.subcategories) return;
            
            const sectionId = sectionName.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
            let totalPoints = 0;
            
            section.subcategories.forEach((sub, i) => {
                const input = document.getElementById(`subcategory-${sectionId}-${i}-points`);
                if (input) {
                    const points = parseInt(input.value) || 0;
                    totalPoints += points;
                    sub.points = points; // Update data
                } else {
                    totalPoints += sub.points || 0; // Use existing if input not found
                }
            });
            
            // Update section score
            section.score = totalPoints;
            
            // Update display
            const scoreInput = document.getElementById('editSectionScore');
            if (scoreInput) {
                scoreInput.value = totalPoints;
            }
            
            // Recalculate overall total score
            recalculateTotalScore();
        }
        
        // Recalculate total evaluation score
        function recalculateTotalScore() {
            if (!evaluationResults || !evaluationResults.sections) return;
            
            let totalScore = 0;
            let maxScore = 0;
            
            Object.values(evaluationResults.sections).forEach(section => {
                totalScore += section.score || 0;
                maxScore += section.maxScore || 0;
            });
            
            evaluationResults.totalScore = totalScore;
            evaluationResults.maxScore = maxScore;
            
            // Update display if results are shown
            const scoreBanner = document.querySelector('.score-banner');
            if (scoreBanner) {
                const scoreValue = scoreBanner.querySelector('.score-value');
                const scorePercentage = scoreBanner.querySelector('.score-percentage');
                if (scoreValue) {
                    scoreValue.textContent = `${totalScore} / ${maxScore}`;
                }
                if (scorePercentage) {
                    const percentage = maxScore > 0 ? ((totalScore / maxScore) * 100).toFixed(1) : '0';
                    scorePercentage.textContent = `${percentage}%`;
                }
            }
        }
        
        function closeEditSectionModal() {
            document.getElementById('editSectionModal').style.display = 'none';
            currentEditingSection = null;
        }
        
        function saveEditedSection() {
            if (!currentEditingSection || !evaluationResults) return;
            
            const section = evaluationResults.sections[currentEditingSection];
            const sectionId = currentEditingSection.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
            const newFeedback = document.getElementById('editSectionFeedback').value.trim();
            const reason = document.getElementById('editSectionReason').value.trim();
            
            // Check if any changes were made
            let hasChanges = false;
            
            // Check feedback change
            if (newFeedback !== section.feedback) {
                hasChanges = true;
            }
            
            // Check subcategory changes
            if (section.subcategories && section.subcategories.length > 0) {
                section.subcategories.forEach((sub, index) => {
                    const pointsInput = document.getElementById(`subcategory-${sectionId}-${index}-points`);
                    const feedbackInput = document.getElementById(`subcategory-${sectionId}-${index}-feedback`);
                    
                    if (pointsInput) {
                        const newPoints = parseInt(pointsInput.value) || 0;
                        const newSubFeedback = feedbackInput ? feedbackInput.value.trim() : '';
                        
                        if (newPoints !== sub.points || newSubFeedback !== (sub.feedback || '')) {
                            hasChanges = true;
                        }
                    }
                });
            }
            
            // If changes were made, require a reason
            if (hasChanges && !reason) {
                alert('Please provide a reason for your changes. This helps improve the AI evaluation system.');
                document.getElementById('editSectionReason').focus();
                return;
            }
            
            // Update subcategories if they exist
            if (section.subcategories && section.subcategories.length > 0) {
                section.subcategories.forEach((sub, index) => {
                    const pointsInput = document.getElementById(`subcategory-${sectionId}-${index}-points`);
                    const feedbackInput = document.getElementById(`subcategory-${sectionId}-${index}-feedback`);
                    
                    if (pointsInput) {
                        const newPoints = parseInt(pointsInput.value) || 0;
                        const newSubFeedback = feedbackInput ? feedbackInput.value.trim() : '';
                        
                        // Log correction if points changed
                        if (newPoints !== sub.points) {
                            correctionLog.push({
                                timestamp: new Date().toISOString(),
                                field: `${currentEditingSection}.${sub.name}.points`,
                                ai_value: sub.points,
                                instructor_value: newPoints,
                                reason: reason
                            });
                        }
                        
                        // Log correction if feedback changed
                        if (newSubFeedback !== (sub.feedback || '')) {
                            correctionLog.push({
                                timestamp: new Date().toISOString(),
                                field: `${currentEditingSection}.${sub.name}.feedback`,
                                ai_value: sub.feedback || '',
                                instructor_value: newSubFeedback,
                                reason: reason
                            });
                        }
                        
                        // Update subcategory
                        sub.points = newPoints;
                        sub.feedback = newSubFeedback;
                        
                        // Recalculate grade
                        const percentage = (newPoints / sub.maxPoints) * 100;
                        if (percentage >= 90) sub.grade = 'A';
                        else if (percentage >= 80) sub.grade = 'B';
                        else if (percentage >= 70) sub.grade = 'C';
                        else if (percentage >= 60) sub.grade = 'D';
                        else sub.grade = 'F';
                    }
                });
                
                // Recalculate section score from subcategories
                let newSectionScore = 0;
                section.subcategories.forEach(sub => {
                    newSectionScore += sub.points;
                });
                
                // Log if section total changed
                if (newSectionScore !== section.score) {
                    correctionLog.push({
                        timestamp: new Date().toISOString(),
                        field: `${currentEditingSection}_total_score`,
                        ai_value: section.score,
                        instructor_value: newSectionScore,
                        reason: reason
                    });
                }
                
                section.score = newSectionScore;
            }
            
            // Log correction if feedback changed
            if (newFeedback !== section.feedback) {
                correctionLog.push({
                    timestamp: new Date().toISOString(),
                    field: `${currentEditingSection}_feedback`,
                    ai_value: section.feedback,
                    instructor_value: newFeedback,
                    reason: reason
                });
            }
            
            // Update section feedback
            section.feedback = newFeedback;
            
            // Recalculate total score for entire evaluation
            let newTotal = 0;
            for (const [key, data] of Object.entries(evaluationResults.sections)) {
                newTotal += data.score;
            }
            evaluationResults.totalScore = newTotal;
            evaluationResults.percentage = ((newTotal / evaluationResults.maxScore) * 100).toFixed(1);
            
            // Update letter grade
            const percentage = (newTotal / evaluationResults.maxScore) * 100;
            evaluationResults.letterGrade = getLetterGrade(percentage, evaluationResults.gradeScale);
            
            // Re-display results
            displayResults(evaluationResults);
            
            closeEditSectionModal();
            
            // Update correction count badge
            updateCorrectionCount();
            
            showNotification('✓ Section updated! Remember to save the evaluation.', 'success');
        }
        
        // Edit Overall Comments
        function editOverallComments() {
            if (!evaluationResults) return;
            
            document.getElementById('editCommentsAI').textContent = evaluationResults.overallComments;
            document.getElementById('editCommentsText').value = evaluationResults.overallComments;
            document.getElementById('editCommentsReason').value = '';
            
            document.getElementById('editCommentsModal').style.display = 'flex';
        }
        
        function closeEditCommentsModal() {
            document.getElementById('editCommentsModal').style.display = 'none';
        }
        
        function saveEditedComments() {
            if (!evaluationResults) return;
            
            const newComments = document.getElementById('editCommentsText').value.trim();
            const reason = document.getElementById('editCommentsReason').value.trim();
            
            if (newComments !== evaluationResults.overallComments) {
                // Require reason for changes
                if (!reason) {
                    alert('Please provide a reason for changing the comments. This helps improve the AI evaluation system.');
                    document.getElementById('editCommentsReason').focus();
                    return;
                }
                
                correctionLog.push({
                    timestamp: new Date().toISOString(),
                    field: 'overall_comments',
                    ai_value: evaluationResults.overallComments,
                    instructor_value: newComments,
                    reason: reason
                });
                
                evaluationResults.overallComments = newComments;
                
                // Update display
                document.getElementById('overall-comments-text').textContent = newComments;
                
                closeEditCommentsModal();
                
                // Update correction count badge
                updateCorrectionCount();
                
                showNotification('✓ Comments updated! Remember to save the evaluation.', 'success');
            } else {
                closeEditCommentsModal();
            }
        }
        
        // Edit Timeline Markers
        function editTimelineMarkers() {
            if (!evaluationResults || !evaluationResults.timeline_markers) return;
            
            renderMarkersList();
            document.getElementById('editMarkersModal').style.display = 'flex';
        }

        function syncMarkerIssueFromBehavior(index) {
            const sel = document.getElementById('marker-behavior-' + index);
            const issueInput = document.getElementById('marker-issue-' + index);
            if (!sel || !issueInput) return;
            const v = sel.value;
            if (BEHAVIOR_LABELS.includes(v)) issueInput.value = v;
        }
        
        function closeEditMarkersModal() {
            document.getElementById('editMarkersModal').style.display = 'none';
        }
        
        function renderMarkersList() {
            const markers = evaluationResults.timeline_markers || [];
            let html = '';
            
            markers.forEach((marker, index) => {
                const severityColors = {
                    'positive': '#10b981',
                    'minor': '#f59e0b',
                    'moderate': '#f59e0b',
                    'major': '#ef4444'
                };
                const color = severityColors[marker.severity] || '#f59e0b';
                
                html += `
                    <div style="background:var(--bg-alt);padding:1rem;border-radius:0.5rem;margin-bottom:1rem;border-left:4px solid ${color};" data-marker-index="${index}">
                        <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:1rem;">
                            <div style="flex:1;">
                                <label style="display:block;font-weight:600;font-size:0.85rem;margin-bottom:0.25rem;">Timestamp:</label>
                                <input type="text" id="marker-time-${index}" value="${escapeHtml(marker.timestamp || '')}" style="width:100px;padding:0.5rem;border:2px solid #ddd;border-radius:0.25rem;" placeholder="0:45">
                            </div>
                            <div style="flex:2;margin-left:1rem;">
                                <label style="display:block;font-weight:600;font-size:0.85rem;margin-bottom:0.25rem;">Category:</label>
                                <input type="text" id="marker-category-${index}" value="${escapeHtml(marker.category || '')}" style="width:100%;padding:0.5rem;border:2px solid #ddd;border-radius:0.25rem;">
                            </div>
                            <button onclick="duplicateMarker(${index})" style="margin-left:0.5rem;padding:0.5rem;background:#6c757d;color:white;border:none;border-radius:0.25rem;cursor:pointer;" title="Add another at a new time">+</button>
                            <button onclick="deleteMarker(${index})" style="margin-left:0.25rem;padding:0.5rem;background:#dc3545;color:white;border:none;border-radius:0.25rem;cursor:pointer;" title="Delete marker"><i data-lucide="trash-2" style="width:1rem;height:1rem;"></i></button>
                        </div>
                        <div style="margin-bottom:0.75rem;">
                            <label style="display:block;font-weight:600;font-size:0.85rem;margin-bottom:0.25rem;">Behavior (from examples):</label>
                            <select id="marker-behavior-${index}" style="width:100%;padding:0.5rem;border:2px solid #ddd;border-radius:0.25rem;" onchange="syncMarkerIssueFromBehavior(${index})">
                                <option value="" ${(!marker.behavior || !BEHAVIOR_LABELS.includes(marker.behavior)) ? 'selected' : ''}>${escapeHtml(BEHAVIOR_OTHER)}</option>
                                ${BEHAVIOR_LABELS.map(l => `<option value="${escapeHtml(l)}" ${(marker.behavior === l) ? 'selected' : ''}>${escapeHtml(l)}</option>`).join('')}
                            </select>
                        </div>
                        <div style="margin-bottom:0.75rem;">
                            <label style="display:block;font-weight:600;font-size:0.85rem;margin-bottom:0.25rem;">Issue:</label>
                            <input type="text" id="marker-issue-${index}" value="${escapeHtml(marker.issue || '')}" style="width:100%;padding:0.5rem;border:2px solid #ddd;border-radius:0.25rem;" placeholder="Custom issue when not using a predefined behavior">
                        </div>
                        <div style="margin-bottom:0.75rem;">
                            <label style="display:block;font-weight:600;font-size:0.85rem;margin-bottom:0.25rem;">Note:</label>
                            <textarea id="marker-note-${index}" rows="2" style="width:100%;padding:0.5rem;border:2px solid #ddd;border-radius:0.25rem;resize:vertical;">${escapeHtml(marker.note || '')}</textarea>
                        </div>
                        <div>
                            <label style="display:block;font-weight:600;font-size:0.85rem;margin-bottom:0.25rem;">Severity:</label>
                            <select id="marker-severity-${index}" style="padding:0.5rem;border:2px solid #ddd;border-radius:0.25rem;">
                                <option value="positive" ${marker.severity === 'positive' ? 'selected' : ''}>✓ Positive</option>
                                <option value="minor" ${marker.severity === 'minor' ? 'selected' : ''}>⚠ Minor</option>
                                <option value="moderate" ${marker.severity === 'moderate' ? 'selected' : ''}>⚠ Moderate</option>
                                <option value="major" ${marker.severity === 'major' ? 'selected' : ''}>✕ Major</option>
                            </select>
                        </div>
                    </div>
                `;
            });
            
            if (markers.length === 0) {
                html = '<div class="empty-state"><i data-lucide="map-pin" class="empty-state-icon" aria-hidden="true"></i><p class="empty-state-title">No timeline markers yet</p><p class="empty-state-desc">Add markers to note specific moments in the video (e.g. purpose statement, hands in pockets).</p><div class="empty-state-action"><button type="button" onclick="addNewMarker()" class="btn" style="background: var(--primary); color: white;"><span class="icon-with-text"><i data-lucide="plus"></i> Add New Marker</span></button></div></div>';
            }
            
            document.getElementById('editMarkersList').innerHTML = html;
            var summaryEl = document.getElementById('editMarkersRecurrenceSummary');
            if (summaryEl && markers.length > 0) {
                var summary = getRecurrenceSummary(markers);
                var parts = [];
                for (var k in summary) parts.push(summary[k].label + ' (' + summary[k].count + ')');
                summaryEl.textContent = parts.length ? 'In this video: ' + parts.join(', ') : '';
                summaryEl.style.display = 'block';
            } else if (summaryEl) {
                summaryEl.textContent = '';
                summaryEl.style.display = 'none';
            }
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: document.getElementById('editMarkersList') });
        }
        
        function deleteMarker(index) {
            showConfirmModal('Delete marker', 'Delete this timeline marker?', function() {
                const marker = evaluationResults.timeline_markers[index];
                correctionLog.push({
                    timestamp: new Date().toISOString(),
                    field: 'timeline_marker_removed',
                    marker_index: index,
                    ai_value: marker,
                    reason: 'Marker removed by instructor'
                });
                evaluationResults.timeline_markers.splice(index, 1);
                renderMarkersList();
            }, null, 'Delete');
        }
        
        function addNewMarker() {
            if (!evaluationResults.timeline_markers) {
                evaluationResults.timeline_markers = [];
            }
            
            var newMarker = {
                id: 'm_' + Date.now() + '_' + Math.random().toString(36).slice(2, 9),
                timestamp: '0:00',
                seconds: 0,
                category: 'New Category',
                behavior: '',
                issue: 'New Issue',
                severity: 'minor',
                note: 'Add your observation here...'
            };
            evaluationResults.timeline_markers.push(newMarker);
            correctionLog.push({
                timestamp: new Date().toISOString(),
                field: 'timeline_marker_added',
                reason: 'Marker added by instructor'
            });
            renderMarkersList();
        }

        function duplicateMarker(index) {
            if (!evaluationResults || !evaluationResults.timeline_markers || !evaluationResults.timeline_markers[index]) return;
            var src = evaluationResults.timeline_markers[index];
            var copy = {
                id: 'm_' + Date.now() + '_' + Math.random().toString(36).slice(2, 9),
                timestamp: src.timestamp || '0:00',
                seconds: src.seconds != null ? src.seconds : 0,
                category: src.category || 'Delivery',
                behavior: src.behavior || '',
                issue: src.issue || '',
                severity: src.severity || 'minor',
                note: src.note ? '(another occurrence) ' + src.note : 'Add note for this time.'
            };
            evaluationResults.timeline_markers.splice(index + 1, 0, copy);
            correctionLog.push({
                timestamp: new Date().toISOString(),
                field: 'timeline_marker_duplicated',
                reason: 'Another occurrence added'
            });
            renderMarkersList();
        }
        
        function saveEditedMarkers() {
            if (!evaluationResults || !evaluationResults.timeline_markers) return;
            
            // Update all markers from form inputs
            evaluationResults.timeline_markers.forEach((marker, index) => {
                const timestamp = document.getElementById(`marker-time-${index}`).value;
                const category = document.getElementById(`marker-category-${index}`).value;
                const behaviorVal = document.getElementById(`marker-behavior-${index}`).value;
                const issueInput = document.getElementById(`marker-issue-${index}`).value;
                const note = document.getElementById(`marker-note-${index}`).value;
                const severity = document.getElementById(`marker-severity-${index}`).value;
                
                // Convert timestamp to seconds
                const parts = timestamp.split(':');
                const seconds = parseInt(parts[0]) * 60 + parseInt(parts[1] || 0);
                
                marker.timestamp = timestamp;
                marker.seconds = seconds;
                marker.category = category;
                if (BEHAVIOR_LABELS.includes(behaviorVal)) {
                    marker.behavior = behaviorVal;
                    marker.issue = behaviorVal;
                } else {
                    marker.behavior = '';
                    marker.issue = issueInput;
                }
                marker.note = note;
                marker.severity = severity;
            });
            
            // Re-display results with updated markers
            displayResults(evaluationResults);
            
            closeEditMarkersModal();
            showNotification('✓ Timeline markers updated! Remember to save the evaluation.', 'success');
        }
        
        
        // Correction History Functions
        function viewCorrectionHistory() {
            if (!correctionLog || correctionLog.length === 0) {
                alert('No corrections have been made to this evaluation yet.');
                return;
            }
            
            const content = document.getElementById('correctionHistoryContent');
            let html = `<div style="color:var(--text-light);font-size:0.9rem;margin-bottom:1rem;padding:0.75rem;background:var(--bg-alt);border-radius:0.5rem;">
                <strong>${correctionLog.length}</strong> correction${correctionLog.length !== 1 ? 's' : ''} recorded
            </div>`;
            
            // Group corrections by timestamp for better readability
            correctionLog.forEach((correction, index) => {
                const date = new Date(correction.timestamp);
                const timeStr = date.toLocaleString();
                
                // Determine field display name
                let fieldDisplay = correction.field;
                if (correction.field && correction.field.includes('.')) {
                    const parts = correction.field.split('.');
                    fieldDisplay = `${parts[0]} → ${parts[1]}`;
                    if (parts[2]) fieldDisplay += ` (${parts[2]})`;
                }
                
                // Safely stringify values for display
                const safeStringify = (value) => {
                    if (value == null) return '';
                    if (typeof value === 'object') {
                        try {
                            return escapeHtml(JSON.stringify(value));
                        } catch (e) {
                            return escapeHtml(String(value));
                        }
                    }
                    return escapeHtml(String(value));
                };
                
                html += `
                    <div style="background:white;border:1px solid var(--border);border-radius:0.5rem;padding:1rem;margin-bottom:1rem;border-left:4px solid var(--primary);">
                        <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:0.75rem;">
                            <div>
                                <strong style="color:var(--primary);font-size:0.95rem;">${escapeHtml(fieldDisplay || '')}</strong>
                                <div style="color:var(--text-light);font-size:0.85rem;margin-top:0.25rem;">${escapeHtml(timeStr || '')}</div>
                            </div>
                            <span style="background:var(--bg-alt);padding:0.25rem 0.75rem;border-radius:0.25rem;font-size:0.85rem;font-weight:600;">#${index + 1}</span>
                        </div>
                        
                        ${correction.reason ? `
                        <div style="background:#fffef7;border:2px solid var(--accent);border-radius:0.5rem;padding:0.75rem;margin-bottom:0.75rem;">
                            <div style="font-size:0.85rem;font-weight:700;color:var(--primary);margin-bottom:0.35rem;">Instructor reason for change:</div>
                            <div style="color:var(--text);font-size:0.9rem;font-style:italic;">
                                "${escapeHtml(correction.reason)}"
                            </div>
                        </div>
                        ` : ''}
                        
                        ${correction.ai_value !== undefined ? `
                            <div style="margin-bottom:0.75rem;">
                                <div style="font-size:0.85rem;font-weight:600;color:var(--text-light);margin-bottom:0.25rem;">AI Original:</div>
                                <div style="background:var(--bg-alt);padding:0.5rem;border-radius:0.25rem;font-size:0.9rem;font-family:monospace;">
                                    ${safeStringify(correction.ai_value)}
                                </div>
                            </div>
                            
                            <div style="margin-bottom:0.75rem;">
                                <div style="font-size:0.85rem;font-weight:600;color:var(--primary);margin-bottom:0.25rem;">Instructor Correction:</div>
                                <div style="background:rgba(40,167,69,0.1);padding:0.5rem;border-radius:0.25rem;font-size:0.9rem;border-left:3px solid var(--success);">
                                    ${safeStringify(correction.instructor_value)}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                `;
            });
            
            content.innerHTML = html;
            document.getElementById('correctionHistoryModal').style.display = 'flex';
        }
        
        function closeCorrectionHistoryModal() {
            document.getElementById('correctionHistoryModal').style.display = 'none';
        }
        
        // Update correction count badge when corrections are made
        function updateCorrectionCount() {
            const countSpan = document.getElementById('correctionCount');
            const btn = document.getElementById('viewCorrectionsBtn');
            
            if (correctionLog && correctionLog.length > 0) {
                countSpan.textContent = correctionLog.length;
                btn.style.display = 'inline-block';
            } else {
                btn.style.display = 'none';
            }
        }
        
        // Notification helper
        /* Apple HIG: Enhanced Notification System */
        function showNotification(message, type = 'info', duration = 4000) {
            // Remove any existing notifications to prevent stacking
            const existing = document.querySelectorAll('.notification-toast');
            existing.forEach(n => n.remove());
            
            // Get CSS variable values from computed styles
            const root = document.documentElement;
            const colors = {
                success: getComputedStyle(root).getPropertyValue('--success').trim() || '#059669',
                error: getComputedStyle(root).getPropertyValue('--error').trim() || '#dc2626',
                warning: getComputedStyle(root).getPropertyValue('--warning').trim() || '#d97706',
                info: getComputedStyle(root).getPropertyValue('--primary').trim() || '#1e3a5f'
            };
            
            const icons = {
                success: 'check-circle',
                error: 'alert-circle',
                warning: 'alert-triangle',
                info: 'info'
            };
            
            const notification = document.createElement('div');
            notification.className = 'notification-toast';
            notification.setAttribute('role', 'alert');
            notification.setAttribute('aria-live', type === 'error' ? 'assertive' : 'polite');
            
            notification.style.cssText = `
                position: fixed;
                top: var(--space-lg);
                right: var(--space-lg);
                background: ${colors[type] || colors.info};
                color: white;
                padding: var(--space-md) var(--space-lg);
                border-radius: var(--radius-md);
                box-shadow: var(--elevation-3);
                z-index: 10000;
                display: flex;
                align-items: center;
                gap: var(--space-sm);
                max-width: 400px;
                min-width: 280px;
                animation: notificationSlideIn var(--motion-normal) var(--motion-ease-out);
                font-size: var(--text-body-size);
                line-height: 1.5;
            `;
            
            // Add icon
            const icon = document.createElement('i');
            icon.setAttribute('data-lucide', icons[type] || icons.info);
            icon.style.cssText = 'width: 1.25rem; height: 1.25rem; flex-shrink: 0;';
            notification.appendChild(icon);
            
            // Add message
            const messageEl = document.createElement('span');
            messageEl.textContent = message;
            notification.appendChild(messageEl);
            
            // Add close button
            const closeBtn = document.createElement('button');
            closeBtn.setAttribute('aria-label', 'Close notification');
            closeBtn.innerHTML = '<i data-lucide="x"></i>';
            closeBtn.style.cssText = `
                background: rgba(255, 255, 255, 0.2);
                border: none;
                color: white;
                width: 1.5rem;
                height: 1.5rem;
                border-radius: 50%;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                margin-left: auto;
                padding: 0;
                transition: background-color var(--motion-fast) var(--motion-ease);
            `;
            closeBtn.onmouseenter = () => closeBtn.style.background = 'rgba(255, 255, 255, 0.3)';
            closeBtn.onmouseleave = () => closeBtn.style.background = 'rgba(255, 255, 255, 0.2)';
            closeBtn.onclick = () => {
                notification.style.animation = 'notificationSlideOut var(--motion-normal) var(--motion-ease-in)';
                setTimeout(() => notification.remove(), 250);
            };
            notification.appendChild(closeBtn);
            
            document.body.appendChild(notification);
            
            // Initialize Lucide icons
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons({ root: notification });
            }
            
            // Auto-dismiss
            const timeoutId = setTimeout(() => {
                notification.style.animation = 'notificationSlideOut var(--motion-normal) var(--motion-ease-in)';
                setTimeout(() => notification.remove(), 250);
            }, duration);
            
            // Store timeout ID for manual close
            notification._timeoutId = timeoutId;
        }
        
        // Add notification animations
        if (!document.querySelector('#notification-styles')) {
            const style = document.createElement('style');
            style.id = 'notification-styles';
            style.textContent = `
                @keyframes notificationSlideIn {
                    from {
                        opacity: 0;
                        transform: translateX(100%);
                    }
                    to {
                        opacity: 1;
                        transform: translateX(0);
                    }
                }
                @keyframes notificationSlideOut {
                    from {
                        opacity: 1;
                        transform: translateX(0);
                    }
                    to {
                        opacity: 0;
                        transform: translateX(100%);
                    }
                }
                @media (prefers-reduced-motion: reduce) {
                    @keyframes notificationSlideIn,
                    @keyframes notificationSlideOut {
                        from, to {
                            opacity: 1;
                            transform: none;
                        }
                    }
                }
            `;
            document.head.appendChild(style);
        }

        /** Apple HIG: Show a notification with an Undo button. undoCallback is called when user clicks Undo. */
        function showNotificationWithUndo(message, undoLabel, undoCallback, durationMs) {
            durationMs = durationMs || 8000;
            
            // Remove any existing notifications
            const existing = document.querySelectorAll('.notification-toast');
            existing.forEach(n => n.remove());
            
            const notification = document.createElement('div');
            notification.className = 'notification-toast';
            notification.setAttribute('role', 'alert');
            notification.setAttribute('aria-live', 'polite');
            
            notification.style.cssText = `
                position: fixed;
                top: var(--space-lg);
                right: var(--space-lg);
                background: var(--primary);
                color: white;
                padding: var(--space-md) var(--space-lg);
                border-radius: var(--radius-md);
                box-shadow: var(--elevation-3);
                z-index: 10000;
                display: flex;
                align-items: center;
                gap: var(--space-sm);
                max-width: 400px;
                min-width: 280px;
                animation: notificationSlideIn var(--motion-normal) var(--motion-ease-out);
                font-size: var(--text-body-size);
                line-height: 1.5;
            `;
            
            const icon = document.createElement('i');
            icon.setAttribute('data-lucide', 'info');
            icon.style.cssText = 'width: 1.25rem; height: 1.25rem; flex-shrink: 0;';
            notification.appendChild(icon);
            
            const text = document.createElement('span');
            text.textContent = message;
            text.style.flex = '1';
            notification.appendChild(text);
            
            const undoBtn = document.createElement('button');
            undoBtn.textContent = undoLabel || 'Undo';
            undoBtn.setAttribute('aria-label', 'Undo action');
            undoBtn.style.cssText = `
                background: rgba(255,255,255,0.25);
                border: 1px solid rgba(255,255,255,0.8);
                color: white;
                padding: var(--space-xs) var(--space-sm);
                border-radius: var(--radius-sm);
                cursor: pointer;
                font-weight: 600;
                font-size: var(--text-caption-size);
                transition: background-color var(--motion-fast) var(--motion-ease);
            `;
            undoBtn.onmouseenter = () => undoBtn.style.background = 'rgba(255,255,255,0.35)';
            undoBtn.onmouseleave = () => undoBtn.style.background = 'rgba(255,255,255,0.25)';
            undoBtn.onclick = () => {
                if (typeof undoCallback === 'function') undoCallback();
                notification.style.animation = 'notificationSlideOut var(--motion-normal) var(--motion-ease-in)';
                setTimeout(() => notification.remove(), 250);
                if (tid) clearTimeout(tid);
            };
            notification.appendChild(undoBtn);
            
            document.body.appendChild(notification);
            
            // Initialize Lucide icons
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons({ root: notification });
            }
            
            const tid = setTimeout(() => {
                notification.style.animation = 'notificationSlideOut var(--motion-normal) var(--motion-ease-in)';
                setTimeout(() => notification.remove(), 250);
            }, durationMs);
        }


        // Export evaluation as accessible HTML file
        function downloadPDF() {
            if (!evaluationResults) {
                alert('No evaluation results to download.');
                return;
            }
            // Audit: log export of evaluation report for FERPA
            logAccess('export', 'evaluations', null, null, { purpose: 'download_report', format: 'html' });
            exportEvaluationHTML(evaluationResults, evaluationResults.studentName);
        }
        
        async function exportEvaluationHTML(evaluation, studentName) {
            console.log('Exporting evaluation as accessible HTML...');
            
            // Build timeline markers HTML if they exist
            let timelineHTML = '';
            if (evaluation.timeline_markers && evaluation.timeline_markers.length > 0) {
                normalizeMarkerBehaviors(evaluation.timeline_markers);
                // Group by category
                const markersByCategory = {};
                evaluation.timeline_markers.forEach(marker => {
                    if (!markersByCategory[marker.category]) {
                        markersByCategory[marker.category] = [];
                    }
                    markersByCategory[marker.category].push(marker);
                });
                
                timelineHTML = `
            <section aria-labelledby="timeline-markers">
                <h2 id="timeline-markers">Timeline Markers</h2>
                
                <div class="instructions" role="note">
                    <h3>How to Use Timeline Markers</h3>
                    <p>Open your video file on your device and seek to the timestamps below to review specific moments from your speech. These markers highlight both strengths and areas for improvement.</p>
                </div>
                `;
                
                Object.entries(markersByCategory).forEach(([category, markers]) => {
                    timelineHTML += `
                <article aria-labelledby="${category.toLowerCase().replace(/\s+/g, '-')}-heading">
                    <h3 id="${category.toLowerCase().replace(/\s+/g, '-')}-heading">${category}</h3>
                    `;
                    
                    markers.forEach(marker => {
                        const severityClass = marker.severity || 'minor';
                        const icon = {positive: '✓', minor: '⚠', moderate: '⚠', major: '✕'}[severityClass] || '⚠';
                        
                        timelineHTML += `
                    <div class="marker ${severityClass}" role="article" aria-label="${severityClass === 'positive' ? 'Strength' : 'Area for improvement'} at ${marker.timestamp}">
                        <div class="marker-time" aria-label="Timestamp">${marker.timestamp}</div>
                        <div class="marker-content">
                            <h4><span aria-hidden="true">${icon}</span> ${escapeHtml(marker.issue || '')}${marker.behavior ? ` <span class="behavior-pill" style="background: var(--primary); color: white; font-size: 0.75rem; padding: 0.2rem 0.5rem; border-radius: 999px; font-weight: 500;">${escapeHtml(marker.behavior)}</span>` : ''}</h4>
                            <p>${escapeHtml(marker.note || '')}</p>
                        </div>
                    </div>
                        `;
                    });
                    
                    timelineHTML += `</article>`;
                });
                
                timelineHTML += `</section>`;
            }
            
            // Create complete HTML document
            const htmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speech Evaluation - ${studentName}</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Work Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; line-height: 1.6; color: #333; max-width: 800px; margin: 0 auto; padding: 2rem; background: #f5f5f5; }
        .container { background: white; padding: 3rem; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        :focus { outline: 3px solid var(--primary); outline-offset: 2px; }
        @media (prefers-contrast: high) { body { background: white; color: black; } .container { border: 2px solid black; } }
        @media print { body { background: white; padding: 0; } .container { box-shadow: none; padding: 1rem; } .no-print { display: none !important; } .section, .marker { page-break-inside: avoid; } }
        h1, h2, h3 { font-family: 'Crimson Pro', serif; }
        h1 { font-size: 2rem; color: #1e293b; margin-bottom: 1.5rem; border-bottom: 3px solid var(--primary); padding-bottom: 0.5rem; }
        h2 { font-size: 1.5rem; color: #1e293b; margin: 2rem 0 1rem 0; }
        h3 { font-size: 1.25rem; color: #334155; margin: 1.5rem 0 0.75rem 0; }
        .meta-info { background: #f1f5f9; padding: 1rem; border-radius: 4px; margin-bottom: 2rem; }
        .meta-info p { margin: 0.25rem 0; }
        .score-highlight { background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%); color: white; padding: 1.5rem; border-radius: 8px; margin: 2rem 0; }
        .score-highlight h2 { color: white; margin: 0 0 0.5rem 0; }
        .section { background: #f8fafc; padding: 1.5rem; border-radius: 4px; margin-bottom: 1rem; border-left: 4px solid var(--primary); }
        .section-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; }
        .section-score { font-size: 1.25rem; font-weight: bold; color: var(--primary); }
        .marker { display: flex; gap: 1rem; background: white; padding: 1rem; border-radius: 4px; margin-bottom: 0.75rem; border-left: 3px solid; }
        .marker.positive { border-left-color: #10b981; }
        .marker.minor { border-left-color: #f59e0b; }
        .marker.moderate { border-left-color: #f59e0b; }
        .marker.major { border-left-color: #ef4444; }
        .marker-time { min-width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; border-radius: 4px; font-weight: bold; color: white; flex-shrink: 0; }
        .marker.positive .marker-time { background: #10b981; }
        .marker.minor .marker-time { background: #f59e0b; }
        .marker.moderate .marker-time { background: #f59e0b; }
        .marker.major .marker-time { background: #ef4444; }
        .marker-content h4 { margin: 0 0 0.5rem 0; color: #1e293b; }
        .marker-content p { margin: 0; color: #64748b; }
        .instructions { background: #fef3c7; border: 1px solid #f59e0b; padding: 1rem; border-radius: 4px; margin: 1rem 0; }
        .instructions h3 { margin-top: 0; color: #92400e; }
        .button { display: inline-block; background: var(--primary); color: white; padding: 0.75rem 1.5rem; border-radius: 4px; text-decoration: none; font-weight: 600; border: none; cursor: pointer; margin-right: 1rem; }
        .button:hover { background: var(--primary-dark); }
        .skip-link { position: absolute; top: -40px; left: 0; background: var(--primary); color: white; padding: 8px; z-index: 100; }
        .skip-link:focus { top: 0; }
    </style>
</head>
<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>
    <div class="container">
        <div class="no-print" style="margin-bottom: 2rem; display: flex; gap: 1rem;">
            <button onclick="window.print()" class="button">🖨️ Print / Save as PDF</button>
            <button onclick="window.close()" class="button" style="background: #6b7280;">✕ Close</button>
        </div>
        <main id="main-content">
            <header>
                <h1>Speech Evaluation Report</h1>
                <div class="meta-info" role="contentinfo">
                    <p><strong>Student:</strong> ${studentName}</p>
                    <p><strong>Date:</strong> ${evaluation.speechDate || new Date().toLocaleDateString()}</p>
                    <p><strong>Assignment:</strong> ${evaluation.assignmentType || 'Speech Evaluation'}</p>
                    <p><strong>Rubric:</strong> ${evaluation.rubricUsed || 'Standard'}</p>
                </div>
            </header>
            <section class="score-highlight" aria-labelledby="overall-score">
                <h2 id="overall-score">Overall Score</h2>
                <p style="font-size: 2rem; margin: 0.5rem 0;">${evaluation.totalScore}/${evaluation.maxScore} <span style="font-size: 1.5rem;">(${evaluation.percentage}%)</span></p>
                <p style="font-size: 1.5rem; margin: 0;">Grade: ${evaluation.letterGrade}</p>
            </section>
            <section aria-labelledby="section-scores">
                <h2 id="section-scores">Section & Subsection Scores & Feedback</h2>
                ${Object.keys(evaluation.sections || {}).map(sectionKey => {
                    const section = evaluation.sections[sectionKey];
                    const sectionName = sectionKey.charAt(0).toUpperCase() + sectionKey.slice(1);
                    let subsHTML = '';
                    const subs = section.subcategories || [];
                    if (Array.isArray(subs) && subs.length > 0) {
                        subsHTML = '<ul style="margin: 0.5rem 0 0 1rem; padding-left: 1rem;">' + subs.map(sub => {
                            const pts = sub.points !== undefined ? sub.points : 'N/A';
                            const max = sub.maxPoints || 0;
                            const grade = sub.grade ? ` (${sub.grade})` : '';
                            return `<li><strong>${sub.name || 'Subcategory'}</strong>: ${pts}/${max}${grade}${sub.feedback ? `<br><span style="font-size:0.9em;color:#64748b;">${sub.feedback}</span>` : ''}</li>`;
                        }).join('') + '</ul>';
                    }
                    return `<article class="section"><div class="section-header"><h3>${sectionName}</h3><span class="section-score" aria-label="${sectionName} score">${section.score}/${section.maxScore}</span></div>${subsHTML}<p>${section.feedback || 'No feedback provided.'}</p></article>`;
                }).join('')}
            </section>
            ${timelineHTML}
            <footer style="margin-top: 3rem; padding-top: 2rem; border-top: 1px solid #e2e8f0; color: #64748b; font-size: 0.875rem;">
                <p>Generated by SpeechGradebook on ${new Date().toLocaleDateString()}</p>
            </footer>
        </main>
    </div>
</body>
</html>`;
            
            // Create blob and download
            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${studentName.replace(/\s+/g, '_')}_Evaluation_${evaluation.speechDate || 'report'}.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log('✓ Accessible HTML evaluation exported');
        }
        
        window.exportEvaluationHTML = exportEvaluationHTML;

        async function emailResults() {
            if (!evaluationResults) {
                alert('No evaluation results to email.');
                return;
            }
            
            // Get evaluation ID and student ID for shareable link
            let evaluationId = editingEvaluationId;
            let studentId = editingStudentId;
            let studentEmail = '';
            
            // If editing, try to get student email from Supabase
            if (editingEvaluationId && supabaseClient) {
                try {
                    const { data: evalData } = await supabaseClient
                        .from('evaluations')
                        .select('student_id, course_students!inner(email)')
                        .eq('id', editingEvaluationId)
                        .single();
                    
                    if (evalData) {
                        studentId = evalData.student_id || studentId;
                        // Get student email separately
                        if (studentId) {
                            const { data: studentData } = await supabaseClient
                                .from('course_students')
                                .select('email')
                                .eq('id', studentId)
                                .single();
                            if (studentData) {
                                studentEmail = studentData.email || '';
                            }
                        }
                    }
                } catch (e) {
                    console.warn('Could not load student email from Supabase:', e);
                }
            }
            
            // If not editing, try to get from current save selection
            if (!evaluationId || !studentId) {
                // Try to get from step 2 selectors first, then save modal
                const evalClassSelect = document.getElementById('evalClassSelect');
                const evalStudentSelect = document.getElementById('evalStudentSelect');
                let saveClassIdx = null;
                let saveStudentIdx = null;
                
                if (evalClassSelect?.value && evalClassSelect.value !== '' && evalClassSelect.value !== 'other') {
                    const classes = JSON.parse(getUserItem('classes') || '[]');
                    const classIndex = classes.findIndex(c => 
                        (c.id === evalClassSelect.value || c.name === evalClassSelect.value) ||
                        (Array.isArray(classes) && classes[parseInt(evalClassSelect.value)])
                    );
                    if (classIndex !== -1) {
                        saveClassIdx = classIndex;
                        if (evalStudentSelect?.value && evalStudentSelect.value !== '') {
                            const selectedClass = classes[classIndex];
                            if (selectedClass && selectedClass.roster) {
                                const studentIndex = selectedClass.roster.findIndex(s =>
                                    (s.id === evalStudentSelect.value || s.studentId === evalStudentSelect.value) ||
                                    (Array.isArray(selectedClass.roster) && selectedClass.roster[parseInt(evalStudentSelect.value)])
                                );
                                if (studentIndex !== -1) {
                                    saveStudentIdx = studentIndex;
                                }
                            }
                        }
                    }
                }
                
                // Fallback to save modal if not set in step 2
                if (!saveClassIdx) {
                    saveClassIdx = document.getElementById('saveClassSel')?.value;
                }
                if (!saveStudentIdx) {
                    saveStudentIdx = document.getElementById('saveStudentSel')?.value;
                }
                if (saveClassIdx && saveStudentIdx) {
                    try {
                        const classes = JSON.parse(getUserItem('classes') || '[]');
                        const classData = classes[saveClassIdx];
                        const student = classData?.roster?.[saveStudentIdx];
                        if (student) {
                            studentId = student.supabaseId || student.id;
                            studentEmail = student.email || '';
                            // Try to find existing evaluation ID
                            if (student.evaluations && student.evaluations.length > 0) {
                                const latestEval = student.evaluations[student.evaluations.length - 1];
                                evaluationId = latestEval.supabaseId || latestEval.id;
                            }
                        }
                    } catch (e) {
                        console.warn('Could not get student info for email:', e);
                    }
                }
            }
            
            // Generate shareable link if we have IDs
            let shareableLink = '';
            if (evaluationId && studentId) {
                const baseUrl = window.location.origin + window.location.pathname;
                shareableLink = `${baseUrl}?view=evaluation&evalId=${encodeURIComponent(evaluationId)}&studentId=${encodeURIComponent(studentId)}`;
            }
            
            // Prompt for student email (pre-fill if we have it)
            const emailPrompt = studentEmail 
                ? `Enter student email address:\n\n(Current: ${studentEmail})`
                : 'Enter student email address:';
            const enteredEmail = prompt(emailPrompt, studentEmail || '');
            
            if (!enteredEmail || !enteredEmail.includes('@')) {
                if (enteredEmail !== null) { // User didn't cancel
                    alert('Please enter a valid email address.');
                }
                return;
            }
            
            const subject = `Speech Evaluation Results - ${evaluationResults.assignmentType || 'Speech'}`;
            let body = `Dear Student,\n\nYour speech evaluation results are ready.\n\nFinal Score: ${evaluationResults.totalScore || 0} / ${evaluationResults.maxScore || 0}\nGrade: ${evaluationResults.letterGrade || 'N/A'}\n\n`;
            
            if (shareableLink) {
                body += `View your complete evaluation results and watch your speech video here:\n${shareableLink}\n\n`;
            } else {
                body += `Please contact your instructor to view your complete evaluation details.\n\n`;
            }
            
            body += `Please contact your instructor if you have any questions.\n\nBest regards`;
            
            const mailtoLink = `mailto:${enteredEmail}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
            window.open(mailtoLink);
        }

        function startOver() {
            uploadedFile = null;
            evaluationResults = null;
            document.getElementById('studentForm').reset();
            document.getElementById('fileInfo').classList.add('hidden');
            document.getElementById('fileInput').value = '';
            hideEvaluationSavedIndicator(); // Hide indicator when starting over
            moveToStep(1);
        }
        
        // Render action buttons for results page (Apple HIG compliant)
        function renderResultsActionButtons(isEditing) {
            const buttonsContainer = document.getElementById('resultsActionButtons');
            if (!buttonsContainer) return;
            
            // Clear existing buttons
            buttonsContainer.innerHTML = '';
            
            // Apple HIG button styles
            const primaryButtonStyle = 'background: #007AFF; color: white; border: none; padding: 12px 24px; border-radius: 10px; cursor: pointer; font-weight: 600; font-size: 17px; min-width: 88px; min-height: 44px; display: inline-flex; align-items: center; justify-content: center; gap: 6px; transition: all 0.2s ease; font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif; letter-spacing: -0.34px; box-shadow: 0 2px 8px rgba(0, 122, 255, 0.3);';
            const secondaryButtonStyle = 'background: #ffffff; color: #1d1d1f; border: 1px solid #d2d2d7; padding: 12px 24px; border-radius: 10px; cursor: pointer; font-weight: 600; font-size: 17px; min-width: 88px; min-height: 44px; display: inline-flex; align-items: center; justify-content: center; gap: 6px; transition: all 0.2s ease; font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif; letter-spacing: -0.34px;';
            const destructiveButtonStyle = 'background: #FF3B30; color: white; border: none; padding: 12px 24px; border-radius: 10px; cursor: pointer; font-weight: 600; font-size: 17px; min-width: 88px; min-height: 44px; display: inline-flex; align-items: center; justify-content: center; gap: 6px; transition: all 0.2s ease; font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif; letter-spacing: -0.34px;';
            
            // Primary action: Save Results
            const saveBtn = document.createElement('button');
            saveBtn.setAttribute('id', 'saveResultsBtn');
            saveBtn.setAttribute('onclick', 'openSaveModal()');
            saveBtn.setAttribute('style', primaryButtonStyle);
            saveBtn.setAttribute('onmouseover', 'this.style.backgroundColor="#0051D5"; this.style.boxShadow="0 4px 12px rgba(0, 122, 255, 0.4)"');
            saveBtn.setAttribute('onmouseout', 'this.style.backgroundColor="#007AFF"; this.style.boxShadow="0 2px 8px rgba(0, 122, 255, 0.3)"');
            saveBtn.innerHTML = '<i data-lucide="save" style="width:18px;height:18px;"></i> Save Results';
            buttonsContainer.appendChild(saveBtn);
            
            // Secondary actions
            const moveBtn = document.createElement('button');
            moveBtn.setAttribute('onclick', `openMoveEvalModal(editingEvaluationId, editingCourseId, editingStudentId)`);
            moveBtn.setAttribute('class', 'btn-secondary');
            moveBtn.setAttribute('id', 'moveEvalBtn');
            moveBtn.setAttribute('style', secondaryButtonStyle + ' display: none;');
            moveBtn.setAttribute('onmouseover', 'this.style.backgroundColor="#f5f5f7"; this.style.borderColor="#007AFF"');
            moveBtn.setAttribute('onmouseout', 'this.style.backgroundColor="#ffffff"; this.style.borderColor="#d2d2d7"');
            moveBtn.innerHTML = '<i data-lucide="move" style="width:18px;height:18px;"></i> Move to Different Class/Student';
            buttonsContainer.appendChild(moveBtn);
            
            const downloadBtn = document.createElement('button');
            downloadBtn.setAttribute('onclick', 'downloadPDF()');
            downloadBtn.setAttribute('class', 'btn-secondary');
            downloadBtn.setAttribute('style', secondaryButtonStyle);
            downloadBtn.setAttribute('onmouseover', 'this.style.backgroundColor="#f5f5f7"; this.style.borderColor="#007AFF"');
            downloadBtn.setAttribute('onmouseout', 'this.style.backgroundColor="#ffffff"; this.style.borderColor="#d2d2d7"');
            downloadBtn.innerHTML = '<i data-lucide="file-text" style="width:18px;height:18px;"></i> Download Report (HTML)';
            buttonsContainer.appendChild(downloadBtn);
            
            const emailBtn = document.createElement('button');
            emailBtn.setAttribute('onclick', 'emailResults()');
            emailBtn.setAttribute('class', 'btn-secondary');
            emailBtn.setAttribute('style', secondaryButtonStyle);
            emailBtn.setAttribute('onmouseover', 'this.style.backgroundColor="#f5f5f7"; this.style.borderColor="#007AFF"');
            emailBtn.setAttribute('onmouseout', 'this.style.backgroundColor="#ffffff"; this.style.borderColor="#d2d2d7"');
            emailBtn.innerHTML = '<i data-lucide="mail" style="width:18px;height:18px;"></i> Email Results';
            buttonsContainer.appendChild(emailBtn);
            
            const correctionsBtn = document.createElement('button');
            correctionsBtn.setAttribute('onclick', 'viewCorrectionHistory()');
            correctionsBtn.setAttribute('class', 'btn-secondary');
            correctionsBtn.setAttribute('id', 'viewCorrectionsBtn');
            correctionsBtn.setAttribute('style', secondaryButtonStyle + ' display: none;');
            correctionsBtn.setAttribute('onmouseover', 'this.style.backgroundColor="#f5f5f7"; this.style.borderColor="#007AFF"');
            correctionsBtn.setAttribute('onmouseout', 'this.style.backgroundColor="#ffffff"; this.style.borderColor="#d2d2d7"');
            correctionsBtn.innerHTML = '<i data-lucide="clipboard-list" style="width:18px;height:18px;"></i> View Corrections (<span id="correctionCount">0</span>)';
            buttonsContainer.appendChild(correctionsBtn);
            
            // Cancel Edit button (only when editing)
            if (isEditing && editingEvaluationId) {
                const cancelEditBtn = document.createElement('button');
                cancelEditBtn.setAttribute('onclick', 'cancelEdit()');
                cancelEditBtn.setAttribute('style', destructiveButtonStyle);
                cancelEditBtn.setAttribute('onmouseover', 'this.style.backgroundColor="#D70015"');
                cancelEditBtn.setAttribute('onmouseout', 'this.style.backgroundColor="#FF3B30"');
                cancelEditBtn.innerHTML = '<i data-lucide="x" style="width:18px;height:18px;"></i> Cancel Edit';
                buttonsContainer.appendChild(cancelEditBtn);
            }
            
            // Start Over button
            const startOverBtn = document.createElement('button');
            startOverBtn.setAttribute('onclick', 'startOver()');
            startOverBtn.setAttribute('class', 'btn-secondary');
            startOverBtn.setAttribute('style', secondaryButtonStyle);
            startOverBtn.setAttribute('onmouseover', 'this.style.backgroundColor="#f5f5f7"; this.style.borderColor="#007AFF"');
            startOverBtn.setAttribute('onmouseout', 'this.style.backgroundColor="#ffffff"; this.style.borderColor="#d2d2d7"');
            startOverBtn.innerHTML = '<i data-lucide="refresh-cw" style="width:18px;height:18px;"></i> Start Over';
            buttonsContainer.appendChild(startOverBtn);
            
            // Initialize Lucide icons for the buttons
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons({ root: buttonsContainer });
            }
        }
        
        // Show persistent "Evaluation Saved" indicator
        // The indicator will stay visible until the user clicks anywhere on the screen
        let evaluationSavedClickHandler = null;
        // Show popup notification when evaluation is saved (appears in viewport center)
        function showEvaluationSavedPopup(message) {
            const popup = document.getElementById('evaluationSavedPopup');
            const messageEl = document.getElementById('evaluationSavedPopupMessage');
            if (popup && messageEl) {
                messageEl.textContent = message || 'Evaluation saved';
                popup.classList.remove('hidden');
                // Re-initialize Lucide icons
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons({ root: popup });
                }
            }
        }
        
        // Hide popup notification
        function hideEvaluationSavedPopup() {
            const popup = document.getElementById('evaluationSavedPopup');
            if (popup) {
                popup.classList.add('hidden');
            }
        }
        
        // Show post-save guidance
        function showPostSaveGuidance() {
            const resultsContent = document.getElementById('resultsContent');
            if (!resultsContent) return;
            
            // Check if guidance already exists
            let guidanceEl = document.getElementById('postSaveGuidance');
            if (guidanceEl) {
                guidanceEl.remove();
            }
            
            const evalClassSelect = document.getElementById('evalClassSelect');
            const evalStudentSelect = document.getElementById('evalStudentSelect');
            const hasClassAndStudent = evalClassSelect?.value && evalClassSelect.value !== '' && evalClassSelect.value !== 'other' &&
                                     evalStudentSelect?.value && evalStudentSelect.value !== '';
            
            let guidanceHtml = `
                <div id="postSaveGuidance" style="background: linear-gradient(135deg, rgba(0, 122, 255, 0.1) 0%, rgba(0, 122, 255, 0.05) 100%); border: 1px solid rgba(0, 122, 255, 0.2); border-radius: 12px; padding: 1.25rem; margin-bottom: 1.5rem; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', sans-serif;">
                    <div style="display: flex; align-items: flex-start; gap: 0.75rem;">
                        <i data-lucide="lightbulb" style="width:20px;height:20px;color:var(--primary);flex-shrink:0;margin-top:0.125rem;"></i>
                        <div style="flex: 1;">
                            <h4 style="margin: 0 0 0.5rem 0; font-size: 1rem; font-weight: 600; color: var(--text);">What's Next?</h4>
                            <div style="display: flex; flex-wrap: wrap; gap: 0.75rem; margin-top: 0.75rem;">
            `;
            
            if (hasClassAndStudent) {
                guidanceHtml += `
                    <button onclick="viewStudentEvals('${evalStudentSelect.value}');" style="padding: 0.625rem 1rem; background: white; color: var(--primary); border: 1px solid var(--primary); border-radius: 0.5rem; cursor: pointer; font-size: 0.875rem; font-weight: 500; transition: all 0.2s ease; display: inline-flex; align-items: center; gap: 0.5rem;" onmouseover="this.style.background='var(--primary)'; this.style.color='white'" onmouseout="this.style.background='white'; this.style.color='var(--primary)'">
                        <i data-lucide="user"></i> View Student Evaluations
                    </button>
                `;
            }
            
            guidanceHtml += `
                                <button onclick="showEvaluate();" style="padding: 0.625rem 1rem; background: white; color: var(--primary); border: 1px solid var(--primary); border-radius: 0.5rem; cursor: pointer; font-size: 0.875rem; font-weight: 500; transition: all 0.2s ease; display: inline-flex; align-items: center; gap: 0.5rem;" onmouseover="this.style.background='var(--primary)'; this.style.color='white'" onmouseout="this.style.background='white'; this.style.color='var(--primary)'">
                                    <i data-lucide="mic"></i> Evaluate Another Speech
                                </button>
                                <button onclick="downloadPDF();" style="padding: 0.625rem 1rem; background: white; color: var(--primary); border: 1px solid var(--primary); border-radius: 0.5rem; cursor: pointer; font-size: 0.875rem; font-weight: 500; transition: all 0.2s ease; display: inline-flex; align-items: center; gap: 0.5rem;" onmouseover="this.style.background='var(--primary)'; this.style.color='white'" onmouseout="this.style.background='white'; this.style.color='var(--primary)'">
                                    <i data-lucide="file-text"></i> Download Report
                                </button>
                            </div>
                        </div>
                        <button onclick="document.getElementById('postSaveGuidance')?.remove();" style="background: transparent; border: none; padding: 0.25rem; cursor: pointer; color: var(--text-light); border-radius: 0.25rem; flex-shrink: 0;" onmouseover="this.style.background='rgba(0,0,0,0.1)'" onmouseout="this.style.background='transparent'">
                            <i data-lucide="x" style="width:16px;height:16px;"></i>
                        </button>
                    </div>
                </div>
            `;
            
            // Insert at the beginning of results content
            resultsContent.insertAdjacentHTML('afterbegin', guidanceHtml);
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons({ root: document.getElementById('postSaveGuidance') });
            }
        }
        
        function showEvaluationSavedIndicator(message) {
            const indicator = document.getElementById('evaluationSavedIndicator');
            const messageEl = document.getElementById('evaluationSavedMessage');
            if (indicator && messageEl) {
                messageEl.textContent = message || 'Evaluation saved';
                indicator.classList.remove('hidden');
                indicator.style.display = 'flex'; // Ensure it's visible when not hidden
                // Re-initialize Lucide icons for the indicator
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                }
                
                // Remove any existing click handler to avoid duplicates
                if (evaluationSavedClickHandler) {
                    document.removeEventListener('click', evaluationSavedClickHandler);
                }
                
                // Add click handler to hide indicator when user clicks anywhere
                // (except on the indicator itself or its dismiss button)
                evaluationSavedClickHandler = function(event) {
                    // Don't hide if clicking on the indicator or its children
                    if (indicator && indicator.contains(event.target)) {
                        return;
                    }
                    // Hide the indicator
                    hideEvaluationSavedIndicator();
                    // Remove the event listener after hiding
                    document.removeEventListener('click', evaluationSavedClickHandler);
                    evaluationSavedClickHandler = null;
                };
                
                // Use capture phase to ensure we catch clicks before they bubble
                document.addEventListener('click', evaluationSavedClickHandler, true);
            }
        }
        
        // Hide persistent "Evaluation Saved" indicator
        function hideEvaluationSavedIndicator() {
            const indicator = document.getElementById('evaluationSavedIndicator');
            if (indicator) {
                indicator.classList.add('hidden');
                indicator.style.display = 'none'; // Ensure it's hidden
            }
            // Remove click handler when hiding
            if (evaluationSavedClickHandler) {
                document.removeEventListener('click', evaluationSavedClickHandler);
                evaluationSavedClickHandler = null;
            }
        }

        // ===== CLASSES MANAGEMENT =====
        /** Build HTML for one course card (shared by flat and grouped render). */
        async function buildOneCourseCard(cls) {
            let evalCount = 0;
            if (supabaseClient && cls.supabaseId) {
                const supabaseEvals = await loadEvaluationsFromSupabase(cls.supabaseId);
                if (supabaseEvals) {
                    const visible = supabaseEvals.filter(ev => !isDeletedId('deleted_evaluation_ids', ev.id));
                    evalCount = visible.length;
                }
            }
            if (cls.roster) {
                cls.roster.forEach(student => {
                    if (student.evaluations) evalCount += student.evaluations.length;
                });
            }
            const courseIdForMenu = String(cls.id || '').replace(/\\/g, '\\\\').replace(/'/g, "\\'");
            return `
            <div class="class-card" data-class-id="${cls.id}" style="position: relative;">
                <button type="button" onclick="var e=event||window.event;if(e){e.stopPropagation();e.preventDefault();}window.toggleCourseActionsMenu('${courseIdForMenu}',e);return false;" class="course-actions-menu-trigger" style="position: absolute; top: 0.75rem; right: 0.75rem; background: none; border: none; padding: 0.5rem; cursor: pointer; border-radius: 0.25rem; color: var(--text-light); transition: background 0.15s; z-index: 10;" aria-label="Course actions" title="Course actions" aria-haspopup="true" aria-expanded="false" onmouseover="this.style.background='var(--bg-alt)'" onmouseout="this.style.background='none'">
                    <i data-lucide="more-vertical" style="width: 1.25rem; height: 1.25rem;"></i>
                </button>
                <div id="courseActionsMenu_${courseIdForMenu}" class="course-actions-menu hidden" style="position: absolute; right: 0.75rem; top: 2.5rem; background: white; border: 1px solid var(--border); border-radius: 0.5rem; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; min-width: 180px; padding: 0.25rem 0;">
                    <button type="button" onclick="if(event)event.stopPropagation();window.editCourse('${courseIdForMenu}');window.toggleCourseActionsMenu('${courseIdForMenu}');return false;" style="width: 100%; text-align: left; padding: 0.5rem 0.75rem; border: none; background: none; cursor: pointer; font-size: 0.875rem; color: var(--text); display: flex; align-items: center; gap: 0.5rem; transition: background 0.15s;" onmouseover="this.style.background='var(--bg-alt)'" onmouseout="this.style.background='white'"><i data-lucide="pencil" style="width:1rem;height:1rem;"></i> Edit</button>
                    <button type="button" onclick="if(event)event.stopPropagation();window.moveCourse('${courseIdForMenu}');window.toggleCourseActionsMenu('${courseIdForMenu}');return false;" style="width: 100%; text-align: left; padding: 0.5rem 0.75rem; border: none; background: none; cursor: pointer; font-size: 0.875rem; color: var(--text); display: flex; align-items: center; gap: 0.5rem; transition: background 0.15s;" onmouseover="this.style.background='var(--bg-alt)'" onmouseout="this.style.background='white'"><i data-lucide="move" style="width:1rem;height:1rem;"></i> Move</button>
                    <div style="border-top: 1px solid var(--border); margin: 0.25rem 0;"></div>
                    <button type="button" onclick="if(event)event.stopPropagation();window.deleteCourse('${courseIdForMenu}');window.toggleCourseActionsMenu('${courseIdForMenu}');return false;" style="width: 100%; text-align: left; padding: 0.5rem 0.75rem; border: none; background: none; cursor: pointer; font-size: 0.875rem; color: var(--error, #dc2626); display: flex; align-items: center; gap: 0.5rem; transition: background 0.15s;" onmouseover="this.style.background='var(--bg-alt)'" onmouseout="this.style.background='white'"><i data-lucide="trash-2" style="width:1rem;height:1rem;"></i> Delete</button>
                </div>
                <div class="class-header">${escapeHtml(cls.name)}</div>
                <div class="class-meta">
                    ${escapeHtml(cls.semester || '')} ${escapeHtml((cls.year || '').toString())} • Section ${escapeHtml(cls.section || '')}
                </div>
                <p style="color: var(--text-light); font-size: 0.9rem; margin-bottom: 1rem;">
                    ${escapeHtml(cls.notes || 'No description')}
                </p>
                <div class="class-stats">
                    <div class="stat">
                        <div class="stat-value">${(cls.roster || []).length}</div>
                        <div class="stat-label">Students</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${evalCount}</div>
                        <div class="stat-label">Evaluations</div>
                    </div>
                </div>
            </div>
            `;
        }
        /** Render course cards into classesGrid. For instructor Current/Previous: classesToRender is flat array (current) or array of { label, courses } (previous). */
        function renderInstructorCoursesGrid(classesToRender) {
            const grid = document.getElementById('classesGrid');
            if (!grid) return;
            const isGrouped = Array.isArray(classesToRender) && classesToRender.length > 0 && classesToRender[0] && typeof classesToRender[0].label === 'string' && Array.isArray(classesToRender[0].courses);
            // Cache the rendered HTML after rendering
            const cacheKey = _coursesViewTab;
            const dataHash = hashCoursesData(classesToRender);
            if (isGrouped) {
                const groupPromises = classesToRender.map(async group => {
                    // Apply saved order to courses in this group
                    let courses = group.courses || [];
                    const savedOrder = getUserItem('courseOrder');
                    if (savedOrder) {
                        try {
                            const order = JSON.parse(savedOrder);
                            courses = order.map(id => courses.find(c => c.id === id)).filter(c => c)
                                .concat(courses.filter(c => !order.includes(c.id)));
                        } catch (e) {
                            console.warn('Failed to parse course order:', e);
                        }
                    }
                    const cards = await Promise.all(courses.map(cls => buildOneCourseCard(cls)));
                    return '<div class="courses-group" style="margin-bottom: 1.5rem;"><h3 style="font-size: 1rem; margin: 0 0 0.75rem 0; color: var(--text-light); border-bottom: 1px solid var(--border); padding-bottom: 0.35rem;">' + escapeHtml(group.label) + '</h3><div class="classes-grid" style="display: grid; gap: 1rem;">' + cards.join('') + '</div></div>';
                });
                Promise.all(groupPromises).then(htmlParts => {
                    const html = htmlParts.join('');
                    grid.innerHTML = html;
                    attachCourseCardListeners(grid);
                    // Cache the rendered HTML
                    _coursesGridCache[cacheKey] = { html: html, dataHash: dataHash };
                });
                return;
            }
            let classes = classesToRender || [];
            // Apply saved order
            const savedOrder = getUserItem('courseOrder');
            if (savedOrder) {
                try {
                    const order = JSON.parse(savedOrder);
                    classes = order.map(id => classes.find(c => c.id === id)).filter(c => c)
                        .concat(classes.filter(c => !order.includes(c.id)));
                } catch (e) {
                    console.warn('Failed to parse course order:', e);
                }
            }
            Promise.all(classes.map(cls => buildOneCourseCard(cls))).then(cards => {
                const html = cards.join('');
                grid.innerHTML = html;
                attachCourseCardListeners(grid);
                // Cache the rendered HTML
                _coursesGridCache[cacheKey] = { html: html, dataHash: dataHash };
            });
        }

        async function loadClasses() {
            // For instructor, show loading state immediately so we never flash demo or stale courses
            const grid = document.getElementById('classesGrid');
            if (grid && typeof userTier !== 'undefined' && userTier === 'instructor') {
                grid.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-light);"><span class="spinner" style="display: inline-block; width: 1.5rem; height: 1.5rem; border: 2px solid var(--border); border-top-color: var(--primary); border-radius: 50%; animation: spin 0.8s linear infinite;"></span><p style="margin-top: 0.75rem;">Loading courses…</p></div>';
            }

            // Try Supabase first
            const supabaseCourses = await loadCoursesFromSupabase();
            
            let classes = [];
            
            if (supabaseCourses && supabaseCourses.length > 0) {
                // Convert Supabase format to app format
                classes = supabaseCourses.map(course => ({
                    id: course.id,
                    supabaseId: course.id,
                    name: course.name,
                    semester: course.semester || 'Fall',
                    section: course.code || '001',
                    year: course.year?.toString() || '2024',
                    notes: '',
                    roster: (course.course_students || []).filter(s => !s.deleted_locally_at && !isDeletedId('deleted_student_ids', course.id + ':' + s.id)).map(student => ({
                        supabaseId: student.id,
                        firstName: student.first_name,
                        lastName: student.last_name,
                        name: `${student.first_name} ${student.last_name}`,
                        email: student.email || '',
                        studentId: student.student_id || '',
                        evaluations: []
                    })),
                    evaluations: []
                }));
                classes = classes.filter(c => !isDeletedId('deleted_course_ids', c.id));
                
                // Store in user-scoped localStorage so viewClass can find them
                setUserItem('classes', JSON.stringify(classes));
                console.log('✓ Synced Supabase classes to user-scoped localStorage');
            } else if (Array.isArray(supabaseCourses) && supabaseCourses.length === 0) {
                classes = [];
            } else {
                classes = JSON.parse(getUserItem('classes') || '[]');
            }
            classes = classes.filter(c => !isDeletedId('deleted_course_ids', c.id));
            
            // Demo: seed sample courses and persist so viewClass can find them
            if (typeof userTier !== 'undefined' && userTier === 'demo' && classes.length === 0) {
                classes = [
                    { id: 'demo-c1', supabaseId: null, name: 'COMM 101', semester: 'Fall', section: '001', year: '2025', notes: 'Introduction to Public Speaking (demo)', roster: [{ supabaseId: null, firstName: 'Alex', lastName: 'Smith', name: 'Alex Smith', email: 'alex@example.edu', studentId: '', evaluations: [] }, { supabaseId: null, firstName: 'Jordan', lastName: 'Lee', name: 'Jordan Lee', email: 'jordan@example.edu', studentId: '', evaluations: [] }], evaluations: [] },
                    { id: 'demo-c2', supabaseId: null, name: 'COMM 205', semester: 'Fall', section: '002', year: '2025', notes: 'Persuasive Speaking (demo)', roster: [{ supabaseId: null, firstName: 'Sam', lastName: 'Jones', name: 'Sam Jones', email: 'sam@example.edu', studentId: '', evaluations: [] }], evaluations: [] }
                ];
                setUserItem('classes', JSON.stringify(classes));
            }
            
            const isInstructorView = userTier === 'instructor' || (currentViewMode === 'own' && typeof isAdmin === 'function' && !isAdmin() && typeof isSuperAdmin === 'function' && !isSuperAdmin());
            if (isInstructorView) {
                _instructorCoursesAll = classes.slice();
                populateInstructorFilterDropdowns(classes);
            // Invalidate cache when courses are reloaded
            _coursesGridCache = {
                current: { html: null, dataHash: null },
                previous: { html: null, dataHash: null }
            };
            // Initialize cache for custom tabs
            const customTabs = getCustomTabs();
            customTabs.forEach(tab => {
                _coursesGridCache[tab.id] = { html: null, dataHash: null };
            });
            renderInstructorCoursesGrid(getCoursesForCurrentTab());
            } else {
                renderInstructorCoursesGrid(classes);
            }
        }

        /** Toggle the add menu dropdown */
        function toggleAddMenu() {
            const menu = document.getElementById('addMenuDropdown');
            if (!menu) return;
            
            const isHidden = menu.classList.contains('hidden');
            // Close all other dropdowns first
            document.querySelectorAll('.add-menu-dropdown').forEach(m => {
                if (m !== menu) m.classList.add('hidden');
            });
            
            if (isHidden) {
                menu.classList.remove('hidden');
                // Initialize icons in dropdown
                if (typeof lucide !== 'undefined' && lucide.createIcons) {
                    lucide.createIcons({ root: menu });
                }
                // Close menu when clicking outside
                setTimeout(() => {
                    const closeHandler = (e) => {
                        if (!menu.contains(e.target) && !e.target.closest('.icon-button-add')) {
                            menu.classList.add('hidden');
                            document.removeEventListener('click', closeHandler);
                        }
                    };
                    document.addEventListener('click', closeHandler);
                }, 0);
            } else {
                menu.classList.add('hidden');
            }
        }
        
        /** Close the add menu dropdown */
        function closeAddMenu() {
            const menu = document.getElementById('addMenuDropdown');
            if (menu) menu.classList.add('hidden');
        }
        
        function showCreateClass() {
            window._createClassPreviousFocus = document.activeElement && document.activeElement.nodeName ? document.activeElement : null;
            const card = document.getElementById('createClassCard');
            card.classList.remove('hidden');
            card.scrollIntoView({ behavior: 'smooth', block: 'start' });
            var firstInput = document.getElementById('className');
            if (firstInput) setTimeout(function() { firstInput.focus(); }, 100);
        }

        function cancelCreateClass() {
            document.getElementById('createClassCard').classList.add('hidden');
            document.getElementById('createClassForm').reset();
            if (window._createClassPreviousFocus && typeof window._createClassPreviousFocus.focus === 'function' && window._createClassPreviousFocus.isConnected) window._createClassPreviousFocus.focus();
        }

        function toggleEvalType(typeId) {
            const content = document.getElementById(typeId);
            const arrow = document.getElementById(typeId + '-arrow');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.style.transform = 'rotate(90deg)';
            } else {
                content.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
            }
        }

        
        // Sort evaluations dynamically
        // Make sortEvaluations globally accessible
        window.sortEvaluations = sortEvaluations;

        async function viewClass(classId, skipReload) {
            // Check if editing before navigating
            if (editingEvaluationId && !skipReload) {
                checkEditingBeforeNavigate(viewClassInternal, classId, skipReload);
                return;
            }
            await viewClassInternal(classId, skipReload);
        }
        
        async function viewClassInternal(classId, skipReload) {
            currentClassId = classId; // Store for later use
            
            if (!skipReload) {
                await loadClasses();
            }
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const selectedClass = classes.find(c => c.id === classId);
            
            if (!selectedClass) {
                if ((typeof isAdmin === 'function' && isAdmin()) || (typeof isSuperAdmin === 'function' && isSuperAdmin())) {
                    currentClassId = null;
                    if (typeof showDashboard === 'function') showDashboard();
                    return;
                }
                alert('Class not found');
                console.error('Class ID not found:', classId, 'Available IDs:', classes.map(c => c.id));
                return;
            }
            
            // Sort roster alphabetically by last name
            const roster = (selectedClass.roster || []).slice().sort((a, b) => {
                const lastNameA = (a.lastName || '').toLowerCase().trim();
                const lastNameB = (b.lastName || '').toLowerCase().trim();
                if (lastNameA < lastNameB) return -1;
                if (lastNameA > lastNameB) return 1;
                // If last names are equal, sort by first name
                const firstNameA = (a.firstName || '').toLowerCase().trim();
                const firstNameB = (b.firstName || '').toLowerCase().trim();
                if (firstNameA < firstNameB) return -1;
                if (firstNameA > firstNameB) return 1;
                return 0;
            });
            
            // Gather all evaluations - from both Supabase and localStorage
            const evals = [];
            
            // Load from Supabase if available
            if (supabaseClient && selectedClass.supabaseId) {
                console.log('Loading evaluations from Supabase for course:', selectedClass.supabaseId);
                const supabaseEvals = await loadEvaluationsFromSupabase(selectedClass.supabaseId);
                console.log('Supabase evaluations result:', supabaseEvals);
                
                if (supabaseEvals && supabaseEvals.length > 0) {
                    const visibleEvals = supabaseEvals.filter(ev => !isDeletedId('deleted_evaluation_ids', ev.id));
                    console.log('Processing', visibleEvals.length, 'Supabase evaluations (after excluding locally deleted)');
                    visibleEvals.forEach(ev => {
                        console.log('Evaluation data:', ev);
                        evals.push({
                            studentName: ev.student ? `${ev.student.first_name} ${ev.student.last_name}` : 'Unknown',
                            studentId: ev.student_id,
                            date: new Date(ev.created_at).toLocaleDateString(),
                            type: ev.evaluation_data?.assignmentType || 'Unknown',
                            totalScore: ev.total_score || 0,
                            maxScore: ev.evaluation_data?.maxScore || 100,
                            results: ev.evaluation_data
                        });
                    });
                    console.log('✓ Added', evals.length, 'evaluations from Supabase');
                } else {
                    console.log('No evaluations found in Supabase for this course');
                }
            } else {
                console.log('Supabase not available or course has no supabaseId');
            }
            
            // Also gather from localStorage (exclude locally deleted) (for backwards compatibility)
            roster.forEach(student => {
                if (student.evaluations) {
                    student.evaluations.forEach(ev => {
                        if (isDeletedId('deleted_evaluation_ids', ev.supabaseId || ev.id)) return;
                        // Only add if not already in evals (avoid duplicates)
                        const exists = evals.find(e => 
                            e.studentId === student.id && 
                            e.date === ev.date &&
                            e.type === ev.type
                        );
                        if (!exists) {
                            evals.push({
                                studentName: escapeHtml((student.firstName || '') + ' ' + (student.lastName || '')),
                                studentId: student.id,
                                date: ev.date,
                                type: ev.type,
                                totalScore: ev.results.totalScore,
                                maxScore: ev.results.maxScore,
                                results: ev.results
                            });
                        }
                    });
                }
            });
            
            // Load consent status per student for this course (instructor view)
            let consentByStudent = {};
            if (supabaseClient && selectedClass.supabaseId) {
                try {
                    const { data: consentRows, error: consentErr } = await supabaseClient
                        .from('consent_forms')
                        .select('student_id, consent_given')
                        .eq('course_id', selectedClass.supabaseId)
                        .eq('consent_type', 'data_collection');
                    if (!consentErr && consentRows && consentRows.length > 0) {
                        consentRows.forEach(function(r) {
                            consentByStudent[r.student_id] = r.consent_given;
                        });
                    }
                } catch (e) {
                    console.warn('Could not load consent status:', e);
                }
            }
            
            // Update title
            document.getElementById('classDetailTitle').textContent = 
                `${selectedClass.name} - ${selectedClass.semester} ${selectedClass.year}`;
            
            console.log('Final evals array before display:', evals);
            console.log('Evals count:', evals.length);
            
            const courseIdForDelete = String(selectedClass.id || '');
            const courseIdForAttr = courseIdForDelete.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
            // Clear header actions (Delete course moved to bottom of content)
            const headerActions = document.getElementById('classDetailHeaderActions');
            if (headerActions) headerActions.innerHTML = '';
            
            // Build compact table-style student roster (Canvas/Apple HIG style)
            let html = '';
            
            // Toolbar with search and add button (compact, at top)
            html += `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; flex-wrap: wrap; gap: 0.75rem;">
                    <div style="display: flex; align-items: center; gap: 0.75rem; flex: 1; min-width: 200px;">
                        <div style="position: relative; flex: 1; max-width: 300px;">
                            <input type="text" id="studentSearchInput" placeholder="Search students" style="width: 100%; padding: 0.5rem 0.75rem 0.5rem 2.25rem; border: 1px solid var(--border); border-radius: 0.5rem; font-size: 0.875rem;" oninput="filterStudentTable()">
                            <i data-lucide="search" style="position: absolute; left: 0.75rem; top: 50%; transform: translateY(-50%); width: 1rem; height: 1rem; color: var(--text-light); pointer-events: none;"></i>
                        </div>
                        <span style="color: var(--text-light); font-size: 0.875rem; white-space: nowrap;">${roster.length} student${roster.length !== 1 ? 's' : ''}</span>
                    </div>
                    <div style="position: relative;">
                        <button type="button" onclick="toggleStudentMenu()" class="btn" style="display: inline-flex; align-items: center; gap: 0.35em; padding: 0.5rem 0.75rem; font-size: 0.875rem;" aria-haspopup="true" aria-expanded="false"><span class="icon-with-text"><i data-lucide="user-plus" style="width:1em;height:1em;"></i> Add Student</span> <i data-lucide="chevron-down" style="width:0.75em;height:0.75em;margin-left:0.25em;"></i></button>
                        <div id="studentMenu" class="student-menu hidden" style="position: absolute; top: 100%; left: 0; margin-top: 0.25rem; background: white; border: 1px solid var(--border); border-radius: 0.5rem; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; min-width: 200px; padding: 0.25rem 0;">
                            <button type="button" onclick="showAddStudent();toggleStudentMenu();" style="width: 100%; text-align: left; padding: 0.5rem 0.75rem; border: none; background: none; cursor: pointer; font-size: 0.875rem; color: var(--text); display: flex; align-items: center; gap: 0.5rem; transition: background 0.15s;" onmouseover="this.style.background='var(--bg-alt)'" onmouseout="this.style.background='white'"><i data-lucide="user-plus" style="width:1rem;height:1rem;"></i> Add Student</button>
                            <button type="button" onclick="showMoveStudentsFromCourse();toggleStudentMenu();" style="width: 100%; text-align: left; padding: 0.5rem 0.75rem; border: none; background: none; cursor: pointer; font-size: 0.875rem; color: var(--text); display: flex; align-items: center; gap: 0.5rem; transition: background 0.15s;" onmouseover="this.style.background='var(--bg-alt)'" onmouseout="this.style.background='white'"><i data-lucide="users" style="width:1rem;height:1rem;"></i> Move Students</button>
                        </div>
                    </div>
                </div>
            `;
            
            if (roster.length === 0) {
                html += `
                    <div class="empty-state" style="padding: 3rem 1.5rem;">
                        <i data-lucide="users" class="empty-state-icon" aria-hidden="true"></i>
                        <p class="empty-state-title">No students yet</p>
                        <p class="empty-state-desc">Add students to this course to record evaluations and track progress.</p>
                        <div class="empty-state-action">
                            <div style="position: relative; display: inline-block;">
                                <button type="button" onclick="toggleStudentMenu()" class="btn" style="background: var(--primary); color: white; display: inline-flex; align-items: center; gap: 0.35em;" aria-haspopup="true" aria-expanded="false">
                                    <span class="icon-with-text"><i data-lucide="user-plus"></i> Add Student</span> <i data-lucide="chevron-down" style="width:0.75em;height:0.75em;margin-left:0.25em;"></i>
                                </button>
                                <div id="studentMenuEmpty" class="student-menu hidden" style="position: absolute; top: 100%; left: 0; margin-top: 0.25rem; background: white; border: 1px solid var(--border); border-radius: 0.5rem; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; min-width: 200px; padding: 0.25rem 0;">
                                    <button type="button" onclick="showAddStudent();toggleStudentMenu();" style="width: 100%; text-align: left; padding: 0.5rem 0.75rem; border: none; background: none; cursor: pointer; font-size: 0.875rem; color: var(--text); display: flex; align-items: center; gap: 0.5rem; transition: background 0.15s;" onmouseover="this.style.background='var(--bg-alt)'" onmouseout="this.style.background='white'">
                                        <i data-lucide="user-plus" style="width:1rem;height:1rem;"></i> Add Student
                                    </button>
                                    <button type="button" onclick="showMoveStudentsFromCourse();toggleStudentMenu();" style="width: 100%; text-align: left; padding: 0.5rem 0.75rem; border: none; background: none; cursor: pointer; font-size: 0.875rem; color: var(--text); display: flex; align-items: center; gap: 0.5rem; transition: background 0.15s;" onmouseover="this.style.background='var(--bg-alt)'" onmouseout="this.style.background='white'">
                                        <i data-lucide="users" style="width:1rem;height:1rem;"></i> Move Students
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                // Compact table layout (Canvas-style)
                html += `
                    <div style="background: white; border: 1px solid var(--border); border-radius: 0.5rem; overflow: hidden;">
                        <table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">
                            <thead>
                                <tr style="background: var(--bg-alt); border-bottom: 2px solid var(--border);">
                                    <th style="text-align: left; padding: 0.75rem; font-weight: 600; color: var(--text); font-size: 0.875rem;">Name</th>
                                    <th style="text-align: left; padding: 0.75rem; font-weight: 600; color: var(--text); font-size: 0.875rem;">Email</th>
                                    <th style="text-align: left; padding: 0.75rem; font-weight: 600; color: var(--text); font-size: 0.875rem;">Student ID</th>
                                    <th style="text-align: center; padding: 0.75rem; font-weight: 600; color: var(--text); font-size: 0.875rem;">Evaluations</th>
                                    <th style="text-align: center; padding: 0.75rem; font-weight: 600; color: var(--text); font-size: 0.875rem;">Consent</th>
                                    <th style="text-align: right; padding: 0.75rem; font-weight: 600; color: var(--text); font-size: 0.875rem; width: 100px;">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="studentTableBody">
                `;
                
                roster.forEach((student, index) => {
                    // Count evaluations for this student from the evals array
                    const studentEvals = evals.filter(e => e.studentId === student.id || e.studentId === student.supabaseId);
                    const evalCount = studentEvals.length;
                    
                    const studentSupabaseId = student.supabaseId || student.id;
                    const consentStatus = consentByStudent[studentSupabaseId];
                    let consentBadge = '';
                    if (consentStatus === true) {
                        consentBadge = '<span style="font-size: 0.8rem; color: var(--success); font-weight: 500;">✓ Consented</span>';
                    } else if (consentStatus === false) {
                        consentBadge = '<span style="font-size: 0.8rem; color: var(--text-light);">Declined</span>';
                    } else {
                        consentBadge = '<span style="font-size: 0.8rem; color: var(--text-light);">—</span>';
                    }
                    
                    const studentId = escapeHtml(String(studentSupabaseId || ''));
                    const firstName = escapeHtml(student.firstName || '');
                    const lastName = escapeHtml(student.lastName || '');
                    const fullName = `${firstName} ${lastName}`;
                    const email = escapeHtml(student.email || '');
                    const studentIdDisplay = escapeHtml(student.studentId || '—');
                    
                    html += `
                        <tr class="student-row" data-student-name="${escapeHtml(fullName.toLowerCase())}" data-student-email="${escapeHtml(email.toLowerCase())}" style="border-bottom: 1px solid var(--border); transition: background 0.15s;" onmouseover="this.style.background='var(--bg-alt)'" onmouseout="this.style.background='white'">
                            <td style="padding: 0.75rem;">
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <div style="width: 32px; height: 32px; border-radius: 50%; background: var(--primary); color: white; display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 0.75rem; flex-shrink: 0;">
                                        ${(firstName.charAt(0) || '').toUpperCase()}${(lastName.charAt(0) || '').toUpperCase()}
                                    </div>
                                    <span style="font-weight: 500; color: var(--text);">${fullName}</span>
                                </div>
                            </td>
                            <td style="padding: 0.75rem; color: var(--text-light);">${email || '—'}</td>
                            <td style="padding: 0.75rem; color: var(--text-light); font-family: ui-monospace, monospace; font-size: 0.8125rem;">${studentIdDisplay}</td>
                            <td style="padding: 0.75rem; text-align: center;">
                                ${evalCount > 0 ? `<a href="#" onclick="viewStudentEvals('${studentId}'); return false;" style="color: var(--primary); text-decoration: none; font-weight: 500;">${evalCount}</a>` : '<span style="color: var(--text-light);">0</span>'}
                            </td>
                            <td style="padding: 0.75rem; text-align: center;">${consentBadge}</td>
                            <td style="padding: 0.75rem; text-align: right;">
                                <div style="position: relative; display: inline-block;">
                                    <button type="button" onclick="toggleStudentActions('${studentId}', event); return false;" class="btn-icon-only" style="padding: 0.375rem; background: transparent; color: var(--text-light); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer; transition: all 0.15s; position: relative; z-index: 1;" aria-label="Student actions" aria-expanded="false" aria-haspopup="true" title="Actions" onmouseover="this.style.background='var(--bg-alt)'; this.style.borderColor='var(--primary)'; this.style.color='var(--primary)'" onmouseout="this.style.background='transparent'; this.style.borderColor='var(--border)'; this.style.color='var(--text-light)'">
                                        <i data-lucide="more-horizontal" style="width:1.125rem;height:1.125rem;"></i>
                                    </button>
                                    <div id="studentActionsMenu_${studentId}" class="student-actions-menu hidden">
                                        <button type="button" onclick="addEvaluationForStudent('${studentId}'); toggleStudentActions('${studentId}');" style="width: 100%; text-align: left; padding: 0.5rem 0.75rem; border: none; background: none; cursor: pointer; font-size: 0.875rem; color: var(--text); display: flex; align-items: center; gap: 0.5rem; transition: background 0.15s;" onmouseover="this.style.background='var(--bg-alt)'" onmouseout="this.style.background='white'"><i data-lucide="plus-circle" style="width:1rem;height:1rem;"></i> Add Evaluation</button>
                                        ${evalCount > 0 ? `<button type="button" onclick="viewStudentEvals('${studentId}'); toggleStudentActions('${studentId}');" style="width: 100%; text-align: left; padding: 0.5rem 0.75rem; border: none; background: none; cursor: pointer; font-size: 0.875rem; color: var(--text); display: flex; align-items: center; gap: 0.5rem; transition: background 0.15s;" onmouseover="this.style.background='var(--bg-alt)'" onmouseout="this.style.background='white'"><i data-lucide="eye" style="width:1rem;height:1rem;"></i> View Evaluations</button>` : ''}
                                        <button type="button" onclick="editStudent('${studentId}'); toggleStudentActions('${studentId}');" style="width: 100%; text-align: left; padding: 0.5rem 0.75rem; border: none; background: none; cursor: pointer; font-size: 0.875rem; color: var(--text); display: flex; align-items: center; gap: 0.5rem; transition: background 0.15s;" onmouseover="this.style.background='var(--bg-alt)'" onmouseout="this.style.background='white'"><i data-lucide="pencil" style="width:1rem;height:1rem;"></i> Edit Student</button>
                                    </div>
                                </div>
                            </td>
                        </tr>
                    `;
                });
                
                html += `
                            </tbody>
                        </table>
                    </div>
                `;
            }
            
            
            // Show content
            const classDetailEl = document.getElementById('classDetailContent');
            if (classDetailEl) {
                classDetailEl.innerHTML = html;
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: classDetailEl });
            }
            
            // Switch to class detail view
            setActiveSection('classDetailSection', 'navDashboard');
            const classDetailSection = document.getElementById('classDetailSection');
            if (classDetailSection && typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: classDetailSection });
            
            // CRITICAL: Remove ALL top spacing to eliminate gap between header and content
            const mainContent = document.getElementById('main-content');
            if (mainContent) {
                mainContent.style.setProperty('padding-top', '0', 'important');
                mainContent.style.setProperty('margin-top', '0', 'important');
                // Force main-content to have no height when classDetailSection is active
                mainContent.style.setProperty('min-height', '0', 'important');
                mainContent.style.setProperty('height', 'auto', 'important');
            }
            
            // Also ensure section and card have no top spacing
            if (classDetailSection) {
                classDetailSection.style.setProperty('margin-top', '0', 'important');
                classDetailSection.style.setProperty('padding-top', '0', 'important');
                // Position classDetailSection at the top of main-content
                classDetailSection.style.setProperty('position', 'relative', 'important');
                classDetailSection.style.setProperty('top', '0', 'important');
                const card = classDetailSection.querySelector('.card');
                if (card) {
                    card.style.setProperty('margin-top', '0', 'important');
                    card.style.setProperty('padding-top', '0', 'important');
                    card.style.setProperty('border-top-left-radius', '0', 'important');
                    card.style.setProperty('border-top-right-radius', '0', 'important');
                }
            }
            
            // Hide all other sections to ensure they don't take up space
            document.querySelectorAll('.section').forEach(section => {
                if (section.id !== 'classDetailSection') {
                    section.style.setProperty('display', 'none', 'important');
                    section.style.setProperty('height', '0', 'important');
                    section.style.setProperty('margin', '0', 'important');
                    section.style.setProperty('padding', '0', 'important');
                }
            });
            
            // #region agent log
            // Instrumentation: Find what's taking up space in main-content
            setTimeout(() => {
                const header = document.querySelector('header');
                const mainContentEl = document.getElementById('main-content');
                const sectionEl = document.getElementById('classDetailSection');
                
                const getComputedStyleValue = (el, prop) => {
                    if (!el) return null;
                    const computed = window.getComputedStyle(el);
                    return computed.getPropertyValue(prop) || computed[prop];
                };
                
                const getRect = (el) => {
                    if (!el) return null;
                    const rect = el.getBoundingClientRect();
                    return { top: rect.top, bottom: rect.bottom, height: rect.height, width: rect.width };
                };
                
                const headerRect = header?.getBoundingClientRect();
                const mainRect = mainContentEl?.getBoundingClientRect();
                const sectionRect = sectionEl?.getBoundingClientRect();
                
                // Find ALL direct children of main-content and check which ones are visible and taking space
                const allMainChildren = Array.from(mainContentEl?.children || []).map(child => {
                    const rect = getRect(child);
                    const display = window.getComputedStyle(child).display;
                    const visibility = window.getComputedStyle(child).visibility;
                    const opacity = window.getComputedStyle(child).opacity;
                    const position = window.getComputedStyle(child).position;
                    const isVisible = display !== 'none' && visibility !== 'hidden' && opacity !== '0' && rect.height > 0;
                    
                    return {
                        id: child.id || 'no-id',
                        tagName: child.tagName,
                        className: child.className,
                        rect: rect,
                        display: display,
                        visibility: visibility,
                        opacity: opacity,
                        position: position,
                        isVisible: isVisible,
                        marginTop: getComputedStyleValue(child, 'margin-top'),
                        paddingTop: getComputedStyleValue(child, 'padding-top'),
                        marginBottom: getComputedStyleValue(child, 'margin-bottom'),
                        paddingBottom: getComputedStyleValue(child, 'padding-bottom')
                    };
                });
                
                // Find visible children that are taking up space
                const visibleChildren = allMainChildren.filter(c => c.isVisible);
                
                const data = {
                    header: {
                        bottom: headerRect?.bottom || null,
                        height: headerRect?.height || null
                    },
                    mainContent: {
                        top: mainRect?.top || null,
                        bottom: mainRect?.bottom || null,
                        height: mainRect?.height || null,
                        paddingTop: getComputedStyleValue(mainContentEl, 'padding-top'),
                        marginTop: getComputedStyleValue(mainContentEl, 'margin-top'),
                        gapFromHeader: mainRect ? (mainRect.top - (headerRect?.bottom || 0)) : null
                    },
                    classDetailSection: {
                        top: sectionRect?.top || null,
                        bottom: sectionRect?.bottom || null,
                        height: sectionRect?.height || null,
                        gapFromMain: sectionRect ? (sectionRect.top - (mainRect?.top || 0)) : null
                    },
                    allMainChildren: allMainChildren,
                    visibleChildren: visibleChildren,
                    totalVisibleHeight: visibleChildren.reduce((sum, c) => sum + (c.rect?.height || 0), 0)
                };
                
                // Analytics endpoint - make it completely non-blocking
                fetch('http://127.0.0.1:7242/ingest/2d493fae-3749-4b25-960d-04d6e5f42b38', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        location: 'viewClass:21950',
                        message: 'All main-content children analyzed for visible elements',
                        data: data,
                        timestamp: Date.now(),
                        runId: 'run4',
                        hypothesisId: 'ALL'
                    }),
                    // Add timeout and make it fail silently
                    signal: AbortSignal.timeout(1000) // 1 second timeout
                }).catch(() => {
                    // Silently fail - this is analytics only
                });
            }, 200);
            // #endregion
        }
        
        // Filter student table by search query
        function filterStudentTable() {
            const searchInput = document.getElementById('studentSearchInput');
            const tbody = document.getElementById('studentTableBody');
            if (!searchInput || !tbody) return;
            
            const query = searchInput.value.toLowerCase().trim();
            const rows = tbody.querySelectorAll('.student-row');
            
            rows.forEach(row => {
                const name = row.getAttribute('data-student-name') || '';
                const email = row.getAttribute('data-student-email') || '';
                const matches = !query || name.includes(query) || email.includes(query);
                row.style.display = matches ? '' : 'none';
            });
        }

        // ===== RUBRICS MANAGEMENT =====
        async function loadRubrics() {
            // Initialize rubrics storage if needed
            initializeRubrics();
            
            // Populate course filter dropdown
            populateCourseFilter();
            
            // Get all rubrics from storage (now async)
            let allRubrics = await getAllRubrics();
            if (!Array.isArray(allRubrics)) allRubrics = [];
            
            // Get all classes for course name lookup
            const classes = JSON.parse(getUserItem('classes') || '[]');
            
            const list = document.getElementById('rubricsList');
            if (!list) return; // Exit if element doesn't exist yet
            
            list.innerHTML = allRubrics.map(rubric => {
                // Get course info - handle both new courseIds array and old single courseId
                let courseInfo = '';
                let courseIdsToDisplay = [];
                
                if (rubric.courseIds && Array.isArray(rubric.courseIds) && rubric.courseIds.length > 0) {
                    courseIdsToDisplay = rubric.courseIds;
                } else if (rubric.courseId) {
                    // Backward compatibility with single courseId
                    courseIdsToDisplay = [rubric.courseId];
                }
                
                if (courseIdsToDisplay.length > 0) {
                    const courses = courseIdsToDisplay
                        .map(id => classes.find(c => c.id === id))
                        .filter(c => c); // Remove undefined (deleted courses)
                    
                    if (courses.length > 0) {
                        // Group by course name
                        const courseGroups = {};
                        courses.forEach(course => {
                            if (!courseGroups[course.name]) {
                                courseGroups[course.name] = [];
                            }
                            courseGroups[course.name].push(course);
                        });
                        
                        // Format display: "CMST 210 (Fall 2024) - Sections 001, 002"
                        const courseDisplays = Object.keys(courseGroups).map(courseName => {
                            const sections = courseGroups[courseName];
                            const firstCourse = sections[0];
                            const sectionNums = sections.map(s => s.section).join(', ');
                            const sectionText = sections.length > 1 ? `Sections ${sectionNums}` : `Section ${sectionNums}`;
                            return `${courseName} (${firstCourse.semester} ${firstCourse.year}) - ${sectionText}`;
                        });
                        
                        courseInfo = ` • <span style="color: var(--primary); font-weight: 500;">${courseDisplays.join(' • ')}</span>`;
                    } else if (courseIdsToDisplay.length > 0) {
                        courseInfo = ' • <span style="color: #999;">Course(s) not found</span>';
                    }
                }
                
                return `
                <div class="rubric-item">
                    <div class="rubric-info">
                        <h4>${rubric.name}</h4>
                        <p>${rubric.description || 'No description'} • ${rubric.totalPoints} points${rubric.speechType ? ' • ' + rubric.speechType : ''}${courseInfo}</p>
                    </div>
                    <div class="rubric-actions">
                        <button class="btn-small btn-view" data-rubric-id="${rubric.id}">View</button>
                        <button class="btn-small btn-edit" data-rubric-id="${rubric.id}">Edit</button>
                        <button class="btn-small btn-duplicate" data-rubric-id="${rubric.id}">Duplicate</button>
                        ${rubric.id !== 'default' ? `
                            <button type="button" class="btn-small btn-danger btn-delete" data-rubric-id="${rubric.id}" aria-label="Delete rubric" title="Delete rubric"><i data-lucide="trash-2" style="width:1.1em;height:1.1em;"></i></button>
                        ` : ''}
                    </div>
                </div>
            `;
            }).join('');
            
            // Add event listeners to all buttons
            document.querySelectorAll('.btn-view').forEach(btn => {
                btn.addEventListener('click', () => viewRubric(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-edit').forEach(btn => {
                btn.addEventListener('click', () => editRubric(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-duplicate').forEach(btn => {
                btn.addEventListener('click', () => duplicateRubricUI(btn.dataset.rubricId));
            });
            
            document.querySelectorAll('.btn-delete').forEach(btn => {
                btn.addEventListener('click', () => {
                    console.log('Delete button clicked via event listener!');
                    deleteRubricUI(btn.dataset.rubricId);
                });
            });
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: list });
        }

        async function viewRubric(rubricId) {
            const rubric = await getRubricById(rubricId);
            if (!rubric) return;
            
            const categories = rubric?.categories;
            if (!categories || !Array.isArray(categories) || categories.length === 0) {
                showModal(`<div style="padding: 2rem;"><h2>${escapeHtml(rubric.name || 'Rubric')}</h2><p style="color: var(--text-light);">This rubric has no categories defined yet. Edit it to add categories and subcategories.</p><button onclick="closeModal()">Close</button></div>`);
                return;
            }
            
            const metrics = calculateRubricMetrics(rubric);
            const maxPointsPerSub = metrics.pointsPerSubcategory;
            
            // Get course info - handle both courseIds array and old courseId
            let courseInfo = '';
            let courseIdsToDisplay = [];
            
            if (rubric.courseIds && Array.isArray(rubric.courseIds) && rubric.courseIds.length > 0) {
                courseIdsToDisplay = rubric.courseIds;
            } else if (rubric.courseId) {
                courseIdsToDisplay = [rubric.courseId];
            }
            
            if (courseIdsToDisplay.length > 0) {
                const classes = JSON.parse(getUserItem('classes') || '[]');
                const courses = courseIdsToDisplay
                    .map(id => classes.find(c => c.id === id))
                    .filter(c => c);
                
                if (courses.length > 0) {
                    const courseDisplays = courses.map(course => 
                        `${course.name} - ${course.semester} ${course.year} (Section ${course.section})`
                    ).join('<br>');
                    courseInfo = `<strong>Course${courses.length > 1 ? 's' : ''}:</strong> ${courseDisplays}<br>`;
                }
            }
            
            let html = `
                <div style="background: white; padding: 2rem; border-radius: 0.5rem; max-width: 800px; margin: 2rem auto;">
                    <h2>${rubric.name}</h2>
                    <p style="color: var(--text-light); margin-bottom: 1rem;">${rubric.description || ''}</p>
                    <div style="background: var(--bg-alt); padding: 1rem; border-radius: 0.5rem; margin-bottom: 1.5rem;">
                        ${courseInfo}
                        <strong>Total Points:</strong> ${rubric.totalPoints}<br>
                        <strong>Total Subcategories:</strong> ${metrics.totalSubcategories}<br>
                        <strong>Maximum Points per Subcategory:</strong> ${maxPointsPerSub.toFixed(2)} (when graded as A)
                    </div>
                    <h3>Grade Scale & Points per Subcategory</h3>
                    <p style="color: var(--text-light); font-size: 0.9rem; margin-bottom: 0.5rem;">Each subcategory can earn different points based on the grade received:</p>
                    <div style="margin-bottom: 1.5rem;">
            `;
            
            const gradeScale = rubric.gradeScale || {};
            for (const [grade, info] of Object.entries(gradeScale)) {
                const pct = info?.percentage ?? (info?.min != null ? info.min / 100 : 1);
                const points = (maxPointsPerSub * pct).toFixed(2);
                const range = info?.range ?? (info?.min != null ? `${info.min}%+` : '—');
                html += `<div style="padding: 0.5rem; border-left: 3px solid var(--primary); margin-bottom: 0.5rem; background: var(--bg-alt);">
                    <strong>${escapeHtml(grade)} - ${escapeHtml(info?.label || '')}:</strong> ${(pct * 100)}% → <strong>${points} points</strong> per subcategory (Range: ${escapeHtml(String(range))})
                </div>`;
            }
            
            html += `</div><h3>Categories & Subcategories</h3>`;
            
            (rubric.categories || []).forEach((cat, idx) => {
                const subs = Array.isArray(cat.subcategories) ? cat.subcategories : [];
                const catMetrics = metrics.categoryPoints[idx] || { maxPoints: 0, subcategoryCount: 0 };
                const subDisplay = subs.map(sub => {
                    const name = typeof sub === 'object' && sub && sub.name != null ? sub.name : String(sub);
                    const pts = typeof sub === 'object' && sub && sub.points != null ? ` (${sub.points} pts)` : '';
                    return `<li>${escapeHtml(name)}${pts}</li>`;
                }).join('');
                html += `
                    <div style="margin-bottom: 1.5rem; padding: 1rem; border: 1px solid var(--border); border-radius: 0.5rem;">
                        <h4>${escapeHtml(cat.name || '')} <span style="color: var(--primary);">(Max: ${(catMetrics.maxPoints || 0).toFixed(1)} points)</span></h4>
                        <p style="color: var(--text-light); font-size: 0.9rem;">${catMetrics.subcategoryCount} subcategories × ${(maxPointsPerSub || 0).toFixed(2)} points each (if all A's)</p>
                        <ul style="margin-top: 0.5rem;">
                            ${subDisplay}
                        </ul>
                    </div>
                `;
            });
            
            html += `<button onclick="closeModal()">Close</button></div>`;
            
            showModal(html);
        }

        async function editRubric(rubricId) {
            const rubric = await getRubricById(rubricId);
            if (!rubric) {
                alert('Rubric not found');
                return;
            }
            await loadTextbooksForRubricForm();
            loadRubricIntoForm(rubric);
        }

        async function duplicateRubricUI(rubricId) {
            console.log('Duplicating rubric:', rubricId);
            const newRubric = await duplicateRubric(rubricId);
            if (newRubric) {
                await loadRubrics();
                if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Rubric duplicated: ' + newRubric.name, 4000);
            }
        }

        async function deleteRubricUI(rubricId) {
            console.log('Delete button clicked for:', rubricId);
            const rubric = await getRubricById(rubricId);
            if (!rubric) {
                console.error('Rubric not found:', rubricId);
                return;
            }
            
            console.log('Found rubric:', rubric.name);
            
            // Use custom confirmation modal instead of native confirm
            showConfirmModal(
                'Delete Rubric',
                `Are you sure you want to delete "${rubric.name}"? This action cannot be undone.`,
                async () => {
                    // User clicked Yes/Confirm
                    console.log('User confirmed deletion via custom modal');
                    const deleteResult = await deleteRubric(rubricId);
                    console.log('deleteRubric returned:', deleteResult);
                    
                    if (deleteResult) {
                        console.log('Rubric deleted successfully');
                        await loadRubrics();
                        if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Rubric deleted successfully.', 4000);
                    } else {
                        console.error('Delete function returned false');
                    }
                },
                () => {
                    // User clicked No/Cancel
                    console.log('User cancelled deletion via custom modal');
                }
            );
        }

        // Make functions globally accessible
        window.deleteRubricUI = deleteRubricUI;
        window.duplicateRubricUI = duplicateRubricUI;
        window.viewRubric = viewRubric;
        window.editRubric = editRubric;
        window.showCreateRubric = showCreateRubric;
        window.cancelCreateRubric = cancelCreateRubric;
        window.addCategory = addCategory;
        window.removeCategory = removeCategory;
        window.addSubcategory = addSubcategory;
        window.removeSubcategory = removeSubcategory;

        // Test function to verify everything is working
        async function testDeleteFunction() {
            console.log('=== TEST FUNCTION CALLED ===');
            console.log('deleteRubricUI exists?', typeof window.deleteRubricUI);
            console.log('deleteRubric exists?', typeof deleteRubric);
            console.log('getRubricById exists?', typeof getRubricById);
            
            const allRubrics = await getAllRubrics();
            const arr = Array.isArray(allRubrics) ? allRubrics : [];
            console.log('All rubrics:', arr);
            
            if (arr.length > 0) {
                const testId = arr[arr.length - 1].id;
                console.log('Attempting to call deleteRubricUI with ID:', testId);
                try {
                    await deleteRubricUI(testId);
                } catch (e) {
                    console.error('Error calling deleteRubricUI:', e);
                }
            }
        }
        window.testDeleteFunction = testDeleteFunction;

        var _genericModalPreviousFocus = null;
        function showModal(content) {
            const modal = document.getElementById('saveModal');
            if (!modal) return;
            _genericModalPreviousFocus = document.activeElement && document.activeElement.nodeName ? document.activeElement : null;

            modal.innerHTML = `
                <div onclick="closeModal()" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 9999; display: flex; align-items: center; justify-content: center;">
                    <div onclick="event.stopPropagation()" style="background: white; border-radius: 0.5rem; max-height: 90vh; overflow-y: auto; max-width: 90vw;">
                        ${content}
                    </div>
                </div>
            `;
            modal.style.display = 'flex';
            var firstBtn = modal.querySelector('button');
            if (firstBtn) firstBtn.focus();
        }

        function closeModal() {
            const modal = document.getElementById('saveModal');
            if (modal) {
                modal.style.display = 'none';
                modal.innerHTML = '';
                if (_genericModalPreviousFocus && typeof _genericModalPreviousFocus.focus === 'function' && _genericModalPreviousFocus.isConnected) _genericModalPreviousFocus.focus();
            }
        }

        function showConfirmModal(title, message, onConfirm, onCancel, destructiveButtonLabel) {
            const modal = document.getElementById('saveModal');
            if (!modal) {
                console.error('Modal element not found');
                return;
            }
            var _confirmModalPreviousFocus = document.activeElement && document.activeElement.nodeName ? document.activeElement : null;
            var safeTitle = typeof escapeHtml === 'function' ? escapeHtml(title) : String(title).replace(/[&<>"']/g, function(c) { return { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c]; });
            var safeMessage = typeof escapeHtml === 'function' ? escapeHtml(message) : String(message).replace(/[&<>"']/g, function(c) { return { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c]; });
            var btnLabel = (destructiveButtonLabel && String(destructiveButtonLabel).trim()) ? String(destructiveButtonLabel).trim() : 'Delete';

            modal.innerHTML = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.4); backdrop-filter: blur(20px); z-index: 9999; display: flex; align-items: center; justify-content: center; padding: 16px; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', sans-serif;" onclick="closeModal()">
                    <div onclick="event.stopPropagation()" style="background: #ffffff; border-radius: 12px; padding: 24px; max-width: 400px; width: 100%; box-shadow: 0 8px 32px rgba(0,0,0,0.2); border: 0.5px solid rgba(0,0,0,0.1);">
                        <h3 style="margin: 0 0 12px 0; font-size: 20px; font-weight: 600; color: #1d1d1f; letter-spacing: -0.4px; line-height: 1.3;">${safeTitle}</h3>
                        <p style="margin: 0 0 24px 0; font-size: 15px; color: #6e6e73; line-height: 1.47; letter-spacing: -0.24px;">${safeMessage}</p>
                        <div style="display: flex; gap: 12px; justify-content: flex-end;">
                            <button id="confirmCancel" style="background: #ffffff; color: #1d1d1f; border: 1px solid #d2d2d7; padding: 12px 24px; border-radius: 10px; cursor: pointer; font-weight: 600; font-size: 17px; min-width: 88px; min-height: 44px; display: inline-flex; align-items: center; justify-content: center; transition: all 0.2s ease; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif; letter-spacing: -0.34px;" onmouseover="this.style.backgroundColor='#f5f5f7'; this.style.borderColor='#007AFF'" onmouseout="this.style.backgroundColor='#ffffff'; this.style.borderColor='#d2d2d7'">Cancel</button>
                            <button id="confirmYes" style="background: #FF3B30; color: white; border: none; padding: 12px 24px; border-radius: 10px; cursor: pointer; font-weight: 600; font-size: 17px; min-width: 88px; min-height: 44px; display: inline-flex; align-items: center; justify-content: center; transition: all 0.2s ease; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif; letter-spacing: -0.34px; box-shadow: 0 2px 8px rgba(255, 59, 48, 0.3);" onmouseover="this.style.backgroundColor='#FF2D55'; this.style.boxShadow='0 4px 12px rgba(255, 59, 48, 0.4)'" onmouseout="this.style.backgroundColor='#FF3B30'; this.style.boxShadow='0 2px 8px rgba(255, 59, 48, 0.3)'">${btnLabel.replace(/[&<>"']/g, function(c) { return { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c]; })}</button>
                        </div>
                    </div>
                </div>
            `;
            modal.style.display = 'flex';
            var cancelBtn = document.getElementById('confirmCancel');
            if (cancelBtn) cancelBtn.focus();

            function closeConfirmAndRestoreFocus() {
                closeModal();
                if (_confirmModalPreviousFocus && typeof _confirmModalPreviousFocus.focus === 'function' && _confirmModalPreviousFocus.isConnected) _confirmModalPreviousFocus.focus();
            }

            document.getElementById('confirmYes').addEventListener('click', () => {
                closeConfirmAndRestoreFocus();
                if (onConfirm) onConfirm();
            });

            document.getElementById('confirmCancel').addEventListener('click', () => {
                closeConfirmAndRestoreFocus();
                if (onCancel) onCancel();
            });
        }

        // Make modal functions globally accessible
        window.showModal = showModal;
        window.closeModal = closeModal;
        window.showConfirmModal = showConfirmModal;

        function showCreateRubric() {
            document.getElementById('rubricFormHeader').textContent = 'Create Custom Rubric';
            document.getElementById('rubricSubmitBtn').textContent = 'Create Rubric';
            document.getElementById('editingRubricId').value = '';
            const supabaseIdEl = document.getElementById('editingRubricSupabaseId');
            if (supabaseIdEl) supabaseIdEl.value = '';
            document.getElementById('createRubricForm').reset();
            
            // Populate course selector
            populateCourseSelector();
            // Populate textbook selector
            loadTextbooksForRubricForm();
            
            // Initialize with one empty category
            document.getElementById('categoriesContainer').innerHTML = '';
            addCategory();
            const exContainer = document.getElementById('exampleVideosContainer');
            if (exContainer) exContainer.innerHTML = '';

            window._createRubricPreviousFocus = document.activeElement && document.activeElement.nodeName ? document.activeElement : null;
            document.getElementById('createRubricCard').classList.remove('hidden');
            document.getElementById('createRubricCard').scrollIntoView({ behavior: 'smooth' });
            var firstInput = document.getElementById('rubricName');
            if (firstInput) setTimeout(function() { firstInput.focus(); }, 100);
        }

        function cancelCreateRubric() {
            document.getElementById('createRubricCard').classList.add('hidden');
            document.getElementById('createRubricForm').reset();
            document.getElementById('editingRubricId').value = '';
            const supabaseIdEl = document.getElementById('editingRubricSupabaseId');
            if (supabaseIdEl) supabaseIdEl.value = '';
            document.getElementById('categoriesContainer').innerHTML = '';
            const exContainer = document.getElementById('exampleVideosContainer');
            if (exContainer) exContainer.innerHTML = '';
            if (window._createRubricPreviousFocus && typeof window._createRubricPreviousFocus.focus === 'function' && window._createRubricPreviousFocus.isConnected) window._createRubricPreviousFocus.focus();
        }

        // ===== UPLOAD RUBRIC FUNCTIONS =====
        
        function showUploadRubric() {
            document.getElementById('uploadRubricForm').reset();
            document.getElementById('uploadProgress').classList.add('hidden');
            document.getElementById('uploadRubricCard').classList.remove('hidden');
            document.getElementById('uploadRubricCard').scrollIntoView({ behavior: 'smooth' });
        }
        
        function getQwenApiUrl() {
            var raw = (typeof localStorage !== 'undefined' && localStorage.getItem('qwen_api_url')) ||
                      (typeof window !== 'undefined' && window.QWEN_API_URL) || '';
            if (!raw || !raw.trim()) return '';
            var origin = typeof window !== 'undefined' && window.location && window.location.origin ? window.location.origin : '';
            // When app is on Render (or any non-localhost host), use same-origin proxy so the browser never hits the tunnel directly (avoids CORS/tunnel issues).
            if (origin && origin.indexOf('localhost') === -1) {
                return origin + '/qwen-api';
            }
            return raw.trim().replace(/\/$/, '');
        }
        
        function checkQwenStatus() {
            const inputEl = document.getElementById('savedQwenUrl');
            const resultEl = document.getElementById('qwenStatusResult');
            const btnEl = document.getElementById('qwenStatusBtn');
            if (!resultEl) return;
            const url = (inputEl && inputEl.value && inputEl.value.trim()) || getQwenApiUrl() || '';
            const baseUrl = url.trim().replace(/\/$/, '');
            if (!baseUrl) {
                resultEl.textContent = 'Set the Qwen URL above and click Save, then check again.';
                resultEl.style.color = 'var(--text-light)';
                return;
            }
            resultEl.textContent = 'Checking…';
            resultEl.style.color = 'var(--text-light)';
            if (btnEl) btnEl.disabled = true;
            const healthUrl = baseUrl + '/health';
            const ac = new AbortController();
            const t = setTimeout(function() { ac.abort(); }, 10000);
            fetch(healthUrl, { method: 'GET', mode: 'cors', credentials: 'omit', signal: ac.signal })
                .then(function(r) { return r.json().then(function(d) { return { ok: r.ok, data: d }; }); })
                .then(function(o) {
                    if (o.ok && o.data && (o.data.status === 'ok' || o.data.status === 'model_not_loaded')) {
                        resultEl.textContent = 'Qwen is reachable' + (o.data.status === 'ok' ? ' (model loaded).' : ' (model still loading).');
                        resultEl.style.color = 'var(--success, green)';
                    } else {
                        var hint = '';
                        if (o.data && (o.data.detail || o.data.error || o.data.message)) hint = ' Response: ' + (o.data.detail || o.data.error || o.data.message);
                        else if (o.data && typeof o.data === 'object') hint = ' Response: ' + JSON.stringify(o.data).slice(0, 120);
                        resultEl.textContent = 'Qwen responded but is not ready. Start Qwen on ISAAC or check the URL.' + hint;
                        resultEl.style.color = 'var(--text-light)';
                    }
                })
                .catch(function() {
                    resultEl.textContent = 'Qwen is not available. Start Qwen on ISAAC (see instructions below) or check the URL.';
                    resultEl.style.color = 'var(--warning, #b8860b)';
                })
                .finally(function() {
                    clearTimeout(t);
                    if (btnEl) btnEl.disabled = false;
                });
        }
        
        function cancelUploadRubric() {
            document.getElementById('uploadRubricCard').classList.add('hidden');
            document.getElementById('uploadRubricForm').reset();
        }
        
        // Handle upload rubric form submission
        document.getElementById('uploadRubricForm')?.addEventListener('submit', async function(e) {
            e.preventDefault();
            await processUploadedRubric();
        });
        
        async function processUploadedRubric() {
            const fileInput = document.getElementById('uploadRubricFile');
            const rubricName = document.getElementById('uploadRubricName').value;
            
            if (!fileInput.files || !fileInput.files[0]) {
                alert('Please select a file to upload');
                return;
            }
            
            const file = fileInput.files[0];
            const maxSize = 10 * 1024 * 1024; // 10MB
            
            if (file.size > maxSize) {
                alert('File size exceeds 10MB limit. Please use a smaller file.');
                return;
            }
            
            const qwenUrl = getQwenApiUrl();
            if (!qwenUrl) {
                alert('The Qwen service is not configured. Ask your Super Admin to set QWEN_API_URL (or the Qwen Service URL in Settings) for rubric extraction.');
                return;
            }
            
            // Show progress
            const progressDiv = document.getElementById('uploadProgress');
            const progressText = document.getElementById('uploadProgressText');
            const progressBar = document.getElementById('uploadProgressBar');
            progressDiv.classList.remove('hidden');
            progressText.textContent = 'Reading file...';
            progressBar.style.width = '20%';
            
            try {
                console.log('Uploading rubric file:', file.name, 'size:', Math.round(file.size / 1024), 'KB');
                progressText.textContent = 'Preparing image...';
                progressBar.style.width = '35%';
                const fileToSend = file.type && file.type.startsWith('image/')
                    ? await resizeImageForRubric(file, 1600)
                    : file;
                if (fileToSend !== file) {
                    console.log('Resized for upload:', fileToSend.name, 'size:', Math.round(fileToSend.size / 1024), 'KB');
                }
                progressText.textContent = 'Analyzing rubric with Qwen (may take 2–10 minutes on CPU)...';
                progressBar.style.width = '40%';
                
                const startTime = performance.now();
                const progressInterval = setInterval(() => {
                    const elapsed = Math.round((performance.now() - startTime) / 60000);
                    if (progressText && elapsed > 0) progressText.textContent = 'Still analyzing... (' + elapsed + ' min)';
                }, 60000);
                let extractedRubric;
                try {
                    extractedRubric = await extractWithQwen(fileToSend, qwenUrl);
                } finally {
                    clearInterval(progressInterval);
                }
                const processingTime = Math.round(performance.now() - startTime);
                progressText.textContent = 'Creating rubric...';
                progressBar.style.width = '80%';
                
                if (!extractedRubric) {
                    throw new Error('Failed to extract rubric from file');
                }
                
                const aiModelName = 'Qwen2.5-VL-7B';
                
                const mimeType = getFileMimeType(file);
                const interactionId = await logLLMInteraction(
                    'rubric_extraction',
                    {
                        file_name: file.name,
                        file_type: mimeType,
                        file_size_kb: Math.round(file.size / 1024),
                        rubric_name: rubricName,
                        prompt_type: 'rubric_extraction_v1'
                    },
                    extractedRubric,
                    'qwen',
                    aiModelName,
                    processingTime
                );
                
                // Create the rubric object
                const rubric = {
                    name: rubricName,
                    speechType: extractedRubric.speechType || 'General',
                    totalPoints: extractedRubric.totalPoints || 100,
                    gradeScale: extractedRubric.gradeScale || {
                        A: { min: 90, label: 'Excellent' },
                        B: { min: 80, label: 'Good' },
                        C: { min: 70, label: 'Satisfactory' },
                        D: { min: 60, label: 'Needs Improvement' },
                        F: { min: 0, label: 'Unsatisfactory' }
                    },
                    categories: extractedRubric.categories,
                    isTemplate: false,
                    extractedFrom: file.name,
                    // Store interaction ID so we can track if user edits this rubric later
                    llmInteractionId: interactionId
                };
                
                // Save the rubric
                const savedRubric = await saveRubric(rubric);
                
                progressText.textContent = '✅ Rubric created successfully!';
                progressBar.style.width = '100%';
                
                // Reload rubrics display
                await loadRubrics();
                
                // Close form after brief delay
                setTimeout(() => {
                    cancelUploadRubric();
                    alert(`Rubric "${rubricName}" has been created successfully from ${file.name}!\n\nYou can edit the rubric to correct any extraction errors.`);
                }, 1500);
                
            } catch (error) {
                console.error('Error processing rubric:', error);
                progressDiv.classList.add('hidden');
                alert('Failed to process rubric: ' + error.message + '\n\nPlease check:\n- The Qwen service is running (QWEN_API_URL configured)\n- The file contains a clear rubric structure (PDF or image)\n- Your connection to the Qwen service is working');
            }
        }
        
        /** Resize image to max long-edge (e.g. 1600px) and compress as JPEG for faster upload + Qwen inference. */
        function resizeImageForRubric(file, maxPx) {
            maxPx = maxPx || 1600;
            return new Promise((resolve, reject) => {
                if (!file.type || !file.type.startsWith('image/')) {
                    resolve(file);
                    return;
                }
                const img = new Image();
                const url = URL.createObjectURL(file);
                img.onload = () => {
                    URL.revokeObjectURL(url);
                    let w = img.width, h = img.height;
                    if (w <= maxPx && h <= maxPx) {
                        resolve(file);
                        return;
                    }
                    if (w > h) { h = Math.round(h * maxPx / w); w = maxPx; } else { w = Math.round(w * maxPx / h); h = maxPx; }
                    const canvas = document.createElement('canvas');
                    canvas.width = w;
                    canvas.height = h;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, w, h);
                    canvas.toBlob(
                        (blob) => {
                            if (!blob) { resolve(file); return; }
                            const name = file.name.replace(/\.[^.]+$/i, '.jpg');
                            resolve(new File([blob], name, { type: 'image/jpeg' }));
                        },
                        'image/jpeg',
                        0.85
                    );
                };
                img.onerror = () => { URL.revokeObjectURL(url); resolve(file); };
                img.src = url;
            });
        }
        
        // Resize image to max dimension (speeds up upload + Qwen processing)
        async function resizeImageFile(file, maxDimension = 1600) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        let width = img.width;
                        let height = img.height;
                        
                        // Only resize if larger than max
                        if (width <= maxDimension && height <= maxDimension) {
                            resolve(file); // Return original
                            return;
                        }
                        
                        // Calculate new dimensions
                        if (width > height) {
                            height = Math.round((height * maxDimension) / width);
                            width = maxDimension;
                        } else {
                            width = Math.round((width * maxDimension) / height);
                            height = maxDimension;
                        }
                        
                        // Resize via canvas
                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        // Convert to blob (JPEG for smaller size, 0.92 quality)
                        canvas.toBlob((blob) => {
                            if (!blob) {
                                reject(new Error('Failed to resize image'));
                                return;
                            }
                            // Create File from Blob with original name
                            const resizedFile = new File([blob], file.name.replace(/\.\w+$/, '.jpg'), { type: 'image/jpeg' });
                            resolve(resizedFile);
                        }, 'image/jpeg', 0.92);
                    };
                    img.onerror = () => reject(new Error('Failed to load image'));
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    const base64 = reader.result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        // Get correct MIME type for file (browser may not always detect correctly)
        function getFileMimeType(file) {
            // If browser detected a type, use it
            if (file.type && file.type !== 'application/octet-stream') {
                return file.type;
            }
            
            // Fallback based on file extension
            const ext = file.name.split('.').pop().toLowerCase();
            const mimeTypes = {
                'pdf': 'application/pdf',
                'png': 'image/png',
                'jpg': 'image/jpeg',
                'jpeg': 'image/jpeg',
                'webp': 'image/webp',
                'gif': 'image/gif',
                'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                'xls': 'application/vnd.ms-excel',
                'csv': 'text/csv',
                'doc': 'application/msword',
                'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
            };
            
            return mimeTypes[ext] || file.type || 'application/octet-stream';
        }
        
        async function extractWithQwen(file, qwenUrl) {
            const baseUrl = qwenUrl.replace(/\/$/, '');
            const formData = new FormData();
            formData.append('file', file);
            const response = await fetchWithTimeout(baseUrl + '/extract_rubric', {
                method: 'POST',
                body: formData
            }, 300000);  // 5 min – Qwen on CPU/large images can be slow
            if (!response.ok) {
                const err = await response.text();
                throw new Error('Qwen rubric extraction failed: ' + (err || response.statusText));
            }
            return await response.json();
        }
        
        async function extractRubricWithAI(base64Data, mimeType, provider, apiKey) {
            console.log('Extracting rubric with', provider, 'mimeType:', mimeType);
            
            const prompt = `You are analyzing a rubric document. Extract ALL the information and return ONLY a valid JSON object (no markdown, no explanation, no preamble).

The JSON must have this exact structure:
{
  "speechType": "type of speech if mentioned, or 'General'",
  "totalPoints": total possible points as a number,
  "categories": [
    {
      "name": "Category Name",
      "subcategories": [
        {
          "name": "Subcategory Name",
          "points": point value as number,
          "description": "criteria description"
        }
      ]
    }
  ],
  "gradeScale": {
    "A": {"min": 90, "label": "Excellent"},
    "B": {"min": 80, "label": "Good"},
    "C": {"min": 70, "label": "Satisfactory"},
    "D": {"min": 60, "label": "Needs Improvement"},
    "F": {"min": 0, "label": "Unsatisfactory"}
  }
}

Extract every category, subcategory, point value, and grading criterion you can find. If the grading scale is specified in the rubric, use those values instead of the defaults shown above.

IMPORTANT: Keep each description to a SHORT phrase (max 40 chars). Use abbreviations if needed. This prevents output truncation.

Return ONLY the JSON object, nothing else.`;

            // Determine if this is an image or document type
            const isImage = mimeType.startsWith('image/');
            const isPDF = mimeType === 'application/pdf';
            const isDocument = isPDF || 
                mimeType.includes('spreadsheet') || 
                mimeType.includes('excel') || 
                mimeType.includes('csv') ||
                mimeType.includes('word') ||
                mimeType.includes('document') ||
                mimeType === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' ||
                mimeType === 'application/vnd.ms-excel' ||
                mimeType === 'text/csv' ||
                mimeType === 'application/msword' ||
                mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';

            console.log('File type:', isImage ? 'image' : isDocument ? 'document' : 'unknown');

            if (provider === 'gemini') {
                return await extractWithGemini(base64Data, mimeType, prompt, apiKey);
            } else if (provider === 'gpt4o') {
                // OpenAI Vision only supports images, not PDFs or documents directly
                if (!isImage) {
                    throw new Error('OpenAI GPT-4o Vision only supports image files (PNG, JPG, JPEG, WebP).\n\nFor PDF, Excel, or Word files, please use Gemini or Claude instead.');
                }
                return await extractWithOpenAI(base64Data, mimeType, prompt, apiKey);
            } else if (provider === 'claude') {
                return await extractWithClaude(base64Data, mimeType, prompt, apiKey, isImage);
            }
        }
        
        async function extractWithGemini(base64Data, mimeType, prompt, apiKey) {
            // Use gemini-2.5-flash which supports documents, images, PDFs, spreadsheets
            // Supported: image/*, application/pdf, text/*, and many document types
            console.log('Gemini extraction with mimeType:', mimeType);
            
            const response = await fetchWithTimeout(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{
                        parts: [
                            { text: prompt },
                            {
                                inline_data: {
                                    mime_type: mimeType,
                                    data: base64Data
                                }
                            }
                        ]
                    }],
                    generationConfig: {
                        temperature: 0.3,
                        topK: 32,
                        topP: 1,
                        maxOutputTokens: 16384  // Large rubrics need more output tokens
                    }
                })
            }, 90000);  // 90 second timeout for document extraction
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                console.error('Gemini API error:', errorData);
                
                // Provide helpful error message
                if (response.status === 404) {
                    throw new Error(`API key may be invalid. Please:\n1. Get a new key from https://aistudio.google.com/app/apikey\n2. Make sure it's enabled for Gemini API\n3. Try again with the new key`);
                } else if (response.status === 400) {
                    const errMsg = errorData.error?.message || 'Check your file format';
                    // Handle unsupported file types
                    if (errMsg.includes('not supported') || errMsg.includes('mime')) {
                        throw new Error(`This file type (${mimeType}) may not be supported.\n\nTry converting to PDF or taking a screenshot of the rubric.`);
                    }
                    throw new Error(`Bad request: ${errMsg}`);
                } else {
                    throw new Error(`Gemini API error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
                }
            }
            
            const data = await response.json();
            
            if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
                console.error('Gemini response:', data);
                // Check for blocked content
                if (data.candidates?.[0]?.finishReason === 'SAFETY') {
                    throw new Error('Content was blocked by safety filters. Please try a different file.');
                }
                throw new Error('Unexpected response format from Gemini API');
            }
            
            const text = data.candidates[0].content.parts[0].text;
            console.log('Gemini response length:', text.length);
            console.log('Gemini raw response:', text.substring(0, 500) + '...');
            
            // Clean up the response to extract JSON
            let cleanedText = text;
            // Remove markdown code fences if present
            cleanedText = cleanedText.replace(/```json\s*/gi, '').replace(/```\s*/g, '');
            
            const jsonMatch = cleanedText.match(/\{[\s\S]*\}/);
            if (!jsonMatch) {
                console.error('AI Response:', text);
                throw new Error('No valid JSON found in AI response. The AI may not have recognized a rubric structure in the document.');
            }
            
            let jsonStr = jsonMatch[0];
            try {
                return JSON.parse(jsonStr);
            } catch (parseError) {
                // Try to repair truncated JSON (AI may cut off mid-response)
                jsonStr = jsonStr.replace(/,\s*$/, '');  // Remove trailing comma if truncated after one
                const openBraces = (jsonStr.match(/\{/g) || []).length;
                const closeBraces = (jsonStr.match(/\}/g) || []).length;
                const openBrackets = (jsonStr.match(/\[/g) || []).length;
                const closeBrackets = (jsonStr.match(/\]/g) || []).length;
                // If truncated mid-string (ends inside quotes), close the string
                const lastQuote = jsonStr.lastIndexOf('"');
                const afterLastQuote = jsonStr.slice(lastQuote + 1);
                if (lastQuote >= 0 && !afterLastQuote.match(/^\s*[,}\]\]]/)) jsonStr += '"';
                // Append missing closers - correct order: } before ] (innermost object before array)
                const needB = openBraces - closeBraces;
                const needBr = openBrackets - closeBrackets;
                for (let i = 0; i < Math.max(needB, needBr); i++) {
                    if (i < needB) jsonStr += '}';
                    if (i < needBr) jsonStr += ']';
                }
                try {
                    return JSON.parse(jsonStr);
                } catch (e2) {
                    console.error('JSON parse error:', parseError.message);
                    console.error('Attempted to parse:', jsonStr.substring(0, 1000));
                    throw new Error('AI returned invalid or truncated JSON. Please try again or use a clearer image of the rubric.');
                }
            }
        }
        
        async function extractWithOpenAI(base64Data, mimeType, prompt, apiKey) {
            const response = await fetchWithTimeout('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: 'gpt-4o',
                    messages: [{
                        role: 'user',
                        content: [
                            { type: 'text', text: prompt },
                            {
                                type: 'image_url',
                                image_url: {
                                    url: `data:${mimeType};base64,${base64Data}`
                                }
                            }
                        ]
                    }],
                    max_tokens: 2000
                })
            }, 60000);  // 60 second timeout for image extraction
            
            if (!response.ok) {
                throw new Error(`OpenAI API error: ${response.status}`);
            }
            
            const data = await response.json();
            const text = data.choices[0].message.content;
            
            const jsonMatch = text.match(/\{[\s\S]*\}/);
            if (!jsonMatch) {
                throw new Error('No valid JSON found in AI response');
            }
            
            return JSON.parse(jsonMatch[0]);
        }
        
        async function extractWithClaude(base64Data, mimeType, prompt, apiKey, isImage = true) {
            // Claude uses 'image' type for images and 'document' type for PDFs and other docs
            let contentPart;
            if (isImage) {
                contentPart = {
                    type: 'image',
                    source: {
                        type: 'base64',
                        media_type: mimeType,
                        data: base64Data
                    }
                };
            } else {
                // For PDFs, Excel, Word docs - use document type
                contentPart = {
                    type: 'document',
                    source: {
                        type: 'base64',
                        media_type: mimeType,
                        data: base64Data
                    }
                };
            }
            
            const response = await fetchWithTimeout('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01',
                    'anthropic-beta': 'pdfs-2024-09-25'  // Enable PDF support
                },
                body: JSON.stringify({
                    model: 'claude-sonnet-4-20250514',
                    max_tokens: 4000,
                    messages: [{
                        role: 'user',
                        content: [
                            { type: 'text', text: prompt },
                            contentPart
                        ]
                    }]
                })
            }, 90000);  // 90 second timeout for document extraction
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                console.error('Claude API error:', response.status, errorData);
                const errorMsg = errorData.error?.message || `Status ${response.status}`;
                throw new Error(`Claude API error: ${errorMsg}`);
            }
            
            const data = await response.json();
            const text = data.content[0].text;
            
            const jsonMatch = text.match(/\{[\s\S]*\}/);
            if (!jsonMatch) {
                console.error('Claude response:', text);
                throw new Error('No valid JSON found in AI response. The AI may not have recognized a rubric structure.');
            }
            
            return JSON.parse(jsonMatch[0]);
        }

        let categoryCounter = 0;

        function addCategory() {
            categoryCounter++;
            const container = document.getElementById('categoriesContainer');
            const categoryDiv = document.createElement('div');
            categoryDiv.className = 'category-item';
            categoryDiv.id = `category-${categoryCounter}`;
            categoryDiv.style.cssText = 'background: var(--bg-alt); padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem; border: 1px solid var(--border); transition: all 0.2s ease;';
            categoryDiv.onmouseover = function() { this.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)'; };
            categoryDiv.onmouseout = function() { this.style.boxShadow = 'none'; };
            
            categoryDiv.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; gap: 0.75rem;">
                    <input type="text" placeholder="Category Name (e.g., Content - Introduction)" 
                           class="category-name" style="flex: 1; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; font-size: 0.9375rem;" required
                           oninput="updateRubricPoints(); updateRubricPreview();">
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <label style="font-size: 0.85rem; color: var(--text-light); white-space: nowrap;">Points:</label>
                        <input type="number" class="category-points" placeholder="0" min="0" step="1" 
                               style="width: 80px; padding: 0.4rem; border: 1px solid var(--border); border-radius: 0.25rem; font-size: 0.9rem;"
                               oninput="updateRubricPoints(); updateRubricPreview();">
                    </div>
                    <button type="button" onclick="removeCategory('category-${categoryCounter}')" class="btn-small btn-danger" style="flex-shrink: 0;"><span class="icon-with-text"><i data-lucide="trash-2" style="width:0.875rem;height:0.875rem;"></i> Remove</span></button>
                </div>
                <div class="form-group" style="margin-bottom: 0.75rem;">
                    <label style="font-size: 0.85rem; color: var(--text-light); font-weight: 500;">Description (helps AI know what to look for)</label>
                    <textarea class="category-description" placeholder="e.g., Assess organization, evidence, and clarity of main ideas" rows="2" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.25rem; font-size: 0.9rem; resize: vertical; font-family: inherit;" oninput="updateRubricPreview();"></textarea>
                </div>
                <div class="subcategories-container" id="subcategories-${categoryCounter}" style="margin-bottom: 0.5rem;"></div>
                <button type="button" onclick="addSubcategory('subcategories-${categoryCounter}')" class="btn-small" style="margin-top: 0.5rem;"><span class="icon-with-text"><i data-lucide="plus" style="width:0.875rem;height:0.875rem;"></i> Add Subcategory</span></button>
            `;
            
            container.appendChild(categoryDiv);
            
            // Initialize icons
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons({ root: categoryDiv });
            }
            
            // Add one default subcategory
            addSubcategory(`subcategories-${categoryCounter}`);
            
            // Update points and preview
            updateRubricPoints();
            updateRubricPreview();
        }

        function removeCategory(categoryId) {
            const element = document.getElementById(categoryId);
            if (element) {
                element.remove();
                updateRubricPoints();
                updateRubricPreview();
            }
        }

        let subcategoryCounter = 0;

        function addSubcategory(containerId) {
            subcategoryCounter++;
            const container = document.getElementById(containerId);
            const subDiv = document.createElement('div');
            subDiv.id = `subcategory-${subcategoryCounter}`;
            subDiv.className = 'subcategory-row';
            subDiv.style.cssText = 'display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.5rem; padding: 0.5rem; background: white; border-radius: 0.25rem; border: 1px solid var(--border); transition: all 0.15s ease;';
            subDiv.onmouseover = function() { this.style.background = 'var(--bg-alt)'; };
            subDiv.onmouseout = function() { this.style.background = 'white'; };
            
            subDiv.innerHTML = `
                <span style="color: var(--text-light); font-size: 0.9rem; flex-shrink: 0;">•</span>
                <input type="text" placeholder="Subcategory (e.g., Eye Contact)" 
                       class="subcategory-name" style="flex: 1; min-width: 0; padding: 0.4rem; border: 1px solid var(--border); border-radius: 0.25rem; font-size: 0.9rem;" required
                       oninput="updateRubricPreview();">
                <input type="text" placeholder="Description (optional)" class="subcategory-description" 
                       style="flex: 1; min-width: 0; padding: 0.4rem; border: 1px solid var(--border); border-radius: 0.25rem; font-size: 0.85rem;" title="Helps the AI know what to look for"
                       oninput="updateRubricPreview();">
                <input type="number" class="subcategory-points" placeholder="pts" min="0" step="0.5" 
                       style="width: 70px; padding: 0.4rem; border: 1px solid var(--border); border-radius: 0.25rem; font-size: 0.85rem;"
                       oninput="updateRubricPoints(); updateRubricPreview();" title="Points for this subcategory">
                <button type="button" onclick="removeSubcategory('subcategory-${subcategoryCounter}')" class="btn-small btn-danger" style="padding: 0.25rem 0.5rem; font-size: 0.8rem; flex-shrink: 0;" aria-label="Remove subcategory">✕</button>
            `;
            
            container.appendChild(subDiv);
            
            // Update points and preview
            updateRubricPoints();
            updateRubricPreview();
        }

        function removeSubcategory(subId) {
            const element = document.getElementById(subId);
            if (element) {
                element.remove();
                updateRubricPoints();
                updateRubricPreview();
            }
        }
        
        // Update rubric point calculations and validation
        function updateRubricPoints() {
            const totalPointsEl = document.getElementById('rubricTotalPoints');
            const totalPoints = totalPointsEl ? parseInt(totalPointsEl.value) || 50 : 50;
            
            // Update display
            const totalDisplay = document.getElementById('rubricTotalPointsDisplay');
            if (totalDisplay) totalDisplay.textContent = totalPoints;
            
            // Calculate assigned points
            let assignedPoints = 0;
            
            // Count points from subcategories (preferred method)
            document.querySelectorAll('.subcategory-points').forEach(input => {
                const points = parseFloat(input.value) || 0;
                assignedPoints += points;
            });
            
            // If no subcategory points, count category points
            if (assignedPoints === 0) {
                document.querySelectorAll('.category-points').forEach(input => {
                    const points = parseFloat(input.value) || 0;
                    assignedPoints += points;
                });
            }
            
            const remaining = totalPoints - assignedPoints;
            
            // Update display
            const assignedEl = document.getElementById('rubricPointsAssigned');
            const unassignedEl = document.getElementById('rubricPointsUnassigned');
            const warningEl = document.getElementById('rubricPointWarning');
            const warningTotalEl = document.getElementById('rubricPointWarningTotal');
            
            if (assignedEl) assignedEl.textContent = assignedPoints;
            if (unassignedEl) {
                unassignedEl.textContent = remaining;
                unassignedEl.style.color = remaining < 0 ? 'var(--error)' : (remaining === 0 ? 'var(--success)' : 'var(--text-light)');
            }
            
            // Show warning if points don't match
            if (warningEl && warningTotalEl) {
                if (assignedPoints !== totalPoints) {
                    warningEl.style.display = 'block';
                    warningTotalEl.textContent = totalPoints;
                } else {
                    warningEl.style.display = 'none';
                }
            }
            
            // Update icons
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                const helper = document.getElementById('rubricPointHelper');
                if (helper) lucide.createIcons({ root: helper });
            }
        }
        
        // Update rubric preview
        function updateRubricPreview() {
            const previewSection = document.getElementById('rubricPreviewSection');
            const previewContent = document.getElementById('rubricPreviewContent');
            if (!previewSection || !previewContent) return;
            
            const name = document.getElementById('rubricName')?.value || '';
            const description = document.getElementById('rubricDescription')?.value || '';
            const speechType = document.getElementById('rubricSpeechType')?.value || '';
            
            if (!name && !description) {
                previewSection.style.display = 'none';
                return;
            }
            
            previewSection.style.display = 'block';
            
            let html = '';
            if (name) {
                html += `<h5 style="margin: 0 0 0.5rem 0; font-size: 1.125rem; font-weight: 600; color: var(--text);">${escapeHtml(name)}</h5>`;
            }
            if (speechType) {
                html += `<p style="margin: 0 0 0.75rem 0; font-size: 0.875rem; color: var(--text-light);"><strong>Type:</strong> ${escapeHtml(speechType)}</p>`;
            }
            if (description) {
                html += `<p style="margin: 0 0 1rem 0; font-size: 0.9rem; color: var(--text); line-height: 1.5;">${escapeHtml(description)}</p>`;
            }
            
            // Show categories
            const categories = [];
            document.querySelectorAll('.category-item').forEach(catEl => {
                const catName = catEl.querySelector('.category-name')?.value || '';
                const catDesc = catEl.querySelector('.category-description')?.value || '';
                if (!catName) return;
                
                const subcategories = [];
                catEl.querySelectorAll('.subcategory-row').forEach(row => {
                    const subName = row.querySelector('.subcategory-name')?.value || '';
                    const subDesc = row.querySelector('.subcategory-description')?.value || '';
                    const subPoints = row.querySelector('.subcategory-points')?.value || '';
                    if (subName) {
                        subcategories.push({ name: subName, description: subDesc, points: subPoints });
                    }
                });
                
                if (subcategories.length > 0) {
                    categories.push({ name: catName, description: catDesc, subcategories });
                }
            });
            
            if (categories.length > 0) {
                html += '<div style="margin-top: 1rem;">';
                categories.forEach((cat, idx) => {
                    html += `<div style="margin-bottom: ${idx < categories.length - 1 ? '1rem' : '0'}; padding-bottom: ${idx < categories.length - 1 ? '1rem' : '0'}; border-bottom: ${idx < categories.length - 1 ? '1px solid var(--border)' : 'none'};">`;
                    html += `<h6 style="margin: 0 0 0.5rem 0; font-size: 1rem; font-weight: 600; color: var(--primary);">${escapeHtml(cat.name)}</h6>`;
                    if (cat.description) {
                        html += `<p style="margin: 0 0 0.5rem 0; font-size: 0.85rem; color: var(--text-light);">${escapeHtml(cat.description)}</p>`;
                    }
                    html += '<ul style="margin: 0; padding-left: 1.25rem; list-style: disc;">';
                    cat.subcategories.forEach(sub => {
                        html += '<li style="margin-bottom: 0.25rem; font-size: 0.9rem; color: var(--text);">';
                        html += `<strong>${escapeHtml(sub.name)}</strong>`;
                        if (sub.points) html += ` <span style="color: var(--text-light);">(${escapeHtml(sub.points)} pts)</span>`;
                        if (sub.description) html += ` — ${escapeHtml(sub.description)}`;
                        html += '</li>';
                    });
                    html += '</ul></div>';
                });
                html += '</div>';
            }
            
            previewContent.innerHTML = html;
        }
        
        // Show rubric templates
        function showRubricTemplates() {
            const templates = [
                {
                    name: 'Self-Introduction Speech',
                    description: 'Standard rubric for introductory speeches',
                    categories: [
                        { name: 'Content - Introduction', subcategories: ['Capture Attention', 'Relevance to Audience', 'Introduction of Topic/Purpose'] },
                        { name: 'Content - Organization', subcategories: ['Pattern', 'Connectives', 'Within Time Limits'] },
                        { name: 'Content - Conclusion', subcategories: ['Summary', 'Memorable Closing'] },
                        { name: 'Delivery', subcategories: ['Eye Contact', 'Vocal Variety', 'Gestures', 'Posture'] }
                    ]
                },
                {
                    name: 'Persuasive Speech',
                    description: 'Rubric for persuasive presentations',
                    categories: [
                        { name: 'Argumentation', subcategories: ['Thesis Statement', 'Supporting Evidence', 'Logical Reasoning', 'Counterarguments'] },
                        { name: 'Organization', subcategories: ['Introduction', 'Body Structure', 'Conclusion', 'Transitions'] },
                        { name: 'Delivery', subcategories: ['Eye Contact', 'Vocal Variety', 'Gestures', 'Enthusiasm'] },
                        { name: 'Language', subcategories: ['Clarity', 'Appropriateness', 'Figurative Language'] }
                    ]
                },
                {
                    name: 'Informative Speech',
                    description: 'Rubric for informative presentations',
                    categories: [
                        { name: 'Content', subcategories: ['Topic Selection', 'Research Quality', 'Information Accuracy', 'Depth of Coverage'] },
                        { name: 'Organization', subcategories: ['Introduction', 'Body Structure', 'Conclusion', 'Transitions'] },
                        { name: 'Delivery', subcategories: ['Eye Contact', 'Vocal Clarity', 'Pacing', 'Visual Aids'] },
                        { name: 'Audience Engagement', subcategories: ['Relevance', 'Interest Level', 'Clarity'] }
                    ]
                }
            ];
            
            // Create modal
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 1rem;';
            modal.setAttribute('role', 'dialog');
            modal.setAttribute('aria-modal', 'true');
            modal.setAttribute('aria-labelledby', 'templateModalTitle');
            
            let templateHTML = '<div style="background: white; border-radius: 1rem; max-width: 600px; width: 100%; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column; box-shadow: 0 20px 60px rgba(0,0,0,0.3);">';
            templateHTML += '<div style="padding: 1.5rem; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center;">';
            templateHTML += '<h2 id="templateModalTitle" style="margin: 0; font-size: 1.25rem; font-weight: 600;">Choose a Template</h2>';
            templateHTML += '<button type="button" onclick="this.closest(\'[role=dialog]\').remove()" aria-label="Close" style="background: none; border: none; padding: 0.5rem; cursor: pointer; color: var(--text-light); border-radius: 0.5rem;" onmouseover="this.style.background=\'var(--bg-alt)\'" onmouseout="this.style.background=\'transparent\'"><i data-lucide="x" style="width:1.25rem;height:1.25rem;"></i></button>';
            templateHTML += '</div>';
            templateHTML += '<div style="padding: 1.5rem; overflow-y: auto; flex: 1;">';
            
            templates.forEach((template, idx) => {
                templateHTML += `<div style="padding: 1rem; border: 1px solid var(--border); border-radius: 0.5rem; margin-bottom: ${idx < templates.length - 1 ? '1rem' : '0'}; cursor: pointer; transition: all 0.2s;" onclick="applyRubricTemplate(${idx}); this.closest('[role=dialog]').remove();" onmouseover="this.style.background='var(--bg-alt)'; this.style.borderColor='var(--primary)'" onmouseout="this.style.background='white'; this.style.borderColor='var(--border)'">`;
                templateHTML += `<h3 style="margin: 0 0 0.5rem 0; font-size: 1rem; font-weight: 600; color: var(--text);">${escapeHtml(template.name)}</h3>`;
                templateHTML += `<p style="margin: 0 0 0.75rem 0; font-size: 0.875rem; color: var(--text-light);">${escapeHtml(template.description)}</p>`;
                templateHTML += `<div style="font-size: 0.85rem; color: var(--text-light);"><strong>${template.categories.length}</strong> categories, <strong>${template.categories.reduce((sum, cat) => sum + cat.subcategories.length, 0)}</strong> subcategories</div>`;
                templateHTML += '</div>';
            });
            
            templateHTML += '</div></div>';
            modal.innerHTML = templateHTML;
            document.body.appendChild(modal);
            
            // Close on backdrop click
            modal.addEventListener('click', function(e) {
                if (e.target === modal) modal.remove();
            });
            
            // Initialize icons
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons({ root: modal });
            }
            
            // Store templates for apply function
            window.rubricTemplates = templates;
        }
        
        // Apply rubric template
        function applyRubricTemplate(templateIndex) {
            const templates = window.rubricTemplates || [];
            if (!templates[templateIndex]) return;
            
            const template = templates[templateIndex];
            
            // Clear existing categories
            document.getElementById('categoriesContainer').innerHTML = '';
            categoryCounter = 0;
            subcategoryCounter = 0;
            
            // Set basic info
            document.getElementById('rubricName').value = template.name;
            document.getElementById('rubricDescription').value = template.description || '';
            
            // Add categories
            template.categories.forEach(cat => {
                addCategory();
                const lastCategory = document.querySelectorAll('.category-item').item(document.querySelectorAll('.category-item').length - 1);
                if (lastCategory) {
                    lastCategory.querySelector('.category-name').value = cat.name;
                    
                    // Clear default subcategory and add template subcategories
                    const subContainer = lastCategory.querySelector('.subcategories-container');
                    if (subContainer) {
                        subContainer.innerHTML = '';
                        cat.subcategories.forEach(subName => {
                            addSubcategory(subContainer.id);
                            const lastSub = subContainer.querySelectorAll('.subcategory-row').item(subContainer.querySelectorAll('.subcategory-row').length - 1);
                            if (lastSub) {
                                lastSub.querySelector('.subcategory-name').value = subName;
                            }
                        });
                    }
                }
            });
            
            updateRubricPoints();
            updateRubricPreview();
            
            // Show notification
            if (typeof showNotification === 'function') {
                showNotification(`Template "${template.name}" applied. Adjust points and descriptions as needed.`, 'success');
            }
        }

        async function suggestDescriptionsFromTextbook() {
            const textbookEl = document.getElementById('rubricTextbook');
            const textbookId = textbookEl && textbookEl.value ? textbookEl.value.trim() : '';
            if (!textbookId) {
                alert('Select a textbook first, then add categories and subcategories. Descriptions will be suggested from the textbook content.');
                return;
            }
            const names = [];
            const elements = [];
            document.querySelectorAll('.category-item').forEach((catEl) => {
                const nameInput = catEl.querySelector('.category-name');
                const descInput = catEl.querySelector('.category-description');
                const name = nameInput ? nameInput.value.trim() : '';
                if (name) {
                    names.push(name);
                    elements.push({ name, input: descInput });
                }
                catEl.querySelectorAll('.subcategory-row').forEach((row) => {
                    const subNameInput = row.querySelector('.subcategory-name');
                    const subDescInput = row.querySelector('.subcategory-description');
                    const subName = subNameInput ? subNameInput.value.trim() : '';
                    if (subName) {
                        names.push(subName);
                        elements.push({ name: subName, input: subDescInput });
                    }
                });
            });
            if (names.length === 0) {
                alert('Add at least one category or subcategory with a name to suggest descriptions.');
                return;
            }
            const btn = document.getElementById('suggestFromTextbookBtn');
            if (btn) btn.disabled = true;
            try {
                const base = (typeof window !== 'undefined' && window.location && window.location.origin) ? window.location.origin : '';
                const r = await fetch(base + '/api/suggest-rubric-descriptions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ textbook_id: textbookId, names: [...new Set(names)] }),
                });
                if (!r.ok) {
                    const err = await r.json().catch(() => ({}));
                    throw new Error(err.detail || 'Failed to get suggestions');
                }
                const data = await r.json();
                const suggestions = data.suggestions || {};
                let filled = 0;
                elements.forEach(({ name, input }) => {
                    const text = suggestions[name];
                    if (input && text) {
                        input.value = text;
                        filled++;
                    }
                });
                alert(filled > 0 ? `Filled ${filled} description(s) from the textbook.` : 'No matching textbook content found for the category names. Try different names or check that the textbook was ingested.');
            } catch (e) {
                alert('Could not suggest descriptions: ' + e.message);
            } finally {
                if (btn) btn.disabled = false;
            }
        }

        let exampleVideoCounter = 0;
        function addExampleVideo(url, label) {
            exampleVideoCounter++;
            const container = document.getElementById('exampleVideosContainer');
            const row = document.createElement('div');
            row.className = 'example-video-row';
            row.id = `example-video-${exampleVideoCounter}`;
            row.style.cssText = 'display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;';
            row.innerHTML = `
                <input type="url" placeholder="Video URL (YouTube, Vimeo, or direct link)" class="example-video-url" 
                       value="${(url || '').replace(/"/g, '&quot;')}" 
                       style="flex: 1; min-width: 200px; padding: 0.4rem; border: 1px solid var(--border); border-radius: 0.25rem;">
                <input type="text" placeholder="Label (e.g., Strong eye contact example)" class="example-video-label" 
                       value="${(label || '').replace(/"/g, '&quot;')}" 
                       style="flex: 1; min-width: 150px; padding: 0.4rem; border: 1px solid var(--border); border-radius: 0.25rem; font-size: 0.9rem;">
                <button type="button" onclick="removeExampleVideo('example-video-${exampleVideoCounter}')" class="btn-small btn-danger" style="padding: 0.25rem 0.5rem;">✕</button>
            `;
            container.appendChild(row);
        }
        function removeExampleVideo(rowId) {
            const el = document.getElementById(rowId);
            if (el) el.remove();
        }

        function collectRubricData() {
            // Collect selected course IDs from checkboxes
            const selectedCourseIds = Array.from(document.querySelectorAll('.course-checkbox:checked'))
                .map(checkbox => checkbox.value);
            
            const editingId = document.getElementById('editingRubricId').value || '';
            const editingSupabaseId = document.getElementById('editingRubricSupabaseId').value || '';
            const rubricData = {
                id: editingId || ('rubric-' + Date.now()),
                supabaseId: editingSupabaseId || undefined,
                name: document.getElementById('rubricName').value.trim(),
                description: document.getElementById('rubricDescription').value.trim(),
                totalPoints: parseInt(document.getElementById('rubricTotalPoints').value),
                speechType: document.getElementById('rubricSpeechType').value.trim() || null,
                courseIds: selectedCourseIds.length > 0 ? selectedCourseIds : [], // Array of course IDs
                gradeScale: {
                    A: {
                        label: document.getElementById('gradeA_label').value,
                        percentage: parseFloat(document.getElementById('gradeA_pct').value) / 100,
                        range: document.getElementById('gradeA_range').value
                    },
                    B: {
                        label: document.getElementById('gradeB_label').value,
                        percentage: parseFloat(document.getElementById('gradeB_pct').value) / 100,
                        range: document.getElementById('gradeB_range').value
                    },
                    C: {
                        label: document.getElementById('gradeC_label').value,
                        percentage: parseFloat(document.getElementById('gradeC_pct').value) / 100,
                        range: document.getElementById('gradeC_range').value
                    },
                    D: {
                        label: document.getElementById('gradeD_label').value,
                        percentage: parseFloat(document.getElementById('gradeD_pct').value) / 100,
                        range: document.getElementById('gradeD_range').value
                    },
                    F: {
                        label: document.getElementById('gradeF_label').value,
                        percentage: parseFloat(document.getElementById('gradeF_pct').value) / 100,
                        range: document.getElementById('gradeF_range').value
                    }
                },
                categories: []
            };

            // Collect categories and subcategories
            const categoryElements = document.querySelectorAll('.category-item');
            
            categoryElements.forEach((catEl) => {
                const categoryName = catEl.querySelector('.category-name').value.trim();
                if (!categoryName) return;
                const categoryDesc = (catEl.querySelector('.category-description')?.value || '').trim();

                const subcategories = [];
                const subRows = catEl.querySelectorAll('.subcategory-row');
                subRows.forEach((row) => {
                    const subInput = row.querySelector('.subcategory-name');
                    const descInput = row.querySelector('.subcategory-description');
                    const subName = subInput ? subInput.value.trim() : '';
                    const subDesc = descInput ? descInput.value.trim() : '';
                    if (subName) {
                        subcategories.push(subDesc ? { name: subName, description: subDesc } : { name: subName, description: '' });
                    }
                });

                if (subcategories.length > 0) {
                    rubricData.categories.push({
                        name: categoryName,
                        description: categoryDesc,
                        subcategories: subcategories
                    });
                }
            });

            // Collect example videos
            rubricData.exampleVideos = [];
            document.querySelectorAll('.example-video-row').forEach((row) => {
                const urlInput = row.querySelector('.example-video-url');
                const labelInput = row.querySelector('.example-video-label');
                const url = (urlInput?.value || '').trim();
                if (url) {
                    rubricData.exampleVideos.push({ url, label: (labelInput?.value || '').trim() });
                }
            });

            // Textbook
            const textbookEl = document.getElementById('rubricTextbook');
            rubricData.textbookId = (textbookEl && textbookEl.value) ? textbookEl.value : null;

            return rubricData;
        }

        async function loadRubricIntoForm(rubric) {
            document.getElementById('rubricFormHeader').textContent = 'Edit Rubric';
            document.getElementById('rubricSubmitBtn').textContent = 'Save Changes';
            document.getElementById('editingRubricId').value = rubric.id || '';
            const supabaseIdEl = document.getElementById('editingRubricSupabaseId');
            if (supabaseIdEl) supabaseIdEl.value = rubric.supabaseId || rubric.id || '';
            
            // Normalize from Supabase snake_case if needed
            const gradeScale = rubric.gradeScale || rubric.grade_scale || {};
            const totalPoints = rubric.totalPoints ?? rubric.total_points ?? 100;
            const speechType = rubric.speechType ?? rubric.speech_type ?? '';
            
            // Basic info
            document.getElementById('rubricName').value = rubric.name || '';
            document.getElementById('rubricDescription').value = rubric.description || '';
            document.getElementById('rubricTotalPoints').value = totalPoints;
            document.getElementById('rubricSpeechType').value = speechType;
            
            // Populate course selector with pre-selected courses
            // Handle both old single courseId and new courseIds array for backward compatibility
            let selectedCourseIds = [];
            if (rubric.courseIds && Array.isArray(rubric.courseIds)) {
                selectedCourseIds = rubric.courseIds;
            } else if (rubric.courseId) {
                // Backward compatibility: convert old single courseId to array
                selectedCourseIds = [rubric.courseId];
            }
            populateCourseSelector(selectedCourseIds);
            await loadTextbooksForRubricForm();
            const textbookId = rubric.textbookId ?? rubric.textbook_id ?? null;
            const textbookEl = document.getElementById('rubricTextbook');
            if (textbookEl) textbookEl.value = textbookId || '';

            // Grade scale (with fallbacks for missing or Supabase format)
            for (const grade of ['A', 'B', 'C', 'D', 'F']) {
                const gradeData = gradeScale[grade] || {};
                const labelEl = document.getElementById(`grade${grade}_label`);
                const pctEl = document.getElementById(`grade${grade}_pct`);
                const rangeEl = document.getElementById(`grade${grade}_range`);
                if (labelEl) labelEl.value = gradeData.label ?? '';
                if (pctEl) pctEl.value = (gradeData.percentage != null ? gradeData.percentage * 100 : 0);
                if (rangeEl) rangeEl.value = gradeData.range ?? '';
            }
            
            // Clear and rebuild categories
            document.getElementById('categoriesContainer').innerHTML = '';
            categoryCounter = 0;
            subcategoryCounter = 0;
            
            const categories = rubric.categories || [];
            categories.forEach((category) => {
                addCategory();
                const lastCategory = document.querySelector('.category-item:last-child');
                if (lastCategory) {
                    const nameInput = lastCategory.querySelector('.category-name');
                    const descInput = lastCategory.querySelector('.category-description');
                    if (nameInput) nameInput.value = category.name || '';
                    if (descInput) descInput.value = (category.description || '').trim();
                }
                const subContainer = lastCategory ? lastCategory.querySelector('.subcategories-container') : null;
                if (subContainer) subContainer.innerHTML = '';
                
                const subcats = category.subcategories || [];
                if (subContainer && subContainer.id) {
                    subcats.forEach((sub) => {
                        addSubcategory(subContainer.id);
                        const rows = subContainer.querySelectorAll('.subcategory-row');
                        const lastRow = rows[rows.length - 1];
                        if (lastRow) {
                            const subName = typeof sub === 'string' ? sub : (sub && sub.name) ? sub.name : '';
                            const subDesc = (typeof sub === 'object' && sub && sub.description) ? sub.description : '';
                            const nameInput = lastRow.querySelector('.subcategory-name');
                            const descInput = lastRow.querySelector('.subcategory-description');
                            if (nameInput) nameInput.value = subName;
                            if (descInput) descInput.value = subDesc;
                        }
                    });
                }
            });

            // Load example videos
            const exampleVideosContainer = document.getElementById('exampleVideosContainer');
            if (exampleVideosContainer) {
                exampleVideosContainer.innerHTML = '';
                const examples = rubric.exampleVideos || rubric.example_videos || [];
                if (examples.length > 0) {
                    examples.forEach(ev => {
                        addExampleVideo(ev.url, ev.label);
                    });
                }
            }
            
            document.getElementById('createRubricCard').classList.remove('hidden');
            document.getElementById('createRubricCard').scrollIntoView({ behavior: 'smooth' });
        }

        // ===== STUDENT MANAGEMENT =====
        function toggleStudentMenu() {
            // Close all student menus first
            document.querySelectorAll('.student-menu:not(.hidden)').forEach(menu => {
                menu.classList.add('hidden');
                const btn = menu.parentElement?.querySelector('button[aria-haspopup="true"]');
                if (btn) btn.setAttribute('aria-expanded', 'false');
            });
            
            // Find the menu associated with the clicked button
            const event = window.event || arguments[0];
            const button = event?.target?.closest('button') || document.querySelector('button[onclick*="toggleStudentMenu()"]');
            if (!button) return;
            
            const menu = button.parentElement?.querySelector('.student-menu');
            if (!menu) return;
            
            const isExpanded = !menu.classList.contains('hidden');
            if (isExpanded) {
                menu.classList.add('hidden');
                button.setAttribute('aria-expanded', 'false');
            } else {
                menu.classList.remove('hidden');
                button.setAttribute('aria-expanded', 'true');
                
                // Initialize icons
                if (typeof lucide !== 'undefined' && lucide.createIcons) {
                    lucide.createIcons({ root: menu });
                }
            }
        }
        
        // Close student menus when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.student-menu') && !e.target.closest('button[onclick*="toggleStudentMenu()"]')) {
                document.querySelectorAll('.student-menu:not(.hidden)').forEach(menu => {
                    menu.classList.add('hidden');
                    const btn = menu.parentElement?.querySelector('button[aria-haspopup="true"]');
                    if (btn) btn.setAttribute('aria-expanded', 'false');
                });
            }
        });
        
        function showAddStudent() {
            window._addStudentPreviousFocus = document.activeElement && document.activeElement.nodeName ? document.activeElement : null;
            const card = document.getElementById('addStudentCard');
            card.classList.remove('hidden');
            card.scrollIntoView({ behavior: 'smooth', block: 'start' });
            var firstInput = document.getElementById('studentFirstName');
            if (firstInput) setTimeout(function() { firstInput.focus(); }, 100);
        }

        function cancelAddStudent() {
            document.getElementById('addStudentCard').classList.add('hidden');
            document.getElementById('addStudentForm').reset();
            if (window._addStudentPreviousFocus && typeof window._addStudentPreviousFocus.focus === 'function' && window._addStudentPreviousFocus.isConnected) window._addStudentPreviousFocus.focus();
        }

        // Edit Student Functions (Apple HIG style)
        let currentEditingStudentId = null;
        
        function deleteStudentFromEditModal() {
            if (!currentEditingStudentId) {
                if (typeof showAnalyticsToast === 'function') showAnalyticsToast('No student selected', 4000);
                else alert('No student selected');
                return;
            }
            closeEditStudentModal();
            deleteStudent(currentEditingStudentId);
        }
        
        // Store values to autopopulate when step 2 is shown
        let pendingClassIdForEval = null;
        let pendingStudentIdForEval = null;
        
        function addEvaluationForStudent(studentId) {
            if (!currentClassId) {
                if (typeof showAnalyticsToast === 'function') showAnalyticsToast('No course selected', 4000);
                else alert('No course selected');
                return;
            }
            
            // Get student and class info
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const classData = classes.find(c => c.id === currentClassId);
            if (!classData) {
                if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Course not found', 4000);
                else alert('Course not found');
                return;
            }
            
            const student = classData.roster?.find(s => s.id === studentId || s.supabaseId === studentId);
            if (!student) {
                if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Student not found', 4000);
                else alert('Student not found');
                return;
            }
            
            // Store the class and student IDs to populate when step 2 is shown
            pendingClassIdForEval = currentClassId;
            pendingStudentIdForEval = student.id || student.supabaseId || student.studentId;
            
            // Show evaluation section and start at step 1
            showEvaluate();
            moveToStep(1);
        }
        
        async function editStudent(studentId) {
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const cls = classes.find(c => c.id === currentClassId);
            if (!cls) {
                alert('Course not found.');
                return;
            }
            
            const student = cls.roster.find(s => s.id === studentId || s.supabaseId === studentId);
            if (!student) {
                alert('Student not found.');
                return;
            }
            
            currentEditingStudentId = studentId;
            
            // Populate form with student data
            document.getElementById('editStudentFirstName').value = student.firstName || '';
            document.getElementById('editStudentLastName').value = student.lastName || '';
            document.getElementById('editStudentEmail').value = student.email || '';
            document.getElementById('editStudentId').value = student.studentId || '';
            
            // Populate course dropdown
            const courseSelect = document.getElementById('editStudentCourse');
            if (courseSelect) {
                courseSelect.innerHTML = '<option value="">-- Select Course --</option>';
                classes.forEach(c => {
                    if (!isDeletedId('deleted_course_ids', c.id)) {
                        const option = document.createElement('option');
                        option.value = c.id;
                        const courseName = `${c.name || 'Unnamed'} - ${c.semester || ''} ${c.year || ''}`.trim();
                        option.textContent = courseName || `Course ${c.id}`;
                        courseSelect.appendChild(option);
                    }
                });
                // Pre-select current course
                courseSelect.value = currentClassId || '';
            }
            
            // Show modal
            const modal = document.getElementById('editStudentModal');
            modal.style.display = 'flex';
            window._editStudentPreviousFocus = document.activeElement && document.activeElement.nodeName ? document.activeElement : null;
            
            // Initialize icons
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: modal });
            
            // Focus first input
            setTimeout(() => {
                const firstInput = document.getElementById('editStudentFirstName');
                if (firstInput) firstInput.focus();
            }, 100);
        }
        
        function closeEditStudentModal() {
            const modal = document.getElementById('editStudentModal');
            modal.style.display = 'none';
            currentEditingStudentId = null;
            document.getElementById('editStudentForm').reset();
            
            // Return focus
            if (window._editStudentPreviousFocus && typeof window._editStudentPreviousFocus.focus === 'function' && window._editStudentPreviousFocus.isConnected) {
                window._editStudentPreviousFocus.focus();
            }
        }
        
        async function saveEditedStudent() {
            if (!currentEditingStudentId) return;
            
            const firstName = document.getElementById('editStudentFirstName').value.trim();
            const lastName = document.getElementById('editStudentLastName').value.trim();
            const email = document.getElementById('editStudentEmail').value.trim();
            const studentId = document.getElementById('editStudentId').value.trim();
            const newCourseId = document.getElementById('editStudentCourse')?.value || '';
            
            if (!firstName || !lastName) {
                alert('First name and last name are required.');
                return;
            }
            
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const sourceClassIndex = classes.findIndex(c => c.id === currentClassId);
            if (sourceClassIndex === -1) {
                alert('Course not found.');
                closeEditStudentModal();
                return;
            }
            
            const sourceClass = classes[sourceClassIndex];
            const studentIndex = sourceClass.roster.findIndex(s => s.id === currentEditingStudentId || s.supabaseId === currentEditingStudentId);
            if (studentIndex === -1) {
                alert('Student not found.');
                closeEditStudentModal();
                return;
            }
            
            const student = sourceClass.roster[studentIndex];
            const originalSupabaseId = student.supabaseId;
            
            // Check if moving to a different course
            const isMovingCourse = newCourseId && newCourseId !== currentClassId;
            
            if (isMovingCourse) {
                // Find target course
                const targetClassIndex = classes.findIndex(c => c.id === newCourseId);
                if (targetClassIndex === -1) {
                    alert('Target course not found.');
                    return;
                }
                
                const targetClass = classes[targetClassIndex];
                
                // Confirm move
                const confirmMessage = `Move "${firstName} ${lastName}" from "${sourceClass.name}" to "${targetClass.name}"?`;
                if (!confirm(confirmMessage)) {
                    return;
                }
                
                // Update student data
                const updatedStudent = {
                    ...student,
                    firstName: firstName,
                    lastName: lastName,
                    email: email || undefined,
                    studentId: studentId || undefined
                };
                
                // Remove from source course
                sourceClass.roster.splice(studentIndex, 1);
                classes[sourceClassIndex] = sourceClass;
                
                // Add to target course
                if (!targetClass.roster) {
                    targetClass.roster = [];
                }
                targetClass.roster.push(updatedStudent);
                classes[targetClassIndex] = targetClass;
                
                setUserItem('classes', JSON.stringify(classes));
                console.log('✓ Student moved to new course in localStorage');
                
                // Update Supabase if both courses have supabaseId
                if (supabaseClient && originalSupabaseId && targetClass.supabaseId) {
                    try {
                        // Update student's course_id in Supabase
                        const { error: moveError } = await supabaseClient
                            .from('course_students')
                            .update({
                                course_id: targetClass.supabaseId,
                                first_name: firstName,
                                last_name: lastName,
                                email: email || null,
                                student_id: studentId || null
                            })
                            .eq('id', originalSupabaseId);
                        
                        if (moveError) {
                            console.error('Error moving student in Supabase:', moveError);
                            alert('Student moved locally, but failed to update in database: ' + (moveError.message || moveError));
                        } else {
                            console.log('✓ Student moved in Supabase');
                        }
                    } catch (e) {
                        console.error('Exception moving student in Supabase:', e);
                        alert('Student moved locally, but failed to update in database.');
                    }
                }
                
                closeEditStudentModal();
                
                // Refresh the class view (show the source class)
                if (currentClassId) {
                    await viewClass(currentClassId);
                }
                
                if (typeof showAnalyticsToast === 'function') {
                    showAnalyticsToast(`Student moved to ${targetClass.name} successfully.`, 4000);
                }
            } else {
                // Just update student data in current course
                sourceClass.roster[studentIndex] = {
                    ...student,
                    firstName: firstName,
                    lastName: lastName,
                    email: email || undefined,
                    studentId: studentId || undefined
                };
                
                setUserItem('classes', JSON.stringify(classes));
                console.log('✓ Student updated in localStorage');
                
                // Update in Supabase if course has supabaseId
                if (supabaseClient && sourceClass.supabaseId && originalSupabaseId) {
                    try {
                        const { error } = await supabaseClient
                            .from('course_students')
                            .update({
                                first_name: firstName,
                                last_name: lastName,
                                email: email || null,
                                student_id: studentId || null
                            })
                            .eq('id', originalSupabaseId);
                        
                        if (error) {
                            console.error('Error updating student in Supabase:', error);
                            // Still show success since local update worked
                        } else {
                            console.log('✓ Student updated in Supabase');
                        }
                    } catch (e) {
                        console.error('Error updating student in Supabase:', e);
                    }
                }
                
                closeEditStudentModal();
                
                // Refresh the class view
                if (currentClassId) {
                    await viewClass(currentClassId);
                }
                
                if (typeof showAnalyticsToast === 'function') {
                    showAnalyticsToast('Student updated successfully.', 4000);
                }
            }
        }
        
        // Close modal on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const modal = document.getElementById('editStudentModal');
                if (modal && modal.style.display === 'flex') {
                    closeEditStudentModal();
                }
            }
        });
        
        // Close modal when clicking outside
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('editStudentModal');
            if (modal && modal.style.display === 'flex' && e.target === modal) {
                closeEditStudentModal();
            }
        });

        async function viewStudentEvals(studentId) {
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const cls = classes.find(c => c.id === currentClassId);
            if (!cls) return;
            
            const student = cls.roster.find(s => s.id === studentId || s.supabaseId === studentId);
            if (!student) {
                alert('Student not found.');
                return;
            }
            
            const courseId = cls.supabaseId || cls.id;
            
            // Update URL for deep linking with path-based routing
            if (typeof Router !== 'undefined' && Router.navigateToStudent && courseId) {
                Router.navigateToStudent(courseId, student.supabaseId || studentId);
            }
            
            // FERPA audit: log access to student evaluations
            await logAccess('view', 'evaluations', null, student.supabaseId || studentId, {
                purpose: 'view_student_evaluations',
                course_id: courseId
            });
            
            // Load evaluations from Supabase
            let allEvals = [];
            if (supabaseClient && cls.supabaseId) {
                const supabaseEvals = await loadEvaluationsFromSupabase(cls.supabaseId, student.supabaseId || studentId);
                if (supabaseEvals && supabaseEvals.length > 0) {
                    allEvals = supabaseEvals.map(ev => {
                        const evalData = ev.evaluation_data || {};
                        // Include video/audio URLs in results
                        if (ev.video_url) evalData.video_url = ev.video_url;
                        if (ev.audio_url) evalData.audio_url = ev.audio_url;
                        return {
                        date: new Date(ev.created_at).toLocaleDateString(),
                            type: evalData.rubricUsed || evalData.assignmentType || 'Unknown',
                            results: evalData,
                            supabaseId: ev.id,
                            video_url: ev.video_url || null,
                            audio_url: ev.audio_url || null,
                            studentId: student.supabaseId || studentId
                        };
                    });
                }
            }
            
            // Also check localStorage
            if (student.evaluations && student.evaluations.length > 0) {
                allEvals = [...allEvals, ...student.evaluations];
            }
            allEvals = allEvals.filter(ev => !isDeletedId('deleted_evaluation_ids', ev.supabaseId || ev.id));
            
            if (allEvals.length === 0) {
                alert('No evaluations found for this student.');
                return;
            }
            
            const isAdminOrSuper = (typeof isAdmin === 'function' && isAdmin()) || (typeof isSuperAdmin === 'function' && isSuperAdmin());
            const backLabel = isAdminOrSuper ? '← Back to Dashboard' : '← Back to Class';
            const backAction = isAdminOrSuper ? "showDashboard()" : "viewClass('" + (currentClassId || '').replace(/\\/g, '\\\\').replace(/'/g, "\\'") + "')";
            let html = `
                <div class="card">
                    <div class="card-header">${escapeHtml(student.firstName || '')} ${escapeHtml(student.lastName || '')} - Evaluations</div>
                    <div style="margin-bottom: 1rem;">
                        <button onclick="${backAction}" class="btn-secondary">${backLabel}</button>
                    </div>
                    <!-- Evaluation Search -->
                    <div style="margin-bottom: 1rem;">
                        <div style="position: relative;">
                            <input 
                                type="text" 
                                id="evaluationSearchInput_${studentId}" 
                                placeholder="Search evaluations by type, date, or score..." 
                                style="width: 100%; padding: 0.75rem 2.5rem 0.75rem 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; font-size: 0.9375rem; transition: all 0.2s ease; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;"
                                oninput="filterEvaluationsBySearch('${studentId}', this.value)"
                                onfocus="this.style.borderColor='var(--primary)'; this.style.outline='none'; this.style.boxShadow='0 0 0 4px rgba(0, 122, 255, 0.1)'"
                                onblur="this.style.borderColor='var(--border)'; this.style.boxShadow='none'"
                                aria-label="Search evaluations"
                            >
                            <i data-lucide="search" style="position: absolute; right: 0.75rem; top: 50%; transform: translateY(-50%); width: 1.125rem; height: 1.125rem; color: var(--text-light); pointer-events: none;"></i>
                        </div>
                    </div>
                    <div style="color: var(--text-light); margin-bottom: 1rem;">Click on an evaluation to view details</div>
                    <div id="evaluationsList_${studentId}">
            `;
            
            allEvals.forEach((ev, index) => {
                const date = ev.date || 'No date';
                const type = (ev.results?.rubricUsed || ev.type) || 'Unknown';
                const results = ev.results;
                const evalId = ev.supabaseId || ev.id;
                // Create unique IDs using studentId and evalId to avoid conflicts
                const uniqueId = `eval-${studentId}-${evalId}`.replace(/[^a-zA-Z0-9-]/g, '-');
                const menuId = `eval-menu-${studentId}-${evalId}`.replace(/[^a-zA-Z0-9-]/g, '-');
                const percentage = (((results.totalScore || 0) / (results.maxScore || 50)) * 100).toFixed(0);
                let color = 'var(--success)';
                if (percentage < 70) color = 'var(--error)';
                else if (percentage < 80) color = 'var(--warning)';
                
                // Check if evaluation has been edited/revised
                // An evaluation is "edited" if it has corrections or the edited flag is explicitly true
                const isEdited = results.edited === true || (results.corrections && Array.isArray(results.corrections) && results.corrections.length > 0);
                // Show "SpeechGradebook Generated" for all evaluations by default
                // Only show "Revised" if explicitly marked as edited
                // Most evaluations will have model_output_original (original AI output), so they're "SpeechGradebook Generated"
                const hasOriginal = !isEdited; // If not edited, it's original/SpeechGradebook Generated
                
                html += `
                    <div class="evaluation-item" data-eval-type="${escapeHtml(type.toLowerCase())}" data-eval-date="${escapeHtml(date.toLowerCase())}" data-eval-score="${escapeHtml(percentage)}" style="background: var(--bg-alt); border-radius: 0.5rem; margin-bottom: 0.75rem; border-left: 4px solid ${color}; overflow: hidden; ${isEdited ? 'box-shadow: 0 2px 8px rgba(0, 123, 255, 0.2);' : ''}">
                        <!-- Collapsed Header (clickable) -->
                        <div onclick="toggleEvaluation('${uniqueId}')" style="padding: 1rem; cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
                            <div style="flex: 1;">
                                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.25rem;">
                                    <strong style="font-size: 1.1rem;">${type}</strong>
                                    ${isEdited ? '<span style="background: #0066cc; color: white; padding: 0.15rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600;">Revised</span>' : ''}
                                    ${hasOriginal ? '<span style="background: #6c757d; color: white; padding: 0.15rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600;">SpeechGradebook Generated</span>' : ''}
                                </div>
                                <span style="color: var(--text-light); font-size: 0.9rem;">${date}</span>
                            </div>
                            <div style="text-align: right; display: flex; align-items: center; gap: 1rem;">
                                <div>
                                    <div style="font-size: 1.3rem; font-weight: bold; color: var(--primary);">
                                        ${results.totalScore || 0}/${results.maxScore || 50}
                                    </div>
                                    <div style="font-size: 0.9rem; color: ${color}; font-weight: 600;">${percentage}% • ${results.letterGrade || 'N/A'}</div>
                                </div>
                                <div style="position: relative;">
                                    <button type="button" onclick="toggleEvaluationMenu('${menuId}', event); return false;" style="padding: 0.4rem; background: transparent; color: var(--text-light); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer; transition: all 0.15s; position: relative; z-index: 1;" aria-label="Evaluation actions" aria-expanded="false" aria-haspopup="true" title="Evaluation actions" onmouseover="this.style.background='var(--bg-alt)'; this.style.borderColor='var(--primary)'; this.style.color='var(--primary)'" onmouseout="this.style.background='transparent'; this.style.borderColor='var(--border)'; this.style.color='var(--text-light)'">
                                        <i data-lucide="more-horizontal" style="width:1.1em;height:1.1em;"></i>
                                    </button>
                                    <div id="${menuId}" class="evaluation-actions-menu hidden">
                                        <button type="button" onclick="event.stopPropagation(); toggleEvaluation('${uniqueId}');" style="width: 100%; text-align: left; padding: 0.5rem 0.75rem; border: none; background: none; cursor: pointer; font-size: 0.875rem; color: var(--text); display: flex; align-items: center; gap: 0.5rem; transition: background 0.15s;" onmouseover="this.style.background='var(--bg-alt)'" onmouseout="this.style.background='white'"><i data-lucide="eye" style="width:1rem;height:1rem;"></i> View Evaluation</button>
                                        <button type="button" onclick="handleEditEvaluation('${evalId}', '${studentId}', '${uniqueId}', '${menuId}');" style="width: 100%; text-align: left; padding: 0.5rem 0.75rem; border: none; background: none; cursor: pointer; font-size: 0.875rem; color: var(--text); display: flex; align-items: center; gap: 0.5rem; transition: background 0.15s;" onmouseover="this.style.background='var(--bg-alt)'" onmouseout="this.style.background='white'"><i data-lucide="pencil" style="width:1rem;height:1rem;"></i> Edit</button>
                                        <button type="button" onclick="event.stopPropagation(); openMoveEvalModal('${evalId}', '${currentClassId || ''}', '${studentId}'); toggleEvaluationMenu('${menuId}');" style="width: 100%; text-align: left; padding: 0.5rem 0.75rem; border: none; background: none; cursor: pointer; font-size: 0.875rem; color: var(--text); display: flex; align-items: center; gap: 0.5rem; transition: background 0.15s; border-top: 1px solid var(--border);" onmouseover="this.style.background='var(--bg-alt)'" onmouseout="this.style.background='white'"><i data-lucide="move" style="width:1rem;height:1rem;"></i> Move to Different Student</button>
                                        <button type="button" onclick="event.stopPropagation(); downloadSavedEvaluation('${evalId}', '${studentId}'); toggleEvaluationMenu('${menuId}');" style="width: 100%; text-align: left; padding: 0.5rem 0.75rem; border: none; background: none; cursor: pointer; font-size: 0.875rem; color: var(--text); display: flex; align-items: center; gap: 0.5rem; transition: background 0.15s; border-top: 1px solid var(--border);" onmouseover="this.style.background='var(--bg-alt)'" onmouseout="this.style.background='white'"><i data-lucide="file-down" style="width:1rem;height:1rem;"></i> Download</button>
                                        <button type="button" onclick="event.stopPropagation(); deleteEvaluation('${evalId}', '${studentId}'); toggleEvaluationMenu('${menuId}');" style="width: 100%; text-align: left; padding: 0.5rem 0.75rem; border: none; background: none; cursor: pointer; font-size: 0.875rem; color: var(--error); display: flex; align-items: center; gap: 0.5rem; transition: background 0.15s; border-top: 1px solid var(--border);" onmouseover="this.style.background='var(--bg-alt)'" onmouseout="this.style.background='white'"><i data-lucide="trash-2" style="width:1rem;height:1rem;"></i> Delete</button>
                                    </div>
                                </div>
                                <span id="${uniqueId}-arrow" style="font-size: 1.2rem; color: var(--text-light);">▼</span>
                            </div>
                        </div>
                        
                        <!-- Expanded Details (hidden by default) -->
                        <div id="${uniqueId}" class="hidden" style="padding: 0 1rem 1rem 1rem; border-top: 1px solid var(--border);">
                            <div style="padding-top: 1rem;">
                `;
                
                // Display video/audio if available
                let videoUrl = ev.video_url || results.video_url || null;
                let audioUrl = ev.audio_url || results.audio_url || null;
                
                // Fix incomplete URLs (just filenames or relative paths)
                // If URL doesn't start with http, construct full Supabase Storage URL
                const supabaseBaseUrl = (typeof CONFIG !== 'undefined' && CONFIG.SUPABASE_URL) ? CONFIG.SUPABASE_URL : '';
                if (videoUrl && !videoUrl.startsWith('http') && supabaseBaseUrl) {
                    // Extract project ref from URL (e.g., mqhbfefylpfqsbtrshpu from https://mqhbfefylpfqsbtrshpu.supabase.co)
                    const projectRef = supabaseBaseUrl.replace('https://', '').replace('http://', '').split('.')[0];
                    // If it's just a filename, construct full path
                    if (!videoUrl.includes('/')) {
                        videoUrl = `https://${projectRef}.supabase.co/storage/v1/object/public/evaluation-media/${ev.studentId || studentId}/${ev.supabaseId || ''}/${videoUrl}`;
                    } else {
                        // If it's a relative path, prepend the base URL
                        videoUrl = `https://${projectRef}.supabase.co/storage/v1/object/public/evaluation-media/${videoUrl}`;
                    }
                }
                if (audioUrl && !audioUrl.startsWith('http') && supabaseBaseUrl) {
                    const projectRef = supabaseBaseUrl.replace('https://', '').replace('http://', '').split('.')[0];
                    if (!audioUrl.includes('/')) {
                        audioUrl = `https://${projectRef}.supabase.co/storage/v1/object/public/evaluation-media/${ev.studentId || studentId}/${ev.supabaseId || ''}/${audioUrl}`;
                    } else {
                        audioUrl = `https://${projectRef}.supabase.co/storage/v1/object/public/evaluation-media/${audioUrl}`;
                    }
                }
                
                const mediaUrl = videoUrl || audioUrl;
                
                if (mediaUrl) {
                    // Debug: log the URL being used
                    console.log('Media URL for evaluation:', ev.supabaseId || 'unknown', 'URL:', mediaUrl);
                    
                    html += `
                        <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 1rem;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                                <h4 style="margin: 0; color: var(--primary);"><span class="icon-with-text"><i data-lucide="${videoUrl ? 'video' : 'headphones'}"></i> ${videoUrl ? 'Video Recording' : 'Audio Recording'}</span></h4>
                            </div>
                            ${videoUrl ? `
                            <video controls preload="metadata" style="width: 100%; max-width: 600px; border-radius: 0.5rem; background: #000;" crossorigin="anonymous">
                                <source src="${videoUrl}" type="video/mp4">
                                <source src="${videoUrl}" type="video/webm">
                                <source src="${videoUrl}" type="video/quicktime">
                                Your browser does not support the video tag.
                                <p>If video doesn't load, check: <a href="${videoUrl}" target="_blank">${videoUrl}</a></p>
                            </video>
                            ` : `
                            <audio controls preload="metadata" style="width: 100%; max-width: 500px;" crossorigin="anonymous">
                                <source src="${audioUrl}" type="audio/mpeg">
                                <source src="${audioUrl}" type="audio/mp3">
                                <source src="${audioUrl}" type="audio/wav">
                                Your browser does not support the audio tag.
                                <p>If audio doesn't load, check: <a href="${audioUrl}" target="_blank">${audioUrl}</a></p>
                            </audio>
                            `}
                            <p style="font-size: 0.85rem; color: var(--text-light); margin-top: 0.75rem;">
                                ${videoUrl ? 'Watch the recorded speech video.' : 'Listen to the recorded speech audio.'}
                            </p>
                        </div>
                    `;
                }
                
                // Display timeline markers right after video (at the top)
                if (results.timeline_markers && results.timeline_markers.length > 0) {
                    // Group by category
                    const markersByCategory = {};
                    results.timeline_markers.forEach(marker => {
                        if (!markersByCategory[marker.category]) {
                            markersByCategory[marker.category] = [];
                        }
                        markersByCategory[marker.category].push(marker);
                    });
                    
                    html += `
                        <div style="background: var(--bg-alt); padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 1rem;">
                            <h4 style="margin: 0 0 1rem 0; color: var(--primary);"><span class="icon-with-text"><i data-lucide="clock"></i> Timeline Markers (${results.timeline_markers.length})</span></h4>
                    `;
                    
                    Object.keys(markersByCategory).forEach(category => {
                        html += `<div style="margin-bottom: 1rem;"><strong style="color: var(--primary);">${category}:</strong><div style="margin-top: 0.5rem;">`;
                        
                        markersByCategory[category].forEach(marker => {
                            const markerColor = {positive: '#10b981', minor: '#f59e0b', moderate: '#f59e0b', major: '#ef4444'}[marker.severity] || '#f59e0b';
                            const icon = {positive: '✓', minor: '⚠', moderate: '⚠', major: '✕'}[marker.severity] || '⚠';
                            
                            html += `
                                <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem; padding: 0.5rem; background: white; border-left: 3px solid ${markerColor}; border-radius: 0.25rem;">
                                    <span style="color: ${markerColor}; font-weight: bold; min-width: 50px;">[${marker.timestamp}]</span>
                                    <span><strong>${icon} ${escapeHtml(marker.issue || '')}:</strong> ${escapeHtml(marker.note || '')}${marker.behavior ? ` <span style="background: var(--primary); color: white; font-size: 0.7rem; padding: 0.15rem 0.4rem; border-radius: 999px;">${escapeHtml(marker.behavior)}</span>` : ''}</span>
                                </div>
                            `;
                        });
                        
                        html += `</div></div>`;
                    });
                    
                    html += '</div>';
                }
                
                // Display individual sections and subcategories
                if (results.sections) {
                    html += '<div style="background: white; padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem;">';
                    html += '<strong style="display: block; margin-bottom: 0.75rem;">Section & Subsection Scores:</strong>';
                    
                    Object.keys(results.sections).forEach(sectionKey => {
                        const section = results.sections[sectionKey];
                        const sectionName = sectionKey.charAt(0).toUpperCase() + sectionKey.slice(1);
                        const sectionPct = section.maxScore > 0 ? ((section.score / section.maxScore) * 100).toFixed(1) : 'N/A';
                        html += `
                            <div style="border-left: 3px solid var(--primary); padding-left: 1rem; margin-bottom: 1rem;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                                    <strong>${sectionName}</strong>
                                    <span style="color: var(--primary); font-weight: bold;">${section.score}/${section.maxScore} (${sectionPct}%)</span>
                                </div>
                                <p style="color: var(--text-light); margin: 0 0 0.5rem 0; font-size: 0.9rem;">${section.feedback || 'No feedback'}</p>
                        `;
                        const subs = section.subcategories || [];
                        if (Array.isArray(subs) && subs.length > 0) {
                            html += '<div style="margin-top: 0.5rem; padding-left: 0.75rem; border-left: 2px solid var(--border);">';
                            subs.forEach(sub => {
                                const subMax = sub.maxPoints || 0;
                                const subScore = sub.points !== undefined ? sub.points : 'N/A';
                                const subPct = (typeof subScore === 'number' && subMax > 0) ? ((subScore / subMax) * 100).toFixed(1) : '';
                                const subGrade = sub.grade ? ` (${sub.grade})` : '';
                                const scoreColor = typeof subScore === 'number' && subMax > 0 && subScore >= subMax * 0.8 ? 'var(--success)' :
                                    typeof subScore === 'number' && subMax > 0 && subScore >= subMax * 0.6 ? 'var(--warning)' : 'var(--error)';
                                html += `<div style="padding: 0.25rem 0; font-size: 0.9rem;">
                                    <div style="display: flex; justify-content: space-between;"><span>${escapeHtml(sub.name || 'Subcategory')}</span><span style="font-weight: 600; color: ${scoreColor};">${subScore}/${subMax}${subPct ? ' ' + subPct + '%' : ''}${subGrade}</span></div>
                                    ${sub.feedback ? `<p style="margin: 0.15rem 0 0 0; font-size: 0.85rem; color: var(--text-light);">${escapeHtml(sub.feedback)}</p>` : ''}
                                </div>`;
                            });
                            html += '</div>';
                        }
                        html += '</div>';
                    });
                    
                    html += '</div>';
                }
                
                // Display timeline markers right after video (at the top) - moved from bottom
                // This is now handled by displayResults() when in edit mode, but we keep it here for non-edit view
                // Timeline markers will be rendered by displayResults() when editing
                
                // Display overall comments
                html += `
                    <div style="background: white; padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem;">
                        <strong>Overall Comments:</strong><br>
                        <p style="margin: 0.5rem 0 0 0;">${results.overallComments || 'No comments'}</p>
                    </div>
                    
                    <div style="display: flex; gap: 1rem;">
                        <button onclick="editSavedEvaluation('${evalId}', '${studentId}');" style="background: var(--primary); color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: pointer; font-weight: 600; min-width: 44px; min-height: 44px;"><i data-lucide="pencil" style="width:1rem;height:1rem;vertical-align:middle;"></i> Edit</button>
                        <button onclick="openMoveEvalModal('${evalId}', '${currentClassId || ''}', '${studentId}')" style="background: var(--bg-alt); color: var(--primary); border: 1px solid var(--primary); padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: pointer; font-weight: 600;"><i data-lucide="move" style="width:1rem;height:1rem;vertical-align:middle;"></i> Move to Different Student</button>
                        <button onclick="downloadSavedEvaluation('${evalId}', '${studentId}')" style="background: var(--secondary); color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: pointer; font-weight: 600;"><i data-lucide="file-down" style="width:1rem;height:1rem;vertical-align:middle;"></i> Download Report</button>
                    </div>
                    </div>
                    </div>
                    </div>
                `;
            });
            
            html += '</div></div>'; // Close evaluationsList and card
            const contentEl = document.getElementById('classDetailContent');
            if (contentEl) {
                contentEl.innerHTML = html;
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: contentEl });
            }
        }
        
        // Filter evaluations by search query
        function filterEvaluationsBySearch(studentId, query) {
            const container = document.getElementById(`evaluationsList_${studentId}`);
            if (!container) return;
            
            const searchTerm = query.toLowerCase().trim();
            const items = container.querySelectorAll('.evaluation-item');
            
            items.forEach(item => {
                const type = item.getAttribute('data-eval-type') || '';
                const date = item.getAttribute('data-eval-date') || '';
                const score = item.getAttribute('data-eval-score') || '';
                
                const matches = !searchTerm || 
                    type.includes(searchTerm) || 
                    date.includes(searchTerm) || 
                    score.includes(searchTerm);
                
                item.style.display = matches ? '' : 'none';
            });
            
            // Update icons after filtering
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons({ root: container });
            }
        }
        
        // Toggle evaluation expand/collapse
        function toggleEvaluation(evalId) {
            const content = document.getElementById(evalId);
            if (!content) {
                console.warn('toggleEvaluation: Content not found for', evalId);
                return;
            }
            const arrow = document.getElementById(evalId + '-arrow');
            
            const isExpanding = content.classList.contains('hidden');
            
            if (isExpanding) {
                content.classList.remove('hidden');
                if (arrow) arrow.textContent = '▲';
                
                // Close all evaluation action menus when expanding an evaluation
                document.querySelectorAll('.evaluation-actions-menu').forEach(menu => {
                    menu.classList.add('hidden');
                    // Reset positioning styles to prevent conflicts
                    menu.style.position = '';
                    menu.style.left = '';
                    menu.style.right = '';
                    menu.style.top = '';
                    menu.style.bottom = '';
                    menu.style.marginTop = '';
                    menu.style.transform = '';
                    const parent = menu.parentElement;
                    if (parent) {
                        const btn = parent.querySelector('button[aria-haspopup="true"]');
                        if (btn) btn.setAttribute('aria-expanded', 'false');
                    }
                });
            } else {
                content.classList.add('hidden');
                if (arrow) arrow.textContent = '▼';
            }
        }
        
        // Handle edit evaluation button click
        function handleEditEvaluation(evalId, studentId, evalContainerId, menuId, evt) {
            const event = evt || window.event;
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }
            
            // Close the menu IMMEDIATELY
            const menu = document.getElementById(menuId);
            if (menu) {
                menu.classList.add('hidden');
                menu.style.display = 'none';
                // Reset positioning styles
                menu.style.position = '';
                menu.style.left = '';
                menu.style.right = '';
                menu.style.top = '';
                menu.style.bottom = '';
                menu.style.marginTop = '';
                menu.style.transform = '';
                const parent = menu.parentElement;
                if (parent) {
                    const btn = parent.querySelector('button[aria-haspopup="true"]');
                    if (btn) {
                        btn.setAttribute('aria-expanded', 'false');
                        btn.classList.remove('active');
                    }
                }
            }
            
            // Also close all other menus
            document.querySelectorAll('.evaluation-actions-menu').forEach(m => {
                m.classList.add('hidden');
                m.style.display = 'none';
                const p = m.parentElement;
                if (p) {
                    const b = p.querySelector('button[aria-haspopup="true"]');
                    if (b) {
                        b.setAttribute('aria-expanded', 'false');
                        b.classList.remove('active');
                    }
                }
            });
            
            // Expand the evaluation
            toggleEvaluation(evalContainerId);
            
            // Start editing after a short delay to ensure dropdown is expanded
            setTimeout(() => {
                editSavedEvaluation(evalId, studentId);
            }, 100);
        }
        
        // Make function globally available
        window.handleEditEvaluation = handleEditEvaluation;
        
        // Toggle evaluation actions menu (three dots)
        // Follows Apple Human Interface Guidelines: menu opens below and aligns to left edge of button
        // Includes visual indicator arrow to show which button the menu belongs to
        function toggleEvaluationMenu(menuId, evt) {
            try {
                const event = evt || window.event;
                if (event) {
                    event.stopPropagation();
                    event.preventDefault();
                }
                const menu = document.getElementById(menuId);
                if (!menu) {
                    console.warn('Menu not found:', menuId);
                    return false;
                }
                
                // Find the button that triggered this menu
                // First try: use event target directly (most reliable)
                let btn = null;
                if (event && event.target) {
                    // Check if event target is the button itself
                    if (event.target.tagName === 'BUTTON' && event.target.hasAttribute('aria-haspopup')) {
                        btn = event.target;
                    } else {
                        // Otherwise, find the closest button
                        btn = event.target.closest('button[aria-haspopup="true"]');
                    }
                }
                
                // Fallback: find button from menu's parent container
                if (!btn) {
                    const parent = menu.parentElement;
                    if (parent) {
                        btn = parent.querySelector('button[aria-haspopup="true"]');
                    }
                }
                
                if (!btn) {
                    console.error('Button not found for menu:', menuId, 'Event:', event);
                    return false;
                }
                
                // Verify the button is actually in the DOM and visible
                if (!btn.isConnected) {
                    console.error('Button is not in DOM:', menuId);
                    return false;
                }
                
                // Close all other evaluation menus first
                document.querySelectorAll('.evaluation-actions-menu').forEach(m => {
                    if (m.id !== menuId) {
                        m.classList.add('hidden');
                        // Reset any inline styles that might interfere
                        m.style.position = '';
                        m.style.left = '';
                        m.style.right = '';
                        m.style.top = '';
                        m.style.bottom = '';
                        m.style.marginTop = '';
                        m.style.transform = '';
                        const otherBtn = m.parentElement?.querySelector('button[aria-haspopup="true"]');
                        if (otherBtn) {
                            otherBtn.setAttribute('aria-expanded', 'false');
                            otherBtn.style.borderColor = '';
                            otherBtn.style.boxShadow = '';
                        }
                    }
                });
                
                // Toggle this menu
                const isHidden = menu.classList.contains('hidden');
                if (isHidden) {
                    // Use fixed positioning to escape any overflow containers that clip the menu
                    // Get button's viewport position (works regardless of scroll or parent containers)
                    // Force a reflow to ensure button position is current
                    void btn.offsetWidth;
                    const btnRect = btn.getBoundingClientRect();
                    
                    // Validate button position
                    if (btnRect.width === 0 && btnRect.height === 0) {
                        console.warn('Button has zero dimensions, may be hidden:', menuId);
                    }
                    
                    // Ensure menu is in the DOM and get its dimensions before positioning
                    // First, make it visible but off-screen to measure
                    menu.style.position = 'fixed';
                    menu.style.visibility = 'hidden';
                    menu.style.display = 'block';
                    menu.style.left = '-9999px';
                    menu.style.top = '-9999px';
                    menu.classList.remove('hidden');
                    
                    // Force browser to calculate layout
                    void menu.offsetWidth; // Force reflow
                    
                    // Now get actual dimensions
                    const menuWidth = Math.max(menu.offsetWidth, 200);
                    const menuHeight = menu.offsetHeight || 150;
                    
                    // Position menu to the left of the button, vertically centered
                    // Align right edge of menu with left edge of button
                    let leftPos = btnRect.left - menuWidth - 8; // 8px gap between menu and button
                    let topPos = btnRect.top + (btnRect.height / 2) - (menuHeight / 2); // Vertically center
                    
                    // Adjust if menu would go off left edge of screen
                    if (leftPos < 10) {
                        // If not enough space on left, position to the right of button instead
                        leftPos = btnRect.right + 8;
                        // But if that also goes off screen, just align to left edge of viewport
                        if (leftPos + menuWidth > window.innerWidth - 10) {
                            leftPos = 10;
                        }
                    }
                    
                    // Adjust vertical position if menu would go off top of screen
                    if (topPos < 10) {
                        topPos = 10;
                        menu.style.maxHeight = (window.innerHeight - 20) + 'px';
                        menu.style.overflowY = 'auto';
                    } 
                    // Adjust if menu would go off bottom of screen
                    else if (topPos + menuHeight > window.innerHeight - 10) {
                        topPos = window.innerHeight - menuHeight - 10;
                        // If still too tall, position at top with max height
                        if (topPos < 10) {
                            topPos = 10;
                            menu.style.maxHeight = (window.innerHeight - 20) + 'px';
                            menu.style.overflowY = 'auto';
                        } else {
                            menu.style.maxHeight = '';
                            menu.style.overflowY = '';
                        }
                    } else {
                        // Menu fits vertically, but ensure it doesn't exceed viewport if content changes
                        const maxHeight = window.innerHeight - topPos - 20;
                        if (maxHeight < menuHeight) {
                            menu.style.maxHeight = maxHeight + 'px';
                            menu.style.overflowY = 'auto';
                        } else {
                            menu.style.maxHeight = '';
                            menu.style.overflowY = '';
                        }
                    }
                    
                    // Set final position using fixed positioning (escapes overflow containers)
                    menu.style.position = 'fixed';
                    menu.style.left = leftPos + 'px';
                    menu.style.top = topPos + 'px';
                    menu.style.right = 'auto';
                    menu.style.bottom = 'auto';
                    menu.style.marginTop = '0';
                    menu.style.marginLeft = '0';
                    menu.style.marginRight = '0';
                    menu.style.marginBottom = '0';
                    menu.style.zIndex = '10000'; // High z-index to ensure it's above everything
                    menu.style.visibility = 'visible';
                    menu.style.display = 'block';
                    menu.style.transform = 'none';
                    menu.style.width = menuWidth + 'px';
                    menu.style.minWidth = '200px';
                    
                    // Ensure menu is visible (already removed hidden class above)
                    // Double-check the menu is actually in the DOM
                    if (!menu.isConnected) {
                        console.error('Menu is not in DOM:', menuId);
                        return false;
                    }
                    
                    // Force another reflow to ensure positioning is applied
                    void menu.offsetHeight;
                    
                    // Highlight the button to show which one the menu belongs to
                    btn.setAttribute('aria-expanded', 'true');
                    const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--primary').trim() || '#007AFF';
                    btn.style.borderColor = primaryColor;
                    btn.style.boxShadow = `0 0 0 2px ${primaryColor}33`; // 33 = 20% opacity in hex
                    btn.style.backgroundColor = 'var(--bg-alt)';
                } else {
                    menu.classList.add('hidden');
                    // Reset positioning styles when closing to prevent conflicts
                    menu.style.position = '';
                    menu.style.left = '';
                    menu.style.right = '';
                    menu.style.top = '';
                    menu.style.bottom = '';
                    menu.style.marginTop = '';
                    menu.style.transform = '';
                    menu.style.maxHeight = '';
                    menu.style.overflowY = '';
                    menu.style.width = '';
                    btn.setAttribute('aria-expanded', 'false');
                    btn.style.borderColor = '';
                    btn.style.boxShadow = '';
                    btn.style.backgroundColor = '';
                }
                return false;
            } catch (error) {
                console.error('Error in toggleEvaluationMenu:', error);
                return false;
            }
        }
        
        // Make function globally available
        window.toggleEvaluationMenu = toggleEvaluationMenu;
        
        // Close evaluation menus when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.evaluation-actions-menu') && !e.target.closest('button[onclick*="toggleEvaluationMenu"]')) {
                document.querySelectorAll('.evaluation-actions-menu').forEach(menu => {
                    menu.classList.add('hidden');
                    const btn = menu.parentElement?.querySelector('button[aria-haspopup="true"]');
                    if (btn) btn.setAttribute('aria-expanded', 'false');
                });
            }
        });

        window.toggleCourseActionsMenu = function(courseId, e) {
            if (e) {
                e.stopPropagation();
                e.preventDefault();
            }
            
            // Clear any pending click-outside timeout
            if (window.courseMenuClickTimeout) {
                clearTimeout(window.courseMenuClickTimeout);
                window.courseMenuClickTimeout = null;
            }
            
            console.log('toggleCourseActionsMenu called with courseId:', courseId);
            const menuId = 'courseActionsMenu_' + courseId;
            const menu = document.getElementById(menuId);
            if (!menu) {
                console.warn('Course actions menu not found. ID:', menuId);
                return;
            }
            
            // Find the button - look for the trigger button in the same card
            const card = menu.closest('.class-card');
            const btn = card ? card.querySelector('.course-actions-menu-trigger') : null;
            
            if (!btn) {
                console.warn('Course actions button not found');
                return;
            }
            
            console.log('Menu and button found. Menu classes:', menu.className);
            
            // Close all other course action menus first
            document.querySelectorAll('.course-actions-menu').forEach(m => {
                if (m.id !== menu.id) {
                    m.classList.add('hidden');
                    const otherCard = m.closest('.class-card');
                    const otherBtn = otherCard ? otherCard.querySelector('.course-actions-menu-trigger') : null;
                    if (otherBtn) otherBtn.setAttribute('aria-expanded', 'false');
                }
            });
            
            const hasHidden = menu.classList.contains('hidden');
            console.log('Menu has hidden class:', hasHidden);
            
            if (hasHidden) {
                // Show the menu
                menu.classList.remove('hidden');
                btn.setAttribute('aria-expanded', 'true');
                console.log('Menu shown. Classes after:', menu.className);
                console.log('Menu computed display:', window.getComputedStyle(menu).display);
                
                // Initialize icons in the menu
                if (typeof lucide !== 'undefined' && lucide.createIcons) {
                    lucide.createIcons({ root: menu });
                }
            } else {
                // Hide the menu
                menu.classList.add('hidden');
                btn.setAttribute('aria-expanded', 'false');
                console.log('Menu hidden');
            }
        };
        
        // Close course actions menus when clicking outside
        // Use a small delay to prevent immediate closing when menu opens
        window.courseMenuClickTimeout = null;
        document.addEventListener('click', function(e) {
            // Clear any pending timeout
            if (window.courseMenuClickTimeout) {
                clearTimeout(window.courseMenuClickTimeout);
            }
            
            // Only close if clicking outside both menu and trigger
            if (!e.target.closest('.course-actions-menu') && !e.target.closest('.course-actions-menu-trigger')) {
                // Small delay to allow menu toggle to complete first
                window.courseMenuClickTimeout = setTimeout(function() {
                    document.querySelectorAll('.course-actions-menu:not(.hidden)').forEach(m => {
                        const card = m.closest('.class-card');
                        const btn = card ? card.querySelector('.course-actions-menu-trigger') : null;
                        m.classList.add('hidden');
                        if (btn) btn.setAttribute('aria-expanded', 'false');
                    });
                }, 100);
            }
        });
        
        window.editCourse = function(courseId) {
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const course = classes.find(c => c.id === courseId);
            if (!course) {
                if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Course not found.', 4000);
                else alert('Course not found');
                return;
            }
            
            // Populate the edit form
            document.getElementById('editCourseId').value = courseId;
            document.getElementById('editCourseName').value = course.name || '';
            document.getElementById('editCourseSemester').value = course.semester || 'Fall';
            document.getElementById('editCourseSection').value = course.section || '';
            document.getElementById('editCourseYear').value = course.year || new Date().getFullYear();
            document.getElementById('editCourseNotes').value = course.notes || '';
            
            // Show the modal
            const modal = document.getElementById('editCourseModal');
            if (modal) {
                modal.style.display = 'flex';
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: modal });
                // Focus first input
                setTimeout(() => {
                    const firstInput = document.getElementById('editCourseName');
                    if (firstInput) firstInput.focus();
                }, 100);
            }
        };
        
        function closeEditCourseModal() {
            const modal = document.getElementById('editCourseModal');
            if (modal) modal.style.display = 'none';
            document.getElementById('editCourseForm').reset();
        }
        
        async function saveEditedCourse() {
            const courseId = document.getElementById('editCourseId').value;
            if (!courseId) {
                alert('Course ID not found');
                return;
            }
            
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const course = classes.find(c => c.id === courseId);
            if (!course) {
                alert('Course not found');
                return;
            }
            
            // Get form values
            const name = document.getElementById('editCourseName').value.trim();
            if (!name) {
                alert('Class name is required');
                return;
            }
            
            const semester = document.getElementById('editCourseSemester').value;
            const section = document.getElementById('editCourseSection').value.trim();
            const year = document.getElementById('editCourseYear').value;
            const notes = document.getElementById('editCourseNotes').value.trim();
            
            // Update course object
            course.name = name;
            course.semester = semester;
            course.section = section;
            course.year = year;
            course.notes = notes;
            
            // Update localStorage
            const classIndex = classes.findIndex(c => c.id === courseId);
            if (classIndex !== -1) {
                classes[classIndex] = course;
                setUserItem('classes', JSON.stringify(classes));
            }
            
            // Update Supabase if course has supabaseId
            if (supabaseClient && course.supabaseId) {
                try {
                    const courseData = {
                        name: course.name,
                        code: course.section || null,
                        semester: course.semester || null,
                        year: parseInt(course.year) || null
                    };
                    
                    const { error } = await supabaseClient
                        .from('courses')
                        .update(courseData)
                        .eq('id', course.supabaseId);
                    
                    if (error) {
                        console.error('Failed to update course in Supabase:', error);
                        alert('Course updated locally, but failed to update in database: ' + (error.message || error));
                    } else {
                        console.log('✓ Course updated in Supabase');
                    }
                } catch (error) {
                    console.error('Error updating course:', error);
                    alert('Course updated locally, but failed to update in database: ' + (error.message || error));
                }
            }
            
            closeEditCourseModal();
            if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Course updated successfully.', 4000);
            await loadClasses();
            
            // If we're currently viewing this course, refresh the view
            if (currentClassId === courseId) {
                await viewClass(courseId, true);
            }
        }
        
        window.moveCourse = function(courseId) {
            // Reorder course cards on dashboard
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const course = classes.find(c => c.id === courseId);
            if (!course) {
                if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Course not found.', 4000);
                else alert('Course not found');
                return;
            }
            
            // Show reorder modal
            showReorderCoursesModal(courseId);
        };
        
        function showReorderCoursesModal(selectedCourseId) {
            // Store selected course ID for tab assignment
            window._selectedCourseForReorder = selectedCourseId;
            
            const classes = JSON.parse(getUserItem('classes') || '[]').filter(c => !isDeletedId('deleted_course_ids', c.id));
            const reorderModal = document.getElementById('reorderCoursesModal');
            if (!reorderModal) {
                // Create the modal if it doesn't exist
                const modalHtml = `
                    <div id="reorderCoursesModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.4); z-index: 9999; align-items: center; justify-content: center; backdrop-filter: blur(4px);" role="dialog" aria-labelledby="reorderCoursesModalTitle" aria-modal="true" onclick="if(event.target===this)closeReorderCoursesModal();">
                        <div style="background: white; border-radius: 1rem; max-width: 500px; width: 90%; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);" onclick="event.stopPropagation();">
                            <div style="padding: 1.5rem 1.5rem 1rem 1.5rem; border-bottom: 0.5px solid rgba(0, 0, 0, 0.1); display: flex; justify-content: space-between; align-items: center;">
                                <h2 id="reorderCoursesModalTitle" style="margin: 0; font-size: 1.25rem; font-weight: 600; color: var(--text);">Reorder Courses</h2>
                                <button type="button" onclick="closeReorderCoursesModal()" aria-label="Close" style="background: none; border: none; padding: 0.5rem; cursor: pointer; color: var(--text-light); border-radius: 0.5rem; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='rgba(0,0,0,0.05)'" onmouseout="this.style.backgroundColor='transparent'">
                                    <i data-lucide="x" style="width: 1.25rem; height: 1.25rem;"></i>
                                </button>
                            </div>
                            <div style="padding: 1.5rem; overflow-y: auto; flex: 1;">
                                <p style="color: var(--text-light); font-size: 0.9rem; margin-bottom: 1.5rem;">Drag courses to reorder them, or use the arrow buttons to move courses up or down.</p>
                                <div style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-alt); border-radius: 0.5rem;">
                                    <label for="moveCourseToTab" style="display: block; font-weight: 500; margin-bottom: 0.5rem; color: var(--text); font-size: 0.9375rem;">Move Selected Course to Tab:</label>
                                    <select id="moveCourseToTab" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; font-size: 1rem;">
                                        <option value="current">Current</option>
                                        <option value="previous">Previous</option>
                                    </select>
                                    <p style="color: var(--text-light); font-size: 0.85rem; margin-top: 0.5rem;">Select a tab to move the course to, then save the order.</p>
                                </div>
                                <div id="reorderCoursesList" style="display: flex; flex-direction: column; gap: 0.5rem;">
                                </div>
                            </div>
                            <div style="padding: 1rem 1.5rem; border-top: 0.5px solid rgba(0, 0, 0, 0.1); display: flex; gap: 0.75rem; justify-content: flex-end;">
                                <button type="button" onclick="closeReorderCoursesModal()" class="btn-secondary" style="padding: 0.625rem 1.25rem; font-size: 0.9375rem; font-weight: 500; border-radius: 0.5rem;">Cancel</button>
                                <button type="button" onclick="saveCourseOrder()" style="padding: 0.625rem 1.25rem; background: var(--primary); color: white; border: none; border-radius: 0.5rem; font-size: 0.9375rem; font-weight: 500; cursor: pointer; transition: opacity 0.2s;" onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">
                                    <span class="icon-with-text"><i data-lucide="check" style="width:1em;height:1em;"></i> Save Order</span>
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHtml);
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons();
            }
            
            // Populate tab selector with custom tabs
            const tabSelect = document.getElementById('moveCourseToTab');
            if (tabSelect) {
                const customTabs = getCustomTabs();
                const currentTab = getCourseTab(selectedCourseId) || 'current';
                let options = '<option value="current">Current</option><option value="previous">Previous</option>';
                customTabs.forEach(tab => {
                    options += `<option value="${tab.id}" ${currentTab === tab.id ? 'selected' : ''}>${escapeHtml(tab.name)}</option>`;
                });
                tabSelect.innerHTML = options;
                tabSelect.value = currentTab;
            }
            
            // Populate the list
            const listContainer = document.getElementById('reorderCoursesList');
            listContainer.innerHTML = classes.map((course, index) => {
                const courseName = escapeHtml(course.name || 'Unnamed');
                const courseInfo = `${course.semester || ''} ${course.year || ''} • Section ${course.section || 'N/A'}`;
                return `
                    <div class="reorder-course-item" data-course-id="${course.id}" style="display: flex; align-items: center; gap: 0.75rem; padding: 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; background: white; cursor: move;">
                        <div style="display: flex; align-items: center; gap: 0.5rem; color: var(--text-light);">
                            <i data-lucide="grip-vertical" style="width: 1rem; height: 1rem; cursor: grab;"></i>
                            <span style="font-weight: 600; color: var(--text);">${index + 1}</span>
                        </div>
                        <div style="flex: 1;">
                            <div style="font-weight: 500; color: var(--text);">${courseName}</div>
                            <div style="font-size: 0.875rem; color: var(--text-light);">${courseInfo}</div>
                        </div>
                        <div style="display: flex; gap: 0.25rem;">
                            <button type="button" onclick="moveCourseUp('${course.id}')" style="padding: 0.375rem; background: var(--bg-alt); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer; color: var(--text);" title="Move up" ${index === 0 ? 'disabled style="opacity:0.5;cursor:not-allowed;"' : ''}><i data-lucide="chevron-up" style="width:1rem;height:1rem;"></i></button>
                            <button type="button" onclick="moveCourseDown('${course.id}')" style="padding: 0.375rem; background: var(--bg-alt); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer; color: var(--text);" title="Move down" ${index === classes.length - 1 ? 'disabled style="opacity:0.5;cursor:not-allowed;"' : ''}><i data-lucide="chevron-down" style="width:1rem;height:1rem;"></i></button>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Initialize icons
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons({ root: listContainer });
            }
            
            // Show modal
            const modal = document.getElementById('reorderCoursesModal');
            modal.style.display = 'flex';
            
            // Store original order
            window._courseReorderOrder = classes.map(c => c.id);
        }
        
        function closeReorderCoursesModal() {
            const modal = document.getElementById('reorderCoursesModal');
            if (modal) modal.style.display = 'none';
            window._courseReorderOrder = null;
        }
        
        function moveCourseUp(courseId) {
            if (!window._courseReorderOrder) return;
            const currentIndex = window._courseReorderOrder.indexOf(courseId);
            if (currentIndex > 0) {
                const temp = window._courseReorderOrder[currentIndex];
                window._courseReorderOrder[currentIndex] = window._courseReorderOrder[currentIndex - 1];
                window._courseReorderOrder[currentIndex - 1] = temp;
                // Refresh the modal display
                const classes = JSON.parse(getUserItem('classes') || '[]').filter(c => !isDeletedId('deleted_course_ids', c.id));
                const listContainer = document.getElementById('reorderCoursesList');
                listContainer.innerHTML = window._courseReorderOrder.map((id, index) => {
                    const course = classes.find(c => c.id === id);
                    if (!course) return '';
                    const courseName = escapeHtml(course.name || 'Unnamed');
                    const courseInfo = `${course.semester || ''} ${course.year || ''} • Section ${course.section || 'N/A'}`;
                    return `
                        <div class="reorder-course-item" data-course-id="${course.id}" style="display: flex; align-items: center; gap: 0.75rem; padding: 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; background: white; cursor: move;">
                            <div style="display: flex; align-items: center; gap: 0.5rem; color: var(--text-light);">
                                <i data-lucide="grip-vertical" style="width: 1rem; height: 1rem; cursor: grab;"></i>
                                <span style="font-weight: 600; color: var(--text);">${index + 1}</span>
                            </div>
                            <div style="flex: 1;">
                                <div style="font-weight: 500; color: var(--text);">${courseName}</div>
                                <div style="font-size: 0.875rem; color: var(--text-light);">${courseInfo}</div>
                            </div>
                            <div style="display: flex; gap: 0.25rem;">
                                <button type="button" onclick="moveCourseUp('${course.id}')" style="padding: 0.375rem; background: var(--bg-alt); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer; color: var(--text);" title="Move up" ${index === 0 ? 'disabled style="opacity:0.5;cursor:not-allowed;"' : ''}><i data-lucide="chevron-up" style="width:1rem;height:1rem;"></i></button>
                                <button type="button" onclick="moveCourseDown('${course.id}')" style="padding: 0.375rem; background: var(--bg-alt); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer; color: var(--text);" title="Move down" ${index === window._courseReorderOrder.length - 1 ? 'disabled style="opacity:0.5;cursor:not-allowed;"' : ''}><i data-lucide="chevron-down" style="width:1rem;height:1rem;"></i></button>
                            </div>
                        </div>
                    `;
                }).filter(h => h).join('');
                if (typeof lucide !== 'undefined' && lucide.createIcons) {
                    lucide.createIcons({ root: listContainer });
                }
            }
        }
        
        function moveCourseDown(courseId) {
            if (!window._courseReorderOrder) return;
            const currentIndex = window._courseReorderOrder.indexOf(courseId);
            if (currentIndex < window._courseReorderOrder.length - 1) {
                const temp = window._courseReorderOrder[currentIndex];
                window._courseReorderOrder[currentIndex] = window._courseReorderOrder[currentIndex + 1];
                window._courseReorderOrder[currentIndex + 1] = temp;
                // Refresh the modal display
                const classes = JSON.parse(getUserItem('classes') || '[]').filter(c => !isDeletedId('deleted_course_ids', c.id));
                const listContainer = document.getElementById('reorderCoursesList');
                listContainer.innerHTML = window._courseReorderOrder.map((id, index) => {
                    const course = classes.find(c => c.id === id);
                    if (!course) return '';
                    const courseName = escapeHtml(course.name || 'Unnamed');
                    const courseInfo = `${course.semester || ''} ${course.year || ''} • Section ${course.section || 'N/A'}`;
                    return `
                        <div class="reorder-course-item" data-course-id="${course.id}" style="display: flex; align-items: center; gap: 0.75rem; padding: 0.75rem; border: 1px solid var(--border); border-radius: 0.5rem; background: white; cursor: move;">
                            <div style="display: flex; align-items: center; gap: 0.5rem; color: var(--text-light);">
                                <i data-lucide="grip-vertical" style="width: 1rem; height: 1rem; cursor: grab;"></i>
                                <span style="font-weight: 600; color: var(--text);">${index + 1}</span>
                            </div>
                            <div style="flex: 1;">
                                <div style="font-weight: 500; color: var(--text);">${courseName}</div>
                                <div style="font-size: 0.875rem; color: var(--text-light);">${courseInfo}</div>
                            </div>
                            <div style="display: flex; gap: 0.25rem;">
                                <button type="button" onclick="moveCourseUp('${course.id}')" style="padding: 0.375rem; background: var(--bg-alt); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer; color: var(--text);" title="Move up" ${index === 0 ? 'disabled style="opacity:0.5;cursor:not-allowed;"' : ''}><i data-lucide="chevron-up" style="width:1rem;height:1rem;"></i></button>
                                <button type="button" onclick="moveCourseDown('${course.id}')" style="padding: 0.375rem; background: var(--bg-alt); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer; color: var(--text);" title="Move down" ${index === window._courseReorderOrder.length - 1 ? 'disabled style="opacity:0.5;cursor:not-allowed;"' : ''}><i data-lucide="chevron-down" style="width:1rem;height:1rem;"></i></button>
                            </div>
                        </div>
                    `;
                }).filter(h => h).join('');
                if (typeof lucide !== 'undefined' && lucide.createIcons) {
                    lucide.createIcons({ root: listContainer });
                }
            }
        }
        
        async function saveCourseOrder() {
            if (!window._courseReorderOrder) {
                closeReorderCoursesModal();
                return;
            }
            
            // Get selected course and tab
            const tabSelect = document.getElementById('moveCourseToTab');
            const selectedTab = tabSelect ? tabSelect.value : 'current';
            const selectedCourseId = window._selectedCourseForReorder || null;
            
            // Assign course to tab if a course was selected
            if (selectedCourseId && selectedTab) {
                assignCourseToTab(selectedCourseId, selectedTab);
                // Invalidate cache
                _coursesGridCache = {
                    current: { html: null, dataHash: null },
                    previous: { html: null, dataHash: null }
                };
            }
            
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const reorderedClasses = window._courseReorderOrder.map(id => classes.find(c => c.id === id)).filter(c => c);
            
            // Add any courses that weren't in the reorder list (shouldn't happen, but just in case)
            classes.forEach(c => {
                if (!reorderedClasses.find(rc => rc.id === c.id)) {
                    reorderedClasses.push(c);
                }
            });
            
            // Save to localStorage
            setUserItem('classes', JSON.stringify(reorderedClasses));
            
            // Save order preference (optional - could store in user preferences)
            setUserItem('courseOrder', JSON.stringify(window._courseReorderOrder));
            
            closeReorderCoursesModal();
            if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Course order saved.', 4000);
            await loadClasses();
        }
        
        /** Show modal for managing custom tabs */
        function showManageTabsModal() {
            const modal = document.getElementById('manageTabsModal');
            if (!modal) {
                // Create the modal
                const modalHtml = `
                    <div id="manageTabsModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.4); z-index: 9999; align-items: center; justify-content: center; backdrop-filter: blur(4px);" role="dialog" aria-labelledby="manageTabsModalTitle" aria-modal="true" onclick="if(event.target===this)closeManageTabsModal();">
                        <div style="background: white; border-radius: 1rem; max-width: 600px; width: 90%; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);" onclick="event.stopPropagation();">
                            <div style="padding: 1.5rem 1.5rem 1rem 1.5rem; border-bottom: 0.5px solid rgba(0, 0, 0, 0.1); display: flex; justify-content: space-between; align-items: center;">
                                <h2 id="manageTabsModalTitle" style="margin: 0; font-size: 1.25rem; font-weight: 600; color: var(--text);">Manage Course Tabs</h2>
                                <button type="button" onclick="closeManageTabsModal()" aria-label="Close" style="background: none; border: none; padding: 0.5rem; cursor: pointer; color: var(--text-light); border-radius: 0.5rem; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='rgba(0,0,0,0.05)'" onmouseout="this.style.backgroundColor='transparent'">
                                    <i data-lucide="x" style="width: 1.25rem; height: 1.25rem;"></i>
                                </button>
                            </div>
                            <div style="padding: 1.5rem; overflow-y: auto; flex: 1;">
                                <div style="margin-bottom: 1.5rem;">
                                    <button type="button" onclick="addNewTab()" style="padding: 0.625rem 1.25rem; background: var(--primary); color: white; border: none; border-radius: 0.5rem; font-size: 0.9375rem; font-weight: 500; cursor: pointer; display: flex; align-items: center; gap: 0.5rem;">
                                        <i data-lucide="plus" style="width: 1rem; height: 1rem;"></i> Add New Tab
                                    </button>
                                </div>
                                <div id="tabsList" style="display: flex; flex-direction: column; gap: 0.75rem;">
                                </div>
                            </div>
                            <div style="padding: 1rem 1.5rem; border-top: 0.5px solid rgba(0, 0, 0, 0.1); display: flex; gap: 0.75rem; justify-content: flex-end;">
                                <button type="button" onclick="closeManageTabsModal()" class="btn-secondary" style="padding: 0.625rem 1.25rem; font-size: 0.9375rem; font-weight: 500; border-radius: 0.5rem;">Close</button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHtml);
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons();
            }
            
            // Populate tabs list
            renderTabsList();
            
            // Show modal
            modal.style.display = 'flex';
        }
        
        function closeManageTabsModal() {
            const modal = document.getElementById('manageTabsModal');
            if (modal) modal.style.display = 'none';
        }
        
        function renderTabsList() {
            const container = document.getElementById('tabsList');
            if (!container) return;
            
            const customTabs = getCustomTabs();
            const assignments = getCourseTabAssignments();
            
            if (customTabs.length === 0) {
                container.innerHTML = '<p style="color: var(--text-light); text-align: center; padding: 2rem;">No custom tabs yet. Click "Add New Tab" to create one.</p>';
                return;
            }
            
            container.innerHTML = customTabs.map(tab => {
                const courseCount = Object.values(assignments).filter(tabId => tabId === tab.id).length;
                return `
                    <div class="tab-item" data-tab-id="${tab.id}" style="display: flex; align-items: center; gap: 0.75rem; padding: 1rem; border: 1px solid var(--border); border-radius: 0.5rem; background: white;">
                        <div style="flex: 1;">
                            <div style="font-weight: 500; color: var(--text);">${escapeHtml(tab.name)}</div>
                            <div style="font-size: 0.875rem; color: var(--text-light);">${courseCount} course${courseCount !== 1 ? 's' : ''}</div>
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button type="button" onclick="editTab('${tab.id}')" style="padding: 0.5rem; background: var(--bg-alt); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer; color: var(--text);" title="Edit">
                                <i data-lucide="pencil" style="width: 1rem; height: 1rem;"></i>
                            </button>
                            <button type="button" onclick="deleteTab('${tab.id}')" style="padding: 0.5rem; background: var(--bg-alt); border: 1px solid var(--border); border-radius: 0.25rem; cursor: pointer; color: var(--error);" title="Delete">
                                <i data-lucide="trash-2" style="width: 1rem; height: 1rem;"></i>
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
            
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons({ root: container });
            }
        }
        
        function addNewTab() {
            const name = prompt('Enter tab name:');
            if (!name || !name.trim()) return;
            
            const customTabs = getCustomTabs();
            const newTab = {
                id: 'tab_' + Date.now(),
                name: name.trim()
            };
            customTabs.push(newTab);
            saveCustomTabs(customTabs);
            
            renderTabsList();
            renderCustomTabs();
            
            // Invalidate cache
            _coursesGridCache = {
                current: { html: null, dataHash: null },
                previous: { html: null, dataHash: null }
            };
            
            // Initialize cache for the new tab
            _coursesGridCache[newTab.id] = { html: null, dataHash: null };
            
            if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Tab created.', 3000);
        }
        
        function editTab(tabId) {
            const customTabs = getCustomTabs();
            const tab = customTabs.find(t => t.id === tabId);
            if (!tab) return;
            
            const newName = prompt('Enter new tab name:', tab.name);
            if (!newName || !newName.trim()) return;
            
            tab.name = newName.trim();
            saveCustomTabs(customTabs);
            
            renderTabsList();
            renderCustomTabs();
            
            if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Tab updated.', 3000);
        }
        
        function deleteTab(tabId) {
            if (!confirm('Are you sure you want to delete this tab? Courses in this tab will be moved back to their default tabs (Current/Previous).')) return;
            
            const customTabs = getCustomTabs();
            const filtered = customTabs.filter(t => t.id !== tabId);
            saveCustomTabs(filtered);
            
            // Remove assignments for this tab
            const assignments = getCourseTabAssignments();
            Object.keys(assignments).forEach(courseId => {
                if (assignments[courseId] === tabId) {
                    delete assignments[courseId];
                }
            });
            saveCourseTabAssignments(assignments);
            
            renderTabsList();
            renderCustomTabs();
            
            // Invalidate cache
            _coursesGridCache = {
                current: { html: null, dataHash: null },
                previous: { html: null, dataHash: null }
            };
            
            // If we're currently viewing this tab, switch to Current
            if (_coursesViewTab === tabId) {
                switchToTab('current');
            }
            
            if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Tab deleted.', 3000);
        }
        
        window.showMoveStudentsFromCourse = function() {
            // Open the move students modal from within the course detail view
            if (!currentClassId) {
                if (typeof showAnalyticsToast === 'function') showAnalyticsToast('No course selected', 4000);
                else alert('No course selected');
                return;
            }
            window.openMoveStudentsModal(currentClassId);
        };
        
        window.openMoveStudentsModal = function(courseId) {
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const course = classes.find(c => c.id === courseId);
            if (!course) {
                if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Course not found.', 4000);
                else alert('Course not found');
                return;
            }
            
            // Check if modal elements exist
            const moveCourseSource = document.getElementById('moveCourseSource');
            const targetSelect = document.getElementById('moveCourseTarget');
            const studentsList = document.getElementById('moveCourseStudentsList');
            const modal = document.getElementById('moveCourseModal');
            
            if (!moveCourseSource || !targetSelect || !studentsList || !modal) {
                console.error('Move course modal elements not found');
                if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Move students feature is not available.', 4000);
                else alert('Move students feature is not available.');
                return;
            }
            
            // Populate the move form
            moveCourseSource.value = `${course.name} - ${course.semester} ${course.year} (Section ${course.section || 'N/A'})`;
            
            // Populate target course dropdown (exclude current course)
            targetSelect.innerHTML = '<option value="">-- Select Course --</option>';
            classes.forEach(c => {
                if (c.id !== courseId && !isDeletedId('deleted_course_ids', c.id)) {
                    const option = document.createElement('option');
                    option.value = c.id;
                    option.textContent = `${c.name} - ${c.semester} ${c.year} (Section ${c.section || 'N/A'})`;
                    targetSelect.appendChild(option);
                }
            });
            
            // Populate students list
            if (!course.roster || course.roster.length === 0) {
                studentsList.innerHTML = '<p style="color: var(--text-light); text-align: center;">No students in this course.</p>';
            } else {
                const studentsHtml = course.roster.map((student, index) => {
                    const studentName = `${student.firstName || ''} ${student.lastName || ''}`.trim() || 'Unnamed';
                    return `
                        <label style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; border-radius: 0.25rem; cursor: pointer; transition: background 0.15s;" onmouseover="this.style.background='var(--bg-alt)'" onmouseout="this.style.background='transparent'">
                            <input type="checkbox" name="moveStudent" value="${student.id || student.supabaseId || index}" checked style="cursor: pointer;">
                            <span>${escapeHtml(studentName)}${student.email ? ' (' + escapeHtml(student.email) + ')' : ''}</span>
                        </label>
                    `;
                }).join('');
                studentsList.innerHTML = studentsHtml;
            }
            
            // Store course ID for the move operation
            targetSelect.setAttribute('data-source-course-id', courseId);
            
            // Show the modal
            modal.style.display = 'flex';
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: modal });
        }
        
        function closeMoveCourseModal() {
            const modal = document.getElementById('moveCourseModal');
            if (modal) modal.style.display = 'none';
            document.getElementById('moveCourseTarget').innerHTML = '<option value="">-- Select Course --</option>';
            document.getElementById('moveCourseStudentsList').innerHTML = '<p style="color: var(--text-light); text-align: center;">Loading students...</p>';
        }
        
        async function executeMoveCourse() {
            const targetSelect = document.getElementById('moveCourseTarget');
            const sourceCourseId = targetSelect.getAttribute('data-source-course-id');
            const targetCourseId = targetSelect.value;
            
            if (!sourceCourseId || !targetCourseId) {
                alert('Please select a target course');
                return;
            }
            
            if (sourceCourseId === targetCourseId) {
                alert('Cannot move students to the same course');
                return;
            }
            
            // Get selected students
            const selectedCheckboxes = document.querySelectorAll('#moveCourseStudentsList input[name="moveStudent"]:checked');
            if (selectedCheckboxes.length === 0) {
                alert('Please select at least one student to move');
                return;
            }
            
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const sourceCourse = classes.find(c => c.id === sourceCourseId);
            const targetCourse = classes.find(c => c.id === targetCourseId);
            
            if (!sourceCourse || !targetCourse) {
                alert('Course not found');
                return;
            }
            
            // Get selected student IDs
            const selectedStudentIds = Array.from(selectedCheckboxes).map(cb => cb.value);
            
            // Find students to move
            const studentsToMove = [];
            const studentsToKeep = [];
            
            sourceCourse.roster.forEach((student, index) => {
                const studentId = student.id || student.supabaseId || index.toString();
                if (selectedStudentIds.includes(studentId.toString())) {
                    studentsToMove.push(student);
                } else {
                    studentsToKeep.push(student);
                }
            });
            
            if (studentsToMove.length === 0) {
                alert('No students selected to move');
                return;
            }
            
            // Confirm action
            const confirmMessage = `Move ${studentsToMove.length} student${studentsToMove.length !== 1 ? 's' : ''} from "${sourceCourse.name}" to "${targetCourse.name}"?`;
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Update source course (remove students)
            sourceCourse.roster = studentsToKeep;
            const sourceIndex = classes.findIndex(c => c.id === sourceCourseId);
            if (sourceIndex !== -1) {
                classes[sourceIndex] = sourceCourse;
            }
            
            // Update target course (add students)
            if (!targetCourse.roster) {
                targetCourse.roster = [];
            }
            targetCourse.roster = targetCourse.roster.concat(studentsToMove);
            const targetIndex = classes.findIndex(c => c.id === targetCourseId);
            if (targetIndex !== -1) {
                classes[targetIndex] = targetCourse;
            }
            
            // Save to localStorage
            setUserItem('classes', JSON.stringify(classes));
            
            // Update Supabase
            if (supabaseClient && sourceCourse.supabaseId && targetCourse.supabaseId) {
                try {
                    // Update student course_id in Supabase
                    const studentSupabaseIds = studentsToMove
                        .map(s => s.supabaseId || s.id)
                        .filter(id => id && /^[0-9a-f-]{36}$/i.test(String(id)));
                    
                    if (studentSupabaseIds.length > 0) {
                        const { error } = await supabaseClient
                            .from('course_students')
                            .update({ course_id: targetCourse.supabaseId })
                            .in('id', studentSupabaseIds);
                        
                        if (error) {
                            console.error('Failed to move students in Supabase:', error);
                            alert('Students moved locally, but failed to update in database: ' + (error.message || error));
                        } else {
                            console.log(`✓ ${studentSupabaseIds.length} students moved in Supabase`);
                        }
                    }
                } catch (error) {
                    console.error('Error moving students:', error);
                    alert('Students moved locally, but failed to update in database: ' + (error.message || error));
                }
            }
            
            closeMoveCourseModal();
            if (typeof showAnalyticsToast === 'function') showAnalyticsToast(`Moved ${studentsToMove.length} student${studentsToMove.length !== 1 ? 's' : ''} successfully.`, 4000);
            await loadClasses();
            
            // If we're currently viewing the source course, refresh the view
            if (currentClassId === sourceCourseId) {
                await viewClass(sourceCourseId, true);
            }
        }
        
        /** Delete course. Instructor/Admin: local only (mark in Supabase). Super Admin: scope from Settings. */
        async function deleteCourse(courseId) {
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const course = classes.find(c => c.id === courseId);
            if (!course) { if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Course not found.', 4000); else alert('Course not found.'); return; }
            const nameDisplay = (course.name || 'Course').trim();
            showConfirmModal('Delete course', 'Are you sure you want to delete this course? (' + nameDisplay + ') This cannot be undone.', function() {
                doDeleteCourse(courseId, course, nameDisplay, classes);
            }, null, 'Delete');
        }
        async function doDeleteCourse(courseId, course, nameDisplay, classes) {
            const scope = typeof getDeletionScope === 'function' ? getDeletionScope('courses') : 'local';
            if (scope === 'local' || scope === 'both') {
                const filtered = classes.filter(c => c.id !== courseId);
                setUserItem('classes', JSON.stringify(filtered));
                addDeletedId('deleted_course_ids', courseId);
            }
            // Resolve Supabase course id (when loaded from API, id === supabaseId)
            const courseSupabaseId = course.supabaseId || (course.id && /^[0-9a-f-]{36}$/i.test(String(course.id)) ? course.id : null);
            if ((scope === 'supabase' || scope === 'both') && supabaseClient && courseSupabaseId) {
                try {
                    await supabaseClient.from('courses').delete().eq('id', courseSupabaseId);
                } catch (e) {
                    console.error('Supabase delete course:', e);
                }
            } else if ((scope === 'local' || scope === 'both') && supabaseClient && currentUser) {
                let updated = false;
                if (courseSupabaseId) {
                    try {
                        const { error } = await supabaseClient.from('courses').update({
                            deleted_locally_at: new Date().toISOString(),
                            deleted_locally_by: currentUser.id
                        }).eq('id', courseSupabaseId);
                        updated = !error;
                        if (error) console.error('Supabase update deleted_locally course:', error);
                    } catch (e) {
                        console.error('Supabase update deleted_locally course:', e);
                    }
                }
                // Fallback: find course by instructor + name/semester/year and mark deleted so admin/super admin hide it
                if (!updated && course.name) {
                    try {
                        let q = supabaseClient.from('courses').select('id').eq('instructor_id', currentUser.id).ilike('name', (course.name || '').trim()).is('deleted_locally_at', null);
                        if (course.semester) q = q.eq('semester', course.semester);
                        if (course.year) q = q.eq('year', parseInt(course.year, 10));
                        const { data: rows } = await q.limit(1);
                        if (rows && rows.length > 0) {
                            await supabaseClient.from('courses').update({
                                deleted_locally_at: new Date().toISOString(),
                                deleted_locally_by: currentUser.id
                            }).eq('id', rows[0].id);
                        }
                    } catch (e) {
                        console.error('Supabase fallback update deleted_locally course:', e);
                    }
                }
            }
            currentClassId = null;
            await loadClasses();
            setActiveSection('dashboardSection', 'navDashboard');
            const courseIdForUndo = course.supabaseId || course.id;
            const courseIdForUndoVal = (scope === 'local' || scope === 'both') ? (courseIdForUndo || courseId) : null;
            if (courseIdForUndoVal) {
                showNotificationWithUndo('Course removed.', 'Undo', () => undoDeleteCourse(courseIdForUndoVal));
            }
        }

        async function deleteStudent(studentId) {
            showConfirmModal('Delete student', 'Are you sure you want to delete this student? This cannot be undone.', function() {
                doDeleteStudent(studentId);
            }, null, 'Delete');
        }
        async function doDeleteStudent(studentId) {
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const classIndex = classes.findIndex(c => c.id === currentClassId);
            if (classIndex === -1) return;
            const cls = classes[classIndex];
            const student = cls.roster && cls.roster.find(s => s.id === studentId || s.supabaseId === studentId);
            const scope = typeof getDeletionScope === 'function' ? getDeletionScope('students') : 'local';
            if (scope === 'local' || scope === 'both') {
                classes[classIndex].roster = (classes[classIndex].roster || []).filter(s => s.id !== studentId && s.supabaseId !== studentId);
                setUserItem('classes', JSON.stringify(classes));
                addDeletedId('deleted_student_ids', currentClassId + ':' + studentId);
            }
            // Resolve course_students row id: use roster supabaseId, or look up by course + name/email so admin count updates
            let courseStudentId = student && student.supabaseId ? student.supabaseId : null;
            if ((scope === 'supabase' || scope === 'both') && supabaseClient && courseStudentId) {
                try {
                    await supabaseClient.from('course_students').delete().eq('id', courseStudentId);
                } catch (e) {
                    console.error('Supabase delete student:', e);
                }
            } else if ((scope === 'local' || scope === 'both') && supabaseClient && currentUser && cls && cls.supabaseId && student) {
                if (courseStudentId) {
                    try {
                        const { error } = await supabaseClient.from('course_students').update({
                            deleted_locally_at: new Date().toISOString(),
                            deleted_locally_by: currentUser.id
                        }).eq('id', courseStudentId);
                        if (error) console.error('Supabase update deleted_locally student:', error);
                    } catch (e) {
                        console.error('Supabase update deleted_locally student:', e);
                    }
                } else {
                    // Fallback: roster item has no supabaseId (e.g. demo or merged view) — find course_students row by name/email
                    try {
                        const { data: rows } = await supabaseClient
                            .from('course_students')
                            .select('id, first_name, last_name, email')
                            .eq('course_id', cls.supabaseId)
                            .is('deleted_locally_at', null);
                        const first = (student.firstName || '').trim().toLowerCase();
                        const last = (student.lastName || '').trim().toLowerCase();
                        const email = (student.email || '').trim().toLowerCase();
                        const match = (rows || []).find(r =>
                            (r.first_name || '').trim().toLowerCase() === first &&
                            (r.last_name || '').trim().toLowerCase() === last &&
                            (r.email || '').trim().toLowerCase() === email
                        );
                        if (match) {
                            courseStudentId = match.id;
                            const { error } = await supabaseClient.from('course_students').update({
                                deleted_locally_at: new Date().toISOString(),
                                deleted_locally_by: currentUser.id
                            }).eq('id', courseStudentId);
                            if (error) console.error('Supabase update deleted_locally student (fallback):', error);
                        }
                    } catch (e) {
                        console.error('Supabase lookup/update course_students (fallback):', e);
                    }
                }
            }
            // When deleting a student locally, also mark all their evaluations in this course as deleted locally (student_id = course_students.id)
            if ((scope === 'local' || scope === 'both') && supabaseClient && cls && cls.supabaseId && currentUser && courseStudentId) {
                const evalStudentId = courseStudentId;
                try {
                    const { data: evals } = await supabaseClient
                        .from('evaluations')
                        .select('id')
                        .eq('course_id', cls.supabaseId)
                        .eq('student_id', evalStudentId);
                    if (evals && evals.length > 0) {
                        for (const ev of evals) {
                            addDeletedId('deleted_evaluation_ids', ev.id);
                        }
                        await supabaseClient.from('evaluations').update({
                            deleted_locally_at: new Date().toISOString(),
                            deleted_locally_by: currentUser.id
                        }).eq('course_id', cls.supabaseId).eq('student_id', evalStudentId);
                    }
                } catch (e) {
                    console.error('Supabase mark student evals deleted_locally:', e);
                }
            }
            viewClass(currentClassId, true); // Refresh view without reloading from Supabase so local delete sticks
            if ((scope === 'local' || scope === 'both') && courseStudentId) {
                showNotificationWithUndo('Student removed.', 'Undo', () => undoDeleteStudent(currentClassId, courseStudentId));
            }
        }

        /** Delete evaluation. Instructor/Admin: local only (mark in Supabase). Super Admin: scope from Settings. */
        async function deleteEvaluation(evaluationId, studentId) {
            showConfirmModal('Delete evaluation', 'Are you sure you want to delete this evaluation? This cannot be undone.', function() {
                doDeleteEvaluation(evaluationId, studentId);
            }, null, 'Delete');
        }
        async function doDeleteEvaluation(evaluationId, studentId) {
            const scope = typeof getDeletionScope === 'function' ? getDeletionScope('evaluations') : 'local';
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const cls = classes.find(c => c.id === currentClassId);
            if (cls && (scope === 'local' || scope === 'both')) {
                const student = cls.roster && cls.roster.find(s => s.id === studentId || s.supabaseId === studentId);
                if (student && student.evaluations) {
                    student.evaluations = student.evaluations.filter(e => (e.id !== evaluationId && e.supabaseId !== evaluationId));
                    setUserItem('classes', JSON.stringify(classes));
                }
                addDeletedId('deleted_evaluation_ids', evaluationId);
            }
            if ((scope === 'supabase' || scope === 'both') && supabaseClient) {
                try {
                    await supabaseClient.from('evaluations').delete().eq('id', evaluationId);
                } catch (e) {
                    console.error('Supabase delete evaluation:', e);
                }
            } else if ((scope === 'local' || scope === 'both') && supabaseClient && currentUser) {
                try {
                    await supabaseClient.from('evaluations').update({
                        deleted_locally_at: new Date().toISOString(),
                        deleted_locally_by: currentUser.id
                    }).eq('id', evaluationId);
                } catch (e) {
                    console.error('Supabase update deleted_locally evaluation:', e);
                }
            }
            viewStudentEvals(studentId);
            if (scope === 'local' || scope === 'both') {
                showNotificationWithUndo('Evaluation removed.', 'Undo', () => undoDeleteEvaluation(evaluationId, studentId));
            }
        }

        /** Undo: restore a locally deleted student and their evaluations. Only works for local (soft) deletes. */
        async function undoDeleteStudent(courseId, courseStudentId) {
            if (!supabaseClient || !currentUser || !courseId || !courseStudentId) return;
            try {
                await supabaseClient.from('course_students').update({
                    deleted_locally_at: null,
                    deleted_locally_by: null
                }).eq('id', courseStudentId);
                removeDeletedId('deleted_student_ids', courseId + ':' + courseStudentId);
                const { data: evals } = await supabaseClient.from('evaluations').select('id').eq('course_id', courseId).eq('student_id', courseStudentId);
                if (evals && evals.length > 0) {
                    await supabaseClient.from('evaluations').update({
                        deleted_locally_at: null,
                        deleted_locally_by: null
                    }).eq('course_id', courseId).eq('student_id', courseStudentId);
                    evals.forEach(ev => removeDeletedId('deleted_evaluation_ids', ev.id));
                }
                await loadClasses();
                await viewClass(courseId);
                showNotification('Student restored.', 'success');
            } catch (e) {
                console.error('Undo delete student:', e);
                showNotification('Could not restore student.', 'error');
            }
        }

        /** Undo: restore a locally deleted evaluation. Only works for local (soft) deletes. */
        async function undoDeleteEvaluation(evaluationId, studentId) {
            if (!supabaseClient || !currentUser || !evaluationId) return;
            try {
                await supabaseClient.from('evaluations').update({
                    deleted_locally_at: null,
                    deleted_locally_by: null
                }).eq('id', evaluationId);
                removeDeletedId('deleted_evaluation_ids', evaluationId);
                await loadClasses();
                if (currentClassId) await viewClass(currentClassId);
                if (studentId) viewStudentEvals(studentId);
                showNotification('Evaluation restored.', 'success');
            } catch (e) {
                console.error('Undo delete evaluation:', e);
                showNotification('Could not restore evaluation.', 'error');
            }
        }

        /** Undo: restore a locally deleted course. Only works for local (soft) deletes. */
        async function undoDeleteCourse(courseId) {
            if (!supabaseClient || !currentUser || !courseId) return;
            try {
                await supabaseClient.from('courses').update({
                    deleted_locally_at: null,
                    deleted_locally_by: null
                }).eq('id', courseId);
                removeDeletedId('deleted_course_ids', courseId);
                await loadClasses();
                setActiveSection('dashboardSection', 'navDashboard');
                showNotification('Course restored.', 'success');
            } catch (e) {
                console.error('Undo delete course:', e);
                showNotification('Could not restore course.', 'error');
            }
        }

        /** Open modal listing locally-deleted students, evaluations, and courses with Restore buttons. */
        async function showRecoverDeletedModal() {
            const modal = document.getElementById('recoverDeletedModal');
            const content = document.getElementById('recoverDeletedContent');
            if (!modal || !content) return;
            content.innerHTML = '<p style="color: var(--text-light);">Loading…</p>';
            modal.style.display = 'flex';
            if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: modal });
            if (!supabaseClient || !currentUser) {
                content.innerHTML = '<p style="color: var(--text-light);">You must be signed in to recover deleted items.</p>';
                return;
            }
            try {
                const myCourseIds = await getMyCourseIds();
                const [deletedCourses, deletedStudents, deletedEvals] = await Promise.all([
                    loadDeletedCourses(),
                    loadDeletedStudents(myCourseIds),
                    loadDeletedEvaluations()
                ]);
                let html = '';
                if (deletedStudents.length > 0) {
                    html += '<h3 style="margin: 0 0 0.75rem 0; font-size: 1rem;">Deleted students</h3><ul style="list-style: none; padding: 0; margin: 0 0 1.5rem 0;">';
                    deletedStudents.forEach(s => {
                        const name = escapeHtml((s.first_name || '') + ' ' + (s.last_name || '')).trim() || '—';
                        const courseName = escapeHtml(s.course_name || 'Course');
                        html += `<li style="display: flex; justify-content: space-between; align-items: center; padding: 0.6rem 0; border-bottom: 1px solid var(--border);">
                            <span>${name} <span style="color: var(--text-light); font-size: 0.9rem;">(${courseName})</span></span>
                            <button type="button" onclick="undoDeleteStudent('${escapeHtml(s.course_id)}', '${escapeHtml(s.id)}'); closeRecoverDeletedModal();" style="padding: 0.35rem 0.75rem; background: var(--primary); color: white; border: none; border-radius: 0.35rem; cursor: pointer; font-size: 0.9rem;">Restore</button>
                        </li>`;
                    });
                    html += '</ul>';
                }
                if (deletedEvals.length > 0) {
                    html += '<h3 style="margin: 0 0 0.75rem 0; font-size: 1rem;">Deleted evaluations</h3><ul style="list-style: none; padding: 0; margin: 0 0 1.5rem 0;">';
                    deletedEvals.forEach(e => {
                        const label = escapeHtml(e.student_name || 'Evaluation') + ' · ' + (e.created_at ? new Date(e.created_at).toLocaleDateString() : '');
                        html += `<li style="display: flex; justify-content: space-between; align-items: center; padding: 0.6rem 0; border-bottom: 1px solid var(--border);">
                            <span>${label}</span>
                            <button type="button" onclick="undoDeleteEvaluation('${escapeHtml(e.id)}', '${escapeHtml(e.student_id || '')}'); closeRecoverDeletedModal();" style="padding: 0.35rem 0.75rem; background: var(--primary); color: white; border: none; border-radius: 0.35rem; cursor: pointer; font-size: 0.9rem;">Restore</button>
                        </li>`;
                    });
                    html += '</ul>';
                }
                if (deletedCourses.length > 0) {
                    html += '<h3 style="margin: 0 0 0.75rem 0; font-size: 1rem;">Deleted courses</h3><ul style="list-style: none; padding: 0; margin: 0;">';
                    deletedCourses.forEach(c => {
                        const name = escapeHtml((c.name || 'Course') + ' (' + (c.semester || '') + ' ' + (c.year || '') + ')').trim();
                        html += `<li style="display: flex; justify-content: space-between; align-items: center; padding: 0.6rem 0; border-bottom: 1px solid var(--border);">
                            <span>${name}</span>
                            <button type="button" onclick="undoDeleteCourse('${escapeHtml(c.id)}'); closeRecoverDeletedModal();" style="padding: 0.35rem 0.75rem; background: var(--primary); color: white; border: none; border-radius: 0.35rem; cursor: pointer; font-size: 0.9rem;">Restore</button>
                        </li>`;
                    });
                    html += '</ul>';
                }
                if (!html) content.innerHTML = '<p style="color: var(--text-light);">No deleted items to recover. Deleted items appear here only when removed with "Remove" or "Delete" (not when permanently deleted by a super admin).</p>';
                else content.innerHTML = html;
                if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: content });
            } catch (e) {
                console.error('Recover deleted modal:', e);
                content.innerHTML = '<p style="color: var(--error);">Failed to load deleted items.</p>';
            }
        }

        function closeRecoverDeletedModal() {
            const modal = document.getElementById('recoverDeletedModal');
            if (modal) modal.style.display = 'none';
        }

        async function getMyCourseIds() {
            const { data: rows } = await supabaseClient.from('courses').select('id').eq('instructor_id', currentUser.id);
            return (rows || []).map(r => r.id);
        }

        async function loadDeletedCourses() {
            const { data } = await supabaseClient.from('courses').select('id, name, semester, year').eq('instructor_id', currentUser.id).not('deleted_locally_at', 'is', null);
            return data || [];
        }

        async function loadDeletedStudents(courseIds) {
            if (!courseIds || courseIds.length === 0) return [];
            const { data: rows } = await supabaseClient.from('course_students').select('id, first_name, last_name, email, course_id').in('course_id', courseIds).not('deleted_locally_at', 'is', null);
            if (!rows || rows.length === 0) return [];
            const { data: courses } = await supabaseClient.from('courses').select('id, name').in('id', [...new Set(rows.map(r => r.course_id))]);
            const courseNames = {};
            (courses || []).forEach(c => { courseNames[c.id] = c.name; });
            return rows.map(r => ({ ...r, course_name: courseNames[r.course_id] }));
        }

        async function loadDeletedEvaluations() {
            const { data } = await supabaseClient.from('evaluations').select('id, student_id, created_at').eq('instructor_id', currentUser.id).not('deleted_locally_at', 'is', null);
            if (!data || data.length === 0) return [];
            const studentIds = [...new Set(data.map(e => e.student_id).filter(Boolean))];
            let studentNames = {};
            if (studentIds.length > 0) {
                const { data: students } = await supabaseClient.from('course_students').select('id, first_name, last_name');
                (students || []).forEach(s => { studentNames[s.id] = (s.first_name || '') + ' ' + (s.last_name || ''); });
            }
            return data.map(e => ({ ...e, student_name: studentNames[e.student_id] || 'Student' }));
        }
        
        // Edit saved evaluation
        let editingEvaluationId = null;
        let editingStudentId = null;
        let editingEvaluationVideoUrl = null;
        
        async function editSavedEvaluation(evaluationId, studentId) {
            console.log('=== editSavedEvaluation START ===');
            console.log('Evaluation ID:', evaluationId);
            console.log('Student ID:', studentId);
            
            // Get courseId from evaluation if available (for proper URL routing)
            let courseId = null;
            try {
                if (supabaseClient && evaluationId) {
                    const { data: evalData, error } = await supabaseClient
                        .from('evaluations')
                        .select('course_id')
                        .eq('id', evaluationId)
                        .single();
                    if (!error && evalData) {
                        courseId = evalData.course_id;
                    }
                }
            } catch (e) {
                console.warn('Could not fetch courseId for evaluation:', e);
            }
            
            // Update URL for deep linking with path-based routing
            if (typeof Router !== 'undefined' && Router.navigateToEvaluation) {
                Router.navigateToEvaluation(evaluationId, studentId, courseId, true); // true = edit mode
            }
            
            // Close all evaluation action menus first - be very aggressive about it
            document.querySelectorAll('.evaluation-actions-menu').forEach(menu => {
                menu.classList.add('hidden');
                menu.style.display = 'none';
                menu.style.visibility = 'hidden';
                const parent = menu.parentElement;
                if (parent) {
                    const btn = parent.querySelector('button[aria-haspopup="true"]');
                    if (btn) {
                        btn.setAttribute('aria-expanded', 'false');
                        btn.classList.remove('active');
                    }
                }
            });
            
            // Also close any eval actions dropdowns
            document.querySelectorAll('[id^="evalActionsMenu_"]').forEach(menu => {
                menu.classList.add('hidden');
                menu.style.display = 'none';
                menu.style.visibility = 'hidden';
            });
            
            // Close any evaluation menus by ID pattern
            document.querySelectorAll('[id^="eval-menu-"]').forEach(menu => {
                menu.classList.add('hidden');
                menu.style.display = 'none';
                menu.style.visibility = 'hidden';
                const parent = menu.parentElement;
                if (parent) {
                    const btn = parent.querySelector('button[onclick*="toggleEvaluationMenu"]');
                    if (btn) {
                        btn.setAttribute('aria-expanded', 'false');
                        btn.classList.remove('active');
                    }
                }
            });
            
            // Force close any visible menus after a brief delay to ensure DOM is updated
            setTimeout(() => {
                document.querySelectorAll('.evaluation-actions-menu').forEach(menu => {
                    if (!menu.classList.contains('hidden')) {
                        menu.classList.add('hidden');
                        menu.style.display = 'none';
                        menu.style.visibility = 'hidden';
                    }
                });
                document.querySelectorAll('[id^="eval-menu-"]').forEach(menu => {
                    if (!menu.classList.contains('hidden')) {
                        menu.classList.add('hidden');
                        menu.style.display = 'none';
                        menu.style.visibility = 'hidden';
                    }
                });
            }, 50);
            
            // Find and expand the evaluation dropdown first
            // Look for all evaluation containers and find the one with matching evalId
            const allEvalContainers = document.querySelectorAll('[id^="eval-"]');
            for (let i = 0; i < allEvalContainers.length; i++) {
                const containerId = allEvalContainers[i].id;
                // Check if this container's menu has the matching evaluationId
                const menuButton = document.querySelector(`button[onclick*="editSavedEvaluation('${evaluationId}'"]`);
                if (menuButton) {
                    // Find the evaluation container by looking for the toggleEvaluation call
                    const evalIndex = containerId.replace('eval-', '');
                    const content = document.getElementById(containerId);
                    const arrow = document.getElementById(containerId + '-arrow');
                    if (content && content.classList.contains('hidden')) {
                        content.classList.remove('hidden');
                        if (arrow) arrow.textContent = '▲';
                    }
                    break;
                }
            }
            
            // Store IDs for later update
            editingEvaluationId = evaluationId;
            editingStudentId = studentId;
            editingEvaluationVideoUrl = null;
            
            // Load the evaluation from Supabase or localStorage
            let evaluation = null;
            
            if (supabaseClient && currentUser) {
                console.log('Loading from Supabase...');
                const { data, error } = await supabaseClient
                    .from('evaluations')
                    .select('*')
                    .eq('id', evaluationId)
                    .single();
                
                if (data) {
                    console.log('✓ Loaded from Supabase');
                    evaluation = data.evaluation_data;
                    if (typeof evaluation === 'string') try { evaluation = JSON.parse(evaluation); } catch (_) { evaluation = null; }
                    if (evaluation && data.transcript != null) evaluation.transcript = data.transcript;
                    editingEvaluationVideoUrl = data.video_url || null;
                    // Store video/audio URLs in evaluation object for display
                    if (data.video_url) evaluation.video_url = data.video_url;
                    if (data.audio_url) evaluation.audio_url = data.audio_url;
                    // Also store in editingEvaluationVideoUrl for backward compatibility
                    if (data.video_url) editingEvaluationVideoUrl = data.video_url;
                    else if (data.audio_url) editingEvaluationVideoUrl = data.audio_url;
                    
                    // CRITICAL: Preserve model_output_original for multi-instructor training
                    // This allows multiple instructors to edit the same evaluation while preserving the original AI output
                    if (evaluation && evaluation.model_output_original) {
                        console.log('✓ Preserved model_output_original for training');
                        // Keep it in the evaluation object so it's saved when updating
                    } else if (evaluation && !evaluation.model_output_original) {
                        // If no original exists, create it from current sections (first instructor edit)
                        console.log('⚠️ No model_output_original found - this may be a pre-training evaluation');
                    }
                } else if (error) {
                    console.error('Supabase error:', error);
                }
            }
            
            // Fallback to localStorage if not in Supabase
            if (!evaluation) {
                console.log('Trying localStorage...');
                const classes = JSON.parse(getUserItem('classes') || '[]');
                const cls = classes.find(c => c.id === currentClassId);
                if (cls) {
                    const student = cls.roster.find(s => s.id === studentId || s.supabaseId === studentId);
                    if (student && student.evaluations) {
                        const evalRecord = student.evaluations.find(e => e.id === evaluationId || e.supabaseId === evaluationId);
                        if (evalRecord) {
                            evaluation = evalRecord.results;
                            console.log('✓ Loaded from localStorage');
                        }
                    }
                }
            }
            
            if (!evaluation) {
                console.error('Could not load evaluation!');
                alert('Could not load evaluation for editing.');
                return;
            }
            
            console.log('Evaluation loaded:', evaluation);
            
            // CRITICAL: Ensure gradeScale is present (for old evaluations that don't have it)
            if (!evaluation.gradeScale && evaluation.rubricUsed) {
                console.log('⚠️ gradeScale missing, attempting to fetch from rubric...');
                const allRubrics = await getAllRubrics();
                const matchingRubric = allRubrics.find(r => r.name === evaluation.rubricUsed);
                if (matchingRubric && matchingRubric.gradeScale) {
                    evaluation.gradeScale = matchingRubric.gradeScale;
                    console.log('✓ gradeScale restored from rubric:', matchingRubric.name);
                    
                    // Recalculate letter grade with the restored gradeScale
                    const percentage = ((evaluation.totalScore / evaluation.maxScore) * 100).toFixed(1);
                    evaluation.letterGrade = getLetterGrade(percentage, evaluation.gradeScale);
                    evaluation.percentage = percentage;
                    console.log('✓ Recalculated letterGrade:', evaluation.letterGrade);
                } else {
                    console.warn('⚠️ Could not find matching rubric to restore gradeScale');
                }
            }
            
            // Set the evaluation as current for editing
            evaluationResults = evaluation;
            correctionLog = evaluation.corrections || [];
            // Note: video/audio URLs are already set on evaluation object above (lines 26344-26345)
            // so they're already included in evaluationResults
            console.log('Set evaluationResults and correctionLog');
            
            // Hide all main sections
            console.log('Hiding main sections...');
            const mainSections = ['dashboardSection'];
            mainSections.forEach(id => {
                const element = document.getElementById(id);
                console.log(`  ${id}:`, element ? 'found' : 'NOT FOUND');
                if (element) {
                    element.classList.remove('active');
                    console.log(`  ${id}: hidden`);
                }
            });
            
            // Note: We don't need to hide the student evaluations list view - 
            // showing evaluateSection will naturally replace it in the UI
            
            // Show evaluation section
            console.log('Showing evaluation section...');
            const evalSection = document.getElementById('evaluateSection');
            console.log('  evaluateSection:', evalSection ? 'found' : 'NOT FOUND');
            if (evalSection) {
                evalSection.classList.add('active');
                // CRITICAL: Force display - logs show display:"none" even with active class
                evalSection.style.display = 'block';
                evalSection.style.visibility = 'visible';
                console.log('  evaluateSection: visible');
                
                // #region agent log
                const evalComputed = window.getComputedStyle(evalSection);
                fetch('http://127.0.0.1:7242/ingest/2d493fae-3749-4b25-960d-04d6e5f42b38',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:27012',message:'evaluateSection visibility check',data:{hasActiveClass:evalSection.classList.contains('active'),display:evalComputed.display,visibility:evalComputed.visibility,offsetHeight:evalSection.offsetHeight,offsetWidth:evalSection.offsetWidth},timestamp:Date.now(),runId:'run9',hypothesisId:'L'})}).catch(()=>{});
                // #endregion
            }
            
            // Set up beforeunload handler to warn when leaving page
            window.addEventListener('beforeunload', handleBeforeUnload);
            
            // Hide all steps within evaluation section AND the progress bar
            console.log('Hiding other steps...');
            const steps = ['uploadStep', 'detailsStep', 'processingStep'];
            steps.forEach(id => {
                const element = document.getElementById(id);
                console.log(`  ${id}:`, element ? 'found' : 'NOT FOUND');
                if (element) {
                    element.classList.add('hidden');
                    console.log(`  ${id}: hidden`);
                }
            });
            
            // Hide progress steps bar when editing (not needed for editing saved evaluations)
            const progressSteps = evalSection ? evalSection.querySelector('.progress-steps') : null;
            if (progressSteps) {
                progressSteps.style.display = 'none';
                console.log('  ✓ Hidden progress steps bar');
            }
            
            // Show results step
            console.log('Showing results step...');
            const resultsStep = document.getElementById('resultsStep');
            console.log('  resultsStep:', resultsStep ? 'found' : 'NOT FOUND');
            console.log('  resultsStep classes before:', resultsStep ? resultsStep.className : 'N/A');
            if (resultsStep) {
                resultsStep.classList.remove('hidden');
                resultsStep.style.display = 'block'; // Force display
                console.log('  resultsStep classes after:', resultsStep.className);
                console.log('  resultsStep: visible');
                
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/2d493fae-3749-4b25-960d-04d6e5f42b38',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:27035',message:'resultsStep visibility check',data:{hasHiddenClass:resultsStep.classList.contains('hidden'),displayStyle:window.getComputedStyle(resultsStep).display,offsetHeight:resultsStep.offsetHeight,offsetWidth:resultsStep.offsetWidth},timestamp:Date.now(),runId:'run9',hypothesisId:'L'})}).catch(()=>{});
                // #endregion
            }
            
            // Render the evaluation results to show edit buttons
            console.log('Rendering evaluation results for editing...');
            console.log('  editingEvaluationId:', editingEvaluationId);
            console.log('  evaluationId parameter:', evaluationId);
            
            // Check if we're in the dropdown view (viewStudentEvals) or main evaluation view
            // Find the evaluation dropdown that contains this evaluation
            let evalDropdown = null;
            const allEvalDropdowns = document.querySelectorAll('[id^="eval-"]');
            for (let i = 0; i < allEvalDropdowns.length; i++) {
                const dropdown = allEvalDropdowns[i];
                // Check if this dropdown contains a button that references this evaluationId
                const editButton = dropdown.querySelector(`button[onclick*="editSavedEvaluation('${evaluationId}'"]`);
                if (editButton) {
                    evalDropdown = dropdown;
                    // Make sure it's expanded
                    const dropdownContentDiv = document.getElementById(dropdown.id);
                    if (dropdownContentDiv && dropdownContentDiv.classList.contains('hidden')) {
                        dropdownContentDiv.classList.remove('hidden');
                        const arrow = document.getElementById(dropdown.id + '-arrow');
                        if (arrow) arrow.textContent = '▲';
                    }
                    break;
                }
            }
            
            // Check if we're in dropdown view or main view
            if (evalDropdown) {
                // We're in dropdown view - render to temp container then inject into dropdown
                console.log('  Rendering to dropdown view...');
                
                // Find the content div inside the dropdown
                const dropdownContentDiv = document.getElementById(evalDropdown.id);
                const dropdownContent = dropdownContentDiv ? dropdownContentDiv.querySelector('div[style*="padding-top: 1rem"]') : null;
                console.log('  dropdownContent found:', !!dropdownContent);
                console.log('  editingEvaluationId when rendering:', editingEvaluationId);
                
                if (dropdownContent && typeof displayResults === 'function' && evaluationResults) {
                    // Create a temporary container to capture the rendered HTML
                    const tempContainer = document.createElement('div');
                    tempContainer.id = 'resultsContent';
                    tempContainer.style.display = 'none';
                    document.body.appendChild(tempContainer);
                    
                    // Store the original resultsContent element if it exists
                    const originalResultsContent = document.getElementById('resultsContent');
                    let originalParent = null;
                    if (originalResultsContent && originalResultsContent !== tempContainer) {
                        originalParent = originalResultsContent.parentElement;
                        // Temporarily replace it
                        if (originalParent) {
                            originalParent.replaceChild(tempContainer, originalResultsContent);
                        }
                    }
                    
                    // Render to temp container (editingEvaluationId is already set at line 26763)
                    console.log('  Calling displayResults with editingEvaluationId:', editingEvaluationId);
                    displayResults(evaluationResults);
                    
                    // Extract the rendered HTML
                    const renderedHTML = tempContainer.innerHTML;
                    console.log('  Rendered HTML length:', renderedHTML.length);
                    console.log('  HTML contains textarea:', renderedHTML.includes('<textarea'));
                    console.log('  HTML contains input:', renderedHTML.includes('<input'));
                    console.log('  HTML contains select:', renderedHTML.includes('<select'));
                    
                    // Restore original resultsContent if it existed
                    if (originalResultsContent && originalResultsContent !== tempContainer && originalParent) {
                        originalParent.replaceChild(originalResultsContent, tempContainer);
                    } else {
                        tempContainer.remove();
                    }
                    
                    // Inject into dropdown IMMEDIATELY
                    dropdownContent.innerHTML = renderedHTML;
                    console.log('  ✓ Injected HTML into dropdown');
                    
                    // Verify editable fields are in the dropdown
                    setTimeout(() => {
                        const editableFieldsInDropdown = dropdownContent.querySelectorAll('textarea, input[type="number"], select');
                        console.log('  Editable fields found in dropdown:', editableFieldsInDropdown.length);
                        if (editableFieldsInDropdown.length === 0) {
                            console.error('  ❌ No editable fields found in dropdown after injection!');
                            console.log('  Dropdown HTML sample:', dropdownContent.innerHTML.substring(0, 500));
                            console.log('  isEditing was:', editingEvaluationId !== null);
                        } else {
                            console.log('  ✓ Editable fields successfully injected into dropdown');
                        }
                    }, 100);
                    
                    // Re-initialize Lucide icons
                    if (typeof lucide !== 'undefined' && lucide.createIcons) {
                        lucide.createIcons({ root: evalDropdown });
                    }
                    
                    // Scroll to the dropdown
                    evalDropdown.scrollIntoView({ behavior: 'smooth', block: 'start' });
                } else {
                    console.warn('  ⚠️ Could not find dropdownContent or displayResults not available');
                    // Fallback to main view
                    if (typeof displayResults === 'function' && evaluationResults) {
                        displayResults(evaluationResults);
                    }
                }
            } else if (typeof displayResults === 'function' && evaluationResults) {
                // Main evaluation view (or bottom edit button was clicked)
                console.log('  Rendering to main evaluation view...');
                console.log('  editingEvaluationId:', editingEvaluationId);
                console.log('  evaluationResults available:', !!evaluationResults);
                
                // Ensure we're showing the evaluation section
                const evalSection = document.getElementById('evaluateSection');
                if (evalSection) {
                    evalSection.classList.add('active');
                    evalSection.style.display = 'block';
                    evalSection.style.visibility = 'visible';
                }
                
                // Ensure results step is visible
                const resultsStep = document.getElementById('resultsStep');
                if (resultsStep) {
                    resultsStep.classList.remove('hidden');
                    resultsStep.style.display = 'block';
                }
                
                displayResults(evaluationResults);
                console.log('  ✓ Results rendered with editable fields');
            } else {
                console.warn('  ⚠️ displayResults function or evaluationResults not available');
                console.log('  evaluationResults:', evaluationResults);
                console.log('  displayResults type:', typeof displayResults);
            }
            
            // Verify editable fields appeared (displayResults already called above)
            setTimeout(() => {
                const editableFields = document.querySelectorAll('textarea, input[type="number"], select');
                console.log('  Found editable fields after render:', editableFields.length);
                if (editableFields.length === 0 && editingEvaluationId) {
                    console.error('❌ No editable fields found! Re-rendering...');
                    if (evaluationResults) {
                        displayResults(evaluationResults);
                    }
                } else if (editableFields.length > 0) {
                    console.log('✓ Editable fields are visible');
                }
            }, 200);
            
            // Check if content was added and ensure it's visible
            const resultsContent = document.getElementById('resultsContent');
            console.log('resultsContent:', resultsContent ? 'found' : 'NOT FOUND');
            console.log('resultsContent innerHTML length:', resultsContent ? resultsContent.innerHTML.length : 0);
            
            // CRITICAL: Ensure resultsContent is visible (not collapsed)
            // Logs show innerHTMLLength:51494 but offsetHeight:0, offsetWidth:0 - parent containers are collapsed
            if (resultsContent) {
                resultsContent.style.display = 'block';
                resultsContent.style.visibility = 'visible';
                resultsContent.style.opacity = '1';
                resultsContent.style.minHeight = '100px'; // Force minimum height
                resultsContent.style.width = '100%'; // Force full width
                resultsContent.classList.remove('hidden');
                
                // Also ensure parent containers have dimensions (logs show they're all collapsed)
                let parent = resultsContent.parentElement;
                let level = 0;
                while (parent && level < 5) {
                    const parentStyle = window.getComputedStyle(parent);
                    if (parentStyle.display === 'none' || (parent.offsetHeight === 0 && parent.offsetWidth === 0)) {
                        if (parentStyle.display === 'flex') {
                            parent.style.display = 'flex';
                        } else {
                            parent.style.display = 'block';
                        }
                        parent.style.minHeight = '100px';
                        parent.style.width = '100%';
                    }
                    parent = parent.parentElement;
                    level++;
                }
                
                // #region agent log
                const computedStyle = window.getComputedStyle(resultsContent);
                fetch('http://127.0.0.1:7242/ingest/2d493fae-3749-4b25-960d-04d6e5f42b38',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:27090',message:'resultsContent visibility check',data:{innerHTMLLength:resultsContent.innerHTML.length,display:computedStyle.display,visibility:computedStyle.visibility,opacity:computedStyle.opacity,offsetHeight:resultsContent.offsetHeight,offsetWidth:resultsContent.offsetWidth,hasHiddenClass:resultsContent.classList.contains('hidden')},timestamp:Date.now(),runId:'run9',hypothesisId:'L'})}).catch(()=>{});
                // #endregion
            }
            
            // Show notification
            showNotification('📝 Editing Mode: All sections are now editable. Scroll down to make changes, then click "Save" at the bottom.', 'info', 6000);
            
            // Final check to close any remaining menus after everything is rendered
            setTimeout(() => {
                document.querySelectorAll('.evaluation-actions-menu').forEach(menu => {
                    menu.classList.add('hidden');
                    menu.style.display = 'none';
                    menu.style.visibility = 'hidden';
                });
                document.querySelectorAll('[id^="eval-menu-"]').forEach(menu => {
                    menu.classList.add('hidden');
                    menu.style.display = 'none';
                    menu.style.visibility = 'hidden';
                });
            }, 200);
            
            // Scroll to top
            window.scrollTo(0, 0);
            
            console.log('=== editSavedEvaluation END ===');
        }
        
        // Edit Evaluation button removed - editing is now enabled automatically when editSavedEvaluation is called
        
        // Download saved evaluation
        async function downloadSavedEvaluation(evaluationId, studentId) {
            let evaluation = null;
            
            if (supabaseClient && currentUser) {
                const { data, error } = await supabaseClient
                    .from('evaluations')
                    .select('*')
                    .eq('id', evaluationId)
                    .single();
                
                if (data) {
                    evaluation = data.evaluation_data;
                }
            }
            
            if (!evaluation) {
                const classes = JSON.parse(getUserItem('classes') || '[]');
                const cls = classes.find(c => c.id === currentClassId);
                if (cls) {
                    const student = cls.roster.find(s => s.id === studentId || s.supabaseId === studentId);
                    if (student && student.evaluations) {
                        const evalRecord = student.evaluations.find(e => e.id === evaluationId || e.supabaseId === evaluationId);
                        if (evalRecord) {
                            evaluation = evalRecord.results;
                        }
                    }
                }
            }
            
            if (!evaluation) {
                alert('Could not load evaluation for download.');
                return;
            }
            
            // Export as HTML
            const studentName = evaluation.studentName || 'Student';
            await exportEvaluationHTML(evaluation, studentName);
        }
        
        // Cancel editing mode
        async function saveEditedEvaluation() {
            if (!editingEvaluationId || !evaluationResults) {
                alert('No evaluation selected for editing.');
                return;
            }
            
            try {
                // Collect all edited data
                const updatedResults = JSON.parse(JSON.stringify(evaluationResults));
                
                // Update section feedbacks
                Object.keys(updatedResults.sections || {}).forEach(sectionName => {
                    const sectionId = sectionName.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                    const feedbackTextarea = document.getElementById('feedback-' + sectionId);
                    if (feedbackTextarea && updatedResults.sections[sectionName]) {
                        updatedResults.sections[sectionName].feedback = feedbackTextarea.value || updatedResults.sections[sectionName].feedback;
                    }
                    
                    // Update subcategory points, grades, and feedbacks
                    if (updatedResults.sections[sectionName].subcategories) {
                        updatedResults.sections[sectionName].subcategories.forEach((sub, subIdx) => {
                            const subId = sectionId + '_sub_' + subIdx;
                            const pointsInput = document.getElementById('subcategory-' + sectionId + '-' + subIdx + '-points');
                            const gradeSelect = document.getElementById('subcategory-' + sectionId + '-' + subIdx + '-grade');
                            const feedbackTextarea = document.getElementById('subfeedback-' + subId);
                            
                            if (pointsInput) {
                                sub.points = parseFloat(pointsInput.value) || sub.points;
                            }
                            if (gradeSelect) {
                                sub.grade = gradeSelect.value || sub.grade;
                            }
                            if (feedbackTextarea) {
                                sub.feedback = feedbackTextarea.value || sub.feedback;
                            }
                        });
                        
                        // Recalculate section score
                        const section = updatedResults.sections[sectionName];
                        section.score = section.subcategories.reduce((sum, sub) => sum + (parseFloat(sub.points) || 0), 0);
                    }
                });
                
                // Update overall comments
                const overallCommentsTextarea = document.getElementById('overall-comments-text');
                if (overallCommentsTextarea) {
                    updatedResults.overallComments = overallCommentsTextarea.value || updatedResults.overallComments;
                }
                
                // Update timeline markers from editable fields
                if (!updatedResults.timeline_markers) {
                    updatedResults.timeline_markers = [];
                }
                
                // Collect all timeline markers from the DOM
                const markerElements = document.querySelectorAll('[data-marker-id]');
                const updatedMarkers = [];
                
                markerElements.forEach(markerEl => {
                    const markerId = markerEl.getAttribute('data-marker-id');
                    if (!markerId) return;
                    
                    // Find inputs for this marker
                    const timestampInput = markerEl.querySelector('input[id^="marker-timestamp-"]');
                    const issueInput = markerEl.querySelector('input[id^="marker-issue-"]');
                    const noteTextarea = markerEl.querySelector('textarea[id^="marker-note-"]');
                    
                    if (timestampInput && issueInput) {
                        const marker = {
                            id: markerId.startsWith('temp-') ? markerId : (markerId || `temp-${Date.now()}`),
                            timestamp: timestampInput.value.trim() || '0:00',
                            issue: issueInput.value.trim() || 'New marker',
                            note: noteTextarea ? noteTextarea.value.trim() : '',
                            category: markerEl.getAttribute('data-marker-category') || 'Other',
                            severity: 'minor', // Default severity
                            behavior: null
                        };
                        
                        // Try to preserve existing marker properties
                        const existingMarker = updatedResults.timeline_markers.find(m => 
                            (m.id && m.id === markerId) || 
                            (m.id && m.id.toString() === markerId.toString())
                        );
                        if (existingMarker) {
                            marker.severity = existingMarker.severity || 'minor';
                            marker.behavior = existingMarker.behavior || null;
                            marker.category = existingMarker.category || marker.category;
                        }
                        
                        updatedMarkers.push(marker);
                    }
                });
                
                // Update timeline markers
                updatedResults.timeline_markers = updatedMarkers;
                
                // Recalculate total score
                updatedResults.totalScore = Object.values(updatedResults.sections || {}).reduce((sum, section) => sum + (parseFloat(section.score) || 0), 0);
                updatedResults.percentage = updatedResults.maxScore > 0 ? (updatedResults.totalScore / updatedResults.maxScore) * 100 : 0;
                
                // Determine letter grade
                const percentage = updatedResults.percentage;
                if (percentage >= 90) updatedResults.letterGrade = 'A';
                else if (percentage >= 80) updatedResults.letterGrade = 'B';
                else if (percentage >= 70) updatedResults.letterGrade = 'C';
                else if (percentage >= 60) updatedResults.letterGrade = 'D';
                else updatedResults.letterGrade = 'F';
                
                // Log the edit
                const editCorrection = {
                    timestamp: new Date().toISOString(),
                    instructor_id: currentUser?.id || null,
                    changes: {
                        sections: updatedResults.sections,
                        overallComments: updatedResults.overallComments,
                        totalScore: updatedResults.totalScore,
                        letterGrade: updatedResults.letterGrade
                    },
                    reason: 'Instructor edit via inline editing'
                };
                
                if (!updatedResults.corrections) updatedResults.corrections = [];
                updatedResults.corrections.push(editCorrection);
                updatedResults.edited = true;
                
                // Prepare update payload
                const evalDataPayload = {
                    sections: updatedResults.sections,
                    studentName: updatedResults.studentName,
                    speechDate: updatedResults.speechDate,
                    assignmentType: updatedResults.assignmentType,
                    speechTime: updatedResults.speechTime,
                    rubricUsed: updatedResults.rubricUsed,
                    totalScore: updatedResults.totalScore,
                    maxScore: updatedResults.maxScore,
                    percentage: updatedResults.percentage,
                    letterGrade: updatedResults.letterGrade,
                    overallComments: updatedResults.overallComments,
                    timeline_markers: updatedResults.timeline_markers || [],
                    corrections: updatedResults.corrections,
                    edited: true
                };
                
                // Preserve original model output if it exists
                if (updatedResults.model_output_original) {
                    evalDataPayload.model_output_original = updatedResults.model_output_original;
                }
                
                // Preserve rubric structure if it exists
                if (updatedResults.rubric_structure) {
                    evalDataPayload.rubric_structure = updatedResults.rubric_structure;
                }
                
                // Update in Supabase
                const { error } = await supabaseClient
                    .from('evaluations')
                    .update({
                        evaluation_data: evalDataPayload,
                        total_score: updatedResults.totalScore,
                        letter_grade: updatedResults.letterGrade
                    })
                    .eq('id', editingEvaluationId);
                
                if (error) {
                    console.error('Failed to save edited evaluation:', error);
                    alert('Error saving evaluation: ' + error.message);
                    return;
                }
                
                // Log the edit for FERPA compliance
                await logAccess('update', 'evaluations', editingEvaluationId, editingStudentId, {
                    changes: 'Instructor edit'
                });
                
                // Show persistent indicator
                // Show popup notification (appears in viewport center)
                showEvaluationSavedPopup('Evaluation saved successfully!');
                
                // Show persistent indicator at top
                showEvaluationSavedIndicator('Evaluation saved successfully!');
                
                // Show "What's Next" guidance
                showPostSaveGuidance();
                
                // Exit edit mode
                editingEvaluationId = null;
                editingStudentId = null;
                editingEvaluationVideoUrl = null;
                correctionLog = [];
                uploadedFile = null;
                window.removeEventListener('beforeunload', handleBeforeUnload);
                
                // Refresh the view
                if (currentClassId) {
                    viewClass(currentClassId);
                } else {
                    showDashboard();
                }
                
            } catch (error) {
                console.error('Error saving edited evaluation:', error);
                alert('Error saving evaluation: ' + error.message);
            }
        }
        
        function cancelEdit() {
            showConfirmModal('Discard changes', 'Cancel editing? Any unsaved changes will be lost.', function() {
                editingEvaluationId = null;
                editingStudentId = null;
                editingEvaluationVideoUrl = null;
                correctionLog = [];
                uploadedFile = null;
                // Remove beforeunload handler
                window.removeEventListener('beforeunload', handleBeforeUnload);
                viewClass(currentClassId);
            }, null, 'Discard');
        }
        
        // Navigation guard function to check if editing before navigating
        function checkEditingBeforeNavigate(callback, ...args) {
            if (editingEvaluationId) {
                showConfirmModal(
                    'Unsaved Changes',
                    'You are currently editing an evaluation. Do you want to save your changes or discard them?',
                    function() {
                        // User chose to discard
                        editingEvaluationId = null;
                        editingStudentId = null;
                        editingEvaluationVideoUrl = null;
                        correctionLog = [];
                        uploadedFile = null;
                        window.removeEventListener('beforeunload', handleBeforeUnload);
                        if (callback) callback(...args);
                    },
                    function() {
                        // User chose to cancel navigation
                        // Do nothing, stay on current page
                    },
                    'Discard Changes',
                    'Stay on Page'
                );
            } else {
                // Not editing, proceed with navigation
                if (callback) callback(...args);
            }
        }
        
        // Handle browser beforeunload (page refresh/close)
        function handleBeforeUnload(e) {
            if (editingEvaluationId) {
                // Standard way
                e.preventDefault();
                // Chrome requires returnValue to be set
                e.returnValue = '';
                return '';
            }
        }

        // ===== SETTINGS =====
        function loadSavedSettings() {
            // Qwen service URL (Super Admin config; also from config.js)
            const qwenUrl = localStorage.getItem('qwen_api_url') || (typeof window !== 'undefined' && window.QWEN_API_URL) || '';
            const savedQwenEl = document.getElementById('savedQwenUrl');
            if (savedQwenEl) savedQwenEl.value = qwenUrl || (window.QWEN_API_URL || '');
            // Evaluation server URL (SpeechGradebook Model); default localhost for all users
            const defaultFinetunedUrl = 'http://localhost:8000/api';
            const finetunedUrl = localStorage.getItem('finetuned_api_url');
            const savedFinetunedEl = document.getElementById('savedFinetunedUrl');
            if (savedFinetunedEl) savedFinetunedEl.value = finetunedUrl || defaultFinetunedUrl;
            // Load all three API keys (Super Admin only - section visibility set elsewhere)
            const geminiKey = localStorage.getItem('gemini_api_key');
            const openaiKey = localStorage.getItem('openai_api_key');
            const claudeKey = localStorage.getItem('anthropic_api_key');
            
            if (geminiKey) {
                document.getElementById('savedGeminiKey').value = geminiKey;
            }
            if (openaiKey) {
                document.getElementById('savedOpenAIKey').value = openaiKey;
            }
            if (claudeKey) {
                document.getElementById('savedClaudeKey').value = claudeKey;
            }
            
            // Note: Theme settings (colors, fonts, logo) are now managed by admins
            // in the Theme Customizer, not in user settings
        }

        function showApiKeyInput(provider) {
            // Hide all API key input sections
            const sections = document.querySelectorAll('.api-key-input-section');
            sections.forEach(section => section.style.display = 'none');
            
            // Show helper text
            const helperText = document.getElementById('apiKeyHelperText');
            if (helperText) helperText.style.display = provider ? 'block' : 'none';
            
            // Show selected provider's input section
            if (provider) {
                const selectedSection = document.getElementById(`apiKeyInput-${provider}`);
                if (selectedSection) selectedSection.style.display = 'block';
            }
        }
        
        function loadApiKeySettings() {
            // Load saved Qwen URL into input
            const qwenUrl = localStorage.getItem('qwen_api_url');
            const savedQwenEl = document.getElementById('savedQwenUrl');
            if (savedQwenEl && qwenUrl) {
                savedQwenEl.value = qwenUrl;
            }
        }
        
        function saveSettings() {
            // Qwen service URL (only provider)
            const savedQwenEl = document.getElementById('savedQwenUrl');
            if (savedQwenEl) {
                const url = savedQwenEl.value.trim().replace(/\/$/, '');
                if (url) localStorage.setItem('qwen_api_url', url);
                else localStorage.removeItem('qwen_api_url');
            }
            
            // Save theme settings (only if elements exist - theme customizer may be admin-only)
            const primaryEl = document.getElementById('themePrimaryColor') || document.getElementById('primaryColor');
            const headingEl = document.getElementById('themeHeadingFont') || document.getElementById('headingFont');
            const bodyEl = document.getElementById('themeBodyFont') || document.getElementById('bodyFont');
            if (primaryEl) {
                const primaryColor = primaryEl.value || document.getElementById('themePrimaryText')?.value;
                if (primaryColor) localStorage.setItem('primary_color', primaryColor);
            }
            if (headingEl) {
                localStorage.setItem('heading_font', headingEl.value);
            }
            if (bodyEl) {
                localStorage.setItem('body_font', bodyEl.value);
            }
            
            showMessage('settingsMessage', '<span class="icon-with-text"><i data-lucide="check-circle" style="width:1.25em;height:1.25em;"></i> Settings saved successfully!</span>', 'success');
        }

        function resetSettings() {
            showConfirmModal('Reset settings', 'Reset all settings to defaults? This will clear all saved API keys and theme preferences.', function() {
                doResetSettings();
            }, null, 'Reset');
        }
        function doResetSettings() {
            // Clear all API keys
            localStorage.removeItem('gemini_api_key');
            localStorage.removeItem('openai_api_key');
            localStorage.removeItem('anthropic_api_key');
            localStorage.removeItem('finetuned_api_url');
            localStorage.removeItem('current_tenant');
            localStorage.removeItem('custom_logo');
            localStorage.removeItem('primary_color');
            localStorage.removeItem('heading_font');
            localStorage.removeItem('body_font');
            
            // Reset form fields
            const savedFinetunedEl = document.getElementById('savedFinetunedUrl');
            if (savedFinetunedEl) savedFinetunedEl.value = '';
            const gemEl = document.getElementById('savedGeminiKey');
            const openEl = document.getElementById('savedOpenAIKey');
            const claudeEl = document.getElementById('savedClaudeKey');
            if (gemEl) gemEl.value = '';
            if (openEl) openEl.value = '';
            if (claudeEl) claudeEl.value = '';
            
            currentTenant = 'default';
            applyTenant('default');
            
            showMessage('settingsMessage', '<span class="icon-with-text"><i data-lucide="check-circle" style="width:1.25em;height:1.25em;"></i> Settings reset to defaults.</span>', 'success');
        }

        // Note: handleLogoUpload is defined earlier in the theme customizer section
        // Old duplicate removed to prevent conflicts

        function updatePrimaryColor(color) {
            document.documentElement.style.setProperty('--primary', color);
            
            // Generate dark variant
            const darkColor = adjustColorBrightness(color, -20);
            document.documentElement.style.setProperty('--primary-dark', darkColor);
        }

        function adjustColorBrightness(hex, percent) {
            const num = parseInt(hex.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255))
                .toString(16).slice(1);
        }

        function updateFonts() {
            const headingFont = document.getElementById('headingFont').value;
            const bodyFont = document.getElementById('bodyFont').value;
            
            document.documentElement.style.setProperty('--heading-font', headingFont);
            document.documentElement.style.setProperty('--body-font', bodyFont);
        }

        // ===== UTILITIES =====
        function showMessage(elementId, message, type) {
            const el = document.getElementById(elementId);
            el.innerHTML = message;
                el.className = type === 'error' ? 'error-message' : 'success-message';
            // Initialize Lucide icons if present
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons({ root: el });
            }
        }

        // ===== SAVE TO CLASS FUNCTIONS =====
        function openSaveModal() {
            // If editing, just update directly without modal
            if (editingEvaluationId) {
                updateExistingEvaluation();
                return;
            }
            
            // Otherwise show the save modal as normal
            try {
                // Ensure modal exists in DOM
                var saveModal = document.getElementById('saveModal');
                if (!saveModal) {
                    console.error('openSaveModal: saveModal element not found');
                    alert('Error: Save modal not found. Please refresh the page.');
                    return;
                }
                
                var classes = JSON.parse(getUserItem('classes') || '[]');
                var sel = document.getElementById('saveClassSel');
                if (!sel) {
                    console.error('openSaveModal: saveClassSel element not found');
                    alert('Error: Save modal elements not found. Please refresh the page.');
                    return;
                }
                sel.innerHTML = '<option value="">-- Select Class --</option>';
                for (var i = 0; i < classes.length; i++) {
                    var opt = document.createElement('option');
                    opt.value = i;
                    opt.textContent = classes[i].name + ' - ' + classes[i].semester + ' ' + classes[i].year;
                    sel.appendChild(opt);
                }
                
                // Pre-select class/student if they were chosen during evaluation (step 2) or stored in evaluationResults
                const evalClassSelect = document.getElementById('evalClassSelect');
                const evalStudentSelect = document.getElementById('evalStudentSelect');
                let evalClassValue = evalClassSelect?.value;
                let evalStudentValue = evalStudentSelect?.value;
                
                // Also check evaluationResults for stored class/student IDs
                if ((!evalClassValue || evalClassValue === '' || evalClassValue === 'other') && evaluationResults && evaluationResults.selectedClassId) {
                    evalClassValue = evaluationResults.selectedClassId;
                }
                if ((!evalStudentValue || evalStudentValue === '') && evaluationResults && evaluationResults.selectedStudentId) {
                    evalStudentValue = evaluationResults.selectedStudentId;
                }
                
                if (evalClassValue && evalClassValue !== '' && evalClassValue !== 'other') {
                    // Find the index of the selected class
                    const classIndex = classes.findIndex(c => {
                        // Try multiple matching strategies
                        if (c.id === evalClassValue || c.name === evalClassValue) return true;
                        if (c.supabaseId === evalClassValue) return true;
                        // Try array index if it's a number
                        const numVal = parseInt(evalClassValue);
                        if (!isNaN(numVal) && numVal >= 0 && numVal < classes.length) {
                            return classes[numVal] === c;
                        }
                        return false;
                    });
                    
                    if (classIndex !== -1) {
                        sel.value = classIndex;
                        loadSaveStudents();
                        if (evalStudentValue && evalStudentValue !== '') {
                            const studentSel = document.getElementById('saveStudentSel');
                            if (studentSel) {
                                setTimeout(() => {
                                    // Find the student index in the class roster
                                    const selectedClass = classes[classIndex];
                                    if (selectedClass && selectedClass.roster) {
                                        const studentIndex = selectedClass.roster.findIndex(s => {
                                            // Try multiple matching strategies
                                            if (s.id === evalStudentValue || s.studentId === evalStudentValue) return true;
                                            if (s.supabaseId === evalStudentValue) return true;
                                            // Try array index if it's a number
                                            const numVal = parseInt(evalStudentValue);
                                            if (!isNaN(numVal) && numVal >= 0 && numVal < selectedClass.roster.length) {
                                                return selectedClass.roster[numVal] === s;
                                            }
                                            return false;
                                        });
                                        if (studentIndex !== -1) {
                                            studentSel.value = studentIndex;
                                        }
                                    }
                                }, 200); // Increased timeout to ensure loadSaveStudents completes
                            }
                        }
                    }
                }
                
                // Modal was already checked at the start, just show it
                saveModal.style.display = 'flex';
            } catch(e) {
                console.error('openSaveModal error:', e);
                alert('Error opening save modal: ' + (e.message || String(e)));
            }
        }

        function loadSaveStudents() {
            try {
                var classSel = document.getElementById('saveClassSel');
                if (!classSel) {
                    console.error('loadSaveStudents: saveClassSel element not found');
                    return;
                }
                var idx = classSel.value;
                var sel = document.getElementById('saveStudentSel');
                if (!sel) {
                    console.error('loadSaveStudents: saveStudentSel element not found');
                    return;
                }
                sel.innerHTML = '<option value="">-- Select Student --</option>';
                if (!idx) return;
                var classes = JSON.parse(getUserItem('classes') || '[]');
                var cls = classes[idx];
                if (cls && cls.roster) {
                    for (var i = 0; i < cls.roster.length; i++) {
                        var s = cls.roster[i];
                        var opt = document.createElement('option');
                        opt.value = i;
                        opt.textContent = s.firstName + ' ' + s.lastName;
                        sel.appendChild(opt);
                    }
                }
            } catch(e) {
                console.error(e);
            }
        }

        async function doSaveEval() {
            try {
                // Disable buttons during save
                const cancelBtn = document.getElementById('saveModalCancelBtn');
                const saveBtn = document.getElementById('saveModalSaveBtn');
                if (cancelBtn) cancelBtn.disabled = true;
                if (saveBtn) {
                    saveBtn.disabled = true;
                    saveBtn.innerHTML = '<i data-lucide="loader" style="animation:spin 1s linear infinite;"></i>';
                    saveBtn.title = 'Saving...';
                    if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: saveBtn });
                }
                
                // Check account tier for save permission
                if (!hasResearchAccess()) {
                    const upgrade = confirm(
                        '🎭 Demo Mode Limitation\n\n' +
                        'Evaluations cannot be saved in Demo mode.\n\n' +
                        'To save evaluations and contribute to research:\n' +
                        '• Upgrade to Research Partner\n' +
                        '• Full evaluation storage\n' +
                        '• Correction tracking\n' +
                        '• Help improve AI\n\n' +
                        'Contact speechgradebook@proton.me to upgrade.\n\n' +
                        'Click OK to copy email address.'
                    );
                    
                    if (upgrade) {
                        // Copy email to clipboard
                        navigator.clipboard.writeText('speechgradebook@proton.me').then(() => {
                            alert('Email address copied to clipboard!');
                        });
                    }
                    return;
                }
                
                // Check if we're editing an existing evaluation
                const isEditing = editingEvaluationId !== null;
                
                if (isEditing) {
                    // UPDATE existing evaluation
                    await updateExistingEvaluation();
                } else {
                    // INSERT new evaluation (original behavior)
                    var savedLocallyOnly = false;
                    // Check if class/student were selected during upload
                    // Try to get from step 2 selectors first, then save modal
                    const evalClassSelect = document.getElementById('evalClassSelect');
                    const evalStudentSelect = document.getElementById('evalStudentSelect');
                    let cIdx = null;
                    let sIdx = null;
                    
                    // Check step 2 selectors first
                    let courseSupabaseId = null;
                    let studentSupabaseId = null;
                    let hasClassAndStudent = false;
                    
                    if (evalClassSelect?.value && evalClassSelect.value !== '' && evalClassSelect.value !== 'other') {
                        const classes = JSON.parse(getUserItem('classes') || '[]');
                        const classValue = evalClassSelect.value;
                        
                        // Try to find class by Supabase ID, name, or index
                        let classIndex = -1;
                        let foundClass = null;
                        
                        // Check if it's a numeric index
                        if (!isNaN(parseInt(classValue)) && parseInt(classValue) >= 0) {
                            const idx = parseInt(classValue);
                            if (idx < classes.length) {
                                classIndex = idx;
                                foundClass = classes[idx];
                            }
                        }
                        
                        // If not found, search by ID or name
                        if (classIndex === -1) {
                            classIndex = classes.findIndex(c => 
                                c.id === classValue || 
                                c.supabaseId === classValue ||
                                c.name === classValue
                            );
                            if (classIndex !== -1) {
                                foundClass = classes[classIndex];
                            }
                        }
                        
                        if (classIndex !== -1 && foundClass) {
                            cIdx = classIndex;
                            courseSupabaseId = foundClass.supabaseId || foundClass.id;
                            
                            if (evalStudentSelect?.value && evalStudentSelect.value !== '' && evalStudentSelect.value !== 'none') {
                                const studentValue = evalStudentSelect.value;
                                const selectedClass = foundClass;
                                
                                if (selectedClass && selectedClass.roster) {
                                    let studentIndex = -1;
                                    
                                    // Check if it's a numeric index
                                    if (!isNaN(parseInt(studentValue)) && parseInt(studentValue) >= 0) {
                                        const idx = parseInt(studentValue);
                                        if (idx < selectedClass.roster.length) {
                                            studentIndex = idx;
                                        }
                                    }
                                    
                                    // If not found, search by ID
                                    if (studentIndex === -1) {
                                        studentIndex = selectedClass.roster.findIndex(s =>
                                            s.id === studentValue || 
                                            s.supabaseId === studentValue ||
                                            s.studentId === studentValue
                                        );
                                    }
                                    
                                    if (studentIndex !== -1) {
                                        sIdx = studentIndex;
                                        const foundStudent = selectedClass.roster[studentIndex];
                                        studentSupabaseId = foundStudent.supabaseId || foundStudent.id;
                                        hasClassAndStudent = true;
                                    }
                                }
                            }
                        }
                    }
                    
                    // If class and student are already selected, save directly without modal
                    if (hasClassAndStudent && cIdx !== null && sIdx !== null) {
                        // Proceed with save using existing selections
                        console.log('Class and student already selected, saving directly...');
                    } else {
                        // If not set in step 2, show save modal
                        const saveClassSel = document.getElementById('saveClassSel');
                        const saveStudentSel = document.getElementById('saveStudentSel');
                        
                        if (saveClassSel?.value !== '' && saveClassSel?.value !== undefined && 
                            saveStudentSel?.value !== '' && saveStudentSel?.value !== undefined) {
                            cIdx = parseInt(saveClassSel.value);
                            sIdx = parseInt(saveStudentSel.value);
                        } else {
                            // Show save modal to get class/student selection
                            openSaveModal();
                            return;
                        }
                    }
                    
                    if (!evaluationResults) {
                        alert('No evaluation to save');
                        return;
                    }
                    
                    // Get class and student info
                    var classes = JSON.parse(getUserItem('classes') || '[]');
                    
                    // Ensure cIdx and sIdx are valid numbers
                    if (cIdx === null || cIdx === undefined || isNaN(cIdx) || cIdx < 0 || cIdx >= classes.length) {
                        alert('Invalid class selection. Please try again.');
                        return;
                    }
                    
                    if (sIdx === null || sIdx === undefined || isNaN(sIdx) || sIdx < 0) {
                        alert('Invalid student selection. Please try again.');
                        return;
                    }
                    
                    var classData = classes[cIdx];
                    if (!classData) {
                        console.error('doSaveEval: Class data not found at index', cIdx);
                        alert('Class not found. Please try again.');
                        return;
                    }
                    
                    if (!classData.roster || !Array.isArray(classData.roster)) {
                        console.error('doSaveEval: Class has no roster array', { classData });
                        alert('Class has no students. Please select a different class.');
                        return;
                    }
                    
                    if (sIdx >= classData.roster.length) {
                        console.error('doSaveEval: Student index out of range', { sIdx, rosterLength: classData.roster.length });
                        alert('Invalid student selection. Please try again.');
                        return;
                    }
                    
                    var student = classData.roster[sIdx];
                    if (!student) {
                        console.error('doSaveEval: Student not found at index', sIdx);
                        alert('Student not found. Please try again.');
                        return;
                    }
                    
                    console.log('doSaveEval: Saving evaluation', {
                        classIndex: cIdx,
                        studentIndex: sIdx,
                        className: classData.name,
                        studentName: (student.firstName || '') + ' ' + (student.lastName || ''),
                        courseSupabaseId: courseSupabaseId || 'not set',
                        studentSupabaseId: studentSupabaseId || 'not set'
                    });
                    
                    // Use Supabase IDs if we found them, otherwise use the ones from classData/student
                    if (!courseSupabaseId) {
                        courseSupabaseId = classData.supabaseId || classData.id;
                    }
                    if (!studentSupabaseId) {
                        studentSupabaseId = student.supabaseId || student.id;
                    }
                    
                    if (!student.evaluations) {
                        student.evaluations = [];
                    }
                    
                    // Create evaluation record
                    var rec = {
                        id: Date.now().toString(),
                        date: document.getElementById('speechDate').value,
                        type: document.getElementById('assignmentType').value,
                        results: evaluationResults,
                        corrections: correctionLog,  // Include instructor corrections
                        editedAt: correctionLog.length > 0 ? new Date().toISOString() : null,
                        savedAt: new Date().toISOString()
                    };
                    
                    // Save to localStorage first (immediate)
                    student.evaluations.push(rec);
                    classes[cIdx].roster[sIdx] = student;
                    setUserItem('classes', JSON.stringify(classes));
                    console.log('✓ Evaluation saved to localStorage');
                    
                    // Also save to Supabase if available
                    if (supabaseClient && currentUser) {
                        const rubricId = document.getElementById('rubricSelect').value;
                        
                        // Use the Supabase IDs we found earlier (or fallback to classData/student)
                        // courseSupabaseId and studentSupabaseId are already set above
                        
                        // Get rubric's Supabase ID
                        const rubrics = await getAllRubrics();
                        const selectedRubric = rubrics.find(r => r.id === rubricId);
                        const rubricSupabaseId = selectedRubric?.supabaseId || null;
                        
                        console.log('Attempting Supabase save with IDs:', {
                            course: courseSupabaseId,
                            student: studentSupabaseId,
                            rubric: rubricSupabaseId,
                            user: currentUser.id
                        });
                        
                        // Only save if course ID is a valid UUID
                        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
                        const courseIdValid = uuidRegex.test(courseSupabaseId);
                        const rubricIdValid = !rubricSupabaseId || uuidRegex.test(rubricSupabaseId);
                        
                        if (courseIdValid && rubricIdValid) {
                            try {
                                // Get the course_students ID (not the students table ID)
                                // The evaluations table expects student_id to be the course_students.id
                                let courseStudentId = null;
                                
                                if (uuidRegex.test(studentSupabaseId)) {
                                    // studentSupabaseId is a students table ID, we need course_students.id
                                    const { data: courseStudent, error: csError } = await supabaseClient
                                        .from('course_students')
                                        .select('id')
                                        .eq('course_id', courseSupabaseId)
                                        .eq('student_id', studentSupabaseId)
                                        .is('deleted_locally_at', null)
                                        .single();
                                    
                                    if (csError) {
                                        // PGRST116 means "0 rows found" - expected when student isn't enrolled in Supabase
                                        // This is a warning, not an error - evaluation will still save to localStorage
                                        if (csError.code !== 'PGRST116') {
                                            console.warn('Could not find course_students record:', csError);
                                        } else {
                                            console.log('Student not enrolled in course_students table (will save locally only)');
                                        }
                                        // Try to continue anyway - maybe the student isn't in the course_students table yet
                                    } else if (courseStudent) {
                                        courseStudentId = courseStudent.id;
                                    }
                                } else {
                                    // studentSupabaseId might already be a course_students ID, or it's not a UUID
                                    // Try using it directly if it's a UUID
                                    if (uuidRegex.test(studentSupabaseId)) {
                                        courseStudentId = studentSupabaseId;
                                    }
                                }
                                
                                // Phase 3: consent check before saving to cloud (no consent = local only)
                                const consent = await getStudentConsentForStorage(courseSupabaseId, studentSupabaseId);
                                if (consent) {
                                    if (!courseStudentId) {
                                        // This is expected if student isn't enrolled in Supabase course_students table
                                        // Evaluation will save to localStorage, but Supabase save may fail
                                        console.log('ℹ️ Student not in course_students table - evaluation will save locally (Supabase save may fail)');
                                        // Still try to save, but it will likely fail
                                    }
                                    
                                    const result = await saveEvaluationToSupabase(
                                        evaluationResults,
                                        courseSupabaseId,
                                        courseStudentId || studentSupabaseId, // Use course_students ID if found, otherwise fallback
                                        rubricSupabaseId,
                                        selectedRubric,
                                        uploadedFile || null
                                    );
                                    if (result) {
                                        console.log('✓ Evaluation saved to Supabase with ID:', result.id);
                                    } else {
                                        console.warn('⚠️ Supabase save returned null - check console for errors');
                                        // Don't show error to user if it saved locally - it's still useful
                                    }
                                } else {
                                    savedLocallyOnly = true;
                                    console.log('✓ Evaluation not sent to cloud (student has not consented); stored in localStorage only.');
                                }
                            } catch (error) {
                                console.error('❌ Error saving evaluation to Supabase:', error);
                                // Evaluation was already saved to localStorage, so this is not critical
                                // But log it for debugging
                                if (error.message) {
                                    console.error('Error details:', error.message);
                                }
                            }
                        } else {
                            console.warn('⚠️ Invalid UUIDs for Supabase save:', {
                                course: courseSupabaseId,
                                student: studentSupabaseId,
                                rubric: rubricSupabaseId
                            });
                            log.debug('Note: Course, student, and rubric must be created in Supabase before evaluations can be saved to database');
                        }
                    } else {
                        log.debug('Supabase not available or user not logged in');
                    }
                    
                    // Re-enable buttons
                    const cancelBtn = document.getElementById('saveModalCancelBtn');
                    const saveBtn = document.getElementById('saveModalSaveBtn');
                    if (cancelBtn) cancelBtn.disabled = false;
                    if (saveBtn) {
                        saveBtn.disabled = false;
                        saveBtn.innerHTML = '<i data-lucide="save"></i>';
                        saveBtn.title = 'Save';
                        if (typeof lucide !== 'undefined' && lucide.createIcons) lucide.createIcons({ root: saveBtn });
                    }
                    
                    // Update Save Results button to "Saved" state
                    updateSaveResultsButtonToSaved();
                    
                    // Show persistent indicator
                    const message = savedLocallyOnly 
                        ? 'Evaluation saved for ' + student.firstName + ' ' + student.lastName + ' (stored locally).'
                        : 'Evaluation saved for ' + student.firstName + ' ' + student.lastName + '.';
                    // Show popup notification (appears in viewport center)
                    showEvaluationSavedPopup(message);
                    
                    // Show persistent indicator at top
                    showEvaluationSavedIndicator(message);
                    
                    // Show "What's Next" guidance
                    showPostSaveGuidance();
                    
                    // Also show toast for immediate feedback
                    if (typeof showAnalyticsToast === 'function') {
                        if (savedLocallyOnly) {
                            showAnalyticsToast('Evaluation saved for ' + student.firstName + ' ' + student.lastName + ' (stored locally).', 5000);
                        } else {
                            showAnalyticsToast('Evaluation saved for ' + student.firstName + ' ' + student.lastName + '.', 4000);
                        }
                    } else {
                        if (savedLocallyOnly) {
                            alert('Success. Evaluation saved for ' + student.firstName + ' ' + student.lastName + ' (stored locally — student has not consented to cloud/research use).');
                        } else {
                            alert('Success. Evaluation saved for ' + student.firstName + ' ' + student.lastName);
                        }
                    }
                    closeSaveModal();
                }
            } catch(e) {
                console.error('Error saving evaluation:', e);
                if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Error: ' + e.message, 6000);
                else alert('Error: ' + e.message);
            }
        }
        
        // Update existing evaluation
        async function updateExistingEvaluation() {
            if (!evaluationResults || !editingEvaluationId) {
                if (typeof showAnalyticsToast === 'function') showAnalyticsToast('No evaluation to update.', 4000);
                else alert('No evaluation to update');
                return;
            }
            
            // Collect all edited data from DOM before saving
            try {
                const updatedResults = JSON.parse(JSON.stringify(evaluationResults));
                
                // Update section feedbacks
                Object.keys(updatedResults.sections || {}).forEach(sectionName => {
                    const sectionId = sectionName.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                    const feedbackTextarea = document.getElementById('feedback-' + sectionId);
                    if (feedbackTextarea && updatedResults.sections[sectionName]) {
                        updatedResults.sections[sectionName].feedback = feedbackTextarea.value || updatedResults.sections[sectionName].feedback;
                    }
                    
                    // Update subcategory points, grades, and feedbacks
                    if (updatedResults.sections[sectionName].subcategories) {
                        updatedResults.sections[sectionName].subcategories.forEach((sub, subIdx) => {
                            const subId = sectionId + '_sub_' + subIdx;
                            const pointsInput = document.getElementById('subcategory-' + sectionId + '-' + subIdx + '-points');
                            const gradeSelect = document.getElementById('subcategory-' + sectionId + '-' + subIdx + '-grade');
                            const feedbackTextarea = document.getElementById('subfeedback-' + subId);
                            
                            if (pointsInput) {
                                sub.points = parseFloat(pointsInput.value) || sub.points;
                            }
                            if (gradeSelect) {
                                sub.grade = gradeSelect.value || sub.grade;
                            }
                            if (feedbackTextarea) {
                                sub.feedback = feedbackTextarea.value || sub.feedback;
                            }
                        });
                        
                        // Recalculate section score
                        const section = updatedResults.sections[sectionName];
                        section.score = section.subcategories.reduce((sum, sub) => sum + (parseFloat(sub.points) || 0), 0);
                    }
                });
                
                // Update overall comments
                const overallCommentsTextarea = document.getElementById('overall-comments-text');
                if (overallCommentsTextarea) {
                    updatedResults.overallComments = overallCommentsTextarea.value || updatedResults.overallComments;
                }
                
                // Update timeline markers from editable fields
                if (!updatedResults.timeline_markers) {
                    updatedResults.timeline_markers = [];
                }
                
                // Collect all timeline markers from the DOM
                const markerElements = document.querySelectorAll('[data-marker-id]');
                const updatedMarkers = [];
                
                markerElements.forEach(markerEl => {
                    const markerId = markerEl.getAttribute('data-marker-id');
                    if (!markerId) return;
                    
                    // Find inputs for this marker
                    const timestampInput = markerEl.querySelector('input[id^="marker-timestamp-"]');
                    const issueInput = markerEl.querySelector('input[id^="marker-issue-"]');
                    const noteTextarea = markerEl.querySelector('textarea[id^="marker-note-"]');
                    
                    if (timestampInput && issueInput) {
                        const marker = {
                            id: markerId.startsWith('temp-') ? markerId : (markerId || `temp-${Date.now()}`),
                            timestamp: timestampInput.value.trim() || '0:00',
                            issue: issueInput.value.trim() || 'New marker',
                            note: noteTextarea ? noteTextarea.value.trim() : '',
                            category: markerEl.getAttribute('data-marker-category') || 'Other',
                            severity: 'minor', // Default severity
                            behavior: null
                        };
                        
                        // Try to preserve existing marker properties
                        const existingMarker = updatedResults.timeline_markers.find(m => 
                            (m.id && m.id === markerId) || 
                            (m.id && m.id.toString() === markerId.toString())
                        );
                        if (existingMarker) {
                            marker.severity = existingMarker.severity || 'minor';
                            marker.behavior = existingMarker.behavior || null;
                            marker.category = existingMarker.category || marker.category;
                        }
                        
                        updatedMarkers.push(marker);
                    }
                });
                
                // Update timeline markers
                updatedResults.timeline_markers = updatedMarkers;
                
                // Recalculate total score
                updatedResults.totalScore = Object.values(updatedResults.sections || {}).reduce((sum, section) => sum + (parseFloat(section.score) || 0), 0);
                updatedResults.percentage = updatedResults.maxScore > 0 ? (updatedResults.totalScore / updatedResults.maxScore) * 100 : 0;
                
                // Determine letter grade
                const percentage = updatedResults.percentage;
                if (percentage >= 90) updatedResults.letterGrade = 'A';
                else if (percentage >= 80) updatedResults.letterGrade = 'B';
                else if (percentage >= 70) updatedResults.letterGrade = 'C';
                else if (percentage >= 60) updatedResults.letterGrade = 'D';
                else updatedResults.letterGrade = 'F';
                
                // Update evaluationResults with collected data
                evaluationResults = updatedResults;
            } catch (error) {
                console.warn('Error collecting data from DOM, using existing evaluationResults:', error);
            }
            
            // Update in Supabase
            if (supabaseClient && currentUser) {
                try {
                    // CRITICAL: Load existing evaluation to preserve model_output_original
                    // This ensures multiple instructors can edit while preserving the original AI output for training
                    let existingEvalData = null;
                    try {
                        const { data: existingData } = await supabaseClient
                            .from('evaluations')
                            .select('evaluation_data')
                            .eq('id', editingEvaluationId)
                            .single();
                        if (existingData && existingData.evaluation_data) {
                            existingEvalData = typeof existingData.evaluation_data === 'string' 
                                ? JSON.parse(existingData.evaluation_data) 
                                : existingData.evaluation_data;
                        }
                    } catch (err) {
                        console.warn('Could not load existing evaluation data:', err);
                    }
                    
                    // Preserve model_output_original from existing evaluation (for multi-instructor training)
                    // If it doesn't exist in the existing evaluation, try to get it from evaluationResults
                    const preservedOriginal = existingEvalData?.model_output_original || evaluationResults.model_output_original;
                    
                    var evalDataPayload = {
                        sections: evaluationResults.sections,
                        studentName: evaluationResults.studentName,
                        speechDate: evaluationResults.speechDate,
                        assignmentType: evaluationResults.assignmentType,
                        speechTime: evaluationResults.speechTime,
                        rubricUsed: evaluationResults.rubricUsed,
                        totalScore: evaluationResults.totalScore,
                        maxScore: evaluationResults.maxScore,
                        percentage: evaluationResults.percentage,
                        letterGrade: evaluationResults.letterGrade,
                        gradeScale: evaluationResults.gradeScale,
                        overallComments: evaluationResults.overallComments,
                        timeline_markers: evaluationResults.timeline_markers || [],
                        video_notes: evaluationResults.video_notes || null,
                        corrections: (() => {
                            // Merge corrections: append new corrections to existing ones (for multi-instructor support)
                            const existingCorrections = existingEvalData?.corrections || [];
                            const newCorrection = {
                                timestamp: new Date().toISOString(),
                                instructor_id: currentUser?.id || null,
                                changes: {
                                    sections: evaluationResults.sections,
                                    overallComments: evaluationResults.overallComments,
                                    totalScore: evaluationResults.totalScore,
                                    letterGrade: evaluationResults.letterGrade
                                },
                                reason: 'Instructor edit via Save Results'
                            };
                            // Also update correctionLog for consistency
                            if (!correctionLog) correctionLog = [];
                            correctionLog.push(newCorrection);
                            return [...existingCorrections, ...correctionLog];
                        })(),
                        edited: true,
                        editedAt: new Date().toISOString(),
                        // Preserve original AI output for training - critical for multi-instructor edits
                        model_output_original: preservedOriginal || undefined,
                        // Track which instructor made this edit (for multi-instructor training)
                        last_edited_by: currentUser.id,
                        last_edited_by_name: currentUser.full_name || currentUser.user_metadata?.full_name || currentUser.email || 'Unknown',
                        // Preserve rubric structure if it exists
                        rubric_structure: existingEvalData?.rubric_structure || evaluationResults.rubric_structure
                    };
                    
                    if (preservedOriginal) {
                        console.log('✓ Preserved model_output_original for training (multi-instructor support)');
                    }
                    const totalCorrections = (existingEvalData?.corrections || []).length + (correctionLog || []).length;
                    console.log('✓ Tracking edit by instructor:', currentUser.id);
                    console.log('✓ Total corrections:', totalCorrections);
                    if (evaluationResults.rubric_structure && evaluationResults.rubric_structure.categories) {
                        evalDataPayload.rubric_structure = evaluationResults.rubric_structure;
                    } else {
                        var rubricId = document.getElementById('rubricSelect') ? document.getElementById('rubricSelect').value : null;
                        if (rubricId) {
                            var rubrics = await getAllRubrics();
                            var rubric = rubrics.find(function(r) { return r.id === rubricId || r.supabaseId === rubricId; });
                            if (rubric && rubric.categories && Array.isArray(rubric.categories)) {
                                evalDataPayload.rubric_structure = { categories: rubric.categories, totalPoints: rubric.totalPoints };
                            }
                        }
                    }
                    var updatePayload = {
                        evaluation_data: evalDataPayload,
                        total_score: evaluationResults.totalScore || 0,
                        letter_grade: evaluationResults.letterGrade || 'N/A',
                        transcript: evaluationResults.transcript || null,
                        updated_at: new Date().toISOString()
                    };
                    const { data: updateResult, error } = await supabaseClient
                        .from('evaluations')
                        .update(updatePayload)
                        .eq('id', editingEvaluationId)
                        .select();
                    
                    if (error) {
                        console.error('Error updating evaluation:', error);
                        if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Error updating evaluation: ' + error.message, 6000);
                        else alert('Error updating evaluation in database: ' + error.message);
                        return;
                    }
                    
                    // Upload video/audio if provided (for Qwen training and replay)
                    if (uploadedFile && uploadedFile.size > 0) {
                        var isVideo = (uploadedFile.type || '').startsWith('video/');
                        var safeName = (uploadedFile.name || 'media').replace(/[^a-zA-Z0-9._-]/g, '_');
                        var storagePath = currentUser.id + '/' + editingEvaluationId + '/' + safeName;
                        try {
                            var uploadErr = (await supabaseClient.storage
                                .from(EVALUATION_MEDIA_BUCKET)
                                .upload(storagePath, uploadedFile, { contentType: uploadedFile.type || (isVideo ? 'video/mp4' : 'audio/mpeg'), upsert: true })).error;
                            if (uploadErr) {
                                console.warn('Storage upload failed (evaluation updated without media URL):', uploadErr);
                            } else {
                                var urlData = supabaseClient.storage.from(EVALUATION_MEDIA_BUCKET).getPublicUrl(storagePath);
                                var mediaUrl = urlData.publicUrl;
                                var mediaPayload = isVideo ? { video_url: mediaUrl } : { audio_url: mediaUrl };
                                var updateErr = (await supabaseClient.from('evaluations').update(mediaPayload).eq('id', editingEvaluationId)).error;
                                if (updateErr) console.warn('Failed to set media URL on evaluation:', updateErr);
                                else console.log('✓ Evaluation media saved to Storage:', isVideo ? 'video' : 'audio');
                            }
                        } catch (e) {
                            console.warn('Storage upload error (evaluation updated without media URL):', e);
                        }
                    }
                    
                    // Log update for FERPA compliance
                    await logAccess('update', 'evaluations', editingEvaluationId, editingStudentId, {
                        action_detail: 'evaluation_data and scores updated'
                    });
                    
                    console.log('✓ Evaluation updated in Supabase');
                } catch (error) {
                    console.error('Supabase error:', error);
                    if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Error updating evaluation: ' + error.message, 6000);
                    else alert('Error updating evaluation: ' + error.message);
                    return;
                }
            }
            
            // Also update localStorage
            const classes = JSON.parse(getUserItem('classes') || '[]');
            const cls = classes.find(c => c.id === currentClassId);
            if (cls) {
                const student = cls.roster.find(s => s.id === editingStudentId || s.supabaseId === editingStudentId);
                if (student && student.evaluations) {
                    const evalIndex = student.evaluations.findIndex(e => 
                        e.id === editingEvaluationId || e.supabaseId === editingEvaluationId
                    );
                    if (evalIndex !== -1) {
                        student.evaluations[evalIndex].results = evaluationResults;
                        student.evaluations[evalIndex].corrections = correctionLog;
                        student.evaluations[evalIndex].editedAt = new Date().toISOString();
                        setUserItem('classes', JSON.stringify(classes));
                        console.log('✓ Evaluation updated in localStorage');
                    }
                }
            }
            
            // Update Save Results button to "Saved" state
            updateSaveResultsButtonToSaved();
            
            // Show persistent indicator
            // Show popup notification (appears in viewport center)
            showEvaluationSavedPopup('Evaluation updated successfully.');
            
            // Show persistent indicator at top
            showEvaluationSavedIndicator('Evaluation updated successfully.');
            
            // Show "What's Next" guidance
            showPostSaveGuidance();
            
            // Also show toast for immediate feedback
            if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Evaluation updated successfully.', 4000);
            else alert('Success. Evaluation updated successfully!');
            
            // Clear editing state and any file selected for upload
            editingEvaluationId = null;
            editingStudentId = null;
            editingEvaluationVideoUrl = null;
            uploadedFile = null;
            // Remove beforeunload handler since we're done editing
            window.removeEventListener('beforeunload', handleBeforeUnload);
            var editInput = document.getElementById('editVideoInput');
            if (editInput) editInput.value = '';
            var editFileName = document.getElementById('editVideoFileName');
            if (editFileName) editFileName.textContent = '';
            
            // Return to class view
            viewClass(currentClassId);
        }

        function closeSaveModal() {
            var saveModal = document.getElementById('saveModal');
            if (saveModal) {
                saveModal.style.display = 'none';
                // Re-enable buttons
                const cancelBtn = document.getElementById('saveModalCancelBtn');
                const saveBtn = document.getElementById('saveModalSaveBtn');
                if (cancelBtn) cancelBtn.disabled = false;
                if (saveBtn) saveBtn.disabled = false;
            }
        }
        
        // Update Save Results button to "Saved" state (green with checkmark)
        function updateSaveResultsButtonToSaved() {
            const saveResultsBtn = document.getElementById('saveResultsBtn');
            if (saveResultsBtn) {
                // Change to green color
                saveResultsBtn.style.backgroundColor = '#34C759';
                saveResultsBtn.style.boxShadow = '0 2px 8px rgba(52, 199, 89, 0.3)';
                saveResultsBtn.innerHTML = '<i data-lucide="check" style="width:18px;height:18px;"></i> Saved';
                saveResultsBtn.setAttribute('onclick', ''); // Remove onclick to prevent re-opening modal
                saveResultsBtn.setAttribute('onmouseover', 'this.style.backgroundColor="#30B04F"; this.style.boxShadow="0 4px 12px rgba(52, 199, 89, 0.4)"');
                saveResultsBtn.setAttribute('onmouseout', 'this.style.backgroundColor="#34C759"; this.style.boxShadow="0 2px 8px rgba(52, 199, 89, 0.3)"');
                saveResultsBtn.disabled = true; // Disable the button since it's already saved
                saveResultsBtn.style.cursor = 'default';
                
                // Update Lucide icons
                if (typeof lucide !== 'undefined' && lucide.createIcons) {
                    lucide.createIcons({ root: saveResultsBtn });
                }
            }
        }
        
        // ===== MOVE EVALUATION FUNCTIONS =====
        let movingEvaluationId = null;
        let movingStudentId = null;
        let movingCourseId = null;
        
        async function openMoveEvalModal(evalId, currentCourseId, currentStudentId) {
            // Can be called from editing a saved evaluation or from a list view
            const evaluationId = evalId || editingEvaluationId;
            
            if (!evaluationId) {
                alert('No evaluation selected to move.');
                return;
            }
            
            movingEvaluationId = evaluationId;
            movingStudentId = currentStudentId || editingStudentId;
            movingCourseId = currentCourseId || editingCourseId;
            
            const moveModal = document.getElementById('moveEvalModal');
            if (!moveModal) {
                console.error('openMoveEvalModal: moveEvalModal element not found');
                alert('Error: Move modal not found. Please refresh the page.');
                return;
            }
            
            const classSel = document.getElementById('moveClassSel');
            if (!classSel) {
                console.error('openMoveEvalModal: moveClassSel element not found');
                alert('Error: Move modal elements not found. Please refresh the page.');
                return;
            }
            
            // Show loading state
            classSel.innerHTML = '<option value="">Loading classes...</option>';
            moveModal.style.display = 'flex';
            
            try {
                // Load courses from Supabase if available
                if (supabaseClient && currentUser) {
                    const { data: courses, error } = await supabaseClient
                        .from('courses')
                        .select('id, name, semester, year')
                        .order('year', { ascending: false })
                        .order('semester', { ascending: false })
                        .order('name', { ascending: true });
                    
                    if (error) {
                        throw error;
                    }
                    
                    if (courses && courses.length > 0) {
                        classSel.innerHTML = '<option value="">-- Select Class --</option>';
                        courses.forEach(course => {
                            const opt = document.createElement('option');
                            opt.value = course.id;
                            opt.textContent = `${course.name} - ${course.semester} ${course.year}`;
                            opt.dataset.courseId = course.id;
                            classSel.appendChild(opt);
                        });
                        
                        // Pre-select current course if provided
                        if (movingCourseId) {
                            classSel.value = movingCourseId;
                            await loadMoveStudents();
                        }
                    } else {
                        classSel.innerHTML = '<option value="">No classes available</option>';
                    }
                } else {
                    // Fallback to localStorage
                    var classes = JSON.parse(getUserItem('classes') || '[]');
                    classSel.innerHTML = '<option value="">-- Select Class --</option>';
                    for (var i = 0; i < classes.length; i++) {
                        var opt = document.createElement('option');
                        opt.value = i;
                        opt.textContent = classes[i].name + ' - ' + classes[i].semester + ' ' + classes[i].year;
                        opt.dataset.courseId = classes[i].supabaseId || classes[i].id;
                        classSel.appendChild(opt);
                    }
                }
            } catch(e) {
                console.error('openMoveEvalModal error:', e);
                alert('Error loading classes: ' + (e.message || String(e)));
                classSel.innerHTML = '<option value="">Error loading classes</option>';
            }
        }
        
        function closeMoveEvalModal() {
            const moveModal = document.getElementById('moveEvalModal');
            if (moveModal) {
                moveModal.style.display = 'none';
            }
            movingEvaluationId = null;
            movingStudentId = null;
            movingCourseId = null;
            
            // Clear selects
            const classSel = document.getElementById('moveClassSel');
            const studentSel = document.getElementById('moveStudentSel');
            if (classSel) classSel.value = '';
            if (studentSel) studentSel.innerHTML = '<option value="">-- Select Student --</option>';
        }
        
        // Helper function to open move modal from anywhere (e.g., from evaluation lists)
        // Usage: openMoveEvalModalFromList(evaluationId, currentCourseId, currentStudentId)
        function openMoveEvalModalFromList(evalId, courseId, studentId) {
            if (!evalId) {
                alert('No evaluation ID provided.');
                return;
            }
            openMoveEvalModal(evalId, courseId, studentId);
        }
        
        // Add move buttons to evaluation cards in student evaluation lists
        // This function can be called after evaluation cards are rendered
        function addMoveButtonsToEvaluationCards() {
            // Find all evaluation cards (they should have data attributes with evaluation IDs)
            const evalCards = document.querySelectorAll('[data-evaluation-id], .eval-card, [class*="eval"]');
            
            evalCards.forEach(card => {
                // Skip if move button already exists
                if (card.querySelector('.move-eval-btn')) return;
                
                // Try to get evaluation ID from data attribute or card structure
                const evalId = card.getAttribute('data-evaluation-id') || 
                              card.getAttribute('data-eval-id') ||
                              card.getAttribute('id')?.replace('eval-', '');
                
                if (!evalId) return;
                
                // Try to get course and student IDs from data attributes or parent context
                const courseId = card.getAttribute('data-course-id') || 
                                card.closest('[data-course-id]')?.getAttribute('data-course-id') || '';
                const studentId = card.getAttribute('data-student-id') || 
                                 card.closest('[data-student-id]')?.getAttribute('data-student-id') || '';
                
                // Find where to add the button (look for existing action buttons or icons area)
                const actionArea = card.querySelector('.eval-actions, .card-actions, [class*="action"]') ||
                                 card.querySelector('.eval-icons, [class*="icon"]') ||
                                 card.querySelector('div:last-child');
                
                if (actionArea) {
                    const moveBtn = document.createElement('button');
                    moveBtn.className = 'move-eval-btn btn-secondary';
                    moveBtn.style.cssText = 'padding: 0.25rem 0.5rem; font-size: 0.875rem; margin-left: 0.5rem;';
                    moveBtn.setAttribute('title', 'Move evaluation to different student');
                    moveBtn.setAttribute('onclick', `openMoveEvalModal('${evalId}', '${courseId}', '${studentId}'); return false;`);
                    moveBtn.innerHTML = '<i data-lucide="move" style="width:0.875rem;height:0.875rem;"></i>';
                    
                    actionArea.appendChild(moveBtn);
                    
                    // Initialize icon
                    if (typeof lucide !== 'undefined' && lucide.createIcons) {
                        lucide.createIcons({ root: moveBtn });
                    }
                }
            });
        }
        
        // Call this function after evaluations are loaded/rendered
        // You can also call it manually: addMoveButtonsToEvaluationCards();
        
        // Auto-add move buttons to evaluation cards when they appear in the DOM
        // This uses a MutationObserver to watch for new evaluation cards
        if (typeof MutationObserver !== 'undefined') {
            const evalCardObserver = new MutationObserver((mutations) => {
                let shouldCheck = false;
                mutations.forEach((mutation) => {
                    if (mutation.addedNodes.length > 0) {
                        mutation.addedNodes.forEach((node) => {
                            if (node.nodeType === 1) { // Element node
                                if (node.classList && (
                                    node.classList.contains('eval-card') ||
                                    node.querySelector('.eval-card') ||
                                    node.getAttribute('data-evaluation-id') ||
                                    node.getAttribute('data-eval-id')
                                )) {
                                    shouldCheck = true;
                                }
                            }
                        });
                    }
                });
                if (shouldCheck) {
                    setTimeout(addMoveButtonsToEvaluationCards, 100);
                }
            });
            
            // Start observing when DOM is ready
            if (document.body) {
                evalCardObserver.observe(document.body, {
                    childList: true,
                    subtree: true
                });
            } else {
                document.addEventListener('DOMContentLoaded', () => {
                    if (document.body) {
                        evalCardObserver.observe(document.body, {
                            childList: true,
                            subtree: true
                        });
                    }
                });
            }
        }
        
        async function loadMoveStudents() {
            try {
                const classSel = document.getElementById('moveClassSel');
                if (!classSel) {
                    console.error('loadMoveStudents: moveClassSel element not found');
                    return;
                }
                
                const courseId = classSel.value;
                const studentSel = document.getElementById('moveStudentSel');
                if (!studentSel) {
                    console.error('loadMoveStudents: moveStudentSel element not found');
                    return;
                }
                
                studentSel.innerHTML = '<option value="">Loading students...</option>';
                
                if (!courseId) {
                    studentSel.innerHTML = '<option value="">-- Select Student --</option>';
                    return;
                }
                
                // Load students from Supabase if available
                if (supabaseClient && currentUser && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(courseId)) {
                    try {
                        const { data: courseStudents, error } = await supabaseClient
                            .from('course_students')
                            .select(`
                                id,
                                student_id,
                                students!inner(id, first_name, last_name)
                            `)
                            .eq('course_id', courseId)
                            .is('deleted_locally_at', null)
                            .order('first_name', { foreignTable: 'students', ascending: true });
                        
                        if (error) {
                            throw error;
                        }
                        
                        if (courseStudents && courseStudents.length > 0) {
                            studentSel.innerHTML = '<option value="">-- Select Student --</option>';
                            
                            // Sort students alphabetically
                            const sortedStudents = courseStudents
                                .map(cs => ({
                                    id: cs.student_id || cs.students?.id,
                                    firstName: cs.students?.first_name || '',
                                    lastName: cs.students?.last_name || ''
                                }))
                                .sort((a, b) => {
                                    const nameA = (a.firstName + ' ' + a.lastName).trim().toLowerCase();
                                    const nameB = (b.firstName + ' ' + b.lastName).trim().toLowerCase();
                                    return nameA.localeCompare(nameB);
                                });
                            
                            sortedStudents.forEach(student => {
                                const opt = document.createElement('option');
                                opt.value = student.id;
                                opt.textContent = `${student.firstName} ${student.lastName}`.trim() || 'Unnamed Student';
                                studentSel.appendChild(opt);
                            });
                        } else {
                            studentSel.innerHTML = '<option value="">No students in this class</option>';
                        }
                    } catch (error) {
                        console.error('Error loading students from Supabase:', error);
                        // Fallback to localStorage
                        loadMoveStudentsFromLocalStorage(courseId);
                    }
                } else {
                    // Fallback to localStorage
                    loadMoveStudentsFromLocalStorage(courseId);
                }
            } catch(e) {
                console.error('loadMoveStudents error:', e);
                const studentSel = document.getElementById('moveStudentSel');
                if (studentSel) {
                    studentSel.innerHTML = '<option value="">Error loading students</option>';
                }
            }
        }
        
        function loadMoveStudentsFromLocalStorage(courseIdOrIndex) {
            try {
                const studentSel = document.getElementById('moveStudentSel');
                if (!studentSel) return;
                
                const classes = JSON.parse(getUserItem('classes') || '[]');
                let classData = null;
                
                // Check if courseIdOrIndex is a UUID (Supabase ID) or an index
                const isUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(courseIdOrIndex);
                
                if (isUUID) {
                    // Find by Supabase ID
                    classData = classes.find(c => (c.supabaseId || c.id) === courseIdOrIndex);
                } else {
                    // Use as index
                    const idx = parseInt(courseIdOrIndex);
                    if (!isNaN(idx) && idx >= 0 && idx < classes.length) {
                        classData = classes[idx];
                    }
                }
                
                studentSel.innerHTML = '<option value="">-- Select Student --</option>';
                
                if (classData && classData.roster) {
                    // Sort students alphabetically
                    const sortedRoster = [...classData.roster].sort((a, b) => {
                        const nameA = ((a.firstName || '') + ' ' + (a.lastName || '')).trim().toLowerCase();
                        const nameB = ((b.firstName || '') + ' ' + (b.lastName || '')).trim().toLowerCase();
                        return nameA.localeCompare(nameB);
                    });
                    
                    sortedRoster.forEach((student, i) => {
                        const opt = document.createElement('option');
                        opt.value = student.supabaseId || student.id || i;
                        opt.textContent = `${student.firstName || ''} ${student.lastName || ''}`.trim() || 'Unnamed Student';
                        studentSel.appendChild(opt);
                    });
                }
            } catch(e) {
                console.error('loadMoveStudentsFromLocalStorage error:', e);
            }
        }
        
        async function doMoveEval() {
            try {
                // Check if this is a bulk move
                if (window.bulkMoveEvaluationIds && window.bulkMoveEvaluationIds.length > 0) {
                    const courseId = document.getElementById('moveClassSel').value;
                    const studentId = document.getElementById('moveStudentSel').value;
                    
                    if (!courseId || !studentId) {
                        alert('Please select both class and student');
                        return;
                    }
                    
                    await bulkMoveEvaluationsFromUpload(window.bulkMoveEvaluationIds, courseId, studentId);
                    window.bulkMoveEvaluationIds = null;
                    return;
                }
                
                if (!movingEvaluationId) {
                    alert('No evaluation selected to move.');
                    return;
                }
                
                const courseId = document.getElementById('moveClassSel').value;
                const studentId = document.getElementById('moveStudentSel').value;
                
                if (!courseId || !studentId) {
                    alert('Please select both class and student');
                    return;
                }
                
                // Get course and student names for confirmation message
                let courseName = 'the selected class';
                let studentName = 'the selected student';
                
                // Try to get names from Supabase
                if (supabaseClient && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(courseId)) {
                    try {
                        const { data: course } = await supabaseClient
                            .from('courses')
                            .select('name')
                            .eq('id', courseId)
                            .single();
                        if (course) courseName = course.name;
                        
                        const { data: student } = await supabaseClient
                            .from('students')
                            .select('first_name, last_name')
                            .eq('id', studentId)
                            .single();
                        if (student) {
                            studentName = `${student.first_name || ''} ${student.last_name || ''}`.trim() || 'Unnamed Student';
                        }
                    } catch (e) {
                        console.warn('Could not fetch course/student names:', e);
                    }
                } else {
                    // Fallback to localStorage
                    const classes = JSON.parse(getUserItem('classes') || '[]');
                    const isUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(courseId);
                    let classData = null;
                    
                    if (isUUID) {
                        classData = classes.find(c => (c.supabaseId || c.id) === courseId);
                    } else {
                        const idx = parseInt(courseId);
                        if (!isNaN(idx) && idx >= 0 && idx < classes.length) {
                            classData = classes[idx];
                        }
                    }
                    
                    if (classData) {
                        courseName = classData.name;
                        if (classData.roster) {
                            const student = classData.roster.find(s => 
                                (s.supabaseId || s.id) === studentId || 
                                s.id === studentId
                            );
                            if (student) {
                                studentName = `${student.firstName || ''} ${student.lastName || ''}`.trim() || 'Unnamed Student';
                            }
                        }
                    }
                }
                
                const courseSupabaseId = courseId;
                const studentSupabaseId = studentId;
                
                // Update in Supabase
                const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
                if (supabaseClient && currentUser && movingEvaluationId && 
                    uuidRegex.test(courseSupabaseId) && uuidRegex.test(studentSupabaseId)) {
                    try {
                        const { error } = await supabaseClient
                            .from('evaluations')
                            .update({
                                course_id: courseSupabaseId,
                                student_id: studentSupabaseId,
                                updated_at: new Date().toISOString()
                            })
                            .eq('id', movingEvaluationId);
                        
                        if (error) {
                            throw error;
                        }
                        
                        console.log('✓ Evaluation moved in Supabase');
                    } catch (error) {
                        console.error('Error moving evaluation in Supabase:', error);
                        alert('Error moving evaluation in database: ' + error.message);
                        return;
                    }
                } else if (!uuidRegex.test(courseSupabaseId) || !uuidRegex.test(studentSupabaseId)) {
                    alert('Invalid course or student ID. Please ensure you are using a valid class and student.');
                    return;
                }
                
                // Update in localStorage (for backward compatibility)
                try {
                    const oldClasses = JSON.parse(getUserItem('classes') || '[]');
                    let evalRec = null;
                    
                    // Find and remove from old location
                    for (var i = 0; i < oldClasses.length; i++) {
                        var oldClass = oldClasses[i];
                        if (oldClass.roster) {
                            for (var j = 0; j < oldClass.roster.length; j++) {
                                var oldStudent = oldClass.roster[j];
                                if (oldStudent.evaluations) {
                                    var evalIndex = oldStudent.evaluations.findIndex(function(e) {
                                        return e.id === movingEvaluationId || e.supabaseId === movingEvaluationId;
                                    });
                                    if (evalIndex !== -1) {
                                        evalRec = oldStudent.evaluations[evalIndex];
                                        oldStudent.evaluations.splice(evalIndex, 1);
                                        break;
                                    }
                                }
                            }
                            if (evalRec) break;
                        }
                    }
                    
                    // Add to new location if found
                    if (evalRec) {
                        const isUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(courseSupabaseId);
                        let targetClass = null;
                        
                        if (isUUID) {
                            targetClass = oldClasses.find(c => (c.supabaseId || c.id) === courseSupabaseId);
                        } else {
                            const idx = parseInt(courseSupabaseId);
                            if (!isNaN(idx) && idx >= 0 && idx < oldClasses.length) {
                                targetClass = oldClasses[idx];
                            }
                        }
                        
                        if (targetClass && targetClass.roster) {
                            const targetStudent = targetClass.roster.find(s => 
                                (s.supabaseId || s.id) === studentSupabaseId
                            );
                            if (targetStudent) {
                                if (!targetStudent.evaluations) {
                                    targetStudent.evaluations = [];
                                }
                                targetStudent.evaluations.push(evalRec);
                                setUserItem('classes', JSON.stringify(oldClasses));
                                console.log('✓ Evaluation moved in localStorage');
                            }
                        }
                    }
                } catch (e) {
                    console.warn('Could not update localStorage (this is okay if using Supabase):', e);
                }
                
                // Show success message
                if (typeof showNotification === 'function') {
                    showNotification(`Evaluation moved to ${studentName} in ${courseName}.`, 'success');
                } else if (typeof showAnalyticsToast === 'function') {
                    showAnalyticsToast(`Evaluation moved to ${studentName} in ${courseName}.`, 4000);
                } else {
                    alert(`Success. Evaluation moved to ${studentName} in ${courseName}.`);
                }
                
                closeMoveEvalModal();
                
                // Refresh the current view
                if (typeof window.location !== 'undefined') {
                    // Reload the page to refresh all views
                    setTimeout(() => {
                        window.location.reload();
                    }, 500);
                } else if (currentClassId) {
                    if (typeof viewClass === 'function') {
                        viewClass(currentClassId);
                    }
                }
            } catch(e) {
                console.error('Error moving evaluation:', e);
                if (typeof showAnalyticsToast === 'function') showAnalyticsToast('Error: ' + e.message, 6000);
                else alert('Error: ' + e.message);
            }
        }
    </script>
    </div> <!-- End mainApp -->
</body>
</html>
